
ESE680A_ApplicationCode.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000311c  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000074  20000000  0000b11c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000100  20000074  0000b190  00010074  2**2
                  ALLOC
  3 .stack        00002004  20000174  0000b290  00010074  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010074  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0001009c  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001a72b  00000000  00000000  000100f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000214a  00000000  00000000  0002a820  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00002485  00000000  00000000  0002c96a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000006e0  00000000  00000000  0002edef  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000005e0  00000000  00000000  0002f4cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00018ebb  00000000  00000000  0002faaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ade9  00000000  00000000  0004896a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00087ba5  00000000  00000000  00053753  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001c04  00000000  00000000  000db2f8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00008000 <_sfixed>:
    8000:	20002178 	.word	0x20002178
    8004:	000081a9 	.word	0x000081a9
    8008:	000082a1 	.word	0x000082a1
    800c:	000082a1 	.word	0x000082a1
	...
    802c:	000082a1 	.word	0x000082a1
	...
    8038:	000082a1 	.word	0x000082a1
    803c:	000082a1 	.word	0x000082a1
    8040:	000082a1 	.word	0x000082a1
    8044:	000082a1 	.word	0x000082a1
    8048:	000082a1 	.word	0x000082a1
    804c:	000082a1 	.word	0x000082a1
    8050:	000082a1 	.word	0x000082a1
    8054:	000082a1 	.word	0x000082a1
    8058:	000082a1 	.word	0x000082a1
    805c:	000082a1 	.word	0x000082a1
    8060:	000082a1 	.word	0x000082a1
    8064:	000093f5 	.word	0x000093f5
    8068:	0000940d 	.word	0x0000940d
    806c:	00009425 	.word	0x00009425
    8070:	0000943d 	.word	0x0000943d
    8074:	00009455 	.word	0x00009455
    8078:	0000946d 	.word	0x0000946d
    807c:	000082a1 	.word	0x000082a1
    8080:	000082a1 	.word	0x000082a1
    8084:	000082a1 	.word	0x000082a1
    8088:	000082a1 	.word	0x000082a1
    808c:	000082a1 	.word	0x000082a1
    8090:	000082a1 	.word	0x000082a1
	...
    809c:	000082a1 	.word	0x000082a1
    80a0:	000082a1 	.word	0x000082a1
    80a4:	000082a1 	.word	0x000082a1
    80a8:	000082a1 	.word	0x000082a1
    80ac:	000082a1 	.word	0x000082a1
    80b0:	00000000 	.word	0x00000000

000080b4 <__do_global_dtors_aux>:
    80b4:	b510      	push	{r4, lr}
    80b6:	4c06      	ldr	r4, [pc, #24]	; (80d0 <__do_global_dtors_aux+0x1c>)
    80b8:	7823      	ldrb	r3, [r4, #0]
    80ba:	2b00      	cmp	r3, #0
    80bc:	d107      	bne.n	80ce <__do_global_dtors_aux+0x1a>
    80be:	4b05      	ldr	r3, [pc, #20]	; (80d4 <__do_global_dtors_aux+0x20>)
    80c0:	2b00      	cmp	r3, #0
    80c2:	d002      	beq.n	80ca <__do_global_dtors_aux+0x16>
    80c4:	4804      	ldr	r0, [pc, #16]	; (80d8 <__do_global_dtors_aux+0x24>)
    80c6:	e000      	b.n	80ca <__do_global_dtors_aux+0x16>
    80c8:	bf00      	nop
    80ca:	2301      	movs	r3, #1
    80cc:	7023      	strb	r3, [r4, #0]
    80ce:	bd10      	pop	{r4, pc}
    80d0:	20000074 	.word	0x20000074
    80d4:	00000000 	.word	0x00000000
    80d8:	0000b11c 	.word	0x0000b11c

000080dc <frame_dummy>:
    80dc:	4b08      	ldr	r3, [pc, #32]	; (8100 <frame_dummy+0x24>)
    80de:	b510      	push	{r4, lr}
    80e0:	2b00      	cmp	r3, #0
    80e2:	d003      	beq.n	80ec <frame_dummy+0x10>
    80e4:	4907      	ldr	r1, [pc, #28]	; (8104 <frame_dummy+0x28>)
    80e6:	4808      	ldr	r0, [pc, #32]	; (8108 <frame_dummy+0x2c>)
    80e8:	e000      	b.n	80ec <frame_dummy+0x10>
    80ea:	bf00      	nop
    80ec:	4807      	ldr	r0, [pc, #28]	; (810c <frame_dummy+0x30>)
    80ee:	6803      	ldr	r3, [r0, #0]
    80f0:	2b00      	cmp	r3, #0
    80f2:	d100      	bne.n	80f6 <frame_dummy+0x1a>
    80f4:	bd10      	pop	{r4, pc}
    80f6:	4b06      	ldr	r3, [pc, #24]	; (8110 <frame_dummy+0x34>)
    80f8:	2b00      	cmp	r3, #0
    80fa:	d0fb      	beq.n	80f4 <frame_dummy+0x18>
    80fc:	4798      	blx	r3
    80fe:	e7f9      	b.n	80f4 <frame_dummy+0x18>
    8100:	00000000 	.word	0x00000000
    8104:	20000078 	.word	0x20000078
    8108:	0000b11c 	.word	0x0000b11c
    810c:	0000b11c 	.word	0x0000b11c
    8110:	00000000 	.word	0x00000000

00008114 <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
    8114:	b580      	push	{r7, lr}
    8116:	b082      	sub	sp, #8
    8118:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
    811a:	4b10      	ldr	r3, [pc, #64]	; (815c <cpu_irq_enter_critical+0x48>)
    811c:	681b      	ldr	r3, [r3, #0]
    811e:	2b00      	cmp	r3, #0
    8120:	d112      	bne.n	8148 <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    8122:	f3ef 8310 	mrs	r3, PRIMASK
    8126:	607b      	str	r3, [r7, #4]
  return(result);
    8128:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
    812a:	2b00      	cmp	r3, #0
    812c:	d109      	bne.n	8142 <cpu_irq_enter_critical+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    812e:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    8130:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    8134:	4b0a      	ldr	r3, [pc, #40]	; (8160 <cpu_irq_enter_critical+0x4c>)
    8136:	2200      	movs	r2, #0
    8138:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    813a:	4b0a      	ldr	r3, [pc, #40]	; (8164 <cpu_irq_enter_critical+0x50>)
    813c:	2201      	movs	r2, #1
    813e:	701a      	strb	r2, [r3, #0]
    8140:	e002      	b.n	8148 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    8142:	4b08      	ldr	r3, [pc, #32]	; (8164 <cpu_irq_enter_critical+0x50>)
    8144:	2200      	movs	r2, #0
    8146:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    8148:	4b04      	ldr	r3, [pc, #16]	; (815c <cpu_irq_enter_critical+0x48>)
    814a:	681b      	ldr	r3, [r3, #0]
    814c:	1c5a      	adds	r2, r3, #1
    814e:	4b03      	ldr	r3, [pc, #12]	; (815c <cpu_irq_enter_critical+0x48>)
    8150:	601a      	str	r2, [r3, #0]
}
    8152:	46c0      	nop			; (mov r8, r8)
    8154:	46bd      	mov	sp, r7
    8156:	b002      	add	sp, #8
    8158:	bd80      	pop	{r7, pc}
    815a:	46c0      	nop			; (mov r8, r8)
    815c:	20000090 	.word	0x20000090
    8160:	20000000 	.word	0x20000000
    8164:	20000094 	.word	0x20000094

00008168 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
    8168:	b580      	push	{r7, lr}
    816a:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    816c:	4b0b      	ldr	r3, [pc, #44]	; (819c <cpu_irq_leave_critical+0x34>)
    816e:	681b      	ldr	r3, [r3, #0]
    8170:	1e5a      	subs	r2, r3, #1
    8172:	4b0a      	ldr	r3, [pc, #40]	; (819c <cpu_irq_leave_critical+0x34>)
    8174:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    8176:	4b09      	ldr	r3, [pc, #36]	; (819c <cpu_irq_leave_critical+0x34>)
    8178:	681b      	ldr	r3, [r3, #0]
    817a:	2b00      	cmp	r3, #0
    817c:	d10a      	bne.n	8194 <cpu_irq_leave_critical+0x2c>
    817e:	4b08      	ldr	r3, [pc, #32]	; (81a0 <cpu_irq_leave_critical+0x38>)
    8180:	781b      	ldrb	r3, [r3, #0]
    8182:	b2db      	uxtb	r3, r3
    8184:	2b00      	cmp	r3, #0
    8186:	d005      	beq.n	8194 <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
    8188:	4b06      	ldr	r3, [pc, #24]	; (81a4 <cpu_irq_leave_critical+0x3c>)
    818a:	2201      	movs	r2, #1
    818c:	701a      	strb	r2, [r3, #0]
    818e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    8192:	b662      	cpsie	i
	}
}
    8194:	46c0      	nop			; (mov r8, r8)
    8196:	46bd      	mov	sp, r7
    8198:	bd80      	pop	{r7, pc}
    819a:	46c0      	nop			; (mov r8, r8)
    819c:	20000090 	.word	0x20000090
    81a0:	20000094 	.word	0x20000094
    81a4:	20000000 	.word	0x20000000

000081a8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    81a8:	b580      	push	{r7, lr}
    81aa:	b082      	sub	sp, #8
    81ac:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    81ae:	4b2f      	ldr	r3, [pc, #188]	; (826c <Reset_Handler+0xc4>)
    81b0:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    81b2:	4b2f      	ldr	r3, [pc, #188]	; (8270 <Reset_Handler+0xc8>)
    81b4:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    81b6:	687a      	ldr	r2, [r7, #4]
    81b8:	683b      	ldr	r3, [r7, #0]
    81ba:	429a      	cmp	r2, r3
    81bc:	d00c      	beq.n	81d8 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    81be:	e007      	b.n	81d0 <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    81c0:	683b      	ldr	r3, [r7, #0]
    81c2:	1d1a      	adds	r2, r3, #4
    81c4:	603a      	str	r2, [r7, #0]
    81c6:	687a      	ldr	r2, [r7, #4]
    81c8:	1d11      	adds	r1, r2, #4
    81ca:	6079      	str	r1, [r7, #4]
    81cc:	6812      	ldr	r2, [r2, #0]
    81ce:	601a      	str	r2, [r3, #0]
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    81d0:	683a      	ldr	r2, [r7, #0]
    81d2:	4b28      	ldr	r3, [pc, #160]	; (8274 <Reset_Handler+0xcc>)
    81d4:	429a      	cmp	r2, r3
    81d6:	d3f3      	bcc.n	81c0 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    81d8:	4b27      	ldr	r3, [pc, #156]	; (8278 <Reset_Handler+0xd0>)
    81da:	603b      	str	r3, [r7, #0]
    81dc:	e004      	b.n	81e8 <Reset_Handler+0x40>
                *pDest++ = 0;
    81de:	683b      	ldr	r3, [r7, #0]
    81e0:	1d1a      	adds	r2, r3, #4
    81e2:	603a      	str	r2, [r7, #0]
    81e4:	2200      	movs	r2, #0
    81e6:	601a      	str	r2, [r3, #0]
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    81e8:	683a      	ldr	r2, [r7, #0]
    81ea:	4b24      	ldr	r3, [pc, #144]	; (827c <Reset_Handler+0xd4>)
    81ec:	429a      	cmp	r2, r3
    81ee:	d3f6      	bcc.n	81de <Reset_Handler+0x36>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    81f0:	4b23      	ldr	r3, [pc, #140]	; (8280 <Reset_Handler+0xd8>)
    81f2:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    81f4:	4b23      	ldr	r3, [pc, #140]	; (8284 <Reset_Handler+0xdc>)
    81f6:	687a      	ldr	r2, [r7, #4]
    81f8:	21ff      	movs	r1, #255	; 0xff
    81fa:	438a      	bics	r2, r1
    81fc:	609a      	str	r2, [r3, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    81fe:	4a22      	ldr	r2, [pc, #136]	; (8288 <Reset_Handler+0xe0>)
    8200:	2390      	movs	r3, #144	; 0x90
    8202:	005b      	lsls	r3, r3, #1
    8204:	2102      	movs	r1, #2
    8206:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    8208:	4a20      	ldr	r2, [pc, #128]	; (828c <Reset_Handler+0xe4>)
    820a:	78d3      	ldrb	r3, [r2, #3]
    820c:	2103      	movs	r1, #3
    820e:	438b      	bics	r3, r1
    8210:	1c19      	adds	r1, r3, #0
    8212:	2302      	movs	r3, #2
    8214:	430b      	orrs	r3, r1
    8216:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    8218:	4a1c      	ldr	r2, [pc, #112]	; (828c <Reset_Handler+0xe4>)
    821a:	78d3      	ldrb	r3, [r2, #3]
    821c:	210c      	movs	r1, #12
    821e:	438b      	bics	r3, r1
    8220:	1c19      	adds	r1, r3, #0
    8222:	2308      	movs	r3, #8
    8224:	430b      	orrs	r3, r1
    8226:	70d3      	strb	r3, [r2, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    8228:	4a19      	ldr	r2, [pc, #100]	; (8290 <Reset_Handler+0xe8>)
    822a:	7b93      	ldrb	r3, [r2, #14]
    822c:	2130      	movs	r1, #48	; 0x30
    822e:	438b      	bics	r3, r1
    8230:	1c19      	adds	r1, r3, #0
    8232:	2320      	movs	r3, #32
    8234:	430b      	orrs	r3, r1
    8236:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    8238:	4a15      	ldr	r2, [pc, #84]	; (8290 <Reset_Handler+0xe8>)
    823a:	7b93      	ldrb	r3, [r2, #14]
    823c:	210c      	movs	r1, #12
    823e:	438b      	bics	r3, r1
    8240:	1c19      	adds	r1, r3, #0
    8242:	2308      	movs	r3, #8
    8244:	430b      	orrs	r3, r1
    8246:	7393      	strb	r3, [r2, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    8248:	4a11      	ldr	r2, [pc, #68]	; (8290 <Reset_Handler+0xe8>)
    824a:	7b93      	ldrb	r3, [r2, #14]
    824c:	2103      	movs	r1, #3
    824e:	438b      	bics	r3, r1
    8250:	1c19      	adds	r1, r3, #0
    8252:	2302      	movs	r3, #2
    8254:	430b      	orrs	r3, r1
    8256:	7393      	strb	r3, [r2, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    8258:	4a0e      	ldr	r2, [pc, #56]	; (8294 <Reset_Handler+0xec>)
    825a:	6853      	ldr	r3, [r2, #4]
    825c:	2180      	movs	r1, #128	; 0x80
    825e:	430b      	orrs	r3, r1
    8260:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    8262:	4b0d      	ldr	r3, [pc, #52]	; (8298 <Reset_Handler+0xf0>)
    8264:	4798      	blx	r3

        /* Branch to main function */
        main();
    8266:	4b0d      	ldr	r3, [pc, #52]	; (829c <Reset_Handler+0xf4>)
    8268:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    826a:	e7fe      	b.n	826a <Reset_Handler+0xc2>
    826c:	0000b11c 	.word	0x0000b11c
    8270:	20000000 	.word	0x20000000
    8274:	20000074 	.word	0x20000074
    8278:	20000074 	.word	0x20000074
    827c:	20000174 	.word	0x20000174
    8280:	00008000 	.word	0x00008000
    8284:	e000ed00 	.word	0xe000ed00
    8288:	41007000 	.word	0x41007000
    828c:	41005000 	.word	0x41005000
    8290:	41004800 	.word	0x41004800
    8294:	41004000 	.word	0x41004000
    8298:	0000a549 	.word	0x0000a549
    829c:	0000a4bd 	.word	0x0000a4bd

000082a0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    82a0:	b580      	push	{r7, lr}
    82a2:	af00      	add	r7, sp, #0
        while (1) {
        }
    82a4:	e7fe      	b.n	82a4 <Dummy_Handler+0x4>
    82a6:	46c0      	nop			; (mov r8, r8)

000082a8 <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    82a8:	b580      	push	{r7, lr}
    82aa:	b084      	sub	sp, #16
    82ac:	af00      	add	r7, sp, #0
    82ae:	6078      	str	r0, [r7, #4]
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    82b0:	4b0a      	ldr	r3, [pc, #40]	; (82dc <_sbrk+0x34>)
    82b2:	681b      	ldr	r3, [r3, #0]
    82b4:	2b00      	cmp	r3, #0
    82b6:	d102      	bne.n	82be <_sbrk+0x16>
		heap = (unsigned char *)&_end;
    82b8:	4b08      	ldr	r3, [pc, #32]	; (82dc <_sbrk+0x34>)
    82ba:	4a09      	ldr	r2, [pc, #36]	; (82e0 <_sbrk+0x38>)
    82bc:	601a      	str	r2, [r3, #0]
	}
	prev_heap = heap;
    82be:	4b07      	ldr	r3, [pc, #28]	; (82dc <_sbrk+0x34>)
    82c0:	681b      	ldr	r3, [r3, #0]
    82c2:	60fb      	str	r3, [r7, #12]

	heap += incr;
    82c4:	4b05      	ldr	r3, [pc, #20]	; (82dc <_sbrk+0x34>)
    82c6:	681a      	ldr	r2, [r3, #0]
    82c8:	687b      	ldr	r3, [r7, #4]
    82ca:	18d2      	adds	r2, r2, r3
    82cc:	4b03      	ldr	r3, [pc, #12]	; (82dc <_sbrk+0x34>)
    82ce:	601a      	str	r2, [r3, #0]

	return (caddr_t) prev_heap;
    82d0:	68fb      	ldr	r3, [r7, #12]
}
    82d2:	0018      	movs	r0, r3
    82d4:	46bd      	mov	sp, r7
    82d6:	b004      	add	sp, #16
    82d8:	bd80      	pop	{r7, pc}
    82da:	46c0      	nop			; (mov r8, r8)
    82dc:	20000098 	.word	0x20000098
    82e0:	20002178 	.word	0x20002178

000082e4 <_close>:
{
	return -1;
}

extern int _close(int file)
{
    82e4:	b580      	push	{r7, lr}
    82e6:	b082      	sub	sp, #8
    82e8:	af00      	add	r7, sp, #0
    82ea:	6078      	str	r0, [r7, #4]
	return -1;
    82ec:	2301      	movs	r3, #1
    82ee:	425b      	negs	r3, r3
}
    82f0:	0018      	movs	r0, r3
    82f2:	46bd      	mov	sp, r7
    82f4:	b002      	add	sp, #8
    82f6:	bd80      	pop	{r7, pc}

000082f8 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
    82f8:	b580      	push	{r7, lr}
    82fa:	b082      	sub	sp, #8
    82fc:	af00      	add	r7, sp, #0
    82fe:	6078      	str	r0, [r7, #4]
    8300:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
    8302:	683b      	ldr	r3, [r7, #0]
    8304:	2280      	movs	r2, #128	; 0x80
    8306:	0192      	lsls	r2, r2, #6
    8308:	605a      	str	r2, [r3, #4]

	return 0;
    830a:	2300      	movs	r3, #0
}
    830c:	0018      	movs	r0, r3
    830e:	46bd      	mov	sp, r7
    8310:	b002      	add	sp, #8
    8312:	bd80      	pop	{r7, pc}

00008314 <_isatty>:

extern int _isatty(int file)
{
    8314:	b580      	push	{r7, lr}
    8316:	b082      	sub	sp, #8
    8318:	af00      	add	r7, sp, #0
    831a:	6078      	str	r0, [r7, #4]
	return 1;
    831c:	2301      	movs	r3, #1
}
    831e:	0018      	movs	r0, r3
    8320:	46bd      	mov	sp, r7
    8322:	b002      	add	sp, #8
    8324:	bd80      	pop	{r7, pc}
    8326:	46c0      	nop			; (mov r8, r8)

00008328 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
    8328:	b580      	push	{r7, lr}
    832a:	b084      	sub	sp, #16
    832c:	af00      	add	r7, sp, #0
    832e:	60f8      	str	r0, [r7, #12]
    8330:	60b9      	str	r1, [r7, #8]
    8332:	607a      	str	r2, [r7, #4]
	return 0;
    8334:	2300      	movs	r3, #0
}
    8336:	0018      	movs	r0, r3
    8338:	46bd      	mov	sp, r7
    833a:	b004      	add	sp, #16
    833c:	bd80      	pop	{r7, pc}
    833e:	46c0      	nop			; (mov r8, r8)

00008340 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    8340:	b580      	push	{r7, lr}
    8342:	af00      	add	r7, sp, #0
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
    8344:	46c0      	nop			; (mov r8, r8)
    8346:	46bd      	mov	sp, r7
    8348:	bd80      	pop	{r7, pc}
    834a:	46c0      	nop			; (mov r8, r8)

0000834c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    834c:	b580      	push	{r7, lr}
    834e:	b084      	sub	sp, #16
    8350:	af00      	add	r7, sp, #0
    8352:	0002      	movs	r2, r0
    8354:	1dfb      	adds	r3, r7, #7
    8356:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    8358:	230f      	movs	r3, #15
    835a:	18fb      	adds	r3, r7, r3
    835c:	1dfa      	adds	r2, r7, #7
    835e:	7812      	ldrb	r2, [r2, #0]
    8360:	09d2      	lsrs	r2, r2, #7
    8362:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    8364:	230e      	movs	r3, #14
    8366:	18fb      	adds	r3, r7, r3
    8368:	1dfa      	adds	r2, r7, #7
    836a:	7812      	ldrb	r2, [r2, #0]
    836c:	0952      	lsrs	r2, r2, #5
    836e:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    8370:	4b0d      	ldr	r3, [pc, #52]	; (83a8 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    8372:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    8374:	230f      	movs	r3, #15
    8376:	18fb      	adds	r3, r7, r3
    8378:	781b      	ldrb	r3, [r3, #0]
    837a:	2b00      	cmp	r3, #0
    837c:	d10f      	bne.n	839e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    837e:	230f      	movs	r3, #15
    8380:	18fb      	adds	r3, r7, r3
    8382:	781b      	ldrb	r3, [r3, #0]
    8384:	009b      	lsls	r3, r3, #2
    8386:	2210      	movs	r2, #16
    8388:	4694      	mov	ip, r2
    838a:	44bc      	add	ip, r7
    838c:	4463      	add	r3, ip
    838e:	3b08      	subs	r3, #8
    8390:	681a      	ldr	r2, [r3, #0]
    8392:	230e      	movs	r3, #14
    8394:	18fb      	adds	r3, r7, r3
    8396:	781b      	ldrb	r3, [r3, #0]
    8398:	01db      	lsls	r3, r3, #7
    839a:	18d3      	adds	r3, r2, r3
    839c:	e000      	b.n	83a0 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    839e:	2300      	movs	r3, #0
	}
}
    83a0:	0018      	movs	r0, r3
    83a2:	46bd      	mov	sp, r7
    83a4:	b004      	add	sp, #16
    83a6:	bd80      	pop	{r7, pc}
    83a8:	41004400 	.word	0x41004400

000083ac <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    83ac:	b580      	push	{r7, lr}
    83ae:	b082      	sub	sp, #8
    83b0:	af00      	add	r7, sp, #0
    83b2:	0002      	movs	r2, r0
    83b4:	1dfb      	adds	r3, r7, #7
    83b6:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    83b8:	1dfb      	adds	r3, r7, #7
    83ba:	781b      	ldrb	r3, [r3, #0]
    83bc:	0018      	movs	r0, r3
    83be:	4b03      	ldr	r3, [pc, #12]	; (83cc <port_get_group_from_gpio_pin+0x20>)
    83c0:	4798      	blx	r3
    83c2:	0003      	movs	r3, r0
}
    83c4:	0018      	movs	r0, r3
    83c6:	46bd      	mov	sp, r7
    83c8:	b002      	add	sp, #8
    83ca:	bd80      	pop	{r7, pc}
    83cc:	0000834d 	.word	0x0000834d

000083d0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    83d0:	b580      	push	{r7, lr}
    83d2:	b084      	sub	sp, #16
    83d4:	af00      	add	r7, sp, #0
    83d6:	0002      	movs	r2, r0
    83d8:	1dfb      	adds	r3, r7, #7
    83da:	701a      	strb	r2, [r3, #0]
    83dc:	1dbb      	adds	r3, r7, #6
    83de:	1c0a      	adds	r2, r1, #0
    83e0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    83e2:	1dfb      	adds	r3, r7, #7
    83e4:	781b      	ldrb	r3, [r3, #0]
    83e6:	0018      	movs	r0, r3
    83e8:	4b0d      	ldr	r3, [pc, #52]	; (8420 <port_pin_set_output_level+0x50>)
    83ea:	4798      	blx	r3
    83ec:	0003      	movs	r3, r0
    83ee:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    83f0:	1dfb      	adds	r3, r7, #7
    83f2:	781b      	ldrb	r3, [r3, #0]
    83f4:	221f      	movs	r2, #31
    83f6:	4013      	ands	r3, r2
    83f8:	2201      	movs	r2, #1
    83fa:	409a      	lsls	r2, r3
    83fc:	0013      	movs	r3, r2
    83fe:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    8400:	1dbb      	adds	r3, r7, #6
    8402:	781b      	ldrb	r3, [r3, #0]
    8404:	2b00      	cmp	r3, #0
    8406:	d003      	beq.n	8410 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    8408:	68fb      	ldr	r3, [r7, #12]
    840a:	68ba      	ldr	r2, [r7, #8]
    840c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    840e:	e002      	b.n	8416 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    8410:	68fb      	ldr	r3, [r7, #12]
    8412:	68ba      	ldr	r2, [r7, #8]
    8414:	615a      	str	r2, [r3, #20]
	}
}
    8416:	46c0      	nop			; (mov r8, r8)
    8418:	46bd      	mov	sp, r7
    841a:	b004      	add	sp, #16
    841c:	bd80      	pop	{r7, pc}
    841e:	46c0      	nop			; (mov r8, r8)
    8420:	000083ad 	.word	0x000083ad

00008424 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
    8424:	b580      	push	{r7, lr}
    8426:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    8428:	4b02      	ldr	r3, [pc, #8]	; (8434 <system_interrupt_enter_critical_section+0x10>)
    842a:	4798      	blx	r3
}
    842c:	46c0      	nop			; (mov r8, r8)
    842e:	46bd      	mov	sp, r7
    8430:	bd80      	pop	{r7, pc}
    8432:	46c0      	nop			; (mov r8, r8)
    8434:	00008115 	.word	0x00008115

00008438 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
    8438:	b580      	push	{r7, lr}
    843a:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    843c:	4b02      	ldr	r3, [pc, #8]	; (8448 <system_interrupt_leave_critical_section+0x10>)
    843e:	4798      	blx	r3
}
    8440:	46c0      	nop			; (mov r8, r8)
    8442:	46bd      	mov	sp, r7
    8444:	bd80      	pop	{r7, pc}
    8446:	46c0      	nop			; (mov r8, r8)
    8448:	00008169 	.word	0x00008169

0000844c <spi_lock>:
 *
 * \retval STATUS_OK If the module was locked
 * \retval STATUS_BUSY If the module was already locked
 */
static inline enum status_code spi_lock(struct spi_module *const module)
{
    844c:	b580      	push	{r7, lr}
    844e:	b084      	sub	sp, #16
    8450:	af00      	add	r7, sp, #0
    8452:	6078      	str	r0, [r7, #4]
	enum status_code status;

	system_interrupt_enter_critical_section();
    8454:	4b0d      	ldr	r3, [pc, #52]	; (848c <spi_lock+0x40>)
    8456:	4798      	blx	r3

	if (module->locked) {
    8458:	687b      	ldr	r3, [r7, #4]
    845a:	791b      	ldrb	r3, [r3, #4]
    845c:	b2db      	uxtb	r3, r3
    845e:	2b00      	cmp	r3, #0
    8460:	d004      	beq.n	846c <spi_lock+0x20>
		status = STATUS_BUSY;
    8462:	230f      	movs	r3, #15
    8464:	18fb      	adds	r3, r7, r3
    8466:	2205      	movs	r2, #5
    8468:	701a      	strb	r2, [r3, #0]
    846a:	e006      	b.n	847a <spi_lock+0x2e>
	} else {
		module->locked = true;
    846c:	687b      	ldr	r3, [r7, #4]
    846e:	2201      	movs	r2, #1
    8470:	711a      	strb	r2, [r3, #4]
		status = STATUS_OK;
    8472:	230f      	movs	r3, #15
    8474:	18fb      	adds	r3, r7, r3
    8476:	2200      	movs	r2, #0
    8478:	701a      	strb	r2, [r3, #0]
	}

	system_interrupt_leave_critical_section();
    847a:	4b05      	ldr	r3, [pc, #20]	; (8490 <spi_lock+0x44>)
    847c:	4798      	blx	r3

	return status;
    847e:	230f      	movs	r3, #15
    8480:	18fb      	adds	r3, r7, r3
    8482:	781b      	ldrb	r3, [r3, #0]
}
    8484:	0018      	movs	r0, r3
    8486:	46bd      	mov	sp, r7
    8488:	b004      	add	sp, #16
    848a:	bd80      	pop	{r7, pc}
    848c:	00008425 	.word	0x00008425
    8490:	00008439 	.word	0x00008439

00008494 <spi_unlock>:
 *
 * \retval STATUS_OK If the module was locked
 * \retval STATUS_BUSY If the module was already locked
 */
static inline void spi_unlock(struct spi_module *const module)
{
    8494:	b580      	push	{r7, lr}
    8496:	b082      	sub	sp, #8
    8498:	af00      	add	r7, sp, #0
    849a:	6078      	str	r0, [r7, #4]
	module->locked = false;
    849c:	687b      	ldr	r3, [r7, #4]
    849e:	2200      	movs	r2, #0
    84a0:	711a      	strb	r2, [r3, #4]
}
    84a2:	46c0      	nop			; (mov r8, r8)
    84a4:	46bd      	mov	sp, r7
    84a6:	b002      	add	sp, #8
    84a8:	bd80      	pop	{r7, pc}
    84aa:	46c0      	nop			; (mov r8, r8)

000084ac <spi_is_ready_to_write>:
 * \retval true   If the SPI module is ready to write data
 * \retval false  If the SPI module is not ready to write data
 */
static inline bool spi_is_ready_to_write(
		struct spi_module *const module)
{
    84ac:	b580      	push	{r7, lr}
    84ae:	b084      	sub	sp, #16
    84b0:	af00      	add	r7, sp, #0
    84b2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    84b4:	687b      	ldr	r3, [r7, #4]
    84b6:	681b      	ldr	r3, [r3, #0]
    84b8:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    84ba:	68fb      	ldr	r3, [r7, #12]
    84bc:	7e1b      	ldrb	r3, [r3, #24]
    84be:	b2db      	uxtb	r3, r3
    84c0:	001a      	movs	r2, r3
    84c2:	2301      	movs	r3, #1
    84c4:	4013      	ands	r3, r2
    84c6:	1e5a      	subs	r2, r3, #1
    84c8:	4193      	sbcs	r3, r2
    84ca:	b2db      	uxtb	r3, r3
}
    84cc:	0018      	movs	r0, r3
    84ce:	46bd      	mov	sp, r7
    84d0:	b004      	add	sp, #16
    84d2:	bd80      	pop	{r7, pc}

000084d4 <spi_is_ready_to_read>:
 * \retval true   If the SPI module is ready to read data
 * \retval false  If the SPI module is not ready to read data
 */
static inline bool spi_is_ready_to_read(
		struct spi_module *const module)
{
    84d4:	b580      	push	{r7, lr}
    84d6:	b084      	sub	sp, #16
    84d8:	af00      	add	r7, sp, #0
    84da:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    84dc:	687b      	ldr	r3, [r7, #4]
    84de:	681b      	ldr	r3, [r3, #0]
    84e0:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    84e2:	68fb      	ldr	r3, [r7, #12]
    84e4:	7e1b      	ldrb	r3, [r3, #24]
    84e6:	b2db      	uxtb	r3, r3
    84e8:	001a      	movs	r2, r3
    84ea:	2304      	movs	r3, #4
    84ec:	4013      	ands	r3, r2
    84ee:	1e5a      	subs	r2, r3, #1
    84f0:	4193      	sbcs	r3, r2
    84f2:	b2db      	uxtb	r3, r3
}
    84f4:	0018      	movs	r0, r3
    84f6:	46bd      	mov	sp, r7
    84f8:	b004      	add	sp, #16
    84fa:	bd80      	pop	{r7, pc}

000084fc <spi_write>:
 * \retval STATUS_BUSY  If the last write was not completed
 */
static inline enum status_code spi_write(
		struct spi_module *module,
		uint16_t tx_data)
{
    84fc:	b580      	push	{r7, lr}
    84fe:	b084      	sub	sp, #16
    8500:	af00      	add	r7, sp, #0
    8502:	6078      	str	r0, [r7, #4]
    8504:	000a      	movs	r2, r1
    8506:	1cbb      	adds	r3, r7, #2
    8508:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    850a:	687b      	ldr	r3, [r7, #4]
    850c:	681b      	ldr	r3, [r3, #0]
    850e:	60fb      	str	r3, [r7, #12]

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    8510:	687b      	ldr	r3, [r7, #4]
    8512:	0018      	movs	r0, r3
    8514:	4b0a      	ldr	r3, [pc, #40]	; (8540 <spi_write+0x44>)
    8516:	4798      	blx	r3
    8518:	0003      	movs	r3, r0
    851a:	001a      	movs	r2, r3
    851c:	2301      	movs	r3, #1
    851e:	4053      	eors	r3, r2
    8520:	b2db      	uxtb	r3, r3
    8522:	2b00      	cmp	r3, #0
    8524:	d001      	beq.n	852a <spi_write+0x2e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
    8526:	2305      	movs	r3, #5
    8528:	e006      	b.n	8538 <spi_write+0x3c>
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    852a:	1cbb      	adds	r3, r7, #2
    852c:	881b      	ldrh	r3, [r3, #0]
    852e:	05db      	lsls	r3, r3, #23
    8530:	0dda      	lsrs	r2, r3, #23
    8532:	68fb      	ldr	r3, [r7, #12]
    8534:	629a      	str	r2, [r3, #40]	; 0x28

	return STATUS_OK;
    8536:	2300      	movs	r3, #0
}
    8538:	0018      	movs	r0, r3
    853a:	46bd      	mov	sp, r7
    853c:	b004      	add	sp, #16
    853e:	bd80      	pop	{r7, pc}
    8540:	000084ad 	.word	0x000084ad

00008544 <spi_read>:
 * \retval STATUS_ERR_OVERFLOW  If the data is overflown
 */
static inline enum status_code spi_read(
		struct spi_module *const module,
		uint16_t *rx_data)
{
    8544:	b580      	push	{r7, lr}
    8546:	b084      	sub	sp, #16
    8548:	af00      	add	r7, sp, #0
    854a:	6078      	str	r0, [r7, #4]
    854c:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    854e:	687b      	ldr	r3, [r7, #4]
    8550:	681b      	ldr	r3, [r3, #0]
    8552:	60bb      	str	r3, [r7, #8]

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    8554:	687b      	ldr	r3, [r7, #4]
    8556:	0018      	movs	r0, r3
    8558:	4b1b      	ldr	r3, [pc, #108]	; (85c8 <spi_read+0x84>)
    855a:	4798      	blx	r3
    855c:	0003      	movs	r3, r0
    855e:	001a      	movs	r2, r3
    8560:	2301      	movs	r3, #1
    8562:	4053      	eors	r3, r2
    8564:	b2db      	uxtb	r3, r3
    8566:	2b00      	cmp	r3, #0
    8568:	d001      	beq.n	856e <spi_read+0x2a>
		/* No data has been received, return */
		return STATUS_ERR_IO;
    856a:	2310      	movs	r3, #16
    856c:	e027      	b.n	85be <spi_read+0x7a>
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    856e:	230f      	movs	r3, #15
    8570:	18fb      	adds	r3, r7, r3
    8572:	2200      	movs	r2, #0
    8574:	701a      	strb	r2, [r3, #0]

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    8576:	68bb      	ldr	r3, [r7, #8]
    8578:	8b5b      	ldrh	r3, [r3, #26]
    857a:	b29b      	uxth	r3, r3
    857c:	001a      	movs	r2, r3
    857e:	2304      	movs	r3, #4
    8580:	4013      	ands	r3, r2
    8582:	d006      	beq.n	8592 <spi_read+0x4e>
		retval = STATUS_ERR_OVERFLOW;
    8584:	230f      	movs	r3, #15
    8586:	18fb      	adds	r3, r7, r3
    8588:	221e      	movs	r2, #30
    858a:	701a      	strb	r2, [r3, #0]
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    858c:	68bb      	ldr	r3, [r7, #8]
    858e:	2204      	movs	r2, #4
    8590:	835a      	strh	r2, [r3, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    8592:	687b      	ldr	r3, [r7, #4]
    8594:	799b      	ldrb	r3, [r3, #6]
    8596:	2b01      	cmp	r3, #1
    8598:	d108      	bne.n	85ac <spi_read+0x68>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    859a:	68bb      	ldr	r3, [r7, #8]
    859c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    859e:	b29b      	uxth	r3, r3
    85a0:	05db      	lsls	r3, r3, #23
    85a2:	0ddb      	lsrs	r3, r3, #23
    85a4:	b29a      	uxth	r2, r3
    85a6:	683b      	ldr	r3, [r7, #0]
    85a8:	801a      	strh	r2, [r3, #0]
    85aa:	e005      	b.n	85b8 <spi_read+0x74>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    85ac:	68bb      	ldr	r3, [r7, #8]
    85ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    85b0:	b2db      	uxtb	r3, r3
    85b2:	b29a      	uxth	r2, r3
    85b4:	683b      	ldr	r3, [r7, #0]
    85b6:	801a      	strh	r2, [r3, #0]
	}

	return retval;
    85b8:	230f      	movs	r3, #15
    85ba:	18fb      	adds	r3, r7, r3
    85bc:	781b      	ldrb	r3, [r3, #0]
}
    85be:	0018      	movs	r0, r3
    85c0:	46bd      	mov	sp, r7
    85c2:	b004      	add	sp, #16
    85c4:	bd80      	pop	{r7, pc}
    85c6:	46c0      	nop			; (mov r8, r8)
    85c8:	000084d5 	.word	0x000084d5

000085cc <_at25dfx_get_device_id>:
 * \param[in] type Type of SerialFlash.
 *
 * \return SerialFlash device ID.
 */
static inline uint32_t _at25dfx_get_device_id(enum at25dfx_type type)
{
    85cc:	b580      	push	{r7, lr}
    85ce:	b082      	sub	sp, #8
    85d0:	af00      	add	r7, sp, #0
    85d2:	0002      	movs	r2, r0
    85d4:	1dfb      	adds	r3, r7, #7
    85d6:	701a      	strb	r2, [r3, #0]
	switch (type) {
    85d8:	1dfb      	adds	r3, r7, #7
    85da:	781b      	ldrb	r3, [r3, #0]
    85dc:	2b09      	cmp	r3, #9
    85de:	d818      	bhi.n	8612 <_at25dfx_get_device_id+0x46>
    85e0:	009a      	lsls	r2, r3, #2
    85e2:	4b0e      	ldr	r3, [pc, #56]	; (861c <_at25dfx_get_device_id+0x50>)
    85e4:	18d3      	adds	r3, r2, r3
    85e6:	681b      	ldr	r3, [r3, #0]
    85e8:	469f      	mov	pc, r3
	case AT25DFX_512B:
		return 0x00651f;
    85ea:	4b0d      	ldr	r3, [pc, #52]	; (8620 <_at25dfx_get_device_id+0x54>)
    85ec:	e012      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_021:
		return 0x00431f;
    85ee:	4b0d      	ldr	r3, [pc, #52]	; (8624 <_at25dfx_get_device_id+0x58>)
    85f0:	e010      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_041A:
		return 0x01441f;
    85f2:	4b0d      	ldr	r3, [pc, #52]	; (8628 <_at25dfx_get_device_id+0x5c>)
    85f4:	e00e      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_081:
		return 0x02451f;
    85f6:	4b0d      	ldr	r3, [pc, #52]	; (862c <_at25dfx_get_device_id+0x60>)
    85f8:	e00c      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_081A:
		return 0x01451f;
    85fa:	4b0d      	ldr	r3, [pc, #52]	; (8630 <_at25dfx_get_device_id+0x64>)
    85fc:	e00a      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_161:
		return 0x02461f;
    85fe:	4b0d      	ldr	r3, [pc, #52]	; (8634 <_at25dfx_get_device_id+0x68>)
    8600:	e008      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_L161:
		return 0x03461f;
    8602:	4b0d      	ldr	r3, [pc, #52]	; (8638 <_at25dfx_get_device_id+0x6c>)
    8604:	e006      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_Q161:
		return 0x00861f;
    8606:	4b0d      	ldr	r3, [pc, #52]	; (863c <_at25dfx_get_device_id+0x70>)
    8608:	e004      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_321A:
		return 0x01471f;
    860a:	4b0d      	ldr	r3, [pc, #52]	; (8640 <_at25dfx_get_device_id+0x74>)
    860c:	e002      	b.n	8614 <_at25dfx_get_device_id+0x48>

	case AT25DFX_641:
		return 0x00481f;
    860e:	4b0d      	ldr	r3, [pc, #52]	; (8644 <_at25dfx_get_device_id+0x78>)
    8610:	e000      	b.n	8614 <_at25dfx_get_device_id+0x48>

	default:
		Assert(false);
		return 0;
    8612:	2300      	movs	r3, #0
	}
}
    8614:	0018      	movs	r0, r3
    8616:	46bd      	mov	sp, r7
    8618:	b002      	add	sp, #8
    861a:	bd80      	pop	{r7, pc}
    861c:	0000aedc 	.word	0x0000aedc
    8620:	0000651f 	.word	0x0000651f
    8624:	0000431f 	.word	0x0000431f
    8628:	0001441f 	.word	0x0001441f
    862c:	0002451f 	.word	0x0002451f
    8630:	0001451f 	.word	0x0001451f
    8634:	0002461f 	.word	0x0002461f
    8638:	0003461f 	.word	0x0003461f
    863c:	0000861f 	.word	0x0000861f
    8640:	0001471f 	.word	0x0001471f
    8644:	0000481f 	.word	0x0000481f

00008648 <_at25dfx_get_device_size>:
 * \param[in] type Type of SerialFlash.
 *
 * \return SerialFlash storage size.
 */
static inline uint32_t _at25dfx_get_device_size(enum at25dfx_type type)
{
    8648:	b580      	push	{r7, lr}
    864a:	b082      	sub	sp, #8
    864c:	af00      	add	r7, sp, #0
    864e:	0002      	movs	r2, r0
    8650:	1dfb      	adds	r3, r7, #7
    8652:	701a      	strb	r2, [r3, #0]
	switch (type) {
    8654:	1dfb      	adds	r3, r7, #7
    8656:	781b      	ldrb	r3, [r3, #0]
    8658:	2b09      	cmp	r3, #9
    865a:	d819      	bhi.n	8690 <_at25dfx_get_device_size+0x48>
    865c:	009a      	lsls	r2, r3, #2
    865e:	4b0f      	ldr	r3, [pc, #60]	; (869c <_at25dfx_get_device_size+0x54>)
    8660:	18d3      	adds	r3, r2, r3
    8662:	681b      	ldr	r3, [r3, #0]
    8664:	469f      	mov	pc, r3
	case AT25DFX_512B:
		return 64 * 1024UL;
    8666:	2380      	movs	r3, #128	; 0x80
    8668:	025b      	lsls	r3, r3, #9
    866a:	e012      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_021:
		return 256 * 1024UL;
    866c:	2380      	movs	r3, #128	; 0x80
    866e:	02db      	lsls	r3, r3, #11
    8670:	e00f      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_041A:
		return 512 * 1024UL;
    8672:	2380      	movs	r3, #128	; 0x80
    8674:	031b      	lsls	r3, r3, #12
    8676:	e00c      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_081:
	case AT25DFX_081A:
		return 1024 * 1024UL;
    8678:	2380      	movs	r3, #128	; 0x80
    867a:	035b      	lsls	r3, r3, #13
    867c:	e009      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_161:
	case AT25DFX_L161:
	case AT25DFX_Q161:
		return 2048 * 1024UL;
    867e:	2380      	movs	r3, #128	; 0x80
    8680:	039b      	lsls	r3, r3, #14
    8682:	e006      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_321A:
		return 4096 * 1024UL;
    8684:	2380      	movs	r3, #128	; 0x80
    8686:	03db      	lsls	r3, r3, #15
    8688:	e003      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	case AT25DFX_641:
		return 8192 * 1024UL;
    868a:	2380      	movs	r3, #128	; 0x80
    868c:	041b      	lsls	r3, r3, #16
    868e:	e000      	b.n	8692 <_at25dfx_get_device_size+0x4a>

	default:
		Assert(false);
		return 0;
    8690:	2300      	movs	r3, #0
	}
}
    8692:	0018      	movs	r0, r3
    8694:	46bd      	mov	sp, r7
    8696:	b002      	add	sp, #8
    8698:	bd80      	pop	{r7, pc}
    869a:	46c0      	nop			; (mov r8, r8)
    869c:	0000af04 	.word	0x0000af04

000086a0 <_at25dfx_chip_select>:
 * This function selects the specified chip by driving its CS line low.
 *
 * \param[in] chip Address of SerialFlash chip instance to operate on.
 */
static inline void _at25dfx_chip_select(struct at25dfx_chip_module *chip)
{
    86a0:	b580      	push	{r7, lr}
    86a2:	b082      	sub	sp, #8
    86a4:	af00      	add	r7, sp, #0
    86a6:	6078      	str	r0, [r7, #4]
	port_pin_set_output_level(chip->cs_pin, false);
    86a8:	687b      	ldr	r3, [r7, #4]
    86aa:	795b      	ldrb	r3, [r3, #5]
    86ac:	2100      	movs	r1, #0
    86ae:	0018      	movs	r0, r3
    86b0:	4b02      	ldr	r3, [pc, #8]	; (86bc <_at25dfx_chip_select+0x1c>)
    86b2:	4798      	blx	r3
}
    86b4:	46c0      	nop			; (mov r8, r8)
    86b6:	46bd      	mov	sp, r7
    86b8:	b002      	add	sp, #8
    86ba:	bd80      	pop	{r7, pc}
    86bc:	000083d1 	.word	0x000083d1

000086c0 <_at25dfx_chip_deselect>:
 * This function deselects the specified chip by driving its CS line high.
 *
 * \param[in] chip Address of SerialFlash chip instance to operate on.
 */
static inline void _at25dfx_chip_deselect(struct at25dfx_chip_module *chip)
{
    86c0:	b580      	push	{r7, lr}
    86c2:	b082      	sub	sp, #8
    86c4:	af00      	add	r7, sp, #0
    86c6:	6078      	str	r0, [r7, #4]
	port_pin_set_output_level(chip->cs_pin, true);
    86c8:	687b      	ldr	r3, [r7, #4]
    86ca:	795b      	ldrb	r3, [r3, #5]
    86cc:	2101      	movs	r1, #1
    86ce:	0018      	movs	r0, r3
    86d0:	4b02      	ldr	r3, [pc, #8]	; (86dc <_at25dfx_chip_deselect+0x1c>)
    86d2:	4798      	blx	r3
}
    86d4:	46c0      	nop			; (mov r8, r8)
    86d6:	46bd      	mov	sp, r7
    86d8:	b002      	add	sp, #8
    86da:	bd80      	pop	{r7, pc}
    86dc:	000083d1 	.word	0x000083d1

000086e0 <_at25dfx_chip_issue_read_command_wait>:
 * \param chip Address of SerialFlash chip instance to operate on.
 * \param cmd The command to issue.
 */
static inline void _at25dfx_chip_issue_read_command_wait(
		struct at25dfx_chip_module *chip, struct at25dfx_command cmd)
{
    86e0:	b084      	sub	sp, #16
    86e2:	b5b0      	push	{r4, r5, r7, lr}
    86e4:	b084      	sub	sp, #16
    86e6:	af00      	add	r7, sp, #0
    86e8:	6078      	str	r0, [r7, #4]
    86ea:	2004      	movs	r0, #4
    86ec:	2420      	movs	r4, #32
    86ee:	46a4      	mov	ip, r4
    86f0:	44bc      	add	ip, r7
    86f2:	4460      	add	r0, ip
    86f4:	6001      	str	r1, [r0, #0]
    86f6:	6042      	str	r2, [r0, #4]
    86f8:	6083      	str	r3, [r0, #8]
	UNUSED(status);

	Assert((cmd.command_size) && (cmd.command_size <= AT25DFX_COMMAND_MAX_SIZE));

	// Construct command to send
	cmd_buffer[0] = cmd.opcode;
    86fa:	2304      	movs	r3, #4
    86fc:	2220      	movs	r2, #32
    86fe:	4694      	mov	ip, r2
    8700:	44bc      	add	ip, r7
    8702:	4463      	add	r3, ip
    8704:	781a      	ldrb	r2, [r3, #0]
    8706:	2308      	movs	r3, #8
    8708:	18fb      	adds	r3, r7, r3
    870a:	701a      	strb	r2, [r3, #0]

	if (cmd.command_size > 1) {
    870c:	2304      	movs	r3, #4
    870e:	2220      	movs	r2, #32
    8710:	4694      	mov	ip, r2
    8712:	44bc      	add	ip, r7
    8714:	4463      	add	r3, ip
    8716:	785b      	ldrb	r3, [r3, #1]
    8718:	2b01      	cmp	r3, #1
    871a:	d91f      	bls.n	875c <_at25dfx_chip_issue_read_command_wait+0x7c>
		Assert(cmd.command_size >= 4);

		cmd_buffer[3] = cmd.address & 0xff;
    871c:	2304      	movs	r3, #4
    871e:	2220      	movs	r2, #32
    8720:	4694      	mov	ip, r2
    8722:	44bc      	add	ip, r7
    8724:	4463      	add	r3, ip
    8726:	685b      	ldr	r3, [r3, #4]
    8728:	b2da      	uxtb	r2, r3
    872a:	2308      	movs	r3, #8
    872c:	18fb      	adds	r3, r7, r3
    872e:	70da      	strb	r2, [r3, #3]
		cmd_buffer[2] = (cmd.address >> 8) & 0xff;
    8730:	2304      	movs	r3, #4
    8732:	2220      	movs	r2, #32
    8734:	4694      	mov	ip, r2
    8736:	44bc      	add	ip, r7
    8738:	4463      	add	r3, ip
    873a:	685b      	ldr	r3, [r3, #4]
    873c:	0a1b      	lsrs	r3, r3, #8
    873e:	b2da      	uxtb	r2, r3
    8740:	2308      	movs	r3, #8
    8742:	18fb      	adds	r3, r7, r3
    8744:	709a      	strb	r2, [r3, #2]
		cmd_buffer[1] = (cmd.address >> 16) & 0xff;
    8746:	2304      	movs	r3, #4
    8748:	2220      	movs	r2, #32
    874a:	4694      	mov	ip, r2
    874c:	44bc      	add	ip, r7
    874e:	4463      	add	r3, ip
    8750:	685b      	ldr	r3, [r3, #4]
    8752:	0c1b      	lsrs	r3, r3, #16
    8754:	b2da      	uxtb	r2, r3
    8756:	2308      	movs	r3, #8
    8758:	18fb      	adds	r3, r7, r3
    875a:	705a      	strb	r2, [r3, #1]
	}
	// Don't bother with init of dummy bytes

	// Issue command, then start read
	_at25dfx_chip_select(chip);
    875c:	687b      	ldr	r3, [r7, #4]
    875e:	0018      	movs	r0, r3
    8760:	4b1d      	ldr	r3, [pc, #116]	; (87d8 <_at25dfx_chip_issue_read_command_wait+0xf8>)
    8762:	4798      	blx	r3

	status = spi_write_buffer_wait(chip->spi, cmd_buffer, cmd.command_size);
    8764:	687b      	ldr	r3, [r7, #4]
    8766:	6818      	ldr	r0, [r3, #0]
    8768:	2304      	movs	r3, #4
    876a:	2220      	movs	r2, #32
    876c:	4694      	mov	ip, r2
    876e:	44bc      	add	ip, r7
    8770:	4463      	add	r3, ip
    8772:	785b      	ldrb	r3, [r3, #1]
    8774:	b29a      	uxth	r2, r3
    8776:	230f      	movs	r3, #15
    8778:	18fc      	adds	r4, r7, r3
    877a:	2308      	movs	r3, #8
    877c:	18fb      	adds	r3, r7, r3
    877e:	0019      	movs	r1, r3
    8780:	4b16      	ldr	r3, [pc, #88]	; (87dc <_at25dfx_chip_issue_read_command_wait+0xfc>)
    8782:	4798      	blx	r3
    8784:	0003      	movs	r3, r0
    8786:	7023      	strb	r3, [r4, #0]
	Assert(status == STATUS_OK);

	if (cmd.length) {
    8788:	2304      	movs	r3, #4
    878a:	2220      	movs	r2, #32
    878c:	4694      	mov	ip, r2
    878e:	44bc      	add	ip, r7
    8790:	4463      	add	r3, ip
    8792:	899b      	ldrh	r3, [r3, #12]
    8794:	2b00      	cmp	r3, #0
    8796:	d014      	beq.n	87c2 <_at25dfx_chip_issue_read_command_wait+0xe2>
		status = spi_read_buffer_wait(chip->spi, cmd.data.rx, cmd.length, 0);
    8798:	687b      	ldr	r3, [r7, #4]
    879a:	6818      	ldr	r0, [r3, #0]
    879c:	2304      	movs	r3, #4
    879e:	2220      	movs	r2, #32
    87a0:	4694      	mov	ip, r2
    87a2:	44bc      	add	ip, r7
    87a4:	4463      	add	r3, ip
    87a6:	6899      	ldr	r1, [r3, #8]
    87a8:	2304      	movs	r3, #4
    87aa:	2220      	movs	r2, #32
    87ac:	4694      	mov	ip, r2
    87ae:	44bc      	add	ip, r7
    87b0:	4463      	add	r3, ip
    87b2:	899a      	ldrh	r2, [r3, #12]
    87b4:	230f      	movs	r3, #15
    87b6:	18fc      	adds	r4, r7, r3
    87b8:	2300      	movs	r3, #0
    87ba:	4d09      	ldr	r5, [pc, #36]	; (87e0 <_at25dfx_chip_issue_read_command_wait+0x100>)
    87bc:	47a8      	blx	r5
    87be:	0003      	movs	r3, r0
    87c0:	7023      	strb	r3, [r4, #0]
		Assert(status == STATUS_OK);
	}

	_at25dfx_chip_deselect(chip);
    87c2:	687b      	ldr	r3, [r7, #4]
    87c4:	0018      	movs	r0, r3
    87c6:	4b07      	ldr	r3, [pc, #28]	; (87e4 <_at25dfx_chip_issue_read_command_wait+0x104>)
    87c8:	4798      	blx	r3
}
    87ca:	46c0      	nop			; (mov r8, r8)
    87cc:	46bd      	mov	sp, r7
    87ce:	b004      	add	sp, #16
    87d0:	bcb0      	pop	{r4, r5, r7}
    87d2:	bc08      	pop	{r3}
    87d4:	b004      	add	sp, #16
    87d6:	4718      	bx	r3
    87d8:	000086a1 	.word	0x000086a1
    87dc:	00009701 	.word	0x00009701
    87e0:	000095cd 	.word	0x000095cd
    87e4:	000086c1 	.word	0x000086c1

000087e8 <_at25dfx_chip_issue_write_command_wait>:
 * \param chip Address of SerialFlash chip instance to operate on.
 * \param cmd The command to issue.
 */
static inline void _at25dfx_chip_issue_write_command_wait(
		struct at25dfx_chip_module *chip, struct at25dfx_command cmd)
{
    87e8:	b084      	sub	sp, #16
    87ea:	b590      	push	{r4, r7, lr}
    87ec:	b085      	sub	sp, #20
    87ee:	af00      	add	r7, sp, #0
    87f0:	6078      	str	r0, [r7, #4]
    87f2:	2004      	movs	r0, #4
    87f4:	2420      	movs	r4, #32
    87f6:	46a4      	mov	ip, r4
    87f8:	44bc      	add	ip, r7
    87fa:	4460      	add	r0, ip
    87fc:	6001      	str	r1, [r0, #0]
    87fe:	6042      	str	r2, [r0, #4]
    8800:	6083      	str	r3, [r0, #8]

	UNUSED(status);

	Assert((cmd.command_size) && (cmd.command_size <= AT25DFX_COMMAND_MAX_SIZE));

	cmd_buffer[0] = cmd.opcode;
    8802:	2304      	movs	r3, #4
    8804:	2220      	movs	r2, #32
    8806:	4694      	mov	ip, r2
    8808:	44bc      	add	ip, r7
    880a:	4463      	add	r3, ip
    880c:	781a      	ldrb	r2, [r3, #0]
    880e:	2308      	movs	r3, #8
    8810:	18fb      	adds	r3, r7, r3
    8812:	701a      	strb	r2, [r3, #0]

	if (cmd.command_size > 1) {
    8814:	2304      	movs	r3, #4
    8816:	2220      	movs	r2, #32
    8818:	4694      	mov	ip, r2
    881a:	44bc      	add	ip, r7
    881c:	4463      	add	r3, ip
    881e:	785b      	ldrb	r3, [r3, #1]
    8820:	2b01      	cmp	r3, #1
    8822:	d91f      	bls.n	8864 <_at25dfx_chip_issue_write_command_wait+0x7c>
		Assert(cmd.command_size >= 4);

		cmd_buffer[3] = cmd.address & 0xff;
    8824:	2304      	movs	r3, #4
    8826:	2220      	movs	r2, #32
    8828:	4694      	mov	ip, r2
    882a:	44bc      	add	ip, r7
    882c:	4463      	add	r3, ip
    882e:	685b      	ldr	r3, [r3, #4]
    8830:	b2da      	uxtb	r2, r3
    8832:	2308      	movs	r3, #8
    8834:	18fb      	adds	r3, r7, r3
    8836:	70da      	strb	r2, [r3, #3]
		cmd_buffer[2] = (cmd.address >> 8) & 0xff;
    8838:	2304      	movs	r3, #4
    883a:	2220      	movs	r2, #32
    883c:	4694      	mov	ip, r2
    883e:	44bc      	add	ip, r7
    8840:	4463      	add	r3, ip
    8842:	685b      	ldr	r3, [r3, #4]
    8844:	0a1b      	lsrs	r3, r3, #8
    8846:	b2da      	uxtb	r2, r3
    8848:	2308      	movs	r3, #8
    884a:	18fb      	adds	r3, r7, r3
    884c:	709a      	strb	r2, [r3, #2]
		cmd_buffer[1] = (cmd.address >> 16) & 0xff;
    884e:	2304      	movs	r3, #4
    8850:	2220      	movs	r2, #32
    8852:	4694      	mov	ip, r2
    8854:	44bc      	add	ip, r7
    8856:	4463      	add	r3, ip
    8858:	685b      	ldr	r3, [r3, #4]
    885a:	0c1b      	lsrs	r3, r3, #16
    885c:	b2da      	uxtb	r2, r3
    885e:	2308      	movs	r3, #8
    8860:	18fb      	adds	r3, r7, r3
    8862:	705a      	strb	r2, [r3, #1]
	}

	_at25dfx_chip_select(chip);
    8864:	687b      	ldr	r3, [r7, #4]
    8866:	0018      	movs	r0, r3
    8868:	4b1d      	ldr	r3, [pc, #116]	; (88e0 <_at25dfx_chip_issue_write_command_wait+0xf8>)
    886a:	4798      	blx	r3

	status = spi_write_buffer_wait(chip->spi, cmd_buffer, cmd.command_size);
    886c:	687b      	ldr	r3, [r7, #4]
    886e:	6818      	ldr	r0, [r3, #0]
    8870:	2304      	movs	r3, #4
    8872:	2220      	movs	r2, #32
    8874:	4694      	mov	ip, r2
    8876:	44bc      	add	ip, r7
    8878:	4463      	add	r3, ip
    887a:	785b      	ldrb	r3, [r3, #1]
    887c:	b29a      	uxth	r2, r3
    887e:	230f      	movs	r3, #15
    8880:	18fc      	adds	r4, r7, r3
    8882:	2308      	movs	r3, #8
    8884:	18fb      	adds	r3, r7, r3
    8886:	0019      	movs	r1, r3
    8888:	4b16      	ldr	r3, [pc, #88]	; (88e4 <_at25dfx_chip_issue_write_command_wait+0xfc>)
    888a:	4798      	blx	r3
    888c:	0003      	movs	r3, r0
    888e:	7023      	strb	r3, [r4, #0]
	Assert(status == STATUS_OK);

	if (cmd.length) {
    8890:	2304      	movs	r3, #4
    8892:	2220      	movs	r2, #32
    8894:	4694      	mov	ip, r2
    8896:	44bc      	add	ip, r7
    8898:	4463      	add	r3, ip
    889a:	899b      	ldrh	r3, [r3, #12]
    889c:	2b00      	cmp	r3, #0
    889e:	d014      	beq.n	88ca <_at25dfx_chip_issue_write_command_wait+0xe2>
		status = spi_write_buffer_wait(chip->spi, cmd.data.tx, cmd.length);
    88a0:	687b      	ldr	r3, [r7, #4]
    88a2:	6818      	ldr	r0, [r3, #0]
    88a4:	2304      	movs	r3, #4
    88a6:	2220      	movs	r2, #32
    88a8:	4694      	mov	ip, r2
    88aa:	44bc      	add	ip, r7
    88ac:	4463      	add	r3, ip
    88ae:	6899      	ldr	r1, [r3, #8]
    88b0:	2304      	movs	r3, #4
    88b2:	2220      	movs	r2, #32
    88b4:	4694      	mov	ip, r2
    88b6:	44bc      	add	ip, r7
    88b8:	4463      	add	r3, ip
    88ba:	899b      	ldrh	r3, [r3, #12]
    88bc:	220f      	movs	r2, #15
    88be:	18bc      	adds	r4, r7, r2
    88c0:	001a      	movs	r2, r3
    88c2:	4b08      	ldr	r3, [pc, #32]	; (88e4 <_at25dfx_chip_issue_write_command_wait+0xfc>)
    88c4:	4798      	blx	r3
    88c6:	0003      	movs	r3, r0
    88c8:	7023      	strb	r3, [r4, #0]
		Assert(status == STATUS_OK);
	}

	_at25dfx_chip_deselect(chip);
    88ca:	687b      	ldr	r3, [r7, #4]
    88cc:	0018      	movs	r0, r3
    88ce:	4b06      	ldr	r3, [pc, #24]	; (88e8 <_at25dfx_chip_issue_write_command_wait+0x100>)
    88d0:	4798      	blx	r3
}
    88d2:	46c0      	nop			; (mov r8, r8)
    88d4:	46bd      	mov	sp, r7
    88d6:	b005      	add	sp, #20
    88d8:	bc90      	pop	{r4, r7}
    88da:	bc08      	pop	{r3}
    88dc:	b004      	add	sp, #16
    88de:	4718      	bx	r3
    88e0:	000086a1 	.word	0x000086a1
    88e4:	00009701 	.word	0x00009701
    88e8:	000086c1 	.word	0x000086c1

000088ec <_at25dfx_chip_get_nonbusy_status>:
 * \retval STATUS_OK if operation succeeded.
 * \retval STATUS_ERR_IO if an error occurred.
 */
static inline enum status_code _at25dfx_chip_get_nonbusy_status(
		struct at25dfx_chip_module *chip)
{
    88ec:	b590      	push	{r4, r7, lr}
    88ee:	b085      	sub	sp, #20
    88f0:	af00      	add	r7, sp, #0
    88f2:	6078      	str	r0, [r7, #4]
	enum status_code status;
	uint16_t status_reg = 0;
    88f4:	230c      	movs	r3, #12
    88f6:	18fb      	adds	r3, r7, r3
    88f8:	2200      	movs	r2, #0
    88fa:	801a      	strh	r2, [r3, #0]

	UNUSED(status);

	// Issue status read command
	while (!spi_is_ready_to_write(chip->spi)) {
    88fc:	46c0      	nop			; (mov r8, r8)
    88fe:	687b      	ldr	r3, [r7, #4]
    8900:	681b      	ldr	r3, [r3, #0]
    8902:	0018      	movs	r0, r3
    8904:	4b3c      	ldr	r3, [pc, #240]	; (89f8 <_at25dfx_chip_get_nonbusy_status+0x10c>)
    8906:	4798      	blx	r3
    8908:	0003      	movs	r3, r0
    890a:	001a      	movs	r2, r3
    890c:	2301      	movs	r3, #1
    890e:	4053      	eors	r3, r2
    8910:	b2db      	uxtb	r3, r3
    8912:	2b00      	cmp	r3, #0
    8914:	d1f3      	bne.n	88fe <_at25dfx_chip_get_nonbusy_status+0x12>
	}

	_at25dfx_chip_select(chip);
    8916:	687b      	ldr	r3, [r7, #4]
    8918:	0018      	movs	r0, r3
    891a:	4b38      	ldr	r3, [pc, #224]	; (89fc <_at25dfx_chip_get_nonbusy_status+0x110>)
    891c:	4798      	blx	r3
	status = spi_write(chip->spi, AT25DFX_COMMAND_READ_STATUS);
    891e:	687b      	ldr	r3, [r7, #4]
    8920:	681b      	ldr	r3, [r3, #0]
    8922:	220f      	movs	r2, #15
    8924:	18bc      	adds	r4, r7, r2
    8926:	2105      	movs	r1, #5
    8928:	0018      	movs	r0, r3
    892a:	4b35      	ldr	r3, [pc, #212]	; (8a00 <_at25dfx_chip_get_nonbusy_status+0x114>)
    892c:	4798      	blx	r3
    892e:	0003      	movs	r3, r0
    8930:	7023      	strb	r3, [r4, #0]
	Assert(status == STATUS_OK);

	while (!spi_is_ready_to_read(chip->spi)) {
    8932:	46c0      	nop			; (mov r8, r8)
    8934:	687b      	ldr	r3, [r7, #4]
    8936:	681b      	ldr	r3, [r3, #0]
    8938:	0018      	movs	r0, r3
    893a:	4b32      	ldr	r3, [pc, #200]	; (8a04 <_at25dfx_chip_get_nonbusy_status+0x118>)
    893c:	4798      	blx	r3
    893e:	0003      	movs	r3, r0
    8940:	001a      	movs	r2, r3
    8942:	2301      	movs	r3, #1
    8944:	4053      	eors	r3, r2
    8946:	b2db      	uxtb	r3, r3
    8948:	2b00      	cmp	r3, #0
    894a:	d1f3      	bne.n	8934 <_at25dfx_chip_get_nonbusy_status+0x48>
	}
	status = spi_read(chip->spi, &status_reg);
    894c:	687b      	ldr	r3, [r7, #4]
    894e:	681b      	ldr	r3, [r3, #0]
    8950:	220f      	movs	r2, #15
    8952:	18bc      	adds	r4, r7, r2
    8954:	220c      	movs	r2, #12
    8956:	18ba      	adds	r2, r7, r2
    8958:	0011      	movs	r1, r2
    895a:	0018      	movs	r0, r3
    895c:	4b2a      	ldr	r3, [pc, #168]	; (8a08 <_at25dfx_chip_get_nonbusy_status+0x11c>)
    895e:	4798      	blx	r3
    8960:	0003      	movs	r3, r0
    8962:	7023      	strb	r3, [r4, #0]

	// Keep reading until busy flag clears
	// TODO: Add some timeout functionality here!
	do {
		// Do dummy writes to read out status
		while (!spi_is_ready_to_write(chip->spi)) {
    8964:	46c0      	nop			; (mov r8, r8)
    8966:	687b      	ldr	r3, [r7, #4]
    8968:	681b      	ldr	r3, [r3, #0]
    896a:	0018      	movs	r0, r3
    896c:	4b22      	ldr	r3, [pc, #136]	; (89f8 <_at25dfx_chip_get_nonbusy_status+0x10c>)
    896e:	4798      	blx	r3
    8970:	0003      	movs	r3, r0
    8972:	001a      	movs	r2, r3
    8974:	2301      	movs	r3, #1
    8976:	4053      	eors	r3, r2
    8978:	b2db      	uxtb	r3, r3
    897a:	2b00      	cmp	r3, #0
    897c:	d1f3      	bne.n	8966 <_at25dfx_chip_get_nonbusy_status+0x7a>
		}
		status = spi_write(chip->spi, 0);
    897e:	687b      	ldr	r3, [r7, #4]
    8980:	681b      	ldr	r3, [r3, #0]
    8982:	220f      	movs	r2, #15
    8984:	18bc      	adds	r4, r7, r2
    8986:	2100      	movs	r1, #0
    8988:	0018      	movs	r0, r3
    898a:	4b1d      	ldr	r3, [pc, #116]	; (8a00 <_at25dfx_chip_get_nonbusy_status+0x114>)
    898c:	4798      	blx	r3
    898e:	0003      	movs	r3, r0
    8990:	7023      	strb	r3, [r4, #0]
		Assert(status == STATUS_OK);

		while (!spi_is_ready_to_read(chip->spi)) {
    8992:	46c0      	nop			; (mov r8, r8)
    8994:	687b      	ldr	r3, [r7, #4]
    8996:	681b      	ldr	r3, [r3, #0]
    8998:	0018      	movs	r0, r3
    899a:	4b1a      	ldr	r3, [pc, #104]	; (8a04 <_at25dfx_chip_get_nonbusy_status+0x118>)
    899c:	4798      	blx	r3
    899e:	0003      	movs	r3, r0
    89a0:	001a      	movs	r2, r3
    89a2:	2301      	movs	r3, #1
    89a4:	4053      	eors	r3, r2
    89a6:	b2db      	uxtb	r3, r3
    89a8:	2b00      	cmp	r3, #0
    89aa:	d1f3      	bne.n	8994 <_at25dfx_chip_get_nonbusy_status+0xa8>
		}
		status = spi_read(chip->spi, &status_reg);
    89ac:	687b      	ldr	r3, [r7, #4]
    89ae:	681b      	ldr	r3, [r3, #0]
    89b0:	220f      	movs	r2, #15
    89b2:	18bc      	adds	r4, r7, r2
    89b4:	220c      	movs	r2, #12
    89b6:	18ba      	adds	r2, r7, r2
    89b8:	0011      	movs	r1, r2
    89ba:	0018      	movs	r0, r3
    89bc:	4b12      	ldr	r3, [pc, #72]	; (8a08 <_at25dfx_chip_get_nonbusy_status+0x11c>)
    89be:	4798      	blx	r3
    89c0:	0003      	movs	r3, r0
    89c2:	7023      	strb	r3, [r4, #0]
		Assert(status == STATUS_OK);
	} while (status_reg & AT25DFX_STATUS_BUSY);
    89c4:	230c      	movs	r3, #12
    89c6:	18fb      	adds	r3, r7, r3
    89c8:	881b      	ldrh	r3, [r3, #0]
    89ca:	001a      	movs	r2, r3
    89cc:	2301      	movs	r3, #1
    89ce:	4013      	ands	r3, r2
    89d0:	d1c8      	bne.n	8964 <_at25dfx_chip_get_nonbusy_status+0x78>

	_at25dfx_chip_deselect(chip);
    89d2:	687b      	ldr	r3, [r7, #4]
    89d4:	0018      	movs	r0, r3
    89d6:	4b0d      	ldr	r3, [pc, #52]	; (8a0c <_at25dfx_chip_get_nonbusy_status+0x120>)
    89d8:	4798      	blx	r3

	// Return final status
	if (status_reg & AT25DFX_STATUS_ERROR) {
    89da:	230c      	movs	r3, #12
    89dc:	18fb      	adds	r3, r7, r3
    89de:	881b      	ldrh	r3, [r3, #0]
    89e0:	001a      	movs	r2, r3
    89e2:	2320      	movs	r3, #32
    89e4:	4013      	ands	r3, r2
    89e6:	d001      	beq.n	89ec <_at25dfx_chip_get_nonbusy_status+0x100>
		return STATUS_ERR_IO;
    89e8:	2310      	movs	r3, #16
    89ea:	e000      	b.n	89ee <_at25dfx_chip_get_nonbusy_status+0x102>
	}
	return STATUS_OK;
    89ec:	2300      	movs	r3, #0
}
    89ee:	0018      	movs	r0, r3
    89f0:	46bd      	mov	sp, r7
    89f2:	b005      	add	sp, #20
    89f4:	bd90      	pop	{r4, r7, pc}
    89f6:	46c0      	nop			; (mov r8, r8)
    89f8:	000084ad 	.word	0x000084ad
    89fc:	000086a1 	.word	0x000086a1
    8a00:	000084fd 	.word	0x000084fd
    8a04:	000084d5 	.word	0x000084d5
    8a08:	00008545 	.word	0x00008545
    8a0c:	000086c1 	.word	0x000086c1

00008a10 <_at25dfx_chip_enable_write>:
 * or unprotecting sectors.
 *
 * \param[in] chip Address of SerialFlash chip instance to operate on.
 */
static inline void _at25dfx_chip_enable_write(struct at25dfx_chip_module *chip)
{
    8a10:	b590      	push	{r4, r7, lr}
    8a12:	b089      	sub	sp, #36	; 0x24
    8a14:	af02      	add	r7, sp, #8
    8a16:	6078      	str	r0, [r7, #4]
	struct at25dfx_command cmd;

	cmd.opcode = AT25DFX_COMMAND_WRITE_ENABLE;
    8a18:	2308      	movs	r3, #8
    8a1a:	18fb      	adds	r3, r7, r3
    8a1c:	2206      	movs	r2, #6
    8a1e:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 1;
    8a20:	2308      	movs	r3, #8
    8a22:	18fb      	adds	r3, r7, r3
    8a24:	2201      	movs	r2, #1
    8a26:	705a      	strb	r2, [r3, #1]
	cmd.length = 0;
    8a28:	2308      	movs	r3, #8
    8a2a:	18fb      	adds	r3, r7, r3
    8a2c:	2200      	movs	r2, #0
    8a2e:	819a      	strh	r2, [r3, #12]

	// Init to avoid warnings with -Os
	cmd.address = (at25dfx_address_t)NULL;
    8a30:	2308      	movs	r3, #8
    8a32:	18fb      	adds	r3, r7, r3
    8a34:	2200      	movs	r2, #0
    8a36:	605a      	str	r2, [r3, #4]
	cmd.data.tx = NULL;
    8a38:	2308      	movs	r3, #8
    8a3a:	18fb      	adds	r3, r7, r3
    8a3c:	2200      	movs	r2, #0
    8a3e:	609a      	str	r2, [r3, #8]

	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8a40:	2308      	movs	r3, #8
    8a42:	18fb      	adds	r3, r7, r3
    8a44:	6878      	ldr	r0, [r7, #4]
    8a46:	466a      	mov	r2, sp
    8a48:	68d9      	ldr	r1, [r3, #12]
    8a4a:	6011      	str	r1, [r2, #0]
    8a4c:	6819      	ldr	r1, [r3, #0]
    8a4e:	685a      	ldr	r2, [r3, #4]
    8a50:	689b      	ldr	r3, [r3, #8]
    8a52:	4c03      	ldr	r4, [pc, #12]	; (8a60 <_at25dfx_chip_enable_write+0x50>)
    8a54:	47a0      	blx	r4
}
    8a56:	46c0      	nop			; (mov r8, r8)
    8a58:	46bd      	mov	sp, r7
    8a5a:	b007      	add	sp, #28
    8a5c:	bd90      	pop	{r4, r7, pc}
    8a5e:	46c0      	nop			; (mov r8, r8)
    8a60:	000087e9 	.word	0x000087e9

00008a64 <at25dfx_chip_check_presence>:
 * \retval STATUS_OK if chip responded with ID matching its type.
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 * \retval STATUS_ERR_NOT_FOUND if chip did not respond, or with wrong ID.
 */
enum status_code at25dfx_chip_check_presence(struct at25dfx_chip_module *chip)
{
    8a64:	b590      	push	{r4, r7, lr}
    8a66:	b08b      	sub	sp, #44	; 0x2c
    8a68:	af02      	add	r7, sp, #8
    8a6a:	6078      	str	r0, [r7, #4]
	enum status_code status;
	struct at25dfx_command cmd;
	uint32_t id = 0;
    8a6c:	2300      	movs	r3, #0
    8a6e:	60bb      	str	r3, [r7, #8]

	Assert(chip);

	// Reserve the SPI for us
	status = _at25dfx_spi_lock(chip->spi);
    8a70:	687b      	ldr	r3, [r7, #4]
    8a72:	681b      	ldr	r3, [r3, #0]
    8a74:	221f      	movs	r2, #31
    8a76:	18bc      	adds	r4, r7, r2
    8a78:	0018      	movs	r0, r3
    8a7a:	4b21      	ldr	r3, [pc, #132]	; (8b00 <at25dfx_chip_check_presence+0x9c>)
    8a7c:	4798      	blx	r3
    8a7e:	0003      	movs	r3, r0
    8a80:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8a82:	231f      	movs	r3, #31
    8a84:	18fb      	adds	r3, r7, r3
    8a86:	781b      	ldrb	r3, [r3, #0]
    8a88:	2b05      	cmp	r3, #5
    8a8a:	d103      	bne.n	8a94 <at25dfx_chip_check_presence+0x30>
		return status;
    8a8c:	231f      	movs	r3, #31
    8a8e:	18fb      	adds	r3, r7, r3
    8a90:	781b      	ldrb	r3, [r3, #0]
    8a92:	e030      	b.n	8af6 <at25dfx_chip_check_presence+0x92>
	}

	cmd.opcode = AT25DFX_COMMAND_READ_DEVICE_ID;
    8a94:	230c      	movs	r3, #12
    8a96:	18fb      	adds	r3, r7, r3
    8a98:	229f      	movs	r2, #159	; 0x9f
    8a9a:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 1;
    8a9c:	230c      	movs	r3, #12
    8a9e:	18fb      	adds	r3, r7, r3
    8aa0:	2201      	movs	r2, #1
    8aa2:	705a      	strb	r2, [r3, #1]
	cmd.data.rx = (uint8_t *)&id;
    8aa4:	230c      	movs	r3, #12
    8aa6:	18fb      	adds	r3, r7, r3
    8aa8:	2208      	movs	r2, #8
    8aaa:	18ba      	adds	r2, r7, r2
    8aac:	609a      	str	r2, [r3, #8]
	cmd.length = 3;
    8aae:	230c      	movs	r3, #12
    8ab0:	18fb      	adds	r3, r7, r3
    8ab2:	2203      	movs	r2, #3
    8ab4:	819a      	strh	r2, [r3, #12]

	// Init to avoid warnings with -Os
	cmd.address = (at25dfx_address_t)NULL;
    8ab6:	230c      	movs	r3, #12
    8ab8:	18fb      	adds	r3, r7, r3
    8aba:	2200      	movs	r2, #0
    8abc:	605a      	str	r2, [r3, #4]

	_at25dfx_chip_issue_read_command_wait(chip, cmd);
    8abe:	230c      	movs	r3, #12
    8ac0:	18fb      	adds	r3, r7, r3
    8ac2:	6878      	ldr	r0, [r7, #4]
    8ac4:	466a      	mov	r2, sp
    8ac6:	68d9      	ldr	r1, [r3, #12]
    8ac8:	6011      	str	r1, [r2, #0]
    8aca:	6819      	ldr	r1, [r3, #0]
    8acc:	685a      	ldr	r2, [r3, #4]
    8ace:	689b      	ldr	r3, [r3, #8]
    8ad0:	4c0c      	ldr	r4, [pc, #48]	; (8b04 <at25dfx_chip_check_presence+0xa0>)
    8ad2:	47a0      	blx	r4

	_at25dfx_spi_unlock(chip->spi);
    8ad4:	687b      	ldr	r3, [r7, #4]
    8ad6:	681b      	ldr	r3, [r3, #0]
    8ad8:	0018      	movs	r0, r3
    8ada:	4b0b      	ldr	r3, [pc, #44]	; (8b08 <at25dfx_chip_check_presence+0xa4>)
    8adc:	4798      	blx	r3

	if (id == _at25dfx_get_device_id(chip->type)) {
    8ade:	687b      	ldr	r3, [r7, #4]
    8ae0:	791b      	ldrb	r3, [r3, #4]
    8ae2:	0018      	movs	r0, r3
    8ae4:	4b09      	ldr	r3, [pc, #36]	; (8b0c <at25dfx_chip_check_presence+0xa8>)
    8ae6:	4798      	blx	r3
    8ae8:	1e02      	subs	r2, r0, #0
    8aea:	68bb      	ldr	r3, [r7, #8]
    8aec:	429a      	cmp	r2, r3
    8aee:	d101      	bne.n	8af4 <at25dfx_chip_check_presence+0x90>
		return STATUS_OK;
    8af0:	2300      	movs	r3, #0
    8af2:	e000      	b.n	8af6 <at25dfx_chip_check_presence+0x92>
	} else {
		return STATUS_ERR_NOT_FOUND;
    8af4:	2314      	movs	r3, #20
	}
}
    8af6:	0018      	movs	r0, r3
    8af8:	46bd      	mov	sp, r7
    8afa:	b009      	add	sp, #36	; 0x24
    8afc:	bd90      	pop	{r4, r7, pc}
    8afe:	46c0      	nop			; (mov r8, r8)
    8b00:	0000844d 	.word	0x0000844d
    8b04:	000086e1 	.word	0x000086e1
    8b08:	00008495 	.word	0x00008495
    8b0c:	000085cd 	.word	0x000085cd

00008b10 <at25dfx_chip_read_buffer>:
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 * \retval STATUS_ERR_INVALID_ARG if address and/or length is out of bounds.
 */
enum status_code at25dfx_chip_read_buffer(struct at25dfx_chip_module *chip,
		at25dfx_address_t address, void *data, at25dfx_datalen_t length)
{
    8b10:	b590      	push	{r4, r7, lr}
    8b12:	b08d      	sub	sp, #52	; 0x34
    8b14:	af02      	add	r7, sp, #8
    8b16:	60f8      	str	r0, [r7, #12]
    8b18:	60b9      	str	r1, [r7, #8]
    8b1a:	607a      	str	r2, [r7, #4]
    8b1c:	001a      	movs	r2, r3
    8b1e:	1cbb      	adds	r3, r7, #2
    8b20:	801a      	strh	r2, [r3, #0]
	Assert(chip);
	Assert(data);
	Assert(length);

	// Address out of range?
	if ((address + length) > _at25dfx_get_device_size(chip->type)) {
    8b22:	1cbb      	adds	r3, r7, #2
    8b24:	881a      	ldrh	r2, [r3, #0]
    8b26:	68bb      	ldr	r3, [r7, #8]
    8b28:	18d4      	adds	r4, r2, r3
    8b2a:	68fb      	ldr	r3, [r7, #12]
    8b2c:	791b      	ldrb	r3, [r3, #4]
    8b2e:	0018      	movs	r0, r3
    8b30:	4b21      	ldr	r3, [pc, #132]	; (8bb8 <at25dfx_chip_read_buffer+0xa8>)
    8b32:	4798      	blx	r3
    8b34:	0003      	movs	r3, r0
    8b36:	429c      	cmp	r4, r3
    8b38:	d901      	bls.n	8b3e <at25dfx_chip_read_buffer+0x2e>
		return STATUS_ERR_INVALID_ARG;
    8b3a:	2317      	movs	r3, #23
    8b3c:	e037      	b.n	8bae <at25dfx_chip_read_buffer+0x9e>
	}

	status = _at25dfx_spi_lock(chip->spi);
    8b3e:	68fb      	ldr	r3, [r7, #12]
    8b40:	681b      	ldr	r3, [r3, #0]
    8b42:	2227      	movs	r2, #39	; 0x27
    8b44:	18bc      	adds	r4, r7, r2
    8b46:	0018      	movs	r0, r3
    8b48:	4b1c      	ldr	r3, [pc, #112]	; (8bbc <at25dfx_chip_read_buffer+0xac>)
    8b4a:	4798      	blx	r3
    8b4c:	0003      	movs	r3, r0
    8b4e:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8b50:	2327      	movs	r3, #39	; 0x27
    8b52:	18fb      	adds	r3, r7, r3
    8b54:	781b      	ldrb	r3, [r3, #0]
    8b56:	2b05      	cmp	r3, #5
    8b58:	d103      	bne.n	8b62 <at25dfx_chip_read_buffer+0x52>
		return status;
    8b5a:	2327      	movs	r3, #39	; 0x27
    8b5c:	18fb      	adds	r3, r7, r3
    8b5e:	781b      	ldrb	r3, [r3, #0]
    8b60:	e025      	b.n	8bae <at25dfx_chip_read_buffer+0x9e>
	}

	cmd.opcode = AT25DFX_COMMAND_READ_ARRAY;
    8b62:	2314      	movs	r3, #20
    8b64:	18fb      	adds	r3, r7, r3
    8b66:	220b      	movs	r2, #11
    8b68:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 5;
    8b6a:	2314      	movs	r3, #20
    8b6c:	18fb      	adds	r3, r7, r3
    8b6e:	2205      	movs	r2, #5
    8b70:	705a      	strb	r2, [r3, #1]
	cmd.address = address;
    8b72:	2314      	movs	r3, #20
    8b74:	18fb      	adds	r3, r7, r3
    8b76:	68ba      	ldr	r2, [r7, #8]
    8b78:	605a      	str	r2, [r3, #4]
	cmd.data.rx = (uint8_t *)data;
    8b7a:	2314      	movs	r3, #20
    8b7c:	18fb      	adds	r3, r7, r3
    8b7e:	687a      	ldr	r2, [r7, #4]
    8b80:	609a      	str	r2, [r3, #8]
	cmd.length = length;
    8b82:	2314      	movs	r3, #20
    8b84:	18fb      	adds	r3, r7, r3
    8b86:	1cba      	adds	r2, r7, #2
    8b88:	8812      	ldrh	r2, [r2, #0]
    8b8a:	819a      	strh	r2, [r3, #12]
	_at25dfx_chip_issue_read_command_wait(chip, cmd);
    8b8c:	2314      	movs	r3, #20
    8b8e:	18fb      	adds	r3, r7, r3
    8b90:	68f8      	ldr	r0, [r7, #12]
    8b92:	466a      	mov	r2, sp
    8b94:	68d9      	ldr	r1, [r3, #12]
    8b96:	6011      	str	r1, [r2, #0]
    8b98:	6819      	ldr	r1, [r3, #0]
    8b9a:	685a      	ldr	r2, [r3, #4]
    8b9c:	689b      	ldr	r3, [r3, #8]
    8b9e:	4c08      	ldr	r4, [pc, #32]	; (8bc0 <at25dfx_chip_read_buffer+0xb0>)
    8ba0:	47a0      	blx	r4

	_at25dfx_spi_unlock(chip->spi);
    8ba2:	68fb      	ldr	r3, [r7, #12]
    8ba4:	681b      	ldr	r3, [r3, #0]
    8ba6:	0018      	movs	r0, r3
    8ba8:	4b06      	ldr	r3, [pc, #24]	; (8bc4 <at25dfx_chip_read_buffer+0xb4>)
    8baa:	4798      	blx	r3

	return STATUS_OK;
    8bac:	2300      	movs	r3, #0
}
    8bae:	0018      	movs	r0, r3
    8bb0:	46bd      	mov	sp, r7
    8bb2:	b00b      	add	sp, #44	; 0x2c
    8bb4:	bd90      	pop	{r4, r7, pc}
    8bb6:	46c0      	nop			; (mov r8, r8)
    8bb8:	00008649 	.word	0x00008649
    8bbc:	0000844d 	.word	0x0000844d
    8bc0:	000086e1 	.word	0x000086e1
    8bc4:	00008495 	.word	0x00008495

00008bc8 <at25dfx_chip_write_buffer>:
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 * \retval STATUS_ERR_INVALID_ARG if address and/or length is out of bounds.
 */
enum status_code at25dfx_chip_write_buffer(struct at25dfx_chip_module *chip,
		at25dfx_address_t address, const void *data, at25dfx_datalen_t length)
{
    8bc8:	b590      	push	{r4, r7, lr}
    8bca:	b08d      	sub	sp, #52	; 0x34
    8bcc:	af02      	add	r7, sp, #8
    8bce:	60f8      	str	r0, [r7, #12]
    8bd0:	60b9      	str	r1, [r7, #8]
    8bd2:	607a      	str	r2, [r7, #4]
    8bd4:	001a      	movs	r2, r3
    8bd6:	1cbb      	adds	r3, r7, #2
    8bd8:	801a      	strh	r2, [r3, #0]

	Assert(chip);
	Assert(data);
	Assert(length);

	if ((address + length) > _at25dfx_get_device_size(chip->type)) {
    8bda:	1cbb      	adds	r3, r7, #2
    8bdc:	881a      	ldrh	r2, [r3, #0]
    8bde:	68bb      	ldr	r3, [r7, #8]
    8be0:	18d4      	adds	r4, r2, r3
    8be2:	68fb      	ldr	r3, [r7, #12]
    8be4:	791b      	ldrb	r3, [r3, #4]
    8be6:	0018      	movs	r0, r3
    8be8:	4b5b      	ldr	r3, [pc, #364]	; (8d58 <at25dfx_chip_write_buffer+0x190>)
    8bea:	4798      	blx	r3
    8bec:	0003      	movs	r3, r0
    8bee:	429c      	cmp	r4, r3
    8bf0:	d901      	bls.n	8bf6 <at25dfx_chip_write_buffer+0x2e>
		return STATUS_ERR_INVALID_ARG;
    8bf2:	2317      	movs	r3, #23
    8bf4:	e0ab      	b.n	8d4e <at25dfx_chip_write_buffer+0x186>
	}

	status = _at25dfx_spi_lock(chip->spi);
    8bf6:	68fb      	ldr	r3, [r7, #12]
    8bf8:	681b      	ldr	r3, [r3, #0]
    8bfa:	2227      	movs	r2, #39	; 0x27
    8bfc:	18bc      	adds	r4, r7, r2
    8bfe:	0018      	movs	r0, r3
    8c00:	4b56      	ldr	r3, [pc, #344]	; (8d5c <at25dfx_chip_write_buffer+0x194>)
    8c02:	4798      	blx	r3
    8c04:	0003      	movs	r3, r0
    8c06:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8c08:	2327      	movs	r3, #39	; 0x27
    8c0a:	18fb      	adds	r3, r7, r3
    8c0c:	781b      	ldrb	r3, [r3, #0]
    8c0e:	2b05      	cmp	r3, #5
    8c10:	d103      	bne.n	8c1a <at25dfx_chip_write_buffer+0x52>
		return status;
    8c12:	2327      	movs	r3, #39	; 0x27
    8c14:	18fb      	adds	r3, r7, r3
    8c16:	781b      	ldrb	r3, [r3, #0]
    8c18:	e099      	b.n	8d4e <at25dfx_chip_write_buffer+0x186>
	}

	_at25dfx_chip_enable_write(chip);
    8c1a:	68fb      	ldr	r3, [r7, #12]
    8c1c:	0018      	movs	r0, r3
    8c1e:	4b50      	ldr	r3, [pc, #320]	; (8d60 <at25dfx_chip_write_buffer+0x198>)
    8c20:	4798      	blx	r3

	cmd.opcode = AT25DFX_COMMAND_PROGRAM_PAGE;
    8c22:	2314      	movs	r3, #20
    8c24:	18fb      	adds	r3, r7, r3
    8c26:	2202      	movs	r2, #2
    8c28:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 4;
    8c2a:	2314      	movs	r3, #20
    8c2c:	18fb      	adds	r3, r7, r3
    8c2e:	2204      	movs	r2, #4
    8c30:	705a      	strb	r2, [r3, #1]
	cmd.address = address;
    8c32:	2314      	movs	r3, #20
    8c34:	18fb      	adds	r3, r7, r3
    8c36:	68ba      	ldr	r2, [r7, #8]
    8c38:	605a      	str	r2, [r3, #4]
	cmd.data.tx = (uint8_t *)data;
    8c3a:	2314      	movs	r3, #20
    8c3c:	18fb      	adds	r3, r7, r3
    8c3e:	687a      	ldr	r2, [r7, #4]
    8c40:	609a      	str	r2, [r3, #8]
	page_bytes = AT25DFX_PAGE_SIZE - (address % AT25DFX_PAGE_SIZE);
    8c42:	68bb      	ldr	r3, [r7, #8]
    8c44:	b29b      	uxth	r3, r3
    8c46:	22ff      	movs	r2, #255	; 0xff
    8c48:	4013      	ands	r3, r2
    8c4a:	b29a      	uxth	r2, r3
    8c4c:	2324      	movs	r3, #36	; 0x24
    8c4e:	18fb      	adds	r3, r7, r3
    8c50:	2180      	movs	r1, #128	; 0x80
    8c52:	0049      	lsls	r1, r1, #1
    8c54:	1a8a      	subs	r2, r1, r2
    8c56:	801a      	strh	r2, [r3, #0]
	cmd.length = min(page_bytes, length);
    8c58:	1cbb      	adds	r3, r7, #2
    8c5a:	2224      	movs	r2, #36	; 0x24
    8c5c:	18ba      	adds	r2, r7, r2
    8c5e:	8810      	ldrh	r0, [r2, #0]
    8c60:	881b      	ldrh	r3, [r3, #0]
    8c62:	b299      	uxth	r1, r3
    8c64:	b282      	uxth	r2, r0
    8c66:	4291      	cmp	r1, r2
    8c68:	d900      	bls.n	8c6c <at25dfx_chip_write_buffer+0xa4>
    8c6a:	1c03      	adds	r3, r0, #0
    8c6c:	b29a      	uxth	r2, r3
    8c6e:	2314      	movs	r3, #20
    8c70:	18fb      	adds	r3, r7, r3
    8c72:	819a      	strh	r2, [r3, #12]
	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8c74:	2314      	movs	r3, #20
    8c76:	18fb      	adds	r3, r7, r3
    8c78:	68f8      	ldr	r0, [r7, #12]
    8c7a:	466a      	mov	r2, sp
    8c7c:	68d9      	ldr	r1, [r3, #12]
    8c7e:	6011      	str	r1, [r2, #0]
    8c80:	6819      	ldr	r1, [r3, #0]
    8c82:	685a      	ldr	r2, [r3, #4]
    8c84:	689b      	ldr	r3, [r3, #8]
    8c86:	4c37      	ldr	r4, [pc, #220]	; (8d64 <at25dfx_chip_write_buffer+0x19c>)
    8c88:	47a0      	blx	r4

	status = _at25dfx_chip_get_nonbusy_status(chip);
    8c8a:	2327      	movs	r3, #39	; 0x27
    8c8c:	18fc      	adds	r4, r7, r3
    8c8e:	68fb      	ldr	r3, [r7, #12]
    8c90:	0018      	movs	r0, r3
    8c92:	4b35      	ldr	r3, [pc, #212]	; (8d68 <at25dfx_chip_write_buffer+0x1a0>)
    8c94:	4798      	blx	r3
    8c96:	0003      	movs	r3, r0
    8c98:	7023      	strb	r3, [r4, #0]

	length -= cmd.length;
    8c9a:	2314      	movs	r3, #20
    8c9c:	18fb      	adds	r3, r7, r3
    8c9e:	899a      	ldrh	r2, [r3, #12]
    8ca0:	1cbb      	adds	r3, r7, #2
    8ca2:	1cb9      	adds	r1, r7, #2
    8ca4:	8809      	ldrh	r1, [r1, #0]
    8ca6:	1a8a      	subs	r2, r1, r2
    8ca8:	801a      	strh	r2, [r3, #0]

	while (length && (status == STATUS_OK)) {
    8caa:	e03f      	b.n	8d2c <at25dfx_chip_write_buffer+0x164>
		_at25dfx_chip_enable_write(chip);
    8cac:	68fb      	ldr	r3, [r7, #12]
    8cae:	0018      	movs	r0, r3
    8cb0:	4b2b      	ldr	r3, [pc, #172]	; (8d60 <at25dfx_chip_write_buffer+0x198>)
    8cb2:	4798      	blx	r3

		cmd.address += cmd.length;
    8cb4:	2314      	movs	r3, #20
    8cb6:	18fb      	adds	r3, r7, r3
    8cb8:	685b      	ldr	r3, [r3, #4]
    8cba:	2214      	movs	r2, #20
    8cbc:	18ba      	adds	r2, r7, r2
    8cbe:	8992      	ldrh	r2, [r2, #12]
    8cc0:	189a      	adds	r2, r3, r2
    8cc2:	2314      	movs	r3, #20
    8cc4:	18fb      	adds	r3, r7, r3
    8cc6:	605a      	str	r2, [r3, #4]
		cmd.data.tx += cmd.length;
    8cc8:	2314      	movs	r3, #20
    8cca:	18fb      	adds	r3, r7, r3
    8ccc:	689b      	ldr	r3, [r3, #8]
    8cce:	2214      	movs	r2, #20
    8cd0:	18ba      	adds	r2, r7, r2
    8cd2:	8992      	ldrh	r2, [r2, #12]
    8cd4:	189a      	adds	r2, r3, r2
    8cd6:	2314      	movs	r3, #20
    8cd8:	18fb      	adds	r3, r7, r3
    8cda:	609a      	str	r2, [r3, #8]
		cmd.length = min(AT25DFX_PAGE_SIZE, length);
    8cdc:	1cbb      	adds	r3, r7, #2
    8cde:	881b      	ldrh	r3, [r3, #0]
    8ce0:	b299      	uxth	r1, r3
    8ce2:	2280      	movs	r2, #128	; 0x80
    8ce4:	0052      	lsls	r2, r2, #1
    8ce6:	4291      	cmp	r1, r2
    8ce8:	d901      	bls.n	8cee <at25dfx_chip_write_buffer+0x126>
    8cea:	2380      	movs	r3, #128	; 0x80
    8cec:	005b      	lsls	r3, r3, #1
    8cee:	b29a      	uxth	r2, r3
    8cf0:	2314      	movs	r3, #20
    8cf2:	18fb      	adds	r3, r7, r3
    8cf4:	819a      	strh	r2, [r3, #12]

		_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8cf6:	2314      	movs	r3, #20
    8cf8:	18fb      	adds	r3, r7, r3
    8cfa:	68f8      	ldr	r0, [r7, #12]
    8cfc:	466a      	mov	r2, sp
    8cfe:	68d9      	ldr	r1, [r3, #12]
    8d00:	6011      	str	r1, [r2, #0]
    8d02:	6819      	ldr	r1, [r3, #0]
    8d04:	685a      	ldr	r2, [r3, #4]
    8d06:	689b      	ldr	r3, [r3, #8]
    8d08:	4c16      	ldr	r4, [pc, #88]	; (8d64 <at25dfx_chip_write_buffer+0x19c>)
    8d0a:	47a0      	blx	r4

		status = _at25dfx_chip_get_nonbusy_status(chip);
    8d0c:	2327      	movs	r3, #39	; 0x27
    8d0e:	18fc      	adds	r4, r7, r3
    8d10:	68fb      	ldr	r3, [r7, #12]
    8d12:	0018      	movs	r0, r3
    8d14:	4b14      	ldr	r3, [pc, #80]	; (8d68 <at25dfx_chip_write_buffer+0x1a0>)
    8d16:	4798      	blx	r3
    8d18:	0003      	movs	r3, r0
    8d1a:	7023      	strb	r3, [r4, #0]

		length -= cmd.length;
    8d1c:	2314      	movs	r3, #20
    8d1e:	18fb      	adds	r3, r7, r3
    8d20:	899a      	ldrh	r2, [r3, #12]
    8d22:	1cbb      	adds	r3, r7, #2
    8d24:	1cb9      	adds	r1, r7, #2
    8d26:	8809      	ldrh	r1, [r1, #0]
    8d28:	1a8a      	subs	r2, r1, r2
    8d2a:	801a      	strh	r2, [r3, #0]

	status = _at25dfx_chip_get_nonbusy_status(chip);

	length -= cmd.length;

	while (length && (status == STATUS_OK)) {
    8d2c:	1cbb      	adds	r3, r7, #2
    8d2e:	881b      	ldrh	r3, [r3, #0]
    8d30:	2b00      	cmp	r3, #0
    8d32:	d004      	beq.n	8d3e <at25dfx_chip_write_buffer+0x176>
    8d34:	2327      	movs	r3, #39	; 0x27
    8d36:	18fb      	adds	r3, r7, r3
    8d38:	781b      	ldrb	r3, [r3, #0]
    8d3a:	2b00      	cmp	r3, #0
    8d3c:	d0b6      	beq.n	8cac <at25dfx_chip_write_buffer+0xe4>
		status = _at25dfx_chip_get_nonbusy_status(chip);

		length -= cmd.length;
	}

	_at25dfx_spi_unlock(chip->spi);
    8d3e:	68fb      	ldr	r3, [r7, #12]
    8d40:	681b      	ldr	r3, [r3, #0]
    8d42:	0018      	movs	r0, r3
    8d44:	4b09      	ldr	r3, [pc, #36]	; (8d6c <at25dfx_chip_write_buffer+0x1a4>)
    8d46:	4798      	blx	r3

	return status;
    8d48:	2327      	movs	r3, #39	; 0x27
    8d4a:	18fb      	adds	r3, r7, r3
    8d4c:	781b      	ldrb	r3, [r3, #0]
}
    8d4e:	0018      	movs	r0, r3
    8d50:	46bd      	mov	sp, r7
    8d52:	b00b      	add	sp, #44	; 0x2c
    8d54:	bd90      	pop	{r4, r7, pc}
    8d56:	46c0      	nop			; (mov r8, r8)
    8d58:	00008649 	.word	0x00008649
    8d5c:	0000844d 	.word	0x0000844d
    8d60:	00008a11 	.word	0x00008a11
    8d64:	000087e9 	.word	0x000087e9
    8d68:	000088ed 	.word	0x000088ed
    8d6c:	00008495 	.word	0x00008495

00008d70 <at25dfx_chip_erase_block>:
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 * \retval STATUS_ERR_INVALID_ARG if address is out of bounds.
 */
enum status_code at25dfx_chip_erase_block(struct at25dfx_chip_module *chip,
		at25dfx_address_t address, enum at25dfx_block_size block_size)
{
    8d70:	b590      	push	{r4, r7, lr}
    8d72:	b08d      	sub	sp, #52	; 0x34
    8d74:	af02      	add	r7, sp, #8
    8d76:	60f8      	str	r0, [r7, #12]
    8d78:	60b9      	str	r1, [r7, #8]
    8d7a:	1dfb      	adds	r3, r7, #7
    8d7c:	701a      	strb	r2, [r3, #0]
	enum status_code status;
	struct at25dfx_command cmd;

	Assert(chip);

	if (address >= _at25dfx_get_device_size(chip->type)) {
    8d7e:	68fb      	ldr	r3, [r7, #12]
    8d80:	791b      	ldrb	r3, [r3, #4]
    8d82:	0018      	movs	r0, r3
    8d84:	4b33      	ldr	r3, [pc, #204]	; (8e54 <at25dfx_chip_erase_block+0xe4>)
    8d86:	4798      	blx	r3
    8d88:	1e02      	subs	r2, r0, #0
    8d8a:	68bb      	ldr	r3, [r7, #8]
    8d8c:	429a      	cmp	r2, r3
    8d8e:	d801      	bhi.n	8d94 <at25dfx_chip_erase_block+0x24>
		return STATUS_ERR_INVALID_ARG;
    8d90:	2317      	movs	r3, #23
    8d92:	e05b      	b.n	8e4c <at25dfx_chip_erase_block+0xdc>
	}

	status = _at25dfx_spi_lock(chip->spi);
    8d94:	68fb      	ldr	r3, [r7, #12]
    8d96:	681b      	ldr	r3, [r3, #0]
    8d98:	2227      	movs	r2, #39	; 0x27
    8d9a:	18bc      	adds	r4, r7, r2
    8d9c:	0018      	movs	r0, r3
    8d9e:	4b2e      	ldr	r3, [pc, #184]	; (8e58 <at25dfx_chip_erase_block+0xe8>)
    8da0:	4798      	blx	r3
    8da2:	0003      	movs	r3, r0
    8da4:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8da6:	2327      	movs	r3, #39	; 0x27
    8da8:	18fb      	adds	r3, r7, r3
    8daa:	781b      	ldrb	r3, [r3, #0]
    8dac:	2b05      	cmp	r3, #5
    8dae:	d103      	bne.n	8db8 <at25dfx_chip_erase_block+0x48>
		return status;
    8db0:	2327      	movs	r3, #39	; 0x27
    8db2:	18fb      	adds	r3, r7, r3
    8db4:	781b      	ldrb	r3, [r3, #0]
    8db6:	e049      	b.n	8e4c <at25dfx_chip_erase_block+0xdc>
	}

	_at25dfx_chip_enable_write(chip);
    8db8:	68fb      	ldr	r3, [r7, #12]
    8dba:	0018      	movs	r0, r3
    8dbc:	4b27      	ldr	r3, [pc, #156]	; (8e5c <at25dfx_chip_erase_block+0xec>)
    8dbe:	4798      	blx	r3

	switch (block_size) {
    8dc0:	1dfb      	adds	r3, r7, #7
    8dc2:	781b      	ldrb	r3, [r3, #0]
    8dc4:	2b01      	cmp	r3, #1
    8dc6:	d008      	beq.n	8dda <at25dfx_chip_erase_block+0x6a>
    8dc8:	2b02      	cmp	r3, #2
    8dca:	d00b      	beq.n	8de4 <at25dfx_chip_erase_block+0x74>
    8dcc:	2b00      	cmp	r3, #0
    8dce:	d10e      	bne.n	8dee <at25dfx_chip_erase_block+0x7e>
	case AT25DFX_BLOCK_SIZE_4KB:
		cmd.opcode = AT25DFX_COMMAND_ERASE_BLOCK_4KB;
    8dd0:	2314      	movs	r3, #20
    8dd2:	18fb      	adds	r3, r7, r3
    8dd4:	2220      	movs	r2, #32
    8dd6:	701a      	strb	r2, [r3, #0]
		break;
    8dd8:	e00d      	b.n	8df6 <at25dfx_chip_erase_block+0x86>

	case AT25DFX_BLOCK_SIZE_32KB:
		cmd.opcode = AT25DFX_COMMAND_ERASE_BLOCK_32KB;
    8dda:	2314      	movs	r3, #20
    8ddc:	18fb      	adds	r3, r7, r3
    8dde:	2252      	movs	r2, #82	; 0x52
    8de0:	701a      	strb	r2, [r3, #0]
		break;
    8de2:	e008      	b.n	8df6 <at25dfx_chip_erase_block+0x86>

	case AT25DFX_BLOCK_SIZE_64KB:
		cmd.opcode = AT25DFX_COMMAND_ERASE_BLOCK_64KB;
    8de4:	2314      	movs	r3, #20
    8de6:	18fb      	adds	r3, r7, r3
    8de8:	22d8      	movs	r2, #216	; 0xd8
    8dea:	701a      	strb	r2, [r3, #0]
		break;
    8dec:	e003      	b.n	8df6 <at25dfx_chip_erase_block+0x86>

	default:
		Assert(false);
		cmd.opcode = (enum at25dfx_command_opcode)0;
    8dee:	2314      	movs	r3, #20
    8df0:	18fb      	adds	r3, r7, r3
    8df2:	2200      	movs	r2, #0
    8df4:	701a      	strb	r2, [r3, #0]
	}
	cmd.command_size = 4;
    8df6:	2314      	movs	r3, #20
    8df8:	18fb      	adds	r3, r7, r3
    8dfa:	2204      	movs	r2, #4
    8dfc:	705a      	strb	r2, [r3, #1]
	cmd.address = address;
    8dfe:	2314      	movs	r3, #20
    8e00:	18fb      	adds	r3, r7, r3
    8e02:	68ba      	ldr	r2, [r7, #8]
    8e04:	605a      	str	r2, [r3, #4]
	cmd.length = 0;
    8e06:	2314      	movs	r3, #20
    8e08:	18fb      	adds	r3, r7, r3
    8e0a:	2200      	movs	r2, #0
    8e0c:	819a      	strh	r2, [r3, #12]

	// Init to avoid warnings with -Os
	cmd.data.tx = NULL;
    8e0e:	2314      	movs	r3, #20
    8e10:	18fb      	adds	r3, r7, r3
    8e12:	2200      	movs	r2, #0
    8e14:	609a      	str	r2, [r3, #8]

	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8e16:	2314      	movs	r3, #20
    8e18:	18fb      	adds	r3, r7, r3
    8e1a:	68f8      	ldr	r0, [r7, #12]
    8e1c:	466a      	mov	r2, sp
    8e1e:	68d9      	ldr	r1, [r3, #12]
    8e20:	6011      	str	r1, [r2, #0]
    8e22:	6819      	ldr	r1, [r3, #0]
    8e24:	685a      	ldr	r2, [r3, #4]
    8e26:	689b      	ldr	r3, [r3, #8]
    8e28:	4c0d      	ldr	r4, [pc, #52]	; (8e60 <at25dfx_chip_erase_block+0xf0>)
    8e2a:	47a0      	blx	r4

	status = _at25dfx_chip_get_nonbusy_status(chip);
    8e2c:	2327      	movs	r3, #39	; 0x27
    8e2e:	18fc      	adds	r4, r7, r3
    8e30:	68fb      	ldr	r3, [r7, #12]
    8e32:	0018      	movs	r0, r3
    8e34:	4b0b      	ldr	r3, [pc, #44]	; (8e64 <at25dfx_chip_erase_block+0xf4>)
    8e36:	4798      	blx	r3
    8e38:	0003      	movs	r3, r0
    8e3a:	7023      	strb	r3, [r4, #0]

	_at25dfx_spi_unlock(chip->spi);
    8e3c:	68fb      	ldr	r3, [r7, #12]
    8e3e:	681b      	ldr	r3, [r3, #0]
    8e40:	0018      	movs	r0, r3
    8e42:	4b09      	ldr	r3, [pc, #36]	; (8e68 <at25dfx_chip_erase_block+0xf8>)
    8e44:	4798      	blx	r3

	return status;
    8e46:	2327      	movs	r3, #39	; 0x27
    8e48:	18fb      	adds	r3, r7, r3
    8e4a:	781b      	ldrb	r3, [r3, #0]
}
    8e4c:	0018      	movs	r0, r3
    8e4e:	46bd      	mov	sp, r7
    8e50:	b00b      	add	sp, #44	; 0x2c
    8e52:	bd90      	pop	{r4, r7, pc}
    8e54:	00008649 	.word	0x00008649
    8e58:	0000844d 	.word	0x0000844d
    8e5c:	00008a11 	.word	0x00008a11
    8e60:	000087e9 	.word	0x000087e9
    8e64:	000088ed 	.word	0x000088ed
    8e68:	00008495 	.word	0x00008495

00008e6c <at25dfx_chip_set_global_sector_protect>:
 * \retval STATUS_OK if write operation succeeded.
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 */
enum status_code at25dfx_chip_set_global_sector_protect(
		struct at25dfx_chip_module *chip, bool protect)
{
    8e6c:	b590      	push	{r4, r7, lr}
    8e6e:	b08b      	sub	sp, #44	; 0x2c
    8e70:	af02      	add	r7, sp, #8
    8e72:	6078      	str	r0, [r7, #4]
    8e74:	000a      	movs	r2, r1
    8e76:	1cfb      	adds	r3, r7, #3
    8e78:	701a      	strb	r2, [r3, #0]
	struct at25dfx_command cmd;
	uint8_t temp_data;

	Assert(chip);

	status = _at25dfx_spi_lock(chip->spi);
    8e7a:	687b      	ldr	r3, [r7, #4]
    8e7c:	681b      	ldr	r3, [r3, #0]
    8e7e:	221f      	movs	r2, #31
    8e80:	18bc      	adds	r4, r7, r2
    8e82:	0018      	movs	r0, r3
    8e84:	4b22      	ldr	r3, [pc, #136]	; (8f10 <at25dfx_chip_set_global_sector_protect+0xa4>)
    8e86:	4798      	blx	r3
    8e88:	0003      	movs	r3, r0
    8e8a:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8e8c:	231f      	movs	r3, #31
    8e8e:	18fb      	adds	r3, r7, r3
    8e90:	781b      	ldrb	r3, [r3, #0]
    8e92:	2b05      	cmp	r3, #5
    8e94:	d103      	bne.n	8e9e <at25dfx_chip_set_global_sector_protect+0x32>
		return status;
    8e96:	231f      	movs	r3, #31
    8e98:	18fb      	adds	r3, r7, r3
    8e9a:	781b      	ldrb	r3, [r3, #0]
    8e9c:	e033      	b.n	8f06 <at25dfx_chip_set_global_sector_protect+0x9a>
	}

	_at25dfx_chip_enable_write(chip);
    8e9e:	687b      	ldr	r3, [r7, #4]
    8ea0:	0018      	movs	r0, r3
    8ea2:	4b1c      	ldr	r3, [pc, #112]	; (8f14 <at25dfx_chip_set_global_sector_protect+0xa8>)
    8ea4:	4798      	blx	r3

	temp_data = protect ? AT25DFX_STATUS_GLOBAL_PROTECT : 0;
    8ea6:	1cfb      	adds	r3, r7, #3
    8ea8:	781b      	ldrb	r3, [r3, #0]
    8eaa:	2b00      	cmp	r3, #0
    8eac:	d001      	beq.n	8eb2 <at25dfx_chip_set_global_sector_protect+0x46>
    8eae:	223c      	movs	r2, #60	; 0x3c
    8eb0:	e000      	b.n	8eb4 <at25dfx_chip_set_global_sector_protect+0x48>
    8eb2:	2200      	movs	r2, #0
    8eb4:	230b      	movs	r3, #11
    8eb6:	18fb      	adds	r3, r7, r3
    8eb8:	701a      	strb	r2, [r3, #0]
	cmd.opcode = AT25DFX_COMMAND_WRITE_STATUS;
    8eba:	230c      	movs	r3, #12
    8ebc:	18fb      	adds	r3, r7, r3
    8ebe:	2201      	movs	r2, #1
    8ec0:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 1;
    8ec2:	230c      	movs	r3, #12
    8ec4:	18fb      	adds	r3, r7, r3
    8ec6:	2201      	movs	r2, #1
    8ec8:	705a      	strb	r2, [r3, #1]
	cmd.length = 1;
    8eca:	230c      	movs	r3, #12
    8ecc:	18fb      	adds	r3, r7, r3
    8ece:	2201      	movs	r2, #1
    8ed0:	819a      	strh	r2, [r3, #12]
	cmd.data.tx = &temp_data;
    8ed2:	230c      	movs	r3, #12
    8ed4:	18fb      	adds	r3, r7, r3
    8ed6:	220b      	movs	r2, #11
    8ed8:	18ba      	adds	r2, r7, r2
    8eda:	609a      	str	r2, [r3, #8]

	// Init to avoid warnings with -Os
	cmd.address = (at25dfx_address_t)NULL;
    8edc:	230c      	movs	r3, #12
    8ede:	18fb      	adds	r3, r7, r3
    8ee0:	2200      	movs	r2, #0
    8ee2:	605a      	str	r2, [r3, #4]

	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8ee4:	230c      	movs	r3, #12
    8ee6:	18fb      	adds	r3, r7, r3
    8ee8:	6878      	ldr	r0, [r7, #4]
    8eea:	466a      	mov	r2, sp
    8eec:	68d9      	ldr	r1, [r3, #12]
    8eee:	6011      	str	r1, [r2, #0]
    8ef0:	6819      	ldr	r1, [r3, #0]
    8ef2:	685a      	ldr	r2, [r3, #4]
    8ef4:	689b      	ldr	r3, [r3, #8]
    8ef6:	4c08      	ldr	r4, [pc, #32]	; (8f18 <at25dfx_chip_set_global_sector_protect+0xac>)
    8ef8:	47a0      	blx	r4

	_at25dfx_spi_unlock(chip->spi);
    8efa:	687b      	ldr	r3, [r7, #4]
    8efc:	681b      	ldr	r3, [r3, #0]
    8efe:	0018      	movs	r0, r3
    8f00:	4b06      	ldr	r3, [pc, #24]	; (8f1c <at25dfx_chip_set_global_sector_protect+0xb0>)
    8f02:	4798      	blx	r3

	return STATUS_OK;
    8f04:	2300      	movs	r3, #0
}
    8f06:	0018      	movs	r0, r3
    8f08:	46bd      	mov	sp, r7
    8f0a:	b009      	add	sp, #36	; 0x24
    8f0c:	bd90      	pop	{r4, r7, pc}
    8f0e:	46c0      	nop			; (mov r8, r8)
    8f10:	0000844d 	.word	0x0000844d
    8f14:	00008a11 	.word	0x00008a11
    8f18:	000087e9 	.word	0x000087e9
    8f1c:	00008495 	.word	0x00008495

00008f20 <at25dfx_chip_sleep>:
 * \return Status of operation.
 * \retval STATUS_OK if write operation succeeded.
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 */
enum status_code at25dfx_chip_sleep(struct at25dfx_chip_module *chip)
{
    8f20:	b590      	push	{r4, r7, lr}
    8f22:	b08b      	sub	sp, #44	; 0x2c
    8f24:	af02      	add	r7, sp, #8
    8f26:	6078      	str	r0, [r7, #4]
	enum status_code status;
	struct at25dfx_command cmd;

	Assert(chip);

	status = _at25dfx_spi_lock(chip->spi);
    8f28:	687b      	ldr	r3, [r7, #4]
    8f2a:	681b      	ldr	r3, [r3, #0]
    8f2c:	221f      	movs	r2, #31
    8f2e:	18bc      	adds	r4, r7, r2
    8f30:	0018      	movs	r0, r3
    8f32:	4b1b      	ldr	r3, [pc, #108]	; (8fa0 <at25dfx_chip_sleep+0x80>)
    8f34:	4798      	blx	r3
    8f36:	0003      	movs	r3, r0
    8f38:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8f3a:	231f      	movs	r3, #31
    8f3c:	18fb      	adds	r3, r7, r3
    8f3e:	781b      	ldrb	r3, [r3, #0]
    8f40:	2b05      	cmp	r3, #5
    8f42:	d103      	bne.n	8f4c <at25dfx_chip_sleep+0x2c>
		return status;
    8f44:	231f      	movs	r3, #31
    8f46:	18fb      	adds	r3, r7, r3
    8f48:	781b      	ldrb	r3, [r3, #0]
    8f4a:	e024      	b.n	8f96 <at25dfx_chip_sleep+0x76>
	}

	cmd.opcode = AT25DFX_COMMAND_SLEEP;
    8f4c:	230c      	movs	r3, #12
    8f4e:	18fb      	adds	r3, r7, r3
    8f50:	22b9      	movs	r2, #185	; 0xb9
    8f52:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 1;
    8f54:	230c      	movs	r3, #12
    8f56:	18fb      	adds	r3, r7, r3
    8f58:	2201      	movs	r2, #1
    8f5a:	705a      	strb	r2, [r3, #1]
	cmd.length = 0;
    8f5c:	230c      	movs	r3, #12
    8f5e:	18fb      	adds	r3, r7, r3
    8f60:	2200      	movs	r2, #0
    8f62:	819a      	strh	r2, [r3, #12]

	// Init to avoid warnings with -Os
	cmd.address = (at25dfx_address_t)NULL;
    8f64:	230c      	movs	r3, #12
    8f66:	18fb      	adds	r3, r7, r3
    8f68:	2200      	movs	r2, #0
    8f6a:	605a      	str	r2, [r3, #4]
	cmd.data.tx = NULL;
    8f6c:	230c      	movs	r3, #12
    8f6e:	18fb      	adds	r3, r7, r3
    8f70:	2200      	movs	r2, #0
    8f72:	609a      	str	r2, [r3, #8]

	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    8f74:	230c      	movs	r3, #12
    8f76:	18fb      	adds	r3, r7, r3
    8f78:	6878      	ldr	r0, [r7, #4]
    8f7a:	466a      	mov	r2, sp
    8f7c:	68d9      	ldr	r1, [r3, #12]
    8f7e:	6011      	str	r1, [r2, #0]
    8f80:	6819      	ldr	r1, [r3, #0]
    8f82:	685a      	ldr	r2, [r3, #4]
    8f84:	689b      	ldr	r3, [r3, #8]
    8f86:	4c07      	ldr	r4, [pc, #28]	; (8fa4 <at25dfx_chip_sleep+0x84>)
    8f88:	47a0      	blx	r4

	_at25dfx_spi_unlock(chip->spi);
    8f8a:	687b      	ldr	r3, [r7, #4]
    8f8c:	681b      	ldr	r3, [r3, #0]
    8f8e:	0018      	movs	r0, r3
    8f90:	4b05      	ldr	r3, [pc, #20]	; (8fa8 <at25dfx_chip_sleep+0x88>)
    8f92:	4798      	blx	r3

	return STATUS_OK;
    8f94:	2300      	movs	r3, #0
}
    8f96:	0018      	movs	r0, r3
    8f98:	46bd      	mov	sp, r7
    8f9a:	b009      	add	sp, #36	; 0x24
    8f9c:	bd90      	pop	{r4, r7, pc}
    8f9e:	46c0      	nop			; (mov r8, r8)
    8fa0:	0000844d 	.word	0x0000844d
    8fa4:	000087e9 	.word	0x000087e9
    8fa8:	00008495 	.word	0x00008495

00008fac <at25dfx_chip_wake>:
 * \return Status of operation.
 * \retval STATUS_OK if write operation succeeded.
 * \retval STATUS_BUSY if SPI is busy with some other operation.
 */
enum status_code at25dfx_chip_wake(struct at25dfx_chip_module *chip)
{
    8fac:	b590      	push	{r4, r7, lr}
    8fae:	b08b      	sub	sp, #44	; 0x2c
    8fb0:	af02      	add	r7, sp, #8
    8fb2:	6078      	str	r0, [r7, #4]
	enum status_code status;
	struct at25dfx_command cmd;

	Assert(chip);

	status = _at25dfx_spi_lock(chip->spi);
    8fb4:	687b      	ldr	r3, [r7, #4]
    8fb6:	681b      	ldr	r3, [r3, #0]
    8fb8:	221f      	movs	r2, #31
    8fba:	18bc      	adds	r4, r7, r2
    8fbc:	0018      	movs	r0, r3
    8fbe:	4b1b      	ldr	r3, [pc, #108]	; (902c <at25dfx_chip_wake+0x80>)
    8fc0:	4798      	blx	r3
    8fc2:	0003      	movs	r3, r0
    8fc4:	7023      	strb	r3, [r4, #0]
	if (status == STATUS_BUSY) {
    8fc6:	231f      	movs	r3, #31
    8fc8:	18fb      	adds	r3, r7, r3
    8fca:	781b      	ldrb	r3, [r3, #0]
    8fcc:	2b05      	cmp	r3, #5
    8fce:	d103      	bne.n	8fd8 <at25dfx_chip_wake+0x2c>
		return status;
    8fd0:	231f      	movs	r3, #31
    8fd2:	18fb      	adds	r3, r7, r3
    8fd4:	781b      	ldrb	r3, [r3, #0]
    8fd6:	e024      	b.n	9022 <at25dfx_chip_wake+0x76>
	}

	cmd.opcode = AT25DFX_COMMAND_WAKE;
    8fd8:	230c      	movs	r3, #12
    8fda:	18fb      	adds	r3, r7, r3
    8fdc:	22ab      	movs	r2, #171	; 0xab
    8fde:	701a      	strb	r2, [r3, #0]
	cmd.command_size = 1;
    8fe0:	230c      	movs	r3, #12
    8fe2:	18fb      	adds	r3, r7, r3
    8fe4:	2201      	movs	r2, #1
    8fe6:	705a      	strb	r2, [r3, #1]
	cmd.length = 0;
    8fe8:	230c      	movs	r3, #12
    8fea:	18fb      	adds	r3, r7, r3
    8fec:	2200      	movs	r2, #0
    8fee:	819a      	strh	r2, [r3, #12]

	// Init to avoid warnings with -Os
	cmd.address = (at25dfx_address_t)NULL;
    8ff0:	230c      	movs	r3, #12
    8ff2:	18fb      	adds	r3, r7, r3
    8ff4:	2200      	movs	r2, #0
    8ff6:	605a      	str	r2, [r3, #4]
	cmd.data.tx = NULL;
    8ff8:	230c      	movs	r3, #12
    8ffa:	18fb      	adds	r3, r7, r3
    8ffc:	2200      	movs	r2, #0
    8ffe:	609a      	str	r2, [r3, #8]

	_at25dfx_chip_issue_write_command_wait(chip, cmd);
    9000:	230c      	movs	r3, #12
    9002:	18fb      	adds	r3, r7, r3
    9004:	6878      	ldr	r0, [r7, #4]
    9006:	466a      	mov	r2, sp
    9008:	68d9      	ldr	r1, [r3, #12]
    900a:	6011      	str	r1, [r2, #0]
    900c:	6819      	ldr	r1, [r3, #0]
    900e:	685a      	ldr	r2, [r3, #4]
    9010:	689b      	ldr	r3, [r3, #8]
    9012:	4c07      	ldr	r4, [pc, #28]	; (9030 <at25dfx_chip_wake+0x84>)
    9014:	47a0      	blx	r4

	_at25dfx_spi_unlock(chip->spi);
    9016:	687b      	ldr	r3, [r7, #4]
    9018:	681b      	ldr	r3, [r3, #0]
    901a:	0018      	movs	r0, r3
    901c:	4b05      	ldr	r3, [pc, #20]	; (9034 <at25dfx_chip_wake+0x88>)
    901e:	4798      	blx	r3

	return STATUS_OK;
    9020:	2300      	movs	r3, #0
    9022:	0018      	movs	r0, r3
    9024:	46bd      	mov	sp, r7
    9026:	b009      	add	sp, #36	; 0x24
    9028:	bd90      	pop	{r4, r7, pc}
    902a:	46c0      	nop			; (mov r8, r8)
    902c:	0000844d 	.word	0x0000844d
    9030:	000087e9 	.word	0x000087e9
    9034:	00008495 	.word	0x00008495

00009038 <nvm_is_ready>:
 * \retval true   If the hardware module is ready for a new command
 * \retval false  If the hardware module is busy executing a command
 *
 */
static inline bool nvm_is_ready(void)
{
    9038:	b580      	push	{r7, lr}
    903a:	b082      	sub	sp, #8
    903c:	af00      	add	r7, sp, #0
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    903e:	4b07      	ldr	r3, [pc, #28]	; (905c <nvm_is_ready+0x24>)
    9040:	607b      	str	r3, [r7, #4]

	return nvm_module->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    9042:	687b      	ldr	r3, [r7, #4]
    9044:	7d1b      	ldrb	r3, [r3, #20]
    9046:	b2db      	uxtb	r3, r3
    9048:	001a      	movs	r2, r3
    904a:	2301      	movs	r3, #1
    904c:	4013      	ands	r3, r2
    904e:	1e5a      	subs	r2, r3, #1
    9050:	4193      	sbcs	r3, r2
    9052:	b2db      	uxtb	r3, r3
}
    9054:	0018      	movs	r0, r3
    9056:	46bd      	mov	sp, r7
    9058:	b002      	add	sp, #8
    905a:	bd80      	pop	{r7, pc}
    905c:	41004000 	.word	0x41004000

00009060 <nvm_execute_command>:
 */
enum status_code nvm_execute_command(
		const enum nvm_command command,
		const uint32_t address,
		const uint32_t parameter)
{
    9060:	b580      	push	{r7, lr}
    9062:	b086      	sub	sp, #24
    9064:	af00      	add	r7, sp, #0
    9066:	60b9      	str	r1, [r7, #8]
    9068:	607a      	str	r2, [r7, #4]
    906a:	230f      	movs	r3, #15
    906c:	18fb      	adds	r3, r7, r3
    906e:	1c02      	adds	r2, r0, #0
    9070:	701a      	strb	r2, [r3, #0]
	uint32_t ctrlb_bak;

	/* Check that the address given is valid  */
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
    9072:	4b3a      	ldr	r3, [pc, #232]	; (915c <nvm_execute_command+0xfc>)
    9074:	881b      	ldrh	r3, [r3, #0]
    9076:	001a      	movs	r2, r3
    9078:	4b38      	ldr	r3, [pc, #224]	; (915c <nvm_execute_command+0xfc>)
    907a:	885b      	ldrh	r3, [r3, #2]
    907c:	435a      	muls	r2, r3
    907e:	68bb      	ldr	r3, [r7, #8]
    9080:	429a      	cmp	r2, r3
    9082:	d209      	bcs.n	9098 <nvm_execute_command+0x38>
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
    9084:	68bb      	ldr	r3, [r7, #8]
    9086:	4a36      	ldr	r2, [pc, #216]	; (9160 <nvm_execute_command+0x100>)
    9088:	4293      	cmp	r3, r2
    908a:	d903      	bls.n	9094 <nvm_execute_command+0x34>
    908c:	68bb      	ldr	r3, [r7, #8]
    908e:	4a35      	ldr	r2, [pc, #212]	; (9164 <nvm_execute_command+0x104>)
    9090:	4293      	cmp	r3, r2
    9092:	d901      	bls.n	9098 <nvm_execute_command+0x38>
		if (address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
#else
		return STATUS_ERR_BAD_ADDRESS;
    9094:	2318      	movs	r3, #24
    9096:	e05c      	b.n	9152 <nvm_execute_command+0xf2>
#endif
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    9098:	4b33      	ldr	r3, [pc, #204]	; (9168 <nvm_execute_command+0x108>)
    909a:	617b      	str	r3, [r7, #20]

	/* Turn off cache before issuing flash commands */
	ctrlb_bak = nvm_module->CTRLB.reg;
    909c:	697b      	ldr	r3, [r7, #20]
    909e:	685b      	ldr	r3, [r3, #4]
    90a0:	613b      	str	r3, [r7, #16]
#if (SAMC20) || (SAMC21)
	nvm_module->CTRLB.reg = ((ctrlb_bak &(~(NVMCTRL_CTRLB_CACHEDIS(0x2)))) 
							| NVMCTRL_CTRLB_CACHEDIS(0x1));
#else
	nvm_module->CTRLB.reg = ctrlb_bak | NVMCTRL_CTRLB_CACHEDIS;
    90a2:	693b      	ldr	r3, [r7, #16]
    90a4:	2280      	movs	r2, #128	; 0x80
    90a6:	02d2      	lsls	r2, r2, #11
    90a8:	431a      	orrs	r2, r3
    90aa:	697b      	ldr	r3, [r7, #20]
    90ac:	605a      	str	r2, [r3, #4]
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg = NVMCTRL_STATUS_MASK;
    90ae:	697b      	ldr	r3, [r7, #20]
    90b0:	2220      	movs	r2, #32
    90b2:	32ff      	adds	r2, #255	; 0xff
    90b4:	831a      	strh	r2, [r3, #24]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    90b6:	4b2d      	ldr	r3, [pc, #180]	; (916c <nvm_execute_command+0x10c>)
    90b8:	4798      	blx	r3
    90ba:	0003      	movs	r3, r0
    90bc:	001a      	movs	r2, r3
    90be:	2301      	movs	r3, #1
    90c0:	4053      	eors	r3, r2
    90c2:	b2db      	uxtb	r3, r3
    90c4:	2b00      	cmp	r3, #0
    90c6:	d004      	beq.n	90d2 <nvm_execute_command+0x72>
		/* Restore the setting */
		nvm_module->CTRLB.reg = ctrlb_bak;
    90c8:	697b      	ldr	r3, [r7, #20]
    90ca:	693a      	ldr	r2, [r7, #16]
    90cc:	605a      	str	r2, [r3, #4]
		return STATUS_BUSY;
    90ce:	2305      	movs	r3, #5
    90d0:	e03f      	b.n	9152 <nvm_execute_command+0xf2>
	}

	switch (command) {
    90d2:	230f      	movs	r3, #15
    90d4:	18fb      	adds	r3, r7, r3
    90d6:	781b      	ldrb	r3, [r3, #0]
    90d8:	2b45      	cmp	r3, #69	; 0x45
    90da:	d81d      	bhi.n	9118 <nvm_execute_command+0xb8>
    90dc:	009a      	lsls	r2, r3, #2
    90de:	4b24      	ldr	r3, [pc, #144]	; (9170 <nvm_execute_command+0x110>)
    90e0:	18d3      	adds	r3, r2, r3
    90e2:	681b      	ldr	r3, [r3, #0]
    90e4:	469f      	mov	pc, r3
		/* Commands requiring address (protected) */
		case NVM_COMMAND_ERASE_AUX_ROW:
		case NVM_COMMAND_WRITE_AUX_ROW:

			/* Auxiliary space cannot be accessed if the security bit is set */
			if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    90e6:	697b      	ldr	r3, [r7, #20]
    90e8:	8b1b      	ldrh	r3, [r3, #24]
    90ea:	b29b      	uxth	r3, r3
    90ec:	001a      	movs	r2, r3
    90ee:	2380      	movs	r3, #128	; 0x80
    90f0:	005b      	lsls	r3, r3, #1
    90f2:	4013      	ands	r3, r2
    90f4:	d004      	beq.n	9100 <nvm_execute_command+0xa0>
				/* Restore the setting */
				nvm_module->CTRLB.reg = ctrlb_bak;
    90f6:	697b      	ldr	r3, [r7, #20]
    90f8:	693a      	ldr	r2, [r7, #16]
    90fa:	605a      	str	r2, [r3, #4]
				return STATUS_ERR_IO;
    90fc:	2310      	movs	r3, #16
    90fe:	e028      	b.n	9152 <nvm_execute_command+0xf2>
			}

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
    9100:	68bb      	ldr	r3, [r7, #8]
    9102:	089b      	lsrs	r3, r3, #2
    9104:	005a      	lsls	r2, r3, #1
    9106:	697b      	ldr	r3, [r7, #20]
    9108:	61da      	str	r2, [r3, #28]
			break;
    910a:	e00b      	b.n	9124 <nvm_execute_command+0xc4>
		case NVM_COMMAND_RWWEE_ERASE_ROW:
		case NVM_COMMAND_RWWEE_WRITE_PAGE:
#endif

			/* Set address, command will be issued elsewhere */
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
    910c:	68bb      	ldr	r3, [r7, #8]
    910e:	089b      	lsrs	r3, r3, #2
    9110:	005a      	lsls	r2, r3, #1
    9112:	697b      	ldr	r3, [r7, #20]
    9114:	61da      	str	r2, [r3, #28]
			break;
    9116:	e005      	b.n	9124 <nvm_execute_command+0xc4>
		case NVM_COMMAND_EXIT_LOW_POWER_MODE:
			break;

		default:
			/* Restore the setting */
			nvm_module->CTRLB.reg = ctrlb_bak;
    9118:	697b      	ldr	r3, [r7, #20]
    911a:	693a      	ldr	r2, [r7, #16]
    911c:	605a      	str	r2, [r3, #4]
			return STATUS_ERR_INVALID_ARG;
    911e:	2317      	movs	r3, #23
    9120:	e017      	b.n	9152 <nvm_execute_command+0xf2>
		/* Commands not requiring address */
		case NVM_COMMAND_PAGE_BUFFER_CLEAR:
		case NVM_COMMAND_SET_SECURITY_BIT:
		case NVM_COMMAND_ENTER_LOW_POWER_MODE:
		case NVM_COMMAND_EXIT_LOW_POWER_MODE:
			break;
    9122:	46c0      	nop			; (mov r8, r8)
			nvm_module->CTRLB.reg = ctrlb_bak;
			return STATUS_ERR_INVALID_ARG;
	}

	/* Set command */
	nvm_module->CTRLA.reg = command | NVMCTRL_CTRLA_CMDEX_KEY;
    9124:	230f      	movs	r3, #15
    9126:	18fb      	adds	r3, r7, r3
    9128:	781b      	ldrb	r3, [r3, #0]
    912a:	b29b      	uxth	r3, r3
    912c:	4a11      	ldr	r2, [pc, #68]	; (9174 <nvm_execute_command+0x114>)
    912e:	4313      	orrs	r3, r2
    9130:	b29a      	uxth	r2, r3
    9132:	697b      	ldr	r3, [r7, #20]
    9134:	801a      	strh	r2, [r3, #0]

	/* Wait for the NVM controller to become ready */
	while (!nvm_is_ready()) {
    9136:	46c0      	nop			; (mov r8, r8)
    9138:	4b0c      	ldr	r3, [pc, #48]	; (916c <nvm_execute_command+0x10c>)
    913a:	4798      	blx	r3
    913c:	0003      	movs	r3, r0
    913e:	001a      	movs	r2, r3
    9140:	2301      	movs	r3, #1
    9142:	4053      	eors	r3, r2
    9144:	b2db      	uxtb	r3, r3
    9146:	2b00      	cmp	r3, #0
    9148:	d1f6      	bne.n	9138 <nvm_execute_command+0xd8>
	}

	/* Restore the setting */
	nvm_module->CTRLB.reg = ctrlb_bak;
    914a:	697b      	ldr	r3, [r7, #20]
    914c:	693a      	ldr	r2, [r7, #16]
    914e:	605a      	str	r2, [r3, #4]

	return STATUS_OK;
    9150:	2300      	movs	r3, #0
}
    9152:	0018      	movs	r0, r3
    9154:	46bd      	mov	sp, r7
    9156:	b006      	add	sp, #24
    9158:	bd80      	pop	{r7, pc}
    915a:	46c0      	nop			; (mov r8, r8)
    915c:	2000009c 	.word	0x2000009c
    9160:	00803fff 	.word	0x00803fff
    9164:	00806000 	.word	0x00806000
    9168:	41004000 	.word	0x41004000
    916c:	00009039 	.word	0x00009039
    9170:	0000af2c 	.word	0x0000af2c
    9174:	ffffa500 	.word	0xffffa500

00009178 <nvm_write_buffer>:
 */
enum status_code nvm_write_buffer(
		const uint32_t destination_address,
		const uint8_t *buffer,
		uint16_t length)
{
    9178:	b580      	push	{r7, lr}
    917a:	b088      	sub	sp, #32
    917c:	af00      	add	r7, sp, #0
    917e:	60f8      	str	r0, [r7, #12]
    9180:	60b9      	str	r1, [r7, #8]
    9182:	1dbb      	adds	r3, r7, #6
    9184:	801a      	strh	r2, [r3, #0]
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    9186:	4b4a      	ldr	r3, [pc, #296]	; (92b0 <nvm_write_buffer+0x138>)
    9188:	881b      	ldrh	r3, [r3, #0]
    918a:	001a      	movs	r2, r3
    918c:	4b48      	ldr	r3, [pc, #288]	; (92b0 <nvm_write_buffer+0x138>)
    918e:	885b      	ldrh	r3, [r3, #2]
    9190:	435a      	muls	r2, r3
#ifdef FEATURE_NVM_RWWEE
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
    9192:	68fb      	ldr	r3, [r7, #12]
    9194:	429a      	cmp	r2, r3
    9196:	d201      	bcs.n	919c <nvm_write_buffer+0x24>
			|| destination_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    9198:	2318      	movs	r3, #24
    919a:	e084      	b.n	92a6 <nvm_write_buffer+0x12e>
#endif
	}

	/* Check if the write address not aligned to the start of a page */
	if (destination_address & (_nvm_dev.page_size - 1)) {
    919c:	4b44      	ldr	r3, [pc, #272]	; (92b0 <nvm_write_buffer+0x138>)
    919e:	881b      	ldrh	r3, [r3, #0]
    91a0:	3b01      	subs	r3, #1
    91a2:	001a      	movs	r2, r3
    91a4:	68fb      	ldr	r3, [r7, #12]
    91a6:	4013      	ands	r3, r2
    91a8:	d001      	beq.n	91ae <nvm_write_buffer+0x36>
		return STATUS_ERR_BAD_ADDRESS;
    91aa:	2318      	movs	r3, #24
    91ac:	e07b      	b.n	92a6 <nvm_write_buffer+0x12e>
	}

	/* Check if the write length is longer than an NVM page */
	if (length > _nvm_dev.page_size) {
    91ae:	4b40      	ldr	r3, [pc, #256]	; (92b0 <nvm_write_buffer+0x138>)
    91b0:	881b      	ldrh	r3, [r3, #0]
    91b2:	1dba      	adds	r2, r7, #6
    91b4:	8812      	ldrh	r2, [r2, #0]
    91b6:	429a      	cmp	r2, r3
    91b8:	d901      	bls.n	91be <nvm_write_buffer+0x46>
		return STATUS_ERR_INVALID_ARG;
    91ba:	2317      	movs	r3, #23
    91bc:	e073      	b.n	92a6 <nvm_write_buffer+0x12e>
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    91be:	4b3d      	ldr	r3, [pc, #244]	; (92b4 <nvm_write_buffer+0x13c>)
    91c0:	617b      	str	r3, [r7, #20]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    91c2:	4b3d      	ldr	r3, [pc, #244]	; (92b8 <nvm_write_buffer+0x140>)
    91c4:	4798      	blx	r3
    91c6:	0003      	movs	r3, r0
    91c8:	001a      	movs	r2, r3
    91ca:	2301      	movs	r3, #1
    91cc:	4053      	eors	r3, r2
    91ce:	b2db      	uxtb	r3, r3
    91d0:	2b00      	cmp	r3, #0
    91d2:	d001      	beq.n	91d8 <nvm_write_buffer+0x60>
		return STATUS_BUSY;
    91d4:	2305      	movs	r3, #5
    91d6:	e066      	b.n	92a6 <nvm_write_buffer+0x12e>
	}

	/* Erase the page buffer before buffering new data */
	nvm_module->CTRLA.reg = NVM_COMMAND_PAGE_BUFFER_CLEAR | NVMCTRL_CTRLA_CMDEX_KEY;
    91d8:	697b      	ldr	r3, [r7, #20]
    91da:	4a38      	ldr	r2, [pc, #224]	; (92bc <nvm_write_buffer+0x144>)
    91dc:	801a      	strh	r2, [r3, #0]

	/* Check if the module is busy */
	while (!nvm_is_ready()) {
    91de:	46c0      	nop			; (mov r8, r8)
    91e0:	4b35      	ldr	r3, [pc, #212]	; (92b8 <nvm_write_buffer+0x140>)
    91e2:	4798      	blx	r3
    91e4:	0003      	movs	r3, r0
    91e6:	001a      	movs	r2, r3
    91e8:	2301      	movs	r3, #1
    91ea:	4053      	eors	r3, r2
    91ec:	b2db      	uxtb	r3, r3
    91ee:	2b00      	cmp	r3, #0
    91f0:	d1f6      	bne.n	91e0 <nvm_write_buffer+0x68>
		/* Force-wait for the buffer clear to complete */
	}

	/* Clear error flags */
	nvm_module->STATUS.reg = NVMCTRL_STATUS_MASK;
    91f2:	697b      	ldr	r3, [r7, #20]
    91f4:	2220      	movs	r2, #32
    91f6:	32ff      	adds	r2, #255	; 0xff
    91f8:	831a      	strh	r2, [r3, #24]

	uint32_t nvm_address = destination_address / 2;
    91fa:	68fb      	ldr	r3, [r7, #12]
    91fc:	085b      	lsrs	r3, r3, #1
    91fe:	61fb      	str	r3, [r7, #28]

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    9200:	231a      	movs	r3, #26
    9202:	18fb      	adds	r3, r7, r3
    9204:	2200      	movs	r2, #0
    9206:	801a      	strh	r2, [r3, #0]
    9208:	e032      	b.n	9270 <nvm_write_buffer+0xf8>
		uint16_t data;

		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];
    920a:	231a      	movs	r3, #26
    920c:	18fb      	adds	r3, r7, r3
    920e:	881b      	ldrh	r3, [r3, #0]
    9210:	68ba      	ldr	r2, [r7, #8]
    9212:	18d3      	adds	r3, r2, r3
    9214:	781a      	ldrb	r2, [r3, #0]
    9216:	2318      	movs	r3, #24
    9218:	18fb      	adds	r3, r7, r3
    921a:	801a      	strh	r2, [r3, #0]

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
    921c:	231a      	movs	r3, #26
    921e:	18fb      	adds	r3, r7, r3
    9220:	881a      	ldrh	r2, [r3, #0]
    9222:	1dbb      	adds	r3, r7, #6
    9224:	881b      	ldrh	r3, [r3, #0]
    9226:	3b01      	subs	r3, #1
    9228:	429a      	cmp	r2, r3
    922a:	da11      	bge.n	9250 <nvm_write_buffer+0xd8>
			data |= (buffer[i + 1] << 8);
    922c:	231a      	movs	r3, #26
    922e:	18fb      	adds	r3, r7, r3
    9230:	881b      	ldrh	r3, [r3, #0]
    9232:	3301      	adds	r3, #1
    9234:	68ba      	ldr	r2, [r7, #8]
    9236:	18d3      	adds	r3, r2, r3
    9238:	781b      	ldrb	r3, [r3, #0]
    923a:	021b      	lsls	r3, r3, #8
    923c:	b21a      	sxth	r2, r3
    923e:	2318      	movs	r3, #24
    9240:	18fb      	adds	r3, r7, r3
    9242:	2100      	movs	r1, #0
    9244:	5e5b      	ldrsh	r3, [r3, r1]
    9246:	4313      	orrs	r3, r2
    9248:	b21a      	sxth	r2, r3
    924a:	2318      	movs	r3, #24
    924c:	18fb      	adds	r3, r7, r3
    924e:	801a      	strh	r2, [r3, #0]
		}

		/* Store next 16-bit chunk to the NVM memory space */
		NVM_MEMORY[nvm_address++] = data;
    9250:	69fb      	ldr	r3, [r7, #28]
    9252:	1c5a      	adds	r2, r3, #1
    9254:	61fa      	str	r2, [r7, #28]
    9256:	005b      	lsls	r3, r3, #1
    9258:	001a      	movs	r2, r3
    925a:	2318      	movs	r3, #24
    925c:	18fb      	adds	r3, r7, r3
    925e:	881b      	ldrh	r3, [r3, #0]
    9260:	8013      	strh	r3, [r2, #0]

	uint32_t nvm_address = destination_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    9262:	231a      	movs	r3, #26
    9264:	18fb      	adds	r3, r7, r3
    9266:	221a      	movs	r2, #26
    9268:	18ba      	adds	r2, r7, r2
    926a:	8812      	ldrh	r2, [r2, #0]
    926c:	3202      	adds	r2, #2
    926e:	801a      	strh	r2, [r3, #0]
    9270:	231a      	movs	r3, #26
    9272:	18fa      	adds	r2, r7, r3
    9274:	1dbb      	adds	r3, r7, #6
    9276:	8812      	ldrh	r2, [r2, #0]
    9278:	881b      	ldrh	r3, [r3, #0]
    927a:	429a      	cmp	r2, r3
    927c:	d3c5      	bcc.n	920a <nvm_write_buffer+0x92>
	}

	/* If automatic page write mode is enable, then perform a manual NVM
	 * write when the length of data to be programmed is less than page size
	 */
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
    927e:	4b0c      	ldr	r3, [pc, #48]	; (92b0 <nvm_write_buffer+0x138>)
    9280:	791b      	ldrb	r3, [r3, #4]
    9282:	2201      	movs	r2, #1
    9284:	4053      	eors	r3, r2
    9286:	b2db      	uxtb	r3, r3
    9288:	2b00      	cmp	r3, #0
    928a:	d00b      	beq.n	92a4 <nvm_write_buffer+0x12c>
    928c:	1dbb      	adds	r3, r7, #6
    928e:	881b      	ldrh	r3, [r3, #0]
    9290:	2b3f      	cmp	r3, #63	; 0x3f
    9292:	d807      	bhi.n	92a4 <nvm_write_buffer+0x12c>
#ifdef FEATURE_NVM_RWWEE
	 return ((is_rww_eeprom) ?
				(nvm_execute_command(NVM_COMMAND_RWWEE_WRITE_PAGE,destination_address, 0)):
	 			(nvm_execute_command(NVM_COMMAND_WRITE_PAGE,destination_address, 0)));
#else
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
    9294:	68fb      	ldr	r3, [r7, #12]
    9296:	2200      	movs	r2, #0
    9298:	0019      	movs	r1, r3
    929a:	2004      	movs	r0, #4
    929c:	4b08      	ldr	r3, [pc, #32]	; (92c0 <nvm_write_buffer+0x148>)
    929e:	4798      	blx	r3
    92a0:	0003      	movs	r3, r0
    92a2:	e000      	b.n	92a6 <nvm_write_buffer+0x12e>
				destination_address, 0);
#endif
	}

	return STATUS_OK;
    92a4:	2300      	movs	r3, #0
}
    92a6:	0018      	movs	r0, r3
    92a8:	46bd      	mov	sp, r7
    92aa:	b008      	add	sp, #32
    92ac:	bd80      	pop	{r7, pc}
    92ae:	46c0      	nop			; (mov r8, r8)
    92b0:	2000009c 	.word	0x2000009c
    92b4:	41004000 	.word	0x41004000
    92b8:	00009039 	.word	0x00009039
    92bc:	ffffa544 	.word	0xffffa544
    92c0:	00009061 	.word	0x00009061

000092c4 <nvm_erase_row>:
 *                                 not aligned to the start of a row
 * \retval STATUS_ABORTED          NVM erased error
 */
enum status_code nvm_erase_row(
		const uint32_t row_address)
{
    92c4:	b580      	push	{r7, lr}
    92c6:	b084      	sub	sp, #16
    92c8:	af00      	add	r7, sp, #0
    92ca:	6078      	str	r0, [r7, #4]
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    92cc:	4b23      	ldr	r3, [pc, #140]	; (935c <nvm_erase_row+0x98>)
    92ce:	881b      	ldrh	r3, [r3, #0]
    92d0:	001a      	movs	r2, r3
    92d2:	4b22      	ldr	r3, [pc, #136]	; (935c <nvm_erase_row+0x98>)
    92d4:	885b      	ldrh	r3, [r3, #2]
    92d6:	435a      	muls	r2, r3
#ifdef FEATURE_NVM_RWWEE
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
    92d8:	687b      	ldr	r3, [r7, #4]
    92da:	429a      	cmp	r2, r3
    92dc:	d201      	bcs.n	92e2 <nvm_erase_row+0x1e>
			|| row_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    92de:	2318      	movs	r3, #24
    92e0:	e037      	b.n	9352 <nvm_erase_row+0x8e>
#endif
	}

	/* Check if the address to erase is not aligned to the start of a row */
	if (row_address & ((_nvm_dev.page_size * NVMCTRL_ROW_PAGES) - 1)) {
    92e2:	4b1e      	ldr	r3, [pc, #120]	; (935c <nvm_erase_row+0x98>)
    92e4:	881b      	ldrh	r3, [r3, #0]
    92e6:	009b      	lsls	r3, r3, #2
    92e8:	3b01      	subs	r3, #1
    92ea:	001a      	movs	r2, r3
    92ec:	687b      	ldr	r3, [r7, #4]
    92ee:	4013      	ands	r3, r2
    92f0:	d001      	beq.n	92f6 <nvm_erase_row+0x32>
		return STATUS_ERR_BAD_ADDRESS;
    92f2:	2318      	movs	r3, #24
    92f4:	e02d      	b.n	9352 <nvm_erase_row+0x8e>
	}

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;
    92f6:	4b1a      	ldr	r3, [pc, #104]	; (9360 <nvm_erase_row+0x9c>)
    92f8:	60fb      	str	r3, [r7, #12]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    92fa:	4b1a      	ldr	r3, [pc, #104]	; (9364 <nvm_erase_row+0xa0>)
    92fc:	4798      	blx	r3
    92fe:	0003      	movs	r3, r0
    9300:	001a      	movs	r2, r3
    9302:	2301      	movs	r3, #1
    9304:	4053      	eors	r3, r2
    9306:	b2db      	uxtb	r3, r3
    9308:	2b00      	cmp	r3, #0
    930a:	d001      	beq.n	9310 <nvm_erase_row+0x4c>
		return STATUS_BUSY;
    930c:	2305      	movs	r3, #5
    930e:	e020      	b.n	9352 <nvm_erase_row+0x8e>
	}

	/* Clear error flags */
	nvm_module->STATUS.reg = NVMCTRL_STATUS_MASK;
    9310:	68fb      	ldr	r3, [r7, #12]
    9312:	2220      	movs	r2, #32
    9314:	32ff      	adds	r2, #255	; 0xff
    9316:	831a      	strh	r2, [r3, #24]

	/* Set address and command */
	nvm_module->ADDR.reg  = (uintptr_t)&NVM_MEMORY[row_address / 4];
    9318:	687b      	ldr	r3, [r7, #4]
    931a:	089b      	lsrs	r3, r3, #2
    931c:	005a      	lsls	r2, r3, #1
    931e:	68fb      	ldr	r3, [r7, #12]
    9320:	61da      	str	r2, [r3, #28]
#ifdef FEATURE_NVM_RWWEE
	nvm_module->CTRLA.reg = ((is_rww_eeprom) ?
								(NVM_COMMAND_RWWEE_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY):
								(NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY));
#else
	nvm_module->CTRLA.reg = NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    9322:	68fb      	ldr	r3, [r7, #12]
    9324:	4a10      	ldr	r2, [pc, #64]	; (9368 <nvm_erase_row+0xa4>)
    9326:	801a      	strh	r2, [r3, #0]
#endif

	while (!nvm_is_ready()) {
    9328:	46c0      	nop			; (mov r8, r8)
    932a:	4b0e      	ldr	r3, [pc, #56]	; (9364 <nvm_erase_row+0xa0>)
    932c:	4798      	blx	r3
    932e:	0003      	movs	r3, r0
    9330:	001a      	movs	r2, r3
    9332:	2301      	movs	r3, #1
    9334:	4053      	eors	r3, r2
    9336:	b2db      	uxtb	r3, r3
    9338:	2b00      	cmp	r3, #0
    933a:	d1f6      	bne.n	932a <nvm_erase_row+0x66>
	}

	/* There existed error in NVM erase operation */
	if ((enum nvm_error)(nvm_module->STATUS.reg & NVM_ERRORS_MASK) != NVM_ERROR_NONE) {
    933c:	68fb      	ldr	r3, [r7, #12]
    933e:	8b1b      	ldrh	r3, [r3, #24]
    9340:	b29b      	uxth	r3, r3
    9342:	b2db      	uxtb	r3, r3
    9344:	001a      	movs	r2, r3
    9346:	231c      	movs	r3, #28
    9348:	4013      	ands	r3, r2
    934a:	d001      	beq.n	9350 <nvm_erase_row+0x8c>
		return STATUS_ABORTED;
    934c:	2304      	movs	r3, #4
    934e:	e000      	b.n	9352 <nvm_erase_row+0x8e>
	}

	return STATUS_OK;
    9350:	2300      	movs	r3, #0
}
    9352:	0018      	movs	r0, r3
    9354:	46bd      	mov	sp, r7
    9356:	b004      	add	sp, #16
    9358:	bd80      	pop	{r7, pc}
    935a:	46c0      	nop			; (mov r8, r8)
    935c:	2000009c 	.word	0x2000009c
    9360:	41004000 	.word	0x41004000
    9364:	00009039 	.word	0x00009039
    9368:	ffffa502 	.word	0xffffa502

0000936c <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    936c:	b580      	push	{r7, lr}
    936e:	b082      	sub	sp, #8
    9370:	af00      	add	r7, sp, #0
    9372:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    9374:	687b      	ldr	r3, [r7, #4]
    9376:	2280      	movs	r2, #128	; 0x80
    9378:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    937a:	687b      	ldr	r3, [r7, #4]
    937c:	2200      	movs	r2, #0
    937e:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    9380:	687b      	ldr	r3, [r7, #4]
    9382:	2201      	movs	r2, #1
    9384:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    9386:	687b      	ldr	r3, [r7, #4]
    9388:	2200      	movs	r2, #0
    938a:	70da      	strb	r2, [r3, #3]
}
    938c:	46c0      	nop			; (mov r8, r8)
    938e:	46bd      	mov	sp, r7
    9390:	b002      	add	sp, #8
    9392:	bd80      	pop	{r7, pc}

00009394 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    9394:	b580      	push	{r7, lr}
    9396:	b084      	sub	sp, #16
    9398:	af00      	add	r7, sp, #0
    939a:	0002      	movs	r2, r0
    939c:	6039      	str	r1, [r7, #0]
    939e:	1dfb      	adds	r3, r7, #7
    93a0:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    93a2:	230c      	movs	r3, #12
    93a4:	18fb      	adds	r3, r7, r3
    93a6:	0018      	movs	r0, r3
    93a8:	4b10      	ldr	r3, [pc, #64]	; (93ec <port_pin_set_config+0x58>)
    93aa:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
    93ac:	230c      	movs	r3, #12
    93ae:	18fb      	adds	r3, r7, r3
    93b0:	2280      	movs	r2, #128	; 0x80
    93b2:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    93b4:	683b      	ldr	r3, [r7, #0]
    93b6:	781a      	ldrb	r2, [r3, #0]
    93b8:	230c      	movs	r3, #12
    93ba:	18fb      	adds	r3, r7, r3
    93bc:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    93be:	683b      	ldr	r3, [r7, #0]
    93c0:	785a      	ldrb	r2, [r3, #1]
    93c2:	230c      	movs	r3, #12
    93c4:	18fb      	adds	r3, r7, r3
    93c6:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    93c8:	683b      	ldr	r3, [r7, #0]
    93ca:	789a      	ldrb	r2, [r3, #2]
    93cc:	230c      	movs	r3, #12
    93ce:	18fb      	adds	r3, r7, r3
    93d0:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    93d2:	230c      	movs	r3, #12
    93d4:	18fa      	adds	r2, r7, r3
    93d6:	1dfb      	adds	r3, r7, #7
    93d8:	781b      	ldrb	r3, [r3, #0]
    93da:	0011      	movs	r1, r2
    93dc:	0018      	movs	r0, r3
    93de:	4b04      	ldr	r3, [pc, #16]	; (93f0 <port_pin_set_config+0x5c>)
    93e0:	4798      	blx	r3
}
    93e2:	46c0      	nop			; (mov r8, r8)
    93e4:	46bd      	mov	sp, r7
    93e6:	b004      	add	sp, #16
    93e8:	bd80      	pop	{r7, pc}
    93ea:	46c0      	nop			; (mov r8, r8)
    93ec:	0000936d 	.word	0x0000936d
    93f0:	0000a079 	.word	0x0000a079

000093f4 <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    93f4:	b580      	push	{r7, lr}
    93f6:	af00      	add	r7, sp, #0
    93f8:	4b03      	ldr	r3, [pc, #12]	; (9408 <SERCOM0_Handler+0x14>)
    93fa:	681b      	ldr	r3, [r3, #0]
    93fc:	2000      	movs	r0, #0
    93fe:	4798      	blx	r3
    9400:	46c0      	nop			; (mov r8, r8)
    9402:	46bd      	mov	sp, r7
    9404:	bd80      	pop	{r7, pc}
    9406:	46c0      	nop			; (mov r8, r8)
    9408:	200000a4 	.word	0x200000a4

0000940c <SERCOM1_Handler>:
    940c:	b580      	push	{r7, lr}
    940e:	af00      	add	r7, sp, #0
    9410:	4b03      	ldr	r3, [pc, #12]	; (9420 <SERCOM1_Handler+0x14>)
    9412:	685b      	ldr	r3, [r3, #4]
    9414:	2001      	movs	r0, #1
    9416:	4798      	blx	r3
    9418:	46c0      	nop			; (mov r8, r8)
    941a:	46bd      	mov	sp, r7
    941c:	bd80      	pop	{r7, pc}
    941e:	46c0      	nop			; (mov r8, r8)
    9420:	200000a4 	.word	0x200000a4

00009424 <SERCOM2_Handler>:
    9424:	b580      	push	{r7, lr}
    9426:	af00      	add	r7, sp, #0
    9428:	4b03      	ldr	r3, [pc, #12]	; (9438 <SERCOM2_Handler+0x14>)
    942a:	689b      	ldr	r3, [r3, #8]
    942c:	2002      	movs	r0, #2
    942e:	4798      	blx	r3
    9430:	46c0      	nop			; (mov r8, r8)
    9432:	46bd      	mov	sp, r7
    9434:	bd80      	pop	{r7, pc}
    9436:	46c0      	nop			; (mov r8, r8)
    9438:	200000a4 	.word	0x200000a4

0000943c <SERCOM3_Handler>:
    943c:	b580      	push	{r7, lr}
    943e:	af00      	add	r7, sp, #0
    9440:	4b03      	ldr	r3, [pc, #12]	; (9450 <SERCOM3_Handler+0x14>)
    9442:	68db      	ldr	r3, [r3, #12]
    9444:	2003      	movs	r0, #3
    9446:	4798      	blx	r3
    9448:	46c0      	nop			; (mov r8, r8)
    944a:	46bd      	mov	sp, r7
    944c:	bd80      	pop	{r7, pc}
    944e:	46c0      	nop			; (mov r8, r8)
    9450:	200000a4 	.word	0x200000a4

00009454 <SERCOM4_Handler>:
    9454:	b580      	push	{r7, lr}
    9456:	af00      	add	r7, sp, #0
    9458:	4b03      	ldr	r3, [pc, #12]	; (9468 <SERCOM4_Handler+0x14>)
    945a:	691b      	ldr	r3, [r3, #16]
    945c:	2004      	movs	r0, #4
    945e:	4798      	blx	r3
    9460:	46c0      	nop			; (mov r8, r8)
    9462:	46bd      	mov	sp, r7
    9464:	bd80      	pop	{r7, pc}
    9466:	46c0      	nop			; (mov r8, r8)
    9468:	200000a4 	.word	0x200000a4

0000946c <SERCOM5_Handler>:
    946c:	b580      	push	{r7, lr}
    946e:	af00      	add	r7, sp, #0
    9470:	4b03      	ldr	r3, [pc, #12]	; (9480 <SERCOM5_Handler+0x14>)
    9472:	695b      	ldr	r3, [r3, #20]
    9474:	2005      	movs	r0, #5
    9476:	4798      	blx	r3
    9478:	46c0      	nop			; (mov r8, r8)
    947a:	46bd      	mov	sp, r7
    947c:	bd80      	pop	{r7, pc}
    947e:	46c0      	nop			; (mov r8, r8)
    9480:	200000a4 	.word	0x200000a4

00009484 <spi_is_write_complete>:
 *                has been drawn high for SPI slave
 * \retval false  If the SPI master module has not shifted out data
 */
static inline bool spi_is_write_complete(
		struct spi_module *const module)
{
    9484:	b580      	push	{r7, lr}
    9486:	b084      	sub	sp, #16
    9488:	af00      	add	r7, sp, #0
    948a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    948c:	687b      	ldr	r3, [r7, #4]
    948e:	681b      	ldr	r3, [r3, #0]
    9490:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    9492:	68fb      	ldr	r3, [r7, #12]
    9494:	7e1b      	ldrb	r3, [r3, #24]
    9496:	b2db      	uxtb	r3, r3
    9498:	001a      	movs	r2, r3
    949a:	2302      	movs	r3, #2
    949c:	4013      	ands	r3, r2
    949e:	1e5a      	subs	r2, r3, #1
    94a0:	4193      	sbcs	r3, r2
    94a2:	b2db      	uxtb	r3, r3
}
    94a4:	0018      	movs	r0, r3
    94a6:	46bd      	mov	sp, r7
    94a8:	b004      	add	sp, #16
    94aa:	bd80      	pop	{r7, pc}

000094ac <spi_is_ready_to_write>:
 * \retval true   If the SPI module is ready to write data
 * \retval false  If the SPI module is not ready to write data
 */
static inline bool spi_is_ready_to_write(
		struct spi_module *const module)
{
    94ac:	b580      	push	{r7, lr}
    94ae:	b084      	sub	sp, #16
    94b0:	af00      	add	r7, sp, #0
    94b2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    94b4:	687b      	ldr	r3, [r7, #4]
    94b6:	681b      	ldr	r3, [r3, #0]
    94b8:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    94ba:	68fb      	ldr	r3, [r7, #12]
    94bc:	7e1b      	ldrb	r3, [r3, #24]
    94be:	b2db      	uxtb	r3, r3
    94c0:	001a      	movs	r2, r3
    94c2:	2301      	movs	r3, #1
    94c4:	4013      	ands	r3, r2
    94c6:	1e5a      	subs	r2, r3, #1
    94c8:	4193      	sbcs	r3, r2
    94ca:	b2db      	uxtb	r3, r3
}
    94cc:	0018      	movs	r0, r3
    94ce:	46bd      	mov	sp, r7
    94d0:	b004      	add	sp, #16
    94d2:	bd80      	pop	{r7, pc}

000094d4 <spi_is_ready_to_read>:
 * \retval true   If the SPI module is ready to read data
 * \retval false  If the SPI module is not ready to read data
 */
static inline bool spi_is_ready_to_read(
		struct spi_module *const module)
{
    94d4:	b580      	push	{r7, lr}
    94d6:	b084      	sub	sp, #16
    94d8:	af00      	add	r7, sp, #0
    94da:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    94dc:	687b      	ldr	r3, [r7, #4]
    94de:	681b      	ldr	r3, [r3, #0]
    94e0:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    94e2:	68fb      	ldr	r3, [r7, #12]
    94e4:	7e1b      	ldrb	r3, [r3, #24]
    94e6:	b2db      	uxtb	r3, r3
    94e8:	001a      	movs	r2, r3
    94ea:	2304      	movs	r3, #4
    94ec:	4013      	ands	r3, r2
    94ee:	1e5a      	subs	r2, r3, #1
    94f0:	4193      	sbcs	r3, r2
    94f2:	b2db      	uxtb	r3, r3
}
    94f4:	0018      	movs	r0, r3
    94f6:	46bd      	mov	sp, r7
    94f8:	b004      	add	sp, #16
    94fa:	bd80      	pop	{r7, pc}

000094fc <spi_write>:
 * \retval STATUS_BUSY  If the last write was not completed
 */
static inline enum status_code spi_write(
		struct spi_module *module,
		uint16_t tx_data)
{
    94fc:	b580      	push	{r7, lr}
    94fe:	b084      	sub	sp, #16
    9500:	af00      	add	r7, sp, #0
    9502:	6078      	str	r0, [r7, #4]
    9504:	000a      	movs	r2, r1
    9506:	1cbb      	adds	r3, r7, #2
    9508:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    950a:	687b      	ldr	r3, [r7, #4]
    950c:	681b      	ldr	r3, [r3, #0]
    950e:	60fb      	str	r3, [r7, #12]

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    9510:	687b      	ldr	r3, [r7, #4]
    9512:	0018      	movs	r0, r3
    9514:	4b0a      	ldr	r3, [pc, #40]	; (9540 <spi_write+0x44>)
    9516:	4798      	blx	r3
    9518:	0003      	movs	r3, r0
    951a:	001a      	movs	r2, r3
    951c:	2301      	movs	r3, #1
    951e:	4053      	eors	r3, r2
    9520:	b2db      	uxtb	r3, r3
    9522:	2b00      	cmp	r3, #0
    9524:	d001      	beq.n	952a <spi_write+0x2e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
    9526:	2305      	movs	r3, #5
    9528:	e006      	b.n	9538 <spi_write+0x3c>
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    952a:	1cbb      	adds	r3, r7, #2
    952c:	881b      	ldrh	r3, [r3, #0]
    952e:	05db      	lsls	r3, r3, #23
    9530:	0dda      	lsrs	r2, r3, #23
    9532:	68fb      	ldr	r3, [r7, #12]
    9534:	629a      	str	r2, [r3, #40]	; 0x28

	return STATUS_OK;
    9536:	2300      	movs	r3, #0
}
    9538:	0018      	movs	r0, r3
    953a:	46bd      	mov	sp, r7
    953c:	b004      	add	sp, #16
    953e:	bd80      	pop	{r7, pc}
    9540:	000094ad 	.word	0x000094ad

00009544 <spi_read>:
 * \retval STATUS_ERR_OVERFLOW  If the data is overflown
 */
static inline enum status_code spi_read(
		struct spi_module *const module,
		uint16_t *rx_data)
{
    9544:	b580      	push	{r7, lr}
    9546:	b084      	sub	sp, #16
    9548:	af00      	add	r7, sp, #0
    954a:	6078      	str	r0, [r7, #4]
    954c:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    954e:	687b      	ldr	r3, [r7, #4]
    9550:	681b      	ldr	r3, [r3, #0]
    9552:	60bb      	str	r3, [r7, #8]

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    9554:	687b      	ldr	r3, [r7, #4]
    9556:	0018      	movs	r0, r3
    9558:	4b1b      	ldr	r3, [pc, #108]	; (95c8 <spi_read+0x84>)
    955a:	4798      	blx	r3
    955c:	0003      	movs	r3, r0
    955e:	001a      	movs	r2, r3
    9560:	2301      	movs	r3, #1
    9562:	4053      	eors	r3, r2
    9564:	b2db      	uxtb	r3, r3
    9566:	2b00      	cmp	r3, #0
    9568:	d001      	beq.n	956e <spi_read+0x2a>
		/* No data has been received, return */
		return STATUS_ERR_IO;
    956a:	2310      	movs	r3, #16
    956c:	e027      	b.n	95be <spi_read+0x7a>
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    956e:	230f      	movs	r3, #15
    9570:	18fb      	adds	r3, r7, r3
    9572:	2200      	movs	r2, #0
    9574:	701a      	strb	r2, [r3, #0]

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    9576:	68bb      	ldr	r3, [r7, #8]
    9578:	8b5b      	ldrh	r3, [r3, #26]
    957a:	b29b      	uxth	r3, r3
    957c:	001a      	movs	r2, r3
    957e:	2304      	movs	r3, #4
    9580:	4013      	ands	r3, r2
    9582:	d006      	beq.n	9592 <spi_read+0x4e>
		retval = STATUS_ERR_OVERFLOW;
    9584:	230f      	movs	r3, #15
    9586:	18fb      	adds	r3, r7, r3
    9588:	221e      	movs	r2, #30
    958a:	701a      	strb	r2, [r3, #0]
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    958c:	68bb      	ldr	r3, [r7, #8]
    958e:	2204      	movs	r2, #4
    9590:	835a      	strh	r2, [r3, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    9592:	687b      	ldr	r3, [r7, #4]
    9594:	799b      	ldrb	r3, [r3, #6]
    9596:	2b01      	cmp	r3, #1
    9598:	d108      	bne.n	95ac <spi_read+0x68>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    959a:	68bb      	ldr	r3, [r7, #8]
    959c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    959e:	b29b      	uxth	r3, r3
    95a0:	05db      	lsls	r3, r3, #23
    95a2:	0ddb      	lsrs	r3, r3, #23
    95a4:	b29a      	uxth	r2, r3
    95a6:	683b      	ldr	r3, [r7, #0]
    95a8:	801a      	strh	r2, [r3, #0]
    95aa:	e005      	b.n	95b8 <spi_read+0x74>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    95ac:	68bb      	ldr	r3, [r7, #8]
    95ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    95b0:	b2db      	uxtb	r3, r3
    95b2:	b29a      	uxth	r2, r3
    95b4:	683b      	ldr	r3, [r7, #0]
    95b6:	801a      	strh	r2, [r3, #0]
	}

	return retval;
    95b8:	230f      	movs	r3, #15
    95ba:	18fb      	adds	r3, r7, r3
    95bc:	781b      	ldrb	r3, [r3, #0]
}
    95be:	0018      	movs	r0, r3
    95c0:	46bd      	mov	sp, r7
    95c2:	b004      	add	sp, #16
    95c4:	bd80      	pop	{r7, pc}
    95c6:	46c0      	nop			; (mov r8, r8)
    95c8:	000094d5 	.word	0x000094d5

000095cc <spi_read_buffer_wait>:
enum status_code spi_read_buffer_wait(
		struct spi_module *const module,
		uint8_t *rx_data,
		uint16_t length,
		uint16_t dummy)
{
    95cc:	b590      	push	{r4, r7, lr}
    95ce:	b087      	sub	sp, #28
    95d0:	af00      	add	r7, sp, #0
    95d2:	60f8      	str	r0, [r7, #12]
    95d4:	60b9      	str	r1, [r7, #8]
    95d6:	0019      	movs	r1, r3
    95d8:	1dbb      	adds	r3, r7, #6
    95da:	801a      	strh	r2, [r3, #0]
    95dc:	1d3b      	adds	r3, r7, #4
    95de:	1c0a      	adds	r2, r1, #0
    95e0:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    95e2:	68fb      	ldr	r3, [r7, #12]
    95e4:	2238      	movs	r2, #56	; 0x38
    95e6:	5c9b      	ldrb	r3, [r3, r2]
    95e8:	b2db      	uxtb	r3, r3
    95ea:	2b05      	cmp	r3, #5
    95ec:	d101      	bne.n	95f2 <spi_read_buffer_wait+0x26>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
    95ee:	2305      	movs	r3, #5
    95f0:	e07a      	b.n	96e8 <spi_read_buffer_wait+0x11c>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
    95f2:	1dbb      	adds	r3, r7, #6
    95f4:	881b      	ldrh	r3, [r3, #0]
    95f6:	2b00      	cmp	r3, #0
    95f8:	d101      	bne.n	95fe <spi_read_buffer_wait+0x32>
		return STATUS_ERR_INVALID_ARG;
    95fa:	2317      	movs	r3, #23
    95fc:	e074      	b.n	96e8 <spi_read_buffer_wait+0x11c>
	}

	if (!(module->receiver_enabled)) {
    95fe:	68fb      	ldr	r3, [r7, #12]
    9600:	79db      	ldrb	r3, [r3, #7]
    9602:	2201      	movs	r2, #1
    9604:	4053      	eors	r3, r2
    9606:	b2db      	uxtb	r3, r3
    9608:	2b00      	cmp	r3, #0
    960a:	d001      	beq.n	9610 <spi_read_buffer_wait+0x44>
		return STATUS_ERR_DENIED;
    960c:	231c      	movs	r3, #28
    960e:	e06b      	b.n	96e8 <spi_read_buffer_wait+0x11c>
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;
    9610:	2316      	movs	r3, #22
    9612:	18fb      	adds	r3, r7, r3
    9614:	2200      	movs	r2, #0
    9616:	801a      	strh	r2, [r3, #0]

	while (length--) {
    9618:	e05e      	b.n	96d8 <spi_read_buffer_wait+0x10c>
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
    961a:	68fb      	ldr	r3, [r7, #12]
    961c:	795b      	ldrb	r3, [r3, #5]
    961e:	2b01      	cmp	r3, #1
    9620:	d112      	bne.n	9648 <spi_read_buffer_wait+0x7c>
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
    9622:	46c0      	nop			; (mov r8, r8)
    9624:	68fb      	ldr	r3, [r7, #12]
    9626:	0018      	movs	r0, r3
    9628:	4b31      	ldr	r3, [pc, #196]	; (96f0 <spi_read_buffer_wait+0x124>)
    962a:	4798      	blx	r3
    962c:	0003      	movs	r3, r0
    962e:	001a      	movs	r2, r3
    9630:	2301      	movs	r3, #1
    9632:	4053      	eors	r3, r2
    9634:	b2db      	uxtb	r3, r3
    9636:	2b00      	cmp	r3, #0
    9638:	d1f4      	bne.n	9624 <spi_read_buffer_wait+0x58>
			}

			/* Send dummy SPI character to read in master mode */
			spi_write(module, dummy);
    963a:	1d3b      	adds	r3, r7, #4
    963c:	881a      	ldrh	r2, [r3, #0]
    963e:	68fb      	ldr	r3, [r7, #12]
    9640:	0011      	movs	r1, r2
    9642:	0018      	movs	r0, r3
    9644:	4b2b      	ldr	r3, [pc, #172]	; (96f4 <spi_read_buffer_wait+0x128>)
    9646:	4798      	blx	r3
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    9648:	46c0      	nop			; (mov r8, r8)
    964a:	68fb      	ldr	r3, [r7, #12]
    964c:	0018      	movs	r0, r3
    964e:	4b2a      	ldr	r3, [pc, #168]	; (96f8 <spi_read_buffer_wait+0x12c>)
    9650:	4798      	blx	r3
    9652:	0003      	movs	r3, r0
    9654:	001a      	movs	r2, r3
    9656:	2301      	movs	r3, #1
    9658:	4053      	eors	r3, r2
    965a:	b2db      	uxtb	r3, r3
    965c:	2b00      	cmp	r3, #0
    965e:	d1f4      	bne.n	964a <spi_read_buffer_wait+0x7e>
		}

		uint16_t received_data = 0;
    9660:	2312      	movs	r3, #18
    9662:	18fb      	adds	r3, r7, r3
    9664:	2200      	movs	r2, #0
    9666:	801a      	strh	r2, [r3, #0]
		enum status_code retval = spi_read(module, &received_data);
    9668:	2315      	movs	r3, #21
    966a:	18fc      	adds	r4, r7, r3
    966c:	2312      	movs	r3, #18
    966e:	18fa      	adds	r2, r7, r3
    9670:	68fb      	ldr	r3, [r7, #12]
    9672:	0011      	movs	r1, r2
    9674:	0018      	movs	r0, r3
    9676:	4b21      	ldr	r3, [pc, #132]	; (96fc <spi_read_buffer_wait+0x130>)
    9678:	4798      	blx	r3
    967a:	0003      	movs	r3, r0
    967c:	7023      	strb	r3, [r4, #0]

		if (retval != STATUS_OK) {
    967e:	2315      	movs	r3, #21
    9680:	18fb      	adds	r3, r7, r3
    9682:	781b      	ldrb	r3, [r3, #0]
    9684:	2b00      	cmp	r3, #0
    9686:	d003      	beq.n	9690 <spi_read_buffer_wait+0xc4>
			/* Overflow, abort */
			return retval;
    9688:	2315      	movs	r3, #21
    968a:	18fb      	adds	r3, r7, r3
    968c:	781b      	ldrb	r3, [r3, #0]
    968e:	e02b      	b.n	96e8 <spi_read_buffer_wait+0x11c>
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    9690:	2316      	movs	r3, #22
    9692:	18fb      	adds	r3, r7, r3
    9694:	881b      	ldrh	r3, [r3, #0]
    9696:	2216      	movs	r2, #22
    9698:	18ba      	adds	r2, r7, r2
    969a:	1c59      	adds	r1, r3, #1
    969c:	8011      	strh	r1, [r2, #0]
    969e:	001a      	movs	r2, r3
    96a0:	68bb      	ldr	r3, [r7, #8]
    96a2:	189b      	adds	r3, r3, r2
    96a4:	2212      	movs	r2, #18
    96a6:	18ba      	adds	r2, r7, r2
    96a8:	8812      	ldrh	r2, [r2, #0]
    96aa:	b2d2      	uxtb	r2, r2
    96ac:	701a      	strb	r2, [r3, #0]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    96ae:	68fb      	ldr	r3, [r7, #12]
    96b0:	799b      	ldrb	r3, [r3, #6]
    96b2:	2b01      	cmp	r3, #1
    96b4:	d110      	bne.n	96d8 <spi_read_buffer_wait+0x10c>
			rx_data[rx_pos++] = (received_data >> 8);
    96b6:	2316      	movs	r3, #22
    96b8:	18fb      	adds	r3, r7, r3
    96ba:	881b      	ldrh	r3, [r3, #0]
    96bc:	2216      	movs	r2, #22
    96be:	18ba      	adds	r2, r7, r2
    96c0:	1c59      	adds	r1, r3, #1
    96c2:	8011      	strh	r1, [r2, #0]
    96c4:	001a      	movs	r2, r3
    96c6:	68bb      	ldr	r3, [r7, #8]
    96c8:	189b      	adds	r3, r3, r2
    96ca:	2212      	movs	r2, #18
    96cc:	18ba      	adds	r2, r7, r2
    96ce:	8812      	ldrh	r2, [r2, #0]
    96d0:	0a12      	lsrs	r2, r2, #8
    96d2:	b292      	uxth	r2, r2
    96d4:	b2d2      	uxtb	r2, r2
    96d6:	701a      	strb	r2, [r3, #0]
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
    96d8:	1dbb      	adds	r3, r7, #6
    96da:	881b      	ldrh	r3, [r3, #0]
    96dc:	1dba      	adds	r2, r7, #6
    96de:	1e59      	subs	r1, r3, #1
    96e0:	8011      	strh	r1, [r2, #0]
    96e2:	2b00      	cmp	r3, #0
    96e4:	d199      	bne.n	961a <spi_read_buffer_wait+0x4e>
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

	return STATUS_OK;
    96e6:	2300      	movs	r3, #0
}
    96e8:	0018      	movs	r0, r3
    96ea:	46bd      	mov	sp, r7
    96ec:	b007      	add	sp, #28
    96ee:	bd90      	pop	{r4, r7, pc}
    96f0:	000094ad 	.word	0x000094ad
    96f4:	000094fd 	.word	0x000094fd
    96f8:	000094d5 	.word	0x000094d5
    96fc:	00009545 	.word	0x00009545

00009700 <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
    9700:	b580      	push	{r7, lr}
    9702:	b086      	sub	sp, #24
    9704:	af00      	add	r7, sp, #0
    9706:	60f8      	str	r0, [r7, #12]
    9708:	60b9      	str	r1, [r7, #8]
    970a:	1dbb      	adds	r3, r7, #6
    970c:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    970e:	68fb      	ldr	r3, [r7, #12]
    9710:	2238      	movs	r2, #56	; 0x38
    9712:	5c9b      	ldrb	r3, [r3, r2]
    9714:	b2db      	uxtb	r3, r3
    9716:	2b05      	cmp	r3, #5
    9718:	d101      	bne.n	971e <spi_write_buffer_wait+0x1e>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
    971a:	2305      	movs	r3, #5
    971c:	e087      	b.n	982e <spi_write_buffer_wait+0x12e>
	}
#  endif

	if (length == 0) {
    971e:	1dbb      	adds	r3, r7, #6
    9720:	881b      	ldrh	r3, [r3, #0]
    9722:	2b00      	cmp	r3, #0
    9724:	d101      	bne.n	972a <spi_write_buffer_wait+0x2a>
		return STATUS_ERR_INVALID_ARG;
    9726:	2317      	movs	r3, #23
    9728:	e081      	b.n	982e <spi_write_buffer_wait+0x12e>
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif

	uint16_t tx_pos = 0;
    972a:	2316      	movs	r3, #22
    972c:	18fb      	adds	r3, r7, r3
    972e:	2200      	movs	r2, #0
    9730:	801a      	strh	r2, [r3, #0]
	uint16_t flush_length = length;
    9732:	2314      	movs	r3, #20
    9734:	18fb      	adds	r3, r7, r3
    9736:	1dba      	adds	r2, r7, #6
    9738:	8812      	ldrh	r2, [r2, #0]
    973a:	801a      	strh	r2, [r3, #0]

	/* Write block */
	while (length--) {
    973c:	e05f      	b.n	97fe <spi_write_buffer_wait+0xfe>
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    973e:	46c0      	nop			; (mov r8, r8)
    9740:	68fb      	ldr	r3, [r7, #12]
    9742:	0018      	movs	r0, r3
    9744:	4b3c      	ldr	r3, [pc, #240]	; (9838 <spi_write_buffer_wait+0x138>)
    9746:	4798      	blx	r3
    9748:	0003      	movs	r3, r0
    974a:	001a      	movs	r2, r3
    974c:	2301      	movs	r3, #1
    974e:	4053      	eors	r3, r2
    9750:	b2db      	uxtb	r3, r3
    9752:	2b00      	cmp	r3, #0
    9754:	d1f4      	bne.n	9740 <spi_write_buffer_wait+0x40>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    9756:	2316      	movs	r3, #22
    9758:	18fb      	adds	r3, r7, r3
    975a:	881b      	ldrh	r3, [r3, #0]
    975c:	2216      	movs	r2, #22
    975e:	18ba      	adds	r2, r7, r2
    9760:	1c59      	adds	r1, r3, #1
    9762:	8011      	strh	r1, [r2, #0]
    9764:	001a      	movs	r2, r3
    9766:	68bb      	ldr	r3, [r7, #8]
    9768:	189b      	adds	r3, r3, r2
    976a:	781a      	ldrb	r2, [r3, #0]
    976c:	2312      	movs	r3, #18
    976e:	18fb      	adds	r3, r7, r3
    9770:	801a      	strh	r2, [r3, #0]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    9772:	68fb      	ldr	r3, [r7, #12]
    9774:	799b      	ldrb	r3, [r3, #6]
    9776:	2b01      	cmp	r3, #1
    9778:	d115      	bne.n	97a6 <spi_write_buffer_wait+0xa6>
			data_to_send |= (tx_data[tx_pos++] << 8);
    977a:	2316      	movs	r3, #22
    977c:	18fb      	adds	r3, r7, r3
    977e:	881b      	ldrh	r3, [r3, #0]
    9780:	2216      	movs	r2, #22
    9782:	18ba      	adds	r2, r7, r2
    9784:	1c59      	adds	r1, r3, #1
    9786:	8011      	strh	r1, [r2, #0]
    9788:	001a      	movs	r2, r3
    978a:	68bb      	ldr	r3, [r7, #8]
    978c:	189b      	adds	r3, r3, r2
    978e:	781b      	ldrb	r3, [r3, #0]
    9790:	021b      	lsls	r3, r3, #8
    9792:	b21a      	sxth	r2, r3
    9794:	2312      	movs	r3, #18
    9796:	18fb      	adds	r3, r7, r3
    9798:	2100      	movs	r1, #0
    979a:	5e5b      	ldrsh	r3, [r3, r1]
    979c:	4313      	orrs	r3, r2
    979e:	b21a      	sxth	r2, r3
    97a0:	2312      	movs	r3, #18
    97a2:	18fb      	adds	r3, r7, r3
    97a4:	801a      	strh	r2, [r3, #0]
		}

		/* Write the data to send */
		spi_write(module, data_to_send);
    97a6:	2312      	movs	r3, #18
    97a8:	18fb      	adds	r3, r7, r3
    97aa:	881a      	ldrh	r2, [r3, #0]
    97ac:	68fb      	ldr	r3, [r7, #12]
    97ae:	0011      	movs	r1, r2
    97b0:	0018      	movs	r0, r3
    97b2:	4b22      	ldr	r3, [pc, #136]	; (983c <spi_write_buffer_wait+0x13c>)
    97b4:	4798      	blx	r3

		if (module->receiver_enabled) {
    97b6:	68fb      	ldr	r3, [r7, #12]
    97b8:	79db      	ldrb	r3, [r3, #7]
    97ba:	2214      	movs	r2, #20
    97bc:	18ba      	adds	r2, r7, r2
    97be:	2114      	movs	r1, #20
    97c0:	1879      	adds	r1, r7, r1
    97c2:	8809      	ldrh	r1, [r1, #0]
    97c4:	8011      	strh	r1, [r2, #0]
    97c6:	2b00      	cmp	r3, #0
    97c8:	d019      	beq.n	97fe <spi_write_buffer_wait+0xfe>
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    97ca:	46c0      	nop			; (mov r8, r8)
    97cc:	68fb      	ldr	r3, [r7, #12]
    97ce:	0018      	movs	r0, r3
    97d0:	4b1b      	ldr	r3, [pc, #108]	; (9840 <spi_write_buffer_wait+0x140>)
    97d2:	4798      	blx	r3
    97d4:	0003      	movs	r3, r0
    97d6:	001a      	movs	r2, r3
    97d8:	2301      	movs	r3, #1
    97da:	4053      	eors	r3, r2
    97dc:	b2db      	uxtb	r3, r3
    97de:	2b00      	cmp	r3, #0
    97e0:	d1f4      	bne.n	97cc <spi_write_buffer_wait+0xcc>
			}

			/* Flush read buffer */
			uint16_t flush;
			spi_read(module, &flush);
    97e2:	2310      	movs	r3, #16
    97e4:	18fa      	adds	r2, r7, r3
    97e6:	68fb      	ldr	r3, [r7, #12]
    97e8:	0011      	movs	r1, r2
    97ea:	0018      	movs	r0, r3
    97ec:	4b15      	ldr	r3, [pc, #84]	; (9844 <spi_write_buffer_wait+0x144>)
    97ee:	4798      	blx	r3
			flush_length--;
    97f0:	2314      	movs	r3, #20
    97f2:	18fb      	adds	r3, r7, r3
    97f4:	881a      	ldrh	r2, [r3, #0]
    97f6:	2314      	movs	r3, #20
    97f8:	18fb      	adds	r3, r7, r3
    97fa:	3a01      	subs	r2, #1
    97fc:	801a      	strh	r2, [r3, #0]

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    97fe:	1dbb      	adds	r3, r7, #6
    9800:	881b      	ldrh	r3, [r3, #0]
    9802:	1dba      	adds	r2, r7, #6
    9804:	1e59      	subs	r1, r3, #1
    9806:	8011      	strh	r1, [r2, #0]
    9808:	2b00      	cmp	r3, #0
    980a:	d198      	bne.n	973e <spi_write_buffer_wait+0x3e>
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    980c:	68fb      	ldr	r3, [r7, #12]
    980e:	795b      	ldrb	r3, [r3, #5]
    9810:	2b01      	cmp	r3, #1
    9812:	d10b      	bne.n	982c <spi_write_buffer_wait+0x12c>
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    9814:	46c0      	nop			; (mov r8, r8)
    9816:	68fb      	ldr	r3, [r7, #12]
    9818:	0018      	movs	r0, r3
    981a:	4b0b      	ldr	r3, [pc, #44]	; (9848 <spi_write_buffer_wait+0x148>)
    981c:	4798      	blx	r3
    981e:	0003      	movs	r3, r0
    9820:	001a      	movs	r2, r3
    9822:	2301      	movs	r3, #1
    9824:	4053      	eors	r3, r2
    9826:	b2db      	uxtb	r3, r3
    9828:	2b00      	cmp	r3, #0
    982a:	d1f4      	bne.n	9816 <spi_write_buffer_wait+0x116>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    982c:	2300      	movs	r3, #0
}
    982e:	0018      	movs	r0, r3
    9830:	46bd      	mov	sp, r7
    9832:	b006      	add	sp, #24
    9834:	bd80      	pop	{r7, pc}
    9836:	46c0      	nop			; (mov r8, r8)
    9838:	000094ad 	.word	0x000094ad
    983c:	000094fd 	.word	0x000094fd
    9840:	000094d5 	.word	0x000094d5
    9844:	00009545 	.word	0x00009545
    9848:	00009485 	.word	0x00009485

0000984c <system_gclk_gen_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_gen_get_config_defaults(
		struct system_gclk_gen_config *const config)
{
    984c:	b580      	push	{r7, lr}
    984e:	b082      	sub	sp, #8
    9850:	af00      	add	r7, sp, #0
    9852:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    9854:	687b      	ldr	r3, [r7, #4]
    9856:	2201      	movs	r2, #1
    9858:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
    985a:	687b      	ldr	r3, [r7, #4]
    985c:	2200      	movs	r2, #0
    985e:	705a      	strb	r2, [r3, #1]
#if SAML21 || SAML22  || SAMR30
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    9860:	687b      	ldr	r3, [r7, #4]
    9862:	2206      	movs	r2, #6
    9864:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
    9866:	687b      	ldr	r3, [r7, #4]
    9868:	2200      	movs	r2, #0
    986a:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
    986c:	687b      	ldr	r3, [r7, #4]
    986e:	2200      	movs	r2, #0
    9870:	725a      	strb	r2, [r3, #9]
}
    9872:	46c0      	nop			; (mov r8, r8)
    9874:	46bd      	mov	sp, r7
    9876:	b002      	add	sp, #8
    9878:	bd80      	pop	{r7, pc}
    987a:	46c0      	nop			; (mov r8, r8)

0000987c <system_clock_source_osc8m_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_osc8m_get_config_defaults(
		struct system_clock_source_osc8m_config *const config)
{
    987c:	b580      	push	{r7, lr}
    987e:	b082      	sub	sp, #8
    9880:	af00      	add	r7, sp, #0
    9882:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
    9884:	687b      	ldr	r3, [r7, #4]
    9886:	2203      	movs	r2, #3
    9888:	701a      	strb	r2, [r3, #0]
	config->run_in_standby  = false;
    988a:	687b      	ldr	r3, [r7, #4]
    988c:	2200      	movs	r2, #0
    988e:	705a      	strb	r2, [r3, #1]
	config->on_demand       = true;
    9890:	687b      	ldr	r3, [r7, #4]
    9892:	2201      	movs	r2, #1
    9894:	709a      	strb	r2, [r3, #2]
}
    9896:	46c0      	nop			; (mov r8, r8)
    9898:	46bd      	mov	sp, r7
    989a:	b002      	add	sp, #8
    989c:	bd80      	pop	{r7, pc}
    989e:	46c0      	nop			; (mov r8, r8)

000098a0 <system_cpu_clock_set_divider>:
 *
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
    98a0:	b580      	push	{r7, lr}
    98a2:	b082      	sub	sp, #8
    98a4:	af00      	add	r7, sp, #0
    98a6:	0002      	movs	r2, r0
    98a8:	1dfb      	adds	r3, r7, #7
    98aa:	701a      	strb	r2, [r3, #0]
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    98ac:	4a03      	ldr	r2, [pc, #12]	; (98bc <system_cpu_clock_set_divider+0x1c>)
    98ae:	1dfb      	adds	r3, r7, #7
    98b0:	781b      	ldrb	r3, [r3, #0]
    98b2:	7213      	strb	r3, [r2, #8]
}
    98b4:	46c0      	nop			; (mov r8, r8)
    98b6:	46bd      	mov	sp, r7
    98b8:	b002      	add	sp, #8
    98ba:	bd80      	pop	{r7, pc}
    98bc:	40000400 	.word	0x40000400

000098c0 <system_apb_clock_set_divider>:
 * \retval STATUS_OK               The APBx clock was set successfully
 */
static inline enum status_code system_apb_clock_set_divider(
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
    98c0:	b580      	push	{r7, lr}
    98c2:	b082      	sub	sp, #8
    98c4:	af00      	add	r7, sp, #0
    98c6:	0002      	movs	r2, r0
    98c8:	1dfb      	adds	r3, r7, #7
    98ca:	701a      	strb	r2, [r3, #0]
    98cc:	1dbb      	adds	r3, r7, #6
    98ce:	1c0a      	adds	r2, r1, #0
    98d0:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    98d2:	1dfb      	adds	r3, r7, #7
    98d4:	781b      	ldrb	r3, [r3, #0]
    98d6:	2b01      	cmp	r3, #1
    98d8:	d008      	beq.n	98ec <system_apb_clock_set_divider+0x2c>
    98da:	2b02      	cmp	r3, #2
    98dc:	d00b      	beq.n	98f6 <system_apb_clock_set_divider+0x36>
    98de:	2b00      	cmp	r3, #0
    98e0:	d10e      	bne.n	9900 <system_apb_clock_set_divider+0x40>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    98e2:	4a0b      	ldr	r2, [pc, #44]	; (9910 <system_apb_clock_set_divider+0x50>)
    98e4:	1dbb      	adds	r3, r7, #6
    98e6:	781b      	ldrb	r3, [r3, #0]
    98e8:	7253      	strb	r3, [r2, #9]
			break;
    98ea:	e00b      	b.n	9904 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    98ec:	4a08      	ldr	r2, [pc, #32]	; (9910 <system_apb_clock_set_divider+0x50>)
    98ee:	1dbb      	adds	r3, r7, #6
    98f0:	781b      	ldrb	r3, [r3, #0]
    98f2:	7293      	strb	r3, [r2, #10]
			break;
    98f4:	e006      	b.n	9904 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    98f6:	4a06      	ldr	r2, [pc, #24]	; (9910 <system_apb_clock_set_divider+0x50>)
    98f8:	1dbb      	adds	r3, r7, #6
    98fa:	781b      	ldrb	r3, [r3, #0]
    98fc:	72d3      	strb	r3, [r2, #11]
			break;
    98fe:	e001      	b.n	9904 <system_apb_clock_set_divider+0x44>
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    9900:	2317      	movs	r3, #23
    9902:	e000      	b.n	9906 <system_apb_clock_set_divider+0x46>
	}

	return STATUS_OK;
    9904:	2300      	movs	r3, #0
}
    9906:	0018      	movs	r0, r3
    9908:	46bd      	mov	sp, r7
    990a:	b002      	add	sp, #8
    990c:	bd80      	pop	{r7, pc}
    990e:	46c0      	nop			; (mov r8, r8)
    9910:	40000400 	.word	0x40000400

00009914 <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
    9914:	b580      	push	{r7, lr}
    9916:	b082      	sub	sp, #8
    9918:	af00      	add	r7, sp, #0
    991a:	0002      	movs	r2, r0
    991c:	1dfb      	adds	r3, r7, #7
    991e:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    9920:	4a08      	ldr	r2, [pc, #32]	; (9944 <system_flash_set_waitstates+0x30>)
    9922:	1dfb      	adds	r3, r7, #7
    9924:	781b      	ldrb	r3, [r3, #0]
    9926:	210f      	movs	r1, #15
    9928:	400b      	ands	r3, r1
    992a:	b2d9      	uxtb	r1, r3
    992c:	6853      	ldr	r3, [r2, #4]
    992e:	200f      	movs	r0, #15
    9930:	4001      	ands	r1, r0
    9932:	0049      	lsls	r1, r1, #1
    9934:	201e      	movs	r0, #30
    9936:	4383      	bics	r3, r0
    9938:	430b      	orrs	r3, r1
    993a:	6053      	str	r3, [r2, #4]
}
    993c:	46c0      	nop			; (mov r8, r8)
    993e:	46bd      	mov	sp, r7
    9940:	b002      	add	sp, #8
    9942:	bd80      	pop	{r7, pc}
    9944:	41004000 	.word	0x41004000

00009948 <_system_dfll_wait_for_sync>:
/**
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
    9948:	b580      	push	{r7, lr}
    994a:	af00      	add	r7, sp, #0
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    994c:	46c0      	nop			; (mov r8, r8)
    994e:	4b04      	ldr	r3, [pc, #16]	; (9960 <_system_dfll_wait_for_sync+0x18>)
    9950:	68db      	ldr	r3, [r3, #12]
    9952:	2210      	movs	r2, #16
    9954:	4013      	ands	r3, r2
    9956:	d0fa      	beq.n	994e <_system_dfll_wait_for_sync+0x6>
		/* Wait for DFLL sync */
	}
}
    9958:	46c0      	nop			; (mov r8, r8)
    995a:	46bd      	mov	sp, r7
    995c:	bd80      	pop	{r7, pc}
    995e:	46c0      	nop			; (mov r8, r8)
    9960:	40000800 	.word	0x40000800

00009964 <_system_clock_source_dfll_set_config_errata_9905>:
		/* Wait for OSC32K sync */
	}
}

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{
    9964:	b580      	push	{r7, lr}
    9966:	af00      	add	r7, sp, #0

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    9968:	4b0c      	ldr	r3, [pc, #48]	; (999c <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    996a:	2202      	movs	r2, #2
    996c:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
    996e:	4b0c      	ldr	r3, [pc, #48]	; (99a0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    9970:	4798      	blx	r3

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    9972:	4a0a      	ldr	r2, [pc, #40]	; (999c <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    9974:	4b0b      	ldr	r3, [pc, #44]	; (99a4 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    9976:	689b      	ldr	r3, [r3, #8]
    9978:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    997a:	4a08      	ldr	r2, [pc, #32]	; (999c <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    997c:	4b09      	ldr	r3, [pc, #36]	; (99a4 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    997e:	685b      	ldr	r3, [r3, #4]
    9980:	6293      	str	r3, [r2, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
    9982:	4b06      	ldr	r3, [pc, #24]	; (999c <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    9984:	2200      	movs	r2, #0
    9986:	849a      	strh	r2, [r3, #36]	; 0x24
	_system_dfll_wait_for_sync();
    9988:	4b05      	ldr	r3, [pc, #20]	; (99a0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    998a:	4798      	blx	r3
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    998c:	4a03      	ldr	r2, [pc, #12]	; (999c <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    998e:	4b05      	ldr	r3, [pc, #20]	; (99a4 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    9990:	681b      	ldr	r3, [r3, #0]
    9992:	b29b      	uxth	r3, r3
    9994:	8493      	strh	r3, [r2, #36]	; 0x24
}
    9996:	46c0      	nop			; (mov r8, r8)
    9998:	46bd      	mov	sp, r7
    999a:	bd80      	pop	{r7, pc}
    999c:	40000800 	.word	0x40000800
    99a0:	00009949 	.word	0x00009949
    99a4:	200000bc 	.word	0x200000bc

000099a8 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    99a8:	b580      	push	{r7, lr}
    99aa:	b084      	sub	sp, #16
    99ac:	af00      	add	r7, sp, #0
    99ae:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    99b0:	4b1a      	ldr	r3, [pc, #104]	; (9a1c <system_clock_source_osc8m_set_config+0x74>)
    99b2:	6a1b      	ldr	r3, [r3, #32]
    99b4:	60fb      	str	r3, [r7, #12]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    99b6:	687b      	ldr	r3, [r7, #4]
    99b8:	781b      	ldrb	r3, [r3, #0]
    99ba:	1c1a      	adds	r2, r3, #0
    99bc:	2303      	movs	r3, #3
    99be:	4013      	ands	r3, r2
    99c0:	b2da      	uxtb	r2, r3
    99c2:	230d      	movs	r3, #13
    99c4:	18fb      	adds	r3, r7, r3
    99c6:	2103      	movs	r1, #3
    99c8:	400a      	ands	r2, r1
    99ca:	0010      	movs	r0, r2
    99cc:	781a      	ldrb	r2, [r3, #0]
    99ce:	2103      	movs	r1, #3
    99d0:	438a      	bics	r2, r1
    99d2:	1c11      	adds	r1, r2, #0
    99d4:	1c02      	adds	r2, r0, #0
    99d6:	430a      	orrs	r2, r1
    99d8:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
    99da:	687b      	ldr	r3, [r7, #4]
    99dc:	789a      	ldrb	r2, [r3, #2]
    99de:	230c      	movs	r3, #12
    99e0:	18fb      	adds	r3, r7, r3
    99e2:	01d0      	lsls	r0, r2, #7
    99e4:	781a      	ldrb	r2, [r3, #0]
    99e6:	217f      	movs	r1, #127	; 0x7f
    99e8:	400a      	ands	r2, r1
    99ea:	1c11      	adds	r1, r2, #0
    99ec:	1c02      	adds	r2, r0, #0
    99ee:	430a      	orrs	r2, r1
    99f0:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
    99f2:	687b      	ldr	r3, [r7, #4]
    99f4:	785a      	ldrb	r2, [r3, #1]
    99f6:	230c      	movs	r3, #12
    99f8:	18fb      	adds	r3, r7, r3
    99fa:	2101      	movs	r1, #1
    99fc:	400a      	ands	r2, r1
    99fe:	0190      	lsls	r0, r2, #6
    9a00:	781a      	ldrb	r2, [r3, #0]
    9a02:	2140      	movs	r1, #64	; 0x40
    9a04:	438a      	bics	r2, r1
    9a06:	1c11      	adds	r1, r2, #0
    9a08:	1c02      	adds	r2, r0, #0
    9a0a:	430a      	orrs	r2, r1
    9a0c:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC8M = temp;
    9a0e:	4b03      	ldr	r3, [pc, #12]	; (9a1c <system_clock_source_osc8m_set_config+0x74>)
    9a10:	68fa      	ldr	r2, [r7, #12]
    9a12:	621a      	str	r2, [r3, #32]
}
    9a14:	46c0      	nop			; (mov r8, r8)
    9a16:	46bd      	mov	sp, r7
    9a18:	b004      	add	sp, #16
    9a1a:	bd80      	pop	{r7, pc}
    9a1c:	40000800 	.word	0x40000800

00009a20 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    9a20:	b580      	push	{r7, lr}
    9a22:	b082      	sub	sp, #8
    9a24:	af00      	add	r7, sp, #0
    9a26:	0002      	movs	r2, r0
    9a28:	1dfb      	adds	r3, r7, #7
    9a2a:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    9a2c:	1dfb      	adds	r3, r7, #7
    9a2e:	781b      	ldrb	r3, [r3, #0]
    9a30:	2b08      	cmp	r3, #8
    9a32:	d83b      	bhi.n	9aac <system_clock_source_enable+0x8c>
    9a34:	009a      	lsls	r2, r3, #2
    9a36:	4b21      	ldr	r3, [pc, #132]	; (9abc <system_clock_source_enable+0x9c>)
    9a38:	18d3      	adds	r3, r2, r3
    9a3a:	681b      	ldr	r3, [r3, #0]
    9a3c:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    9a3e:	4b20      	ldr	r3, [pc, #128]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a40:	4a1f      	ldr	r2, [pc, #124]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a42:	6a12      	ldr	r2, [r2, #32]
    9a44:	2102      	movs	r1, #2
    9a46:	430a      	orrs	r2, r1
    9a48:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
    9a4a:	2300      	movs	r3, #0
    9a4c:	e031      	b.n	9ab2 <system_clock_source_enable+0x92>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    9a4e:	4b1c      	ldr	r3, [pc, #112]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a50:	4a1b      	ldr	r2, [pc, #108]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a52:	6992      	ldr	r2, [r2, #24]
    9a54:	2102      	movs	r1, #2
    9a56:	430a      	orrs	r2, r1
    9a58:	619a      	str	r2, [r3, #24]
		break;
    9a5a:	e029      	b.n	9ab0 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    9a5c:	4a18      	ldr	r2, [pc, #96]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a5e:	4b18      	ldr	r3, [pc, #96]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a60:	8a1b      	ldrh	r3, [r3, #16]
    9a62:	b29b      	uxth	r3, r3
    9a64:	2102      	movs	r1, #2
    9a66:	430b      	orrs	r3, r1
    9a68:	b29b      	uxth	r3, r3
    9a6a:	8213      	strh	r3, [r2, #16]
		break;
    9a6c:	e020      	b.n	9ab0 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    9a6e:	4a14      	ldr	r2, [pc, #80]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a70:	4b13      	ldr	r3, [pc, #76]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a72:	8a9b      	ldrh	r3, [r3, #20]
    9a74:	b29b      	uxth	r3, r3
    9a76:	2102      	movs	r1, #2
    9a78:	430b      	orrs	r3, r1
    9a7a:	b29b      	uxth	r3, r3
    9a7c:	8293      	strh	r3, [r2, #20]
		break;
    9a7e:	e017      	b.n	9ab0 <system_clock_source_enable+0x90>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    9a80:	4b10      	ldr	r3, [pc, #64]	; (9ac4 <system_clock_source_enable+0xa4>)
    9a82:	681b      	ldr	r3, [r3, #0]
    9a84:	2202      	movs	r2, #2
    9a86:	431a      	orrs	r2, r3
    9a88:	4b0e      	ldr	r3, [pc, #56]	; (9ac4 <system_clock_source_enable+0xa4>)
    9a8a:	601a      	str	r2, [r3, #0]
		_system_clock_source_dfll_set_config_errata_9905();
    9a8c:	4b0e      	ldr	r3, [pc, #56]	; (9ac8 <system_clock_source_enable+0xa8>)
    9a8e:	4798      	blx	r3
		break;
    9a90:	e00e      	b.n	9ab0 <system_clock_source_enable+0x90>

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    9a92:	4a0b      	ldr	r2, [pc, #44]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a94:	490a      	ldr	r1, [pc, #40]	; (9ac0 <system_clock_source_enable+0xa0>)
    9a96:	2344      	movs	r3, #68	; 0x44
    9a98:	5ccb      	ldrb	r3, [r1, r3]
    9a9a:	b2db      	uxtb	r3, r3
    9a9c:	2102      	movs	r1, #2
    9a9e:	430b      	orrs	r3, r1
    9aa0:	b2d9      	uxtb	r1, r3
    9aa2:	2344      	movs	r3, #68	; 0x44
    9aa4:	54d1      	strb	r1, [r2, r3]
		break;
    9aa6:	e003      	b.n	9ab0 <system_clock_source_enable+0x90>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    9aa8:	2300      	movs	r3, #0
    9aaa:	e002      	b.n	9ab2 <system_clock_source_enable+0x92>

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    9aac:	2317      	movs	r3, #23
    9aae:	e000      	b.n	9ab2 <system_clock_source_enable+0x92>
	}

	return STATUS_OK;
    9ab0:	2300      	movs	r3, #0
}
    9ab2:	0018      	movs	r0, r3
    9ab4:	46bd      	mov	sp, r7
    9ab6:	b002      	add	sp, #8
    9ab8:	bd80      	pop	{r7, pc}
    9aba:	46c0      	nop			; (mov r8, r8)
    9abc:	0000b044 	.word	0x0000b044
    9ac0:	40000800 	.word	0x40000800
    9ac4:	200000bc 	.word	0x200000bc
    9ac8:	00009965 	.word	0x00009965

00009acc <_switch_peripheral_gclk>:
 *
 * Switch all peripheral clock to a not enabled general clock
 * to save power.
 */
static void _switch_peripheral_gclk(void)
{
    9acc:	b580      	push	{r7, lr}
    9ace:	b082      	sub	sp, #8
    9ad0:	af00      	add	r7, sp, #0
	uint32_t gclk_id;
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
    9ad2:	003b      	movs	r3, r7
    9ad4:	2201      	movs	r2, #1
    9ad6:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    9ad8:	2300      	movs	r3, #0
    9ada:	607b      	str	r3, [r7, #4]
    9adc:	e009      	b.n	9af2 <_switch_peripheral_gclk+0x26>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    9ade:	687b      	ldr	r3, [r7, #4]
    9ae0:	b2db      	uxtb	r3, r3
    9ae2:	003a      	movs	r2, r7
    9ae4:	0011      	movs	r1, r2
    9ae6:	0018      	movs	r0, r3
    9ae8:	4b05      	ldr	r3, [pc, #20]	; (9b00 <_switch_peripheral_gclk+0x34>)
    9aea:	4798      	blx	r3
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    9aec:	687b      	ldr	r3, [r7, #4]
    9aee:	3301      	adds	r3, #1
    9af0:	607b      	str	r3, [r7, #4]
    9af2:	687b      	ldr	r3, [r7, #4]
    9af4:	2b24      	cmp	r3, #36	; 0x24
    9af6:	d9f2      	bls.n	9ade <_switch_peripheral_gclk+0x12>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
	}
}
    9af8:	46c0      	nop			; (mov r8, r8)
    9afa:	46bd      	mov	sp, r7
    9afc:	b002      	add	sp, #8
    9afe:	bd80      	pop	{r7, pc}
    9b00:	00009e2d 	.word	0x00009e2d

00009b04 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    9b04:	b580      	push	{r7, lr}
    9b06:	b0a0      	sub	sp, #128	; 0x80
    9b08:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    9b0a:	4b27      	ldr	r3, [pc, #156]	; (9ba8 <system_clock_init+0xa4>)
    9b0c:	22c2      	movs	r2, #194	; 0xc2
    9b0e:	00d2      	lsls	r2, r2, #3
    9b10:	609a      	str	r2, [r3, #8]
			SYSCTRL_INTFLAG_DFLLRDY;

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
    9b12:	2000      	movs	r0, #0
    9b14:	4b25      	ldr	r3, [pc, #148]	; (9bac <system_clock_init+0xa8>)
    9b16:	4798      	blx	r3

	/* Switch all peripheral clock to a not enabled general clock to save power. */
	_switch_peripheral_gclk();
    9b18:	4b25      	ldr	r3, [pc, #148]	; (9bb0 <system_clock_init+0xac>)
    9b1a:	4798      	blx	r3
#endif


	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);
    9b1c:	237c      	movs	r3, #124	; 0x7c
    9b1e:	18fb      	adds	r3, r7, r3
    9b20:	0018      	movs	r0, r3
    9b22:	4b24      	ldr	r3, [pc, #144]	; (9bb4 <system_clock_init+0xb0>)
    9b24:	4798      	blx	r3

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    9b26:	237c      	movs	r3, #124	; 0x7c
    9b28:	18fb      	adds	r3, r7, r3
    9b2a:	2200      	movs	r2, #0
    9b2c:	701a      	strb	r2, [r3, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
    9b2e:	237c      	movs	r3, #124	; 0x7c
    9b30:	18fb      	adds	r3, r7, r3
    9b32:	2201      	movs	r2, #1
    9b34:	709a      	strb	r2, [r3, #2]
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
    9b36:	237c      	movs	r3, #124	; 0x7c
    9b38:	18fb      	adds	r3, r7, r3
    9b3a:	2200      	movs	r2, #0
    9b3c:	705a      	strb	r2, [r3, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
    9b3e:	237c      	movs	r3, #124	; 0x7c
    9b40:	18fb      	adds	r3, r7, r3
    9b42:	0018      	movs	r0, r3
    9b44:	4b1c      	ldr	r3, [pc, #112]	; (9bb8 <system_clock_init+0xb4>)
    9b46:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    9b48:	2006      	movs	r0, #6
    9b4a:	4b1c      	ldr	r3, [pc, #112]	; (9bbc <system_clock_init+0xb8>)
    9b4c:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    9b4e:	4b1c      	ldr	r3, [pc, #112]	; (9bc0 <system_clock_init+0xbc>)
    9b50:	4798      	blx	r3

#  endif
#endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
    9b52:	2000      	movs	r0, #0
    9b54:	4b1b      	ldr	r3, [pc, #108]	; (9bc4 <system_clock_init+0xc0>)
    9b56:	4798      	blx	r3

	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBA, CONF_CLOCK_APBA_DIVIDER);
    9b58:	2100      	movs	r1, #0
    9b5a:	2000      	movs	r0, #0
    9b5c:	4b1a      	ldr	r3, [pc, #104]	; (9bc8 <system_clock_init+0xc4>)
    9b5e:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);
    9b60:	2100      	movs	r1, #0
    9b62:	2001      	movs	r0, #1
    9b64:	4b18      	ldr	r3, [pc, #96]	; (9bc8 <system_clock_init+0xc4>)
    9b66:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);
    9b68:	2100      	movs	r1, #0
    9b6a:	2002      	movs	r0, #2
    9b6c:	4b16      	ldr	r3, [pc, #88]	; (9bc8 <system_clock_init+0xc4>)
    9b6e:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    9b70:	1d3b      	adds	r3, r7, #4
    9b72:	0018      	movs	r0, r3
    9b74:	4b15      	ldr	r3, [pc, #84]	; (9bcc <system_clock_init+0xc8>)
    9b76:	4798      	blx	r3
    9b78:	1d3b      	adds	r3, r7, #4
    9b7a:	2206      	movs	r2, #6
    9b7c:	701a      	strb	r2, [r3, #0]
    9b7e:	1d3b      	adds	r3, r7, #4
    9b80:	2201      	movs	r2, #1
    9b82:	605a      	str	r2, [r3, #4]
    9b84:	1d3b      	adds	r3, r7, #4
    9b86:	2200      	movs	r2, #0
    9b88:	721a      	strb	r2, [r3, #8]
    9b8a:	1d3b      	adds	r3, r7, #4
    9b8c:	2200      	movs	r2, #0
    9b8e:	725a      	strb	r2, [r3, #9]
    9b90:	1d3b      	adds	r3, r7, #4
    9b92:	0019      	movs	r1, r3
    9b94:	2000      	movs	r0, #0
    9b96:	4b0e      	ldr	r3, [pc, #56]	; (9bd0 <system_clock_init+0xcc>)
    9b98:	4798      	blx	r3
    9b9a:	2000      	movs	r0, #0
    9b9c:	4b0d      	ldr	r3, [pc, #52]	; (9bd4 <system_clock_init+0xd0>)
    9b9e:	4798      	blx	r3
#endif
}
    9ba0:	46c0      	nop			; (mov r8, r8)
    9ba2:	46bd      	mov	sp, r7
    9ba4:	b020      	add	sp, #128	; 0x80
    9ba6:	bd80      	pop	{r7, pc}
    9ba8:	40000800 	.word	0x40000800
    9bac:	00009915 	.word	0x00009915
    9bb0:	00009acd 	.word	0x00009acd
    9bb4:	0000987d 	.word	0x0000987d
    9bb8:	000099a9 	.word	0x000099a9
    9bbc:	00009a21 	.word	0x00009a21
    9bc0:	00009c7d 	.word	0x00009c7d
    9bc4:	000098a1 	.word	0x000098a1
    9bc8:	000098c1 	.word	0x000098c1
    9bcc:	0000984d 	.word	0x0000984d
    9bd0:	00009cad 	.word	0x00009cad
    9bd4:	00009dd1 	.word	0x00009dd1

00009bd8 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    9bd8:	b580      	push	{r7, lr}
    9bda:	b082      	sub	sp, #8
    9bdc:	af00      	add	r7, sp, #0
    9bde:	0002      	movs	r2, r0
    9be0:	6039      	str	r1, [r7, #0]
    9be2:	1dfb      	adds	r3, r7, #7
    9be4:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    9be6:	1dfb      	adds	r3, r7, #7
    9be8:	781b      	ldrb	r3, [r3, #0]
    9bea:	2b01      	cmp	r3, #1
    9bec:	d00a      	beq.n	9c04 <system_apb_clock_set_mask+0x2c>
    9bee:	2b02      	cmp	r3, #2
    9bf0:	d00f      	beq.n	9c12 <system_apb_clock_set_mask+0x3a>
    9bf2:	2b00      	cmp	r3, #0
    9bf4:	d114      	bne.n	9c20 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    9bf6:	4b0e      	ldr	r3, [pc, #56]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9bf8:	4a0d      	ldr	r2, [pc, #52]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9bfa:	6991      	ldr	r1, [r2, #24]
    9bfc:	683a      	ldr	r2, [r7, #0]
    9bfe:	430a      	orrs	r2, r1
    9c00:	619a      	str	r2, [r3, #24]
			break;
    9c02:	e00f      	b.n	9c24 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    9c04:	4b0a      	ldr	r3, [pc, #40]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9c06:	4a0a      	ldr	r2, [pc, #40]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9c08:	69d1      	ldr	r1, [r2, #28]
    9c0a:	683a      	ldr	r2, [r7, #0]
    9c0c:	430a      	orrs	r2, r1
    9c0e:	61da      	str	r2, [r3, #28]
			break;
    9c10:	e008      	b.n	9c24 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    9c12:	4b07      	ldr	r3, [pc, #28]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9c14:	4a06      	ldr	r2, [pc, #24]	; (9c30 <system_apb_clock_set_mask+0x58>)
    9c16:	6a11      	ldr	r1, [r2, #32]
    9c18:	683a      	ldr	r2, [r7, #0]
    9c1a:	430a      	orrs	r2, r1
    9c1c:	621a      	str	r2, [r3, #32]
			break;
    9c1e:	e001      	b.n	9c24 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    9c20:	2317      	movs	r3, #23
    9c22:	e000      	b.n	9c26 <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    9c24:	2300      	movs	r3, #0
}
    9c26:	0018      	movs	r0, r3
    9c28:	46bd      	mov	sp, r7
    9c2a:	b002      	add	sp, #8
    9c2c:	bd80      	pop	{r7, pc}
    9c2e:	46c0      	nop			; (mov r8, r8)
    9c30:	40000400 	.word	0x40000400

00009c34 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
    9c34:	b580      	push	{r7, lr}
    9c36:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    9c38:	4b02      	ldr	r3, [pc, #8]	; (9c44 <system_interrupt_enter_critical_section+0x10>)
    9c3a:	4798      	blx	r3
}
    9c3c:	46c0      	nop			; (mov r8, r8)
    9c3e:	46bd      	mov	sp, r7
    9c40:	bd80      	pop	{r7, pc}
    9c42:	46c0      	nop			; (mov r8, r8)
    9c44:	00008115 	.word	0x00008115

00009c48 <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
    9c48:	b580      	push	{r7, lr}
    9c4a:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    9c4c:	4b02      	ldr	r3, [pc, #8]	; (9c58 <system_interrupt_leave_critical_section+0x10>)
    9c4e:	4798      	blx	r3
}
    9c50:	46c0      	nop			; (mov r8, r8)
    9c52:	46bd      	mov	sp, r7
    9c54:	bd80      	pop	{r7, pc}
    9c56:	46c0      	nop			; (mov r8, r8)
    9c58:	00008169 	.word	0x00008169

00009c5c <system_gclk_is_syncing>:
 *
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
    9c5c:	b580      	push	{r7, lr}
    9c5e:	af00      	add	r7, sp, #0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    9c60:	4b05      	ldr	r3, [pc, #20]	; (9c78 <system_gclk_is_syncing+0x1c>)
    9c62:	785b      	ldrb	r3, [r3, #1]
    9c64:	b2db      	uxtb	r3, r3
    9c66:	b25b      	sxtb	r3, r3
    9c68:	2b00      	cmp	r3, #0
    9c6a:	da01      	bge.n	9c70 <system_gclk_is_syncing+0x14>
		return true;
    9c6c:	2301      	movs	r3, #1
    9c6e:	e000      	b.n	9c72 <system_gclk_is_syncing+0x16>
	}

	return false;
    9c70:	2300      	movs	r3, #0
}
    9c72:	0018      	movs	r0, r3
    9c74:	46bd      	mov	sp, r7
    9c76:	bd80      	pop	{r7, pc}
    9c78:	40000c00 	.word	0x40000c00

00009c7c <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
    9c7c:	b580      	push	{r7, lr}
    9c7e:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);
    9c80:	2108      	movs	r1, #8
    9c82:	2000      	movs	r0, #0
    9c84:	4b07      	ldr	r3, [pc, #28]	; (9ca4 <system_gclk_init+0x28>)
    9c86:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    9c88:	4b07      	ldr	r3, [pc, #28]	; (9ca8 <system_gclk_init+0x2c>)
    9c8a:	2201      	movs	r2, #1
    9c8c:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    9c8e:	46c0      	nop			; (mov r8, r8)
    9c90:	4b05      	ldr	r3, [pc, #20]	; (9ca8 <system_gclk_init+0x2c>)
    9c92:	781b      	ldrb	r3, [r3, #0]
    9c94:	b2db      	uxtb	r3, r3
    9c96:	001a      	movs	r2, r3
    9c98:	2301      	movs	r3, #1
    9c9a:	4013      	ands	r3, r2
    9c9c:	d1f8      	bne.n	9c90 <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
    9c9e:	46c0      	nop			; (mov r8, r8)
    9ca0:	46bd      	mov	sp, r7
    9ca2:	bd80      	pop	{r7, pc}
    9ca4:	00009bd9 	.word	0x00009bd9
    9ca8:	40000c00 	.word	0x40000c00

00009cac <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    9cac:	b580      	push	{r7, lr}
    9cae:	b086      	sub	sp, #24
    9cb0:	af00      	add	r7, sp, #0
    9cb2:	0002      	movs	r2, r0
    9cb4:	6039      	str	r1, [r7, #0]
    9cb6:	1dfb      	adds	r3, r7, #7
    9cb8:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    9cba:	1dfb      	adds	r3, r7, #7
    9cbc:	781b      	ldrb	r3, [r3, #0]
    9cbe:	617b      	str	r3, [r7, #20]
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);
    9cc0:	1dfb      	adds	r3, r7, #7
    9cc2:	781b      	ldrb	r3, [r3, #0]
    9cc4:	613b      	str	r3, [r7, #16]

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    9cc6:	683b      	ldr	r3, [r7, #0]
    9cc8:	781b      	ldrb	r3, [r3, #0]
    9cca:	021b      	lsls	r3, r3, #8
    9ccc:	001a      	movs	r2, r3
    9cce:	697b      	ldr	r3, [r7, #20]
    9cd0:	4313      	orrs	r3, r2
    9cd2:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    9cd4:	683b      	ldr	r3, [r7, #0]
    9cd6:	785b      	ldrb	r3, [r3, #1]
    9cd8:	2b00      	cmp	r3, #0
    9cda:	d004      	beq.n	9ce6 <system_gclk_gen_set_config+0x3a>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    9cdc:	697b      	ldr	r3, [r7, #20]
    9cde:	2280      	movs	r2, #128	; 0x80
    9ce0:	02d2      	lsls	r2, r2, #11
    9ce2:	4313      	orrs	r3, r2
    9ce4:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    9ce6:	683b      	ldr	r3, [r7, #0]
    9ce8:	7a5b      	ldrb	r3, [r3, #9]
    9cea:	2b00      	cmp	r3, #0
    9cec:	d004      	beq.n	9cf8 <system_gclk_gen_set_config+0x4c>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    9cee:	697b      	ldr	r3, [r7, #20]
    9cf0:	2280      	movs	r2, #128	; 0x80
    9cf2:	0312      	lsls	r2, r2, #12
    9cf4:	4313      	orrs	r3, r2
    9cf6:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    9cf8:	683b      	ldr	r3, [r7, #0]
    9cfa:	685b      	ldr	r3, [r3, #4]
    9cfc:	2b01      	cmp	r3, #1
    9cfe:	d92c      	bls.n	9d5a <system_gclk_gen_set_config+0xae>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    9d00:	683b      	ldr	r3, [r7, #0]
    9d02:	685a      	ldr	r2, [r3, #4]
    9d04:	683b      	ldr	r3, [r7, #0]
    9d06:	685b      	ldr	r3, [r3, #4]
    9d08:	3b01      	subs	r3, #1
    9d0a:	4013      	ands	r3, r2
    9d0c:	d11a      	bne.n	9d44 <system_gclk_gen_set_config+0x98>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
    9d0e:	2300      	movs	r3, #0
    9d10:	60fb      	str	r3, [r7, #12]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    9d12:	2302      	movs	r3, #2
    9d14:	60bb      	str	r3, [r7, #8]
    9d16:	e005      	b.n	9d24 <system_gclk_gen_set_config+0x78>
						mask <<= 1) {
				div2_count++;
    9d18:	68fb      	ldr	r3, [r7, #12]
    9d1a:	3301      	adds	r3, #1
    9d1c:	60fb      	str	r3, [r7, #12]

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    9d1e:	68bb      	ldr	r3, [r7, #8]
    9d20:	005b      	lsls	r3, r3, #1
    9d22:	60bb      	str	r3, [r7, #8]
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    9d24:	683b      	ldr	r3, [r7, #0]
    9d26:	685a      	ldr	r2, [r3, #4]
    9d28:	68bb      	ldr	r3, [r7, #8]
    9d2a:	429a      	cmp	r2, r3
    9d2c:	d8f4      	bhi.n	9d18 <system_gclk_gen_set_config+0x6c>
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    9d2e:	68fb      	ldr	r3, [r7, #12]
    9d30:	021b      	lsls	r3, r3, #8
    9d32:	693a      	ldr	r2, [r7, #16]
    9d34:	4313      	orrs	r3, r2
    9d36:	613b      	str	r3, [r7, #16]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    9d38:	697b      	ldr	r3, [r7, #20]
    9d3a:	2280      	movs	r2, #128	; 0x80
    9d3c:	0352      	lsls	r2, r2, #13
    9d3e:	4313      	orrs	r3, r2
    9d40:	617b      	str	r3, [r7, #20]
    9d42:	e00a      	b.n	9d5a <system_gclk_gen_set_config+0xae>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    9d44:	683b      	ldr	r3, [r7, #0]
    9d46:	685b      	ldr	r3, [r3, #4]
    9d48:	021b      	lsls	r3, r3, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    9d4a:	693a      	ldr	r2, [r7, #16]
    9d4c:	4313      	orrs	r3, r2
    9d4e:	613b      	str	r3, [r7, #16]
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    9d50:	697b      	ldr	r3, [r7, #20]
    9d52:	2280      	movs	r2, #128	; 0x80
    9d54:	0292      	lsls	r2, r2, #10
    9d56:	4313      	orrs	r3, r2
    9d58:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    9d5a:	683b      	ldr	r3, [r7, #0]
    9d5c:	7a1b      	ldrb	r3, [r3, #8]
    9d5e:	2b00      	cmp	r3, #0
    9d60:	d004      	beq.n	9d6c <system_gclk_gen_set_config+0xc0>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    9d62:	697b      	ldr	r3, [r7, #20]
    9d64:	2280      	movs	r2, #128	; 0x80
    9d66:	0392      	lsls	r2, r2, #14
    9d68:	4313      	orrs	r3, r2
    9d6a:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing()) {
    9d6c:	46c0      	nop			; (mov r8, r8)
    9d6e:	4b13      	ldr	r3, [pc, #76]	; (9dbc <system_gclk_gen_set_config+0x110>)
    9d70:	4798      	blx	r3
    9d72:	1e03      	subs	r3, r0, #0
    9d74:	d1fb      	bne.n	9d6e <system_gclk_gen_set_config+0xc2>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    9d76:	4b12      	ldr	r3, [pc, #72]	; (9dc0 <system_gclk_gen_set_config+0x114>)
    9d78:	4798      	blx	r3

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    9d7a:	4a12      	ldr	r2, [pc, #72]	; (9dc4 <system_gclk_gen_set_config+0x118>)
    9d7c:	1dfb      	adds	r3, r7, #7
    9d7e:	781b      	ldrb	r3, [r3, #0]
    9d80:	7013      	strb	r3, [r2, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    9d82:	46c0      	nop			; (mov r8, r8)
    9d84:	4b0d      	ldr	r3, [pc, #52]	; (9dbc <system_gclk_gen_set_config+0x110>)
    9d86:	4798      	blx	r3
    9d88:	1e03      	subs	r3, r0, #0
    9d8a:	d1fb      	bne.n	9d84 <system_gclk_gen_set_config+0xd8>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    9d8c:	4b0e      	ldr	r3, [pc, #56]	; (9dc8 <system_gclk_gen_set_config+0x11c>)
    9d8e:	693a      	ldr	r2, [r7, #16]
    9d90:	609a      	str	r2, [r3, #8]

	while (system_gclk_is_syncing()) {
    9d92:	46c0      	nop			; (mov r8, r8)
    9d94:	4b09      	ldr	r3, [pc, #36]	; (9dbc <system_gclk_gen_set_config+0x110>)
    9d96:	4798      	blx	r3
    9d98:	1e03      	subs	r3, r0, #0
    9d9a:	d1fb      	bne.n	9d94 <system_gclk_gen_set_config+0xe8>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    9d9c:	4b0a      	ldr	r3, [pc, #40]	; (9dc8 <system_gclk_gen_set_config+0x11c>)
    9d9e:	4a0a      	ldr	r2, [pc, #40]	; (9dc8 <system_gclk_gen_set_config+0x11c>)
    9da0:	6851      	ldr	r1, [r2, #4]
    9da2:	2280      	movs	r2, #128	; 0x80
    9da4:	0252      	lsls	r2, r2, #9
    9da6:	4011      	ands	r1, r2
    9da8:	697a      	ldr	r2, [r7, #20]
    9daa:	430a      	orrs	r2, r1
    9dac:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    9dae:	4b07      	ldr	r3, [pc, #28]	; (9dcc <system_gclk_gen_set_config+0x120>)
    9db0:	4798      	blx	r3
}
    9db2:	46c0      	nop			; (mov r8, r8)
    9db4:	46bd      	mov	sp, r7
    9db6:	b006      	add	sp, #24
    9db8:	bd80      	pop	{r7, pc}
    9dba:	46c0      	nop			; (mov r8, r8)
    9dbc:	00009c5d 	.word	0x00009c5d
    9dc0:	00009c35 	.word	0x00009c35
    9dc4:	40000c08 	.word	0x40000c08
    9dc8:	40000c00 	.word	0x40000c00
    9dcc:	00009c49 	.word	0x00009c49

00009dd0 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    9dd0:	b580      	push	{r7, lr}
    9dd2:	b082      	sub	sp, #8
    9dd4:	af00      	add	r7, sp, #0
    9dd6:	0002      	movs	r2, r0
    9dd8:	1dfb      	adds	r3, r7, #7
    9dda:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
    9ddc:	46c0      	nop			; (mov r8, r8)
    9dde:	4b0e      	ldr	r3, [pc, #56]	; (9e18 <system_gclk_gen_enable+0x48>)
    9de0:	4798      	blx	r3
    9de2:	1e03      	subs	r3, r0, #0
    9de4:	d1fb      	bne.n	9dde <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    9de6:	4b0d      	ldr	r3, [pc, #52]	; (9e1c <system_gclk_gen_enable+0x4c>)
    9de8:	4798      	blx	r3

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    9dea:	4a0d      	ldr	r2, [pc, #52]	; (9e20 <system_gclk_gen_enable+0x50>)
    9dec:	1dfb      	adds	r3, r7, #7
    9dee:	781b      	ldrb	r3, [r3, #0]
    9df0:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    9df2:	46c0      	nop			; (mov r8, r8)
    9df4:	4b08      	ldr	r3, [pc, #32]	; (9e18 <system_gclk_gen_enable+0x48>)
    9df6:	4798      	blx	r3
    9df8:	1e03      	subs	r3, r0, #0
    9dfa:	d1fb      	bne.n	9df4 <system_gclk_gen_enable+0x24>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    9dfc:	4b09      	ldr	r3, [pc, #36]	; (9e24 <system_gclk_gen_enable+0x54>)
    9dfe:	4a09      	ldr	r2, [pc, #36]	; (9e24 <system_gclk_gen_enable+0x54>)
    9e00:	6852      	ldr	r2, [r2, #4]
    9e02:	2180      	movs	r1, #128	; 0x80
    9e04:	0249      	lsls	r1, r1, #9
    9e06:	430a      	orrs	r2, r1
    9e08:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    9e0a:	4b07      	ldr	r3, [pc, #28]	; (9e28 <system_gclk_gen_enable+0x58>)
    9e0c:	4798      	blx	r3
}
    9e0e:	46c0      	nop			; (mov r8, r8)
    9e10:	46bd      	mov	sp, r7
    9e12:	b002      	add	sp, #8
    9e14:	bd80      	pop	{r7, pc}
    9e16:	46c0      	nop			; (mov r8, r8)
    9e18:	00009c5d 	.word	0x00009c5d
    9e1c:	00009c35 	.word	0x00009c35
    9e20:	40000c04 	.word	0x40000c04
    9e24:	40000c00 	.word	0x40000c00
    9e28:	00009c49 	.word	0x00009c49

00009e2c <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    9e2c:	b580      	push	{r7, lr}
    9e2e:	b084      	sub	sp, #16
    9e30:	af00      	add	r7, sp, #0
    9e32:	0002      	movs	r2, r0
    9e34:	6039      	str	r1, [r7, #0]
    9e36:	1dfb      	adds	r3, r7, #7
    9e38:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);
    9e3a:	1dfb      	adds	r3, r7, #7
    9e3c:	781b      	ldrb	r3, [r3, #0]
    9e3e:	60fb      	str	r3, [r7, #12]

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    9e40:	683b      	ldr	r3, [r7, #0]
    9e42:	781b      	ldrb	r3, [r3, #0]
    9e44:	021b      	lsls	r3, r3, #8
    9e46:	001a      	movs	r2, r3
    9e48:	68fb      	ldr	r3, [r7, #12]
    9e4a:	4313      	orrs	r3, r2
    9e4c:	60fb      	str	r3, [r7, #12]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    9e4e:	1dfb      	adds	r3, r7, #7
    9e50:	781b      	ldrb	r3, [r3, #0]
    9e52:	0018      	movs	r0, r3
    9e54:	4b04      	ldr	r3, [pc, #16]	; (9e68 <system_gclk_chan_set_config+0x3c>)
    9e56:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    9e58:	4b04      	ldr	r3, [pc, #16]	; (9e6c <system_gclk_chan_set_config+0x40>)
    9e5a:	68fa      	ldr	r2, [r7, #12]
    9e5c:	b292      	uxth	r2, r2
    9e5e:	805a      	strh	r2, [r3, #2]
}
    9e60:	46c0      	nop			; (mov r8, r8)
    9e62:	46bd      	mov	sp, r7
    9e64:	b004      	add	sp, #16
    9e66:	bd80      	pop	{r7, pc}
    9e68:	00009e71 	.word	0x00009e71
    9e6c:	40000c00 	.word	0x40000c00

00009e70 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    9e70:	b580      	push	{r7, lr}
    9e72:	b084      	sub	sp, #16
    9e74:	af00      	add	r7, sp, #0
    9e76:	0002      	movs	r2, r0
    9e78:	1dfb      	adds	r3, r7, #7
    9e7a:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    9e7c:	4b1c      	ldr	r3, [pc, #112]	; (9ef0 <system_gclk_chan_disable+0x80>)
    9e7e:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    9e80:	4a1c      	ldr	r2, [pc, #112]	; (9ef4 <system_gclk_chan_disable+0x84>)
    9e82:	1dfb      	adds	r3, r7, #7
    9e84:	781b      	ldrb	r3, [r3, #0]
    9e86:	7013      	strb	r3, [r2, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    9e88:	4b1b      	ldr	r3, [pc, #108]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9e8a:	885b      	ldrh	r3, [r3, #2]
    9e8c:	051b      	lsls	r3, r3, #20
    9e8e:	0f1b      	lsrs	r3, r3, #28
    9e90:	b2db      	uxtb	r3, r3
    9e92:	60fb      	str	r3, [r7, #12]
	GCLK->CLKCTRL.bit.GEN = 0;
    9e94:	4a18      	ldr	r2, [pc, #96]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9e96:	8853      	ldrh	r3, [r2, #2]
    9e98:	4918      	ldr	r1, [pc, #96]	; (9efc <system_gclk_chan_disable+0x8c>)
    9e9a:	400b      	ands	r3, r1
    9e9c:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    9e9e:	4a16      	ldr	r2, [pc, #88]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9ea0:	4b15      	ldr	r3, [pc, #84]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9ea2:	885b      	ldrh	r3, [r3, #2]
    9ea4:	b29b      	uxth	r3, r3
    9ea6:	4916      	ldr	r1, [pc, #88]	; (9f00 <system_gclk_chan_disable+0x90>)
    9ea8:	400b      	ands	r3, r1
    9eaa:	b29b      	uxth	r3, r3
    9eac:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    9eae:	46c0      	nop			; (mov r8, r8)
    9eb0:	4b11      	ldr	r3, [pc, #68]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9eb2:	885b      	ldrh	r3, [r3, #2]
    9eb4:	b29b      	uxth	r3, r3
    9eb6:	001a      	movs	r2, r3
    9eb8:	2380      	movs	r3, #128	; 0x80
    9eba:	01db      	lsls	r3, r3, #7
    9ebc:	4013      	ands	r3, r2
    9ebe:	d1f7      	bne.n	9eb0 <system_gclk_chan_disable+0x40>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    9ec0:	4a0d      	ldr	r2, [pc, #52]	; (9ef8 <system_gclk_chan_disable+0x88>)
    9ec2:	68fb      	ldr	r3, [r7, #12]
    9ec4:	b2db      	uxtb	r3, r3
    9ec6:	1c19      	adds	r1, r3, #0
    9ec8:	230f      	movs	r3, #15
    9eca:	400b      	ands	r3, r1
    9ecc:	b2d9      	uxtb	r1, r3
    9ece:	8853      	ldrh	r3, [r2, #2]
    9ed0:	1c08      	adds	r0, r1, #0
    9ed2:	210f      	movs	r1, #15
    9ed4:	4001      	ands	r1, r0
    9ed6:	0208      	lsls	r0, r1, #8
    9ed8:	4908      	ldr	r1, [pc, #32]	; (9efc <system_gclk_chan_disable+0x8c>)
    9eda:	400b      	ands	r3, r1
    9edc:	1c19      	adds	r1, r3, #0
    9ede:	1c03      	adds	r3, r0, #0
    9ee0:	430b      	orrs	r3, r1
    9ee2:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
    9ee4:	4b07      	ldr	r3, [pc, #28]	; (9f04 <system_gclk_chan_disable+0x94>)
    9ee6:	4798      	blx	r3
}
    9ee8:	46c0      	nop			; (mov r8, r8)
    9eea:	46bd      	mov	sp, r7
    9eec:	b004      	add	sp, #16
    9eee:	bd80      	pop	{r7, pc}
    9ef0:	00009c35 	.word	0x00009c35
    9ef4:	40000c02 	.word	0x40000c02
    9ef8:	40000c00 	.word	0x40000c00
    9efc:	fffff0ff 	.word	0xfffff0ff
    9f00:	ffffbfff 	.word	0xffffbfff
    9f04:	00009c49 	.word	0x00009c49

00009f08 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    9f08:	b580      	push	{r7, lr}
    9f0a:	b084      	sub	sp, #16
    9f0c:	af00      	add	r7, sp, #0
    9f0e:	0002      	movs	r2, r0
    9f10:	1dfb      	adds	r3, r7, #7
    9f12:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    9f14:	230f      	movs	r3, #15
    9f16:	18fb      	adds	r3, r7, r3
    9f18:	1dfa      	adds	r2, r7, #7
    9f1a:	7812      	ldrb	r2, [r2, #0]
    9f1c:	09d2      	lsrs	r2, r2, #7
    9f1e:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    9f20:	230e      	movs	r3, #14
    9f22:	18fb      	adds	r3, r7, r3
    9f24:	1dfa      	adds	r2, r7, #7
    9f26:	7812      	ldrb	r2, [r2, #0]
    9f28:	0952      	lsrs	r2, r2, #5
    9f2a:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    9f2c:	4b0d      	ldr	r3, [pc, #52]	; (9f64 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    9f2e:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    9f30:	230f      	movs	r3, #15
    9f32:	18fb      	adds	r3, r7, r3
    9f34:	781b      	ldrb	r3, [r3, #0]
    9f36:	2b00      	cmp	r3, #0
    9f38:	d10f      	bne.n	9f5a <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    9f3a:	230f      	movs	r3, #15
    9f3c:	18fb      	adds	r3, r7, r3
    9f3e:	781b      	ldrb	r3, [r3, #0]
    9f40:	009b      	lsls	r3, r3, #2
    9f42:	2210      	movs	r2, #16
    9f44:	4694      	mov	ip, r2
    9f46:	44bc      	add	ip, r7
    9f48:	4463      	add	r3, ip
    9f4a:	3b08      	subs	r3, #8
    9f4c:	681a      	ldr	r2, [r3, #0]
    9f4e:	230e      	movs	r3, #14
    9f50:	18fb      	adds	r3, r7, r3
    9f52:	781b      	ldrb	r3, [r3, #0]
    9f54:	01db      	lsls	r3, r3, #7
    9f56:	18d3      	adds	r3, r2, r3
    9f58:	e000      	b.n	9f5c <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    9f5a:	2300      	movs	r3, #0
	}
}
    9f5c:	0018      	movs	r0, r3
    9f5e:	46bd      	mov	sp, r7
    9f60:	b004      	add	sp, #16
    9f62:	bd80      	pop	{r7, pc}
    9f64:	41004400 	.word	0x41004400

00009f68 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    9f68:	b580      	push	{r7, lr}
    9f6a:	b088      	sub	sp, #32
    9f6c:	af00      	add	r7, sp, #0
    9f6e:	60f8      	str	r0, [r7, #12]
    9f70:	60b9      	str	r1, [r7, #8]
    9f72:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    9f74:	2300      	movs	r3, #0
    9f76:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    9f78:	687b      	ldr	r3, [r7, #4]
    9f7a:	78db      	ldrb	r3, [r3, #3]
    9f7c:	2201      	movs	r2, #1
    9f7e:	4053      	eors	r3, r2
    9f80:	b2db      	uxtb	r3, r3
    9f82:	2b00      	cmp	r3, #0
    9f84:	d035      	beq.n	9ff2 <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    9f86:	687b      	ldr	r3, [r7, #4]
    9f88:	781b      	ldrb	r3, [r3, #0]
    9f8a:	2b80      	cmp	r3, #128	; 0x80
    9f8c:	d00b      	beq.n	9fa6 <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
    9f8e:	69fb      	ldr	r3, [r7, #28]
    9f90:	2280      	movs	r2, #128	; 0x80
    9f92:	0252      	lsls	r2, r2, #9
    9f94:	4313      	orrs	r3, r2
    9f96:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    9f98:	687b      	ldr	r3, [r7, #4]
    9f9a:	781b      	ldrb	r3, [r3, #0]
    9f9c:	061b      	lsls	r3, r3, #24
    9f9e:	001a      	movs	r2, r3
    9fa0:	69fb      	ldr	r3, [r7, #28]
    9fa2:	4313      	orrs	r3, r2
    9fa4:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    9fa6:	687b      	ldr	r3, [r7, #4]
    9fa8:	785b      	ldrb	r3, [r3, #1]
    9faa:	2b00      	cmp	r3, #0
    9fac:	d003      	beq.n	9fb6 <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    9fae:	687b      	ldr	r3, [r7, #4]
    9fb0:	785b      	ldrb	r3, [r3, #1]
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    9fb2:	2b02      	cmp	r3, #2
    9fb4:	d110      	bne.n	9fd8 <_system_pinmux_config+0x70>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    9fb6:	69fb      	ldr	r3, [r7, #28]
    9fb8:	2280      	movs	r2, #128	; 0x80
    9fba:	0292      	lsls	r2, r2, #10
    9fbc:	4313      	orrs	r3, r2
    9fbe:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    9fc0:	687b      	ldr	r3, [r7, #4]
    9fc2:	789b      	ldrb	r3, [r3, #2]
    9fc4:	2b00      	cmp	r3, #0
    9fc6:	d004      	beq.n	9fd2 <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    9fc8:	69fb      	ldr	r3, [r7, #28]
    9fca:	2280      	movs	r2, #128	; 0x80
    9fcc:	02d2      	lsls	r2, r2, #11
    9fce:	4313      	orrs	r3, r2
    9fd0:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    9fd2:	68fb      	ldr	r3, [r7, #12]
    9fd4:	68ba      	ldr	r2, [r7, #8]
    9fd6:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    9fd8:	687b      	ldr	r3, [r7, #4]
    9fda:	785b      	ldrb	r3, [r3, #1]
    9fdc:	2b01      	cmp	r3, #1
    9fde:	d003      	beq.n	9fe8 <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    9fe0:	687b      	ldr	r3, [r7, #4]
    9fe2:	785b      	ldrb	r3, [r3, #1]
			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    9fe4:	2b02      	cmp	r3, #2
    9fe6:	d107      	bne.n	9ff8 <_system_pinmux_config+0x90>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    9fe8:	69fb      	ldr	r3, [r7, #28]
    9fea:	4a22      	ldr	r2, [pc, #136]	; (a074 <_system_pinmux_config+0x10c>)
    9fec:	4013      	ands	r3, r2
    9fee:	61fb      	str	r3, [r7, #28]
    9ff0:	e002      	b.n	9ff8 <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    9ff2:	68fb      	ldr	r3, [r7, #12]
    9ff4:	68ba      	ldr	r2, [r7, #8]
    9ff6:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    9ff8:	68bb      	ldr	r3, [r7, #8]
    9ffa:	041b      	lsls	r3, r3, #16
    9ffc:	0c1b      	lsrs	r3, r3, #16
    9ffe:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
    a000:	68bb      	ldr	r3, [r7, #8]
    a002:	0c1b      	lsrs	r3, r3, #16
    a004:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    a006:	69ba      	ldr	r2, [r7, #24]
    a008:	69fb      	ldr	r3, [r7, #28]
    a00a:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    a00c:	22a0      	movs	r2, #160	; 0xa0
    a00e:	05d2      	lsls	r2, r2, #23
    a010:	431a      	orrs	r2, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    a012:	68fb      	ldr	r3, [r7, #12]
    a014:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    a016:	697a      	ldr	r2, [r7, #20]
    a018:	69fb      	ldr	r3, [r7, #28]
    a01a:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    a01c:	22d0      	movs	r2, #208	; 0xd0
    a01e:	0612      	lsls	r2, r2, #24
    a020:	431a      	orrs	r2, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    a022:	68fb      	ldr	r3, [r7, #12]
    a024:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    a026:	687b      	ldr	r3, [r7, #4]
    a028:	78db      	ldrb	r3, [r3, #3]
    a02a:	2201      	movs	r2, #1
    a02c:	4053      	eors	r3, r2
    a02e:	b2db      	uxtb	r3, r3
    a030:	2b00      	cmp	r3, #0
    a032:	d01a      	beq.n	a06a <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    a034:	69fa      	ldr	r2, [r7, #28]
    a036:	2380      	movs	r3, #128	; 0x80
    a038:	02db      	lsls	r3, r3, #11
    a03a:	4013      	ands	r3, r2
    a03c:	d00a      	beq.n	a054 <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    a03e:	687b      	ldr	r3, [r7, #4]
    a040:	789b      	ldrb	r3, [r3, #2]
    a042:	2b01      	cmp	r3, #1
    a044:	d103      	bne.n	a04e <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
    a046:	68fb      	ldr	r3, [r7, #12]
    a048:	68ba      	ldr	r2, [r7, #8]
    a04a:	619a      	str	r2, [r3, #24]
    a04c:	e002      	b.n	a054 <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
    a04e:	68fb      	ldr	r3, [r7, #12]
    a050:	68ba      	ldr	r2, [r7, #8]
    a052:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    a054:	687b      	ldr	r3, [r7, #4]
    a056:	785b      	ldrb	r3, [r3, #1]
    a058:	2b01      	cmp	r3, #1
    a05a:	d003      	beq.n	a064 <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    a05c:	687b      	ldr	r3, [r7, #4]
    a05e:	785b      	ldrb	r3, [r3, #1]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    a060:	2b02      	cmp	r3, #2
    a062:	d102      	bne.n	a06a <_system_pinmux_config+0x102>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    a064:	68fb      	ldr	r3, [r7, #12]
    a066:	68ba      	ldr	r2, [r7, #8]
    a068:	609a      	str	r2, [r3, #8]
		}
	}
}
    a06a:	46c0      	nop			; (mov r8, r8)
    a06c:	46bd      	mov	sp, r7
    a06e:	b008      	add	sp, #32
    a070:	bd80      	pop	{r7, pc}
    a072:	46c0      	nop			; (mov r8, r8)
    a074:	fffbffff 	.word	0xfffbffff

0000a078 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    a078:	b580      	push	{r7, lr}
    a07a:	b084      	sub	sp, #16
    a07c:	af00      	add	r7, sp, #0
    a07e:	0002      	movs	r2, r0
    a080:	6039      	str	r1, [r7, #0]
    a082:	1dfb      	adds	r3, r7, #7
    a084:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
    a086:	1dfb      	adds	r3, r7, #7
    a088:	781b      	ldrb	r3, [r3, #0]
    a08a:	0018      	movs	r0, r3
    a08c:	4b0a      	ldr	r3, [pc, #40]	; (a0b8 <system_pinmux_pin_set_config+0x40>)
    a08e:	4798      	blx	r3
    a090:	0003      	movs	r3, r0
    a092:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    a094:	1dfb      	adds	r3, r7, #7
    a096:	781b      	ldrb	r3, [r3, #0]
    a098:	221f      	movs	r2, #31
    a09a:	4013      	ands	r3, r2
    a09c:	2201      	movs	r2, #1
    a09e:	409a      	lsls	r2, r3
    a0a0:	0013      	movs	r3, r2
    a0a2:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
    a0a4:	683a      	ldr	r2, [r7, #0]
    a0a6:	68b9      	ldr	r1, [r7, #8]
    a0a8:	68fb      	ldr	r3, [r7, #12]
    a0aa:	0018      	movs	r0, r3
    a0ac:	4b03      	ldr	r3, [pc, #12]	; (a0bc <system_pinmux_pin_set_config+0x44>)
    a0ae:	4798      	blx	r3
}
    a0b0:	46c0      	nop			; (mov r8, r8)
    a0b2:	46bd      	mov	sp, r7
    a0b4:	b004      	add	sp, #16
    a0b6:	bd80      	pop	{r7, pc}
    a0b8:	00009f09 	.word	0x00009f09
    a0bc:	00009f69 	.word	0x00009f69

0000a0c0 <_system_dummy_init>:
 * Dummy initialization function, used as a weak alias target for the various
 * init functions called by \ref system_init().
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
    a0c0:	b580      	push	{r7, lr}
    a0c2:	af00      	add	r7, sp, #0
	return;
    a0c4:	46c0      	nop			; (mov r8, r8)
}
    a0c6:	46bd      	mov	sp, r7
    a0c8:	bd80      	pop	{r7, pc}
    a0ca:	46c0      	nop			; (mov r8, r8)

0000a0cc <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    a0cc:	b580      	push	{r7, lr}
    a0ce:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    a0d0:	4b06      	ldr	r3, [pc, #24]	; (a0ec <system_init+0x20>)
    a0d2:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    a0d4:	4b06      	ldr	r3, [pc, #24]	; (a0f0 <system_init+0x24>)
    a0d6:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    a0d8:	4b06      	ldr	r3, [pc, #24]	; (a0f4 <system_init+0x28>)
    a0da:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    a0dc:	4b06      	ldr	r3, [pc, #24]	; (a0f8 <system_init+0x2c>)
    a0de:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    a0e0:	4b06      	ldr	r3, [pc, #24]	; (a0fc <system_init+0x30>)
    a0e2:	4798      	blx	r3
}
    a0e4:	46c0      	nop			; (mov r8, r8)
    a0e6:	46bd      	mov	sp, r7
    a0e8:	bd80      	pop	{r7, pc}
    a0ea:	46c0      	nop			; (mov r8, r8)
    a0ec:	00009b05 	.word	0x00009b05
    a0f0:	00008341 	.word	0x00008341
    a0f4:	0000a0c1 	.word	0x0000a0c1
    a0f8:	0000a0c1 	.word	0x0000a0c1
    a0fc:	0000a0c1 	.word	0x0000a0c1

0000a100 <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    a100:	b580      	push	{r7, lr}
    a102:	b086      	sub	sp, #24
    a104:	af00      	add	r7, sp, #0
    a106:	60f8      	str	r0, [r7, #12]
    a108:	60b9      	str	r1, [r7, #8]
    a10a:	607a      	str	r2, [r7, #4]
	int nChars = 0;
    a10c:	2300      	movs	r3, #0
    a10e:	617b      	str	r3, [r7, #20]

	if (file != 0) {
    a110:	68fb      	ldr	r3, [r7, #12]
    a112:	2b00      	cmp	r3, #0
    a114:	d012      	beq.n	a13c <_read+0x3c>
		return -1;
    a116:	2301      	movs	r3, #1
    a118:	425b      	negs	r3, r3
    a11a:	e013      	b.n	a144 <_read+0x44>
	}

	for (; len > 0; --len) {
		ptr_get(stdio_base, ptr);
    a11c:	4b0b      	ldr	r3, [pc, #44]	; (a14c <_read+0x4c>)
    a11e:	681a      	ldr	r2, [r3, #0]
    a120:	4b0b      	ldr	r3, [pc, #44]	; (a150 <_read+0x50>)
    a122:	681b      	ldr	r3, [r3, #0]
    a124:	68b9      	ldr	r1, [r7, #8]
    a126:	0018      	movs	r0, r3
    a128:	4790      	blx	r2
		ptr++;
    a12a:	68bb      	ldr	r3, [r7, #8]
    a12c:	3301      	adds	r3, #1
    a12e:	60bb      	str	r3, [r7, #8]
		nChars++;
    a130:	697b      	ldr	r3, [r7, #20]
    a132:	3301      	adds	r3, #1
    a134:	617b      	str	r3, [r7, #20]

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    a136:	687b      	ldr	r3, [r7, #4]
    a138:	3b01      	subs	r3, #1
    a13a:	607b      	str	r3, [r7, #4]
    a13c:	687b      	ldr	r3, [r7, #4]
    a13e:	2b00      	cmp	r3, #0
    a140:	dcec      	bgt.n	a11c <_read+0x1c>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
    a142:	697b      	ldr	r3, [r7, #20]
}
    a144:	0018      	movs	r0, r3
    a146:	46bd      	mov	sp, r7
    a148:	b006      	add	sp, #24
    a14a:	bd80      	pop	{r7, pc}
    a14c:	200000ec 	.word	0x200000ec
    a150:	200000f4 	.word	0x200000f4

0000a154 <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    a154:	b580      	push	{r7, lr}
    a156:	b086      	sub	sp, #24
    a158:	af00      	add	r7, sp, #0
    a15a:	60f8      	str	r0, [r7, #12]
    a15c:	60b9      	str	r1, [r7, #8]
    a15e:	607a      	str	r2, [r7, #4]
	int nChars = 0;
    a160:	2300      	movs	r3, #0
    a162:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
    a164:	68fb      	ldr	r3, [r7, #12]
    a166:	2b01      	cmp	r3, #1
    a168:	d01d      	beq.n	a1a6 <_write+0x52>
    a16a:	68fb      	ldr	r3, [r7, #12]
    a16c:	2b02      	cmp	r3, #2
    a16e:	d01a      	beq.n	a1a6 <_write+0x52>
    a170:	68fb      	ldr	r3, [r7, #12]
    a172:	2b03      	cmp	r3, #3
    a174:	d017      	beq.n	a1a6 <_write+0x52>
		return -1;
    a176:	2301      	movs	r3, #1
    a178:	425b      	negs	r3, r3
    a17a:	e018      	b.n	a1ae <_write+0x5a>
	}

	for (; len != 0; --len) {
		if (ptr_put(stdio_base, *ptr++) < 0) {
    a17c:	4b0e      	ldr	r3, [pc, #56]	; (a1b8 <_write+0x64>)
    a17e:	681a      	ldr	r2, [r3, #0]
    a180:	4b0e      	ldr	r3, [pc, #56]	; (a1bc <_write+0x68>)
    a182:	6818      	ldr	r0, [r3, #0]
    a184:	68bb      	ldr	r3, [r7, #8]
    a186:	1c59      	adds	r1, r3, #1
    a188:	60b9      	str	r1, [r7, #8]
    a18a:	781b      	ldrb	r3, [r3, #0]
    a18c:	0019      	movs	r1, r3
    a18e:	4790      	blx	r2
    a190:	1e03      	subs	r3, r0, #0
    a192:	da02      	bge.n	a19a <_write+0x46>
			return -1;
    a194:	2301      	movs	r3, #1
    a196:	425b      	negs	r3, r3
    a198:	e009      	b.n	a1ae <_write+0x5a>
		}
		++nChars;
    a19a:	697b      	ldr	r3, [r7, #20]
    a19c:	3301      	adds	r3, #1
    a19e:	617b      	str	r3, [r7, #20]

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    a1a0:	687b      	ldr	r3, [r7, #4]
    a1a2:	3b01      	subs	r3, #1
    a1a4:	607b      	str	r3, [r7, #4]
    a1a6:	687b      	ldr	r3, [r7, #4]
    a1a8:	2b00      	cmp	r3, #0
    a1aa:	d1e7      	bne.n	a17c <_write+0x28>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
	}
	return nChars;
    a1ac:	697b      	ldr	r3, [r7, #20]
}
    a1ae:	0018      	movs	r0, r3
    a1b0:	46bd      	mov	sp, r7
    a1b2:	b006      	add	sp, #24
    a1b4:	bd80      	pop	{r7, pc}
    a1b6:	46c0      	nop			; (mov r8, r8)
    a1b8:	200000f0 	.word	0x200000f0
    a1bc:	200000f4 	.word	0x200000f4

0000a1c0 <NVIC_SystemReset>:
/** \brief  System Reset

    The function initiates a system reset request to reset the MCU.
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
    a1c0:	b580      	push	{r7, lr}
    a1c2:	af00      	add	r7, sp, #0
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
    a1c4:	f3bf 8f4f 	dsb	sy
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
    a1c8:	4b02      	ldr	r3, [pc, #8]	; (a1d4 <NVIC_SystemReset+0x14>)
    a1ca:	4a03      	ldr	r2, [pc, #12]	; (a1d8 <NVIC_SystemReset+0x18>)
    a1cc:	60da      	str	r2, [r3, #12]
    a1ce:	f3bf 8f4f 	dsb	sy
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                     /* Ensure completion of memory access */
  while(1);                                                    /* wait until reset */
    a1d2:	e7fe      	b.n	a1d2 <NVIC_SystemReset+0x12>
    a1d4:	e000ed00 	.word	0xe000ed00
    a1d8:	05fa0004 	.word	0x05fa0004

0000a1dc <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    a1dc:	b580      	push	{r7, lr}
    a1de:	b084      	sub	sp, #16
    a1e0:	af00      	add	r7, sp, #0
    a1e2:	0002      	movs	r2, r0
    a1e4:	1dfb      	adds	r3, r7, #7
    a1e6:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    a1e8:	230f      	movs	r3, #15
    a1ea:	18fb      	adds	r3, r7, r3
    a1ec:	1dfa      	adds	r2, r7, #7
    a1ee:	7812      	ldrb	r2, [r2, #0]
    a1f0:	09d2      	lsrs	r2, r2, #7
    a1f2:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    a1f4:	230e      	movs	r3, #14
    a1f6:	18fb      	adds	r3, r7, r3
    a1f8:	1dfa      	adds	r2, r7, #7
    a1fa:	7812      	ldrb	r2, [r2, #0]
    a1fc:	0952      	lsrs	r2, r2, #5
    a1fe:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    a200:	4b0d      	ldr	r3, [pc, #52]	; (a238 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    a202:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    a204:	230f      	movs	r3, #15
    a206:	18fb      	adds	r3, r7, r3
    a208:	781b      	ldrb	r3, [r3, #0]
    a20a:	2b00      	cmp	r3, #0
    a20c:	d10f      	bne.n	a22e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    a20e:	230f      	movs	r3, #15
    a210:	18fb      	adds	r3, r7, r3
    a212:	781b      	ldrb	r3, [r3, #0]
    a214:	009b      	lsls	r3, r3, #2
    a216:	2210      	movs	r2, #16
    a218:	4694      	mov	ip, r2
    a21a:	44bc      	add	ip, r7
    a21c:	4463      	add	r3, ip
    a21e:	3b08      	subs	r3, #8
    a220:	681a      	ldr	r2, [r3, #0]
    a222:	230e      	movs	r3, #14
    a224:	18fb      	adds	r3, r7, r3
    a226:	781b      	ldrb	r3, [r3, #0]
    a228:	01db      	lsls	r3, r3, #7
    a22a:	18d3      	adds	r3, r2, r3
    a22c:	e000      	b.n	a230 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    a22e:	2300      	movs	r3, #0
	}
}
    a230:	0018      	movs	r0, r3
    a232:	46bd      	mov	sp, r7
    a234:	b004      	add	sp, #16
    a236:	bd80      	pop	{r7, pc}
    a238:	41004400 	.word	0x41004400

0000a23c <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    a23c:	b580      	push	{r7, lr}
    a23e:	b082      	sub	sp, #8
    a240:	af00      	add	r7, sp, #0
    a242:	0002      	movs	r2, r0
    a244:	1dfb      	adds	r3, r7, #7
    a246:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    a248:	1dfb      	adds	r3, r7, #7
    a24a:	781b      	ldrb	r3, [r3, #0]
    a24c:	0018      	movs	r0, r3
    a24e:	4b03      	ldr	r3, [pc, #12]	; (a25c <port_get_group_from_gpio_pin+0x20>)
    a250:	4798      	blx	r3
    a252:	0003      	movs	r3, r0
}
    a254:	0018      	movs	r0, r3
    a256:	46bd      	mov	sp, r7
    a258:	b002      	add	sp, #8
    a25a:	bd80      	pop	{r7, pc}
    a25c:	0000a1dd 	.word	0x0000a1dd

0000a260 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    a260:	b580      	push	{r7, lr}
    a262:	b082      	sub	sp, #8
    a264:	af00      	add	r7, sp, #0
    a266:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    a268:	687b      	ldr	r3, [r7, #4]
    a26a:	2200      	movs	r2, #0
    a26c:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    a26e:	687b      	ldr	r3, [r7, #4]
    a270:	2201      	movs	r2, #1
    a272:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    a274:	687b      	ldr	r3, [r7, #4]
    a276:	2200      	movs	r2, #0
    a278:	709a      	strb	r2, [r3, #2]
}
    a27a:	46c0      	nop			; (mov r8, r8)
    a27c:	46bd      	mov	sp, r7
    a27e:	b002      	add	sp, #8
    a280:	bd80      	pop	{r7, pc}
    a282:	46c0      	nop			; (mov r8, r8)

0000a284 <port_pin_get_input_level>:
 *
 *  \return Status of the port pin's input buffer.
 */
static inline bool port_pin_get_input_level(
		const uint8_t gpio_pin)
{
    a284:	b580      	push	{r7, lr}
    a286:	b084      	sub	sp, #16
    a288:	af00      	add	r7, sp, #0
    a28a:	0002      	movs	r2, r0
    a28c:	1dfb      	adds	r3, r7, #7
    a28e:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    a290:	1dfb      	adds	r3, r7, #7
    a292:	781b      	ldrb	r3, [r3, #0]
    a294:	0018      	movs	r0, r3
    a296:	4b0b      	ldr	r3, [pc, #44]	; (a2c4 <port_pin_get_input_level+0x40>)
    a298:	4798      	blx	r3
    a29a:	0003      	movs	r3, r0
    a29c:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    a29e:	1dfb      	adds	r3, r7, #7
    a2a0:	781b      	ldrb	r3, [r3, #0]
    a2a2:	221f      	movs	r2, #31
    a2a4:	4013      	ands	r3, r2
    a2a6:	2201      	movs	r2, #1
    a2a8:	409a      	lsls	r2, r3
    a2aa:	0013      	movs	r3, r2
    a2ac:	60bb      	str	r3, [r7, #8]

	return (port_base->IN.reg & pin_mask);
    a2ae:	68fb      	ldr	r3, [r7, #12]
    a2b0:	6a1b      	ldr	r3, [r3, #32]
    a2b2:	68ba      	ldr	r2, [r7, #8]
    a2b4:	4013      	ands	r3, r2
    a2b6:	1e5a      	subs	r2, r3, #1
    a2b8:	4193      	sbcs	r3, r2
    a2ba:	b2db      	uxtb	r3, r3
}
    a2bc:	0018      	movs	r0, r3
    a2be:	46bd      	mov	sp, r7
    a2c0:	b004      	add	sp, #16
    a2c2:	bd80      	pop	{r7, pc}
    a2c4:	0000a23d 	.word	0x0000a23d

0000a2c8 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    a2c8:	b580      	push	{r7, lr}
    a2ca:	b084      	sub	sp, #16
    a2cc:	af00      	add	r7, sp, #0
    a2ce:	0002      	movs	r2, r0
    a2d0:	1dfb      	adds	r3, r7, #7
    a2d2:	701a      	strb	r2, [r3, #0]
    a2d4:	1dbb      	adds	r3, r7, #6
    a2d6:	1c0a      	adds	r2, r1, #0
    a2d8:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    a2da:	1dfb      	adds	r3, r7, #7
    a2dc:	781b      	ldrb	r3, [r3, #0]
    a2de:	0018      	movs	r0, r3
    a2e0:	4b0d      	ldr	r3, [pc, #52]	; (a318 <port_pin_set_output_level+0x50>)
    a2e2:	4798      	blx	r3
    a2e4:	0003      	movs	r3, r0
    a2e6:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    a2e8:	1dfb      	adds	r3, r7, #7
    a2ea:	781b      	ldrb	r3, [r3, #0]
    a2ec:	221f      	movs	r2, #31
    a2ee:	4013      	ands	r3, r2
    a2f0:	2201      	movs	r2, #1
    a2f2:	409a      	lsls	r2, r3
    a2f4:	0013      	movs	r3, r2
    a2f6:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    a2f8:	1dbb      	adds	r3, r7, #6
    a2fa:	781b      	ldrb	r3, [r3, #0]
    a2fc:	2b00      	cmp	r3, #0
    a2fe:	d003      	beq.n	a308 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    a300:	68fb      	ldr	r3, [r7, #12]
    a302:	68ba      	ldr	r2, [r7, #8]
    a304:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    a306:	e002      	b.n	a30e <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    a308:	68fb      	ldr	r3, [r7, #12]
    a30a:	68ba      	ldr	r2, [r7, #8]
    a30c:	615a      	str	r2, [r3, #20]
	}
}
    a30e:	46c0      	nop			; (mov r8, r8)
    a310:	46bd      	mov	sp, r7
    a312:	b004      	add	sp, #16
    a314:	bd80      	pop	{r7, pc}
    a316:	46c0      	nop			; (mov r8, r8)
    a318:	0000a23d 	.word	0x0000a23d

0000a31c <system_reset>:
 * Resets the MCU and all associated peripherals and registers, except RTC, all 32KHz sources,
 * WDT (if ALWAYSON is set) and GCLK (if WRTLOCK is set).
 *
 */
static inline void system_reset(void)
{
    a31c:	b580      	push	{r7, lr}
    a31e:	af00      	add	r7, sp, #0
	NVIC_SystemReset();
    a320:	4b02      	ldr	r3, [pc, #8]	; (a32c <system_reset+0x10>)
    a322:	4798      	blx	r3
}
    a324:	46c0      	nop			; (mov r8, r8)
    a326:	46bd      	mov	sp, r7
    a328:	bd80      	pop	{r7, pc}
    a32a:	46c0      	nop			; (mov r8, r8)
    a32c:	0000a1c1 	.word	0x0000a1c1

0000a330 <writeFWStat>:
	config.manual_page_write = false;
	nvm_set_config(&config);
}

static void writeFWStat(Firmware_Status_t thisFW)
{
    a330:	b590      	push	{r4, r7, lr}
    a332:	b095      	sub	sp, #84	; 0x54
    a334:	af00      	add	r7, sp, #0
    a336:	003b      	movs	r3, r7
    a338:	6018      	str	r0, [r3, #0]
    a33a:	6059      	str	r1, [r3, #4]
	uint8_t page_buffer[NVMCTRL_PAGE_SIZE]={0};
    a33c:	230c      	movs	r3, #12
    a33e:	18fb      	adds	r3, r7, r3
    a340:	0018      	movs	r0, r3
    a342:	2340      	movs	r3, #64	; 0x40
    a344:	001a      	movs	r2, r3
    a346:	2100      	movs	r1, #0
    a348:	4b23      	ldr	r3, [pc, #140]	; (a3d8 <writeFWStat+0xa8>)
    a34a:	4798      	blx	r3
	page_buffer[0] = thisFW.signature[0];
    a34c:	003b      	movs	r3, r7
    a34e:	781a      	ldrb	r2, [r3, #0]
    a350:	230c      	movs	r3, #12
    a352:	18fb      	adds	r3, r7, r3
    a354:	701a      	strb	r2, [r3, #0]
	page_buffer[1] = thisFW.signature[1];
    a356:	003b      	movs	r3, r7
    a358:	785a      	ldrb	r2, [r3, #1]
    a35a:	230c      	movs	r3, #12
    a35c:	18fb      	adds	r3, r7, r3
    a35e:	705a      	strb	r2, [r3, #1]
	page_buffer[2] = thisFW.signature[2];
    a360:	003b      	movs	r3, r7
    a362:	789a      	ldrb	r2, [r3, #2]
    a364:	230c      	movs	r3, #12
    a366:	18fb      	adds	r3, r7, r3
    a368:	709a      	strb	r2, [r3, #2]
	page_buffer[3] = thisFW.signature[3];
    a36a:	003b      	movs	r3, r7
    a36c:	78da      	ldrb	r2, [r3, #3]
    a36e:	230c      	movs	r3, #12
    a370:	18fb      	adds	r3, r7, r3
    a372:	70da      	strb	r2, [r3, #3]
	page_buffer[4] = thisFW.executing_image;
    a374:	003b      	movs	r3, r7
    a376:	791a      	ldrb	r2, [r3, #4]
    a378:	230c      	movs	r3, #12
    a37a:	18fb      	adds	r3, r7, r3
    a37c:	711a      	strb	r2, [r3, #4]
	page_buffer[5] = thisFW.downloaded_image;
    a37e:	003b      	movs	r3, r7
    a380:	795a      	ldrb	r2, [r3, #5]
    a382:	230c      	movs	r3, #12
    a384:	18fb      	adds	r3, r7, r3
    a386:	715a      	strb	r2, [r3, #5]
	page_buffer[6] = thisFW.writenew_image;
    a388:	003b      	movs	r3, r7
    a38a:	799a      	ldrb	r2, [r3, #6]
    a38c:	230c      	movs	r3, #12
    a38e:	18fb      	adds	r3, r7, r3
    a390:	719a      	strb	r2, [r3, #6]
	
	status_code_genare_t error_code;
	do
	{
		error_code = nvm_erase_row(FW_STAT_ADDRESS);			// Erase FW stat row
    a392:	234f      	movs	r3, #79	; 0x4f
    a394:	18fc      	adds	r4, r7, r3
    a396:	23fe      	movs	r3, #254	; 0xfe
    a398:	01db      	lsls	r3, r3, #7
    a39a:	0018      	movs	r0, r3
    a39c:	4b0f      	ldr	r3, [pc, #60]	; (a3dc <writeFWStat+0xac>)
    a39e:	4798      	blx	r3
    a3a0:	0003      	movs	r3, r0
    a3a2:	7023      	strb	r3, [r4, #0]
	} while (error_code == STATUS_BUSY);
    a3a4:	234f      	movs	r3, #79	; 0x4f
    a3a6:	18fb      	adds	r3, r7, r3
    a3a8:	781b      	ldrb	r3, [r3, #0]
    a3aa:	2b05      	cmp	r3, #5
    a3ac:	d0f1      	beq.n	a392 <writeFWStat+0x62>
	
	do
	{
		error_code = nvm_write_buffer(FW_STAT_ADDRESS, page_buffer, NVMCTRL_PAGE_SIZE);	// Write buffer to FW_STAT page
    a3ae:	234f      	movs	r3, #79	; 0x4f
    a3b0:	18fc      	adds	r4, r7, r3
    a3b2:	230c      	movs	r3, #12
    a3b4:	18f9      	adds	r1, r7, r3
    a3b6:	23fe      	movs	r3, #254	; 0xfe
    a3b8:	01db      	lsls	r3, r3, #7
    a3ba:	2240      	movs	r2, #64	; 0x40
    a3bc:	0018      	movs	r0, r3
    a3be:	4b08      	ldr	r3, [pc, #32]	; (a3e0 <writeFWStat+0xb0>)
    a3c0:	4798      	blx	r3
    a3c2:	0003      	movs	r3, r0
    a3c4:	7023      	strb	r3, [r4, #0]
	} while (error_code == STATUS_BUSY);
    a3c6:	234f      	movs	r3, #79	; 0x4f
    a3c8:	18fb      	adds	r3, r7, r3
    a3ca:	781b      	ldrb	r3, [r3, #0]
    a3cc:	2b05      	cmp	r3, #5
    a3ce:	d0ee      	beq.n	a3ae <writeFWStat+0x7e>
}
    a3d0:	46c0      	nop			; (mov r8, r8)
    a3d2:	46bd      	mov	sp, r7
    a3d4:	b015      	add	sp, #84	; 0x54
    a3d6:	bd90      	pop	{r4, r7, pc}
    a3d8:	0000a5a7 	.word	0x0000a5a7
    a3dc:	000092c5 	.word	0x000092c5
    a3e0:	00009179 	.word	0x00009179

0000a3e4 <configure_port_pins>:
void configure_port_pins(void)
{
    a3e4:	b580      	push	{r7, lr}
    a3e6:	b082      	sub	sp, #8
    a3e8:	af00      	add	r7, sp, #0
	struct port_config config_port_pin;
	port_get_config_defaults(&config_port_pin);
    a3ea:	1d3b      	adds	r3, r7, #4
    a3ec:	0018      	movs	r0, r3
    a3ee:	4b0b      	ldr	r3, [pc, #44]	; (a41c <configure_port_pins+0x38>)
    a3f0:	4798      	blx	r3
	config_port_pin.direction = PORT_PIN_DIR_OUTPUT;
    a3f2:	1d3b      	adds	r3, r7, #4
    a3f4:	2201      	movs	r2, #1
    a3f6:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(LED_0_PIN, &config_port_pin);
    a3f8:	1d3b      	adds	r3, r7, #4
    a3fa:	0019      	movs	r1, r3
    a3fc:	2017      	movs	r0, #23
    a3fe:	4b08      	ldr	r3, [pc, #32]	; (a420 <configure_port_pins+0x3c>)
    a400:	4798      	blx	r3
	config_port_pin.direction = PORT_PIN_DIR_INPUT;
    a402:	1d3b      	adds	r3, r7, #4
    a404:	2200      	movs	r2, #0
    a406:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(B1, &config_port_pin);
    a408:	1d3b      	adds	r3, r7, #4
    a40a:	0019      	movs	r1, r3
    a40c:	2037      	movs	r0, #55	; 0x37
    a40e:	4b04      	ldr	r3, [pc, #16]	; (a420 <configure_port_pins+0x3c>)
    a410:	4798      	blx	r3
}
    a412:	46c0      	nop			; (mov r8, r8)
    a414:	46bd      	mov	sp, r7
    a416:	b002      	add	sp, #8
    a418:	bd80      	pop	{r7, pc}
    a41a:	46c0      	nop			; (mov r8, r8)
    a41c:	0000a261 	.word	0x0000a261
    a420:	00009395 	.word	0x00009395

0000a424 <download_firmware>:
	at25dfx_chip_config.cs_pin = AT25DFX_CS;
	at25dfx_chip_init(&at25dfx_chip, &at25dfx_spi, &at25dfx_chip_config);
}

static void download_firmware()
{
    a424:	b5b0      	push	{r4, r5, r7, lr}
    a426:	af00      	add	r7, sp, #0
	at25dfx_chip_wake(&at25dfx_chip);
    a428:	4b18      	ldr	r3, [pc, #96]	; (a48c <download_firmware+0x68>)
    a42a:	0018      	movs	r0, r3
    a42c:	4b18      	ldr	r3, [pc, #96]	; (a490 <download_firmware+0x6c>)
    a42e:	4798      	blx	r3

	if (at25dfx_chip_check_presence(&at25dfx_chip) != STATUS_OK)
    a430:	4b16      	ldr	r3, [pc, #88]	; (a48c <download_firmware+0x68>)
    a432:	0018      	movs	r0, r3
    a434:	4b17      	ldr	r3, [pc, #92]	; (a494 <download_firmware+0x70>)
    a436:	4798      	blx	r3
    a438:	1e03      	subs	r3, r0, #0
    a43a:	d004      	beq.n	a446 <download_firmware+0x22>
	{
		printf("Flash Chip did not respond. Download failed !\n");
    a43c:	4b16      	ldr	r3, [pc, #88]	; (a498 <download_firmware+0x74>)
    a43e:	0018      	movs	r0, r3
    a440:	4b16      	ldr	r3, [pc, #88]	; (a49c <download_firmware+0x78>)
    a442:	4798      	blx	r3
		return;
    a444:	e01f      	b.n	a486 <download_firmware+0x62>
	}
	// 		.......CALL HTTP DOWNLOADER................ 
	at25dfx_chip_set_global_sector_protect(&at25dfx_chip, false);				// unprotect sector
    a446:	4b11      	ldr	r3, [pc, #68]	; (a48c <download_firmware+0x68>)
    a448:	2100      	movs	r1, #0
    a44a:	0018      	movs	r0, r3
    a44c:	4b14      	ldr	r3, [pc, #80]	; (a4a0 <download_firmware+0x7c>)
    a44e:	4798      	blx	r3
	at25dfx_chip_erase_block(&at25dfx_chip, 0x00000, AT25DFX_BLOCK_SIZE_4KB);	// erase block
    a450:	4b0e      	ldr	r3, [pc, #56]	; (a48c <download_firmware+0x68>)
    a452:	2200      	movs	r2, #0
    a454:	2100      	movs	r1, #0
    a456:	0018      	movs	r0, r3
    a458:	4b12      	ldr	r3, [pc, #72]	; (a4a4 <download_firmware+0x80>)
    a45a:	4798      	blx	r3
	at25dfx_chip_write_buffer(&at25dfx_chip, 0x00000, write_buffer, AT25DFX_BUFFER_SIZE);	// write buffer
    a45c:	4a12      	ldr	r2, [pc, #72]	; (a4a8 <download_firmware+0x84>)
    a45e:	480b      	ldr	r0, [pc, #44]	; (a48c <download_firmware+0x68>)
    a460:	230a      	movs	r3, #10
    a462:	2100      	movs	r1, #0
    a464:	4c11      	ldr	r4, [pc, #68]	; (a4ac <download_firmware+0x88>)
    a466:	47a0      	blx	r4
	at25dfx_chip_read_buffer(&at25dfx_chip, 0x00000, read_buffer, AT25DFX_BUFFER_SIZE);		// read same location
    a468:	4a11      	ldr	r2, [pc, #68]	; (a4b0 <download_firmware+0x8c>)
    a46a:	4808      	ldr	r0, [pc, #32]	; (a48c <download_firmware+0x68>)
    a46c:	230a      	movs	r3, #10
    a46e:	2100      	movs	r1, #0
    a470:	4c10      	ldr	r4, [pc, #64]	; (a4b4 <download_firmware+0x90>)
    a472:	47a0      	blx	r4
	at25dfx_chip_set_global_sector_protect(&at25dfx_chip, true);				// protect sector
    a474:	4b05      	ldr	r3, [pc, #20]	; (a48c <download_firmware+0x68>)
    a476:	2101      	movs	r1, #1
    a478:	0018      	movs	r0, r3
    a47a:	4b09      	ldr	r3, [pc, #36]	; (a4a0 <download_firmware+0x7c>)
    a47c:	4798      	blx	r3
	at25dfx_chip_sleep(&at25dfx_chip);
    a47e:	4b03      	ldr	r3, [pc, #12]	; (a48c <download_firmware+0x68>)
    a480:	0018      	movs	r0, r3
    a482:	4b0d      	ldr	r3, [pc, #52]	; (a4b8 <download_firmware+0x94>)
    a484:	4798      	blx	r3
}
    a486:	46bd      	mov	sp, r7
    a488:	bdb0      	pop	{r4, r5, r7, pc}
    a48a:	46c0      	nop			; (mov r8, r8)
    a48c:	2000012c 	.word	0x2000012c
    a490:	00008fad 	.word	0x00008fad
    a494:	00008a65 	.word	0x00008a65
    a498:	0000b068 	.word	0x0000b068
    a49c:	0000a67d 	.word	0x0000a67d
    a4a0:	00008e6d 	.word	0x00008e6d
    a4a4:	00008d71 	.word	0x00008d71
    a4a8:	20000004 	.word	0x20000004
    a4ac:	00008bc9 	.word	0x00008bc9
    a4b0:	200000d8 	.word	0x200000d8
    a4b4:	00008b11 	.word	0x00008b11
    a4b8:	00008f21 	.word	0x00008f21

0000a4bc <main>:

int main (void)
{
    a4bc:	b580      	push	{r7, lr}
    a4be:	b082      	sub	sp, #8
    a4c0:	af00      	add	r7, sp, #0
	system_init();
    a4c2:	4b17      	ldr	r3, [pc, #92]	; (a520 <main+0x64>)
    a4c4:	4798      	blx	r3
	//system_interrupt_enable_global();
	configure_port_pins();
    a4c6:	4b17      	ldr	r3, [pc, #92]	; (a524 <main+0x68>)
    a4c8:	4798      	blx	r3
	//configure_nvm();
	//configure_spi_flash();
	//printf("app started\n");
	while (1) 
	{
		if (port_pin_get_input_level(B1) == true) {
    a4ca:	2037      	movs	r0, #55	; 0x37
    a4cc:	4b16      	ldr	r3, [pc, #88]	; (a528 <main+0x6c>)
    a4ce:	4798      	blx	r3
    a4d0:	1e03      	subs	r3, r0, #0
    a4d2:	d004      	beq.n	a4de <main+0x22>
			port_pin_set_output_level(LED_0_PIN, false);
    a4d4:	2100      	movs	r1, #0
    a4d6:	2017      	movs	r0, #23
    a4d8:	4b14      	ldr	r3, [pc, #80]	; (a52c <main+0x70>)
    a4da:	4798      	blx	r3
    a4dc:	e003      	b.n	a4e6 <main+0x2a>
		}
		else 
		{
			port_pin_set_output_level(LED_0_PIN, true);
    a4de:	2101      	movs	r1, #1
    a4e0:	2017      	movs	r0, #23
    a4e2:	4b12      	ldr	r3, [pc, #72]	; (a52c <main+0x70>)
    a4e4:	4798      	blx	r3
		}
		
		// receive command from IBM BlueMix
		//....................
		write_firmware = false; //set this to true
    a4e6:	4b12      	ldr	r3, [pc, #72]	; (a530 <main+0x74>)
    a4e8:	2200      	movs	r2, #0
    a4ea:	701a      	strb	r2, [r3, #0]
		//write the updated status
		if(write_firmware)
    a4ec:	4b10      	ldr	r3, [pc, #64]	; (a530 <main+0x74>)
    a4ee:	781b      	ldrb	r3, [r3, #0]
    a4f0:	2b00      	cmp	r3, #0
    a4f2:	d0ea      	beq.n	a4ca <main+0xe>
		{
			// download firmware into serial flash and upgrade
			download_firmware();
    a4f4:	4b0f      	ldr	r3, [pc, #60]	; (a534 <main+0x78>)
    a4f6:	4798      	blx	r3
			Firmware_Status_t fw_status = *(Firmware_Status_t*)FW_STAT_ADDRESS;
    a4f8:	23fe      	movs	r3, #254	; 0xfe
    a4fa:	01db      	lsls	r3, r3, #7
    a4fc:	003a      	movs	r2, r7
    a4fe:	0010      	movs	r0, r2
    a500:	0019      	movs	r1, r3
    a502:	2307      	movs	r3, #7
    a504:	001a      	movs	r2, r3
    a506:	4b0c      	ldr	r3, [pc, #48]	; (a538 <main+0x7c>)
    a508:	4798      	blx	r3
			*(uint32_t*)fw_status.signature = 0xEFBEADDE; //replace with checksum of downloaded image
    a50a:	003b      	movs	r3, r7
    a50c:	4a0b      	ldr	r2, [pc, #44]	; (a53c <main+0x80>)
    a50e:	601a      	str	r2, [r3, #0]
// 			fw_status.downloaded_image = fill version for downloaded image
// 			fw_status.writenew_image = 0xFF;  // write image flag
			writeFWStat(fw_status);
    a510:	003b      	movs	r3, r7
    a512:	6818      	ldr	r0, [r3, #0]
    a514:	6859      	ldr	r1, [r3, #4]
    a516:	4b0a      	ldr	r3, [pc, #40]	; (a540 <main+0x84>)
    a518:	4798      	blx	r3
			// reset to begin writing firmware
			system_reset();
    a51a:	4b0a      	ldr	r3, [pc, #40]	; (a544 <main+0x88>)
    a51c:	4798      	blx	r3
		}
	}	
    a51e:	e7d4      	b.n	a4ca <main+0xe>
    a520:	0000a0cd 	.word	0x0000a0cd
    a524:	0000a3e5 	.word	0x0000a3e5
    a528:	0000a285 	.word	0x0000a285
    a52c:	0000a2c9 	.word	0x0000a2c9
    a530:	200000d4 	.word	0x200000d4
    a534:	0000a425 	.word	0x0000a425
    a538:	0000a595 	.word	0x0000a595
    a53c:	efbeadde 	.word	0xefbeadde
    a540:	0000a331 	.word	0x0000a331
    a544:	0000a31d 	.word	0x0000a31d

0000a548 <__libc_init_array>:
    a548:	4b0e      	ldr	r3, [pc, #56]	; (a584 <__libc_init_array+0x3c>)
    a54a:	b570      	push	{r4, r5, r6, lr}
    a54c:	2500      	movs	r5, #0
    a54e:	001e      	movs	r6, r3
    a550:	4c0d      	ldr	r4, [pc, #52]	; (a588 <__libc_init_array+0x40>)
    a552:	1ae4      	subs	r4, r4, r3
    a554:	10a4      	asrs	r4, r4, #2
    a556:	42a5      	cmp	r5, r4
    a558:	d004      	beq.n	a564 <__libc_init_array+0x1c>
    a55a:	00ab      	lsls	r3, r5, #2
    a55c:	58f3      	ldr	r3, [r6, r3]
    a55e:	4798      	blx	r3
    a560:	3501      	adds	r5, #1
    a562:	e7f8      	b.n	a556 <__libc_init_array+0xe>
    a564:	f000 fdca 	bl	b0fc <_init>
    a568:	4b08      	ldr	r3, [pc, #32]	; (a58c <__libc_init_array+0x44>)
    a56a:	2500      	movs	r5, #0
    a56c:	001e      	movs	r6, r3
    a56e:	4c08      	ldr	r4, [pc, #32]	; (a590 <__libc_init_array+0x48>)
    a570:	1ae4      	subs	r4, r4, r3
    a572:	10a4      	asrs	r4, r4, #2
    a574:	42a5      	cmp	r5, r4
    a576:	d004      	beq.n	a582 <__libc_init_array+0x3a>
    a578:	00ab      	lsls	r3, r5, #2
    a57a:	58f3      	ldr	r3, [r6, r3]
    a57c:	4798      	blx	r3
    a57e:	3501      	adds	r5, #1
    a580:	e7f8      	b.n	a574 <__libc_init_array+0x2c>
    a582:	bd70      	pop	{r4, r5, r6, pc}
    a584:	0000b108 	.word	0x0000b108
    a588:	0000b108 	.word	0x0000b108
    a58c:	0000b108 	.word	0x0000b108
    a590:	0000b10c 	.word	0x0000b10c

0000a594 <memcpy>:
    a594:	2300      	movs	r3, #0
    a596:	b510      	push	{r4, lr}
    a598:	429a      	cmp	r2, r3
    a59a:	d003      	beq.n	a5a4 <memcpy+0x10>
    a59c:	5ccc      	ldrb	r4, [r1, r3]
    a59e:	54c4      	strb	r4, [r0, r3]
    a5a0:	3301      	adds	r3, #1
    a5a2:	e7f9      	b.n	a598 <memcpy+0x4>
    a5a4:	bd10      	pop	{r4, pc}

0000a5a6 <memset>:
    a5a6:	0003      	movs	r3, r0
    a5a8:	1882      	adds	r2, r0, r2
    a5aa:	4293      	cmp	r3, r2
    a5ac:	d002      	beq.n	a5b4 <memset+0xe>
    a5ae:	7019      	strb	r1, [r3, #0]
    a5b0:	3301      	adds	r3, #1
    a5b2:	e7fa      	b.n	a5aa <memset+0x4>
    a5b4:	4770      	bx	lr
	...

0000a5b8 <_puts_r>:
    a5b8:	b570      	push	{r4, r5, r6, lr}
    a5ba:	0005      	movs	r5, r0
    a5bc:	000e      	movs	r6, r1
    a5be:	2800      	cmp	r0, #0
    a5c0:	d004      	beq.n	a5cc <_puts_r+0x14>
    a5c2:	6983      	ldr	r3, [r0, #24]
    a5c4:	2b00      	cmp	r3, #0
    a5c6:	d101      	bne.n	a5cc <_puts_r+0x14>
    a5c8:	f000 fa24 	bl	aa14 <__sinit>
    a5cc:	69ab      	ldr	r3, [r5, #24]
    a5ce:	68ac      	ldr	r4, [r5, #8]
    a5d0:	2b00      	cmp	r3, #0
    a5d2:	d102      	bne.n	a5da <_puts_r+0x22>
    a5d4:	0028      	movs	r0, r5
    a5d6:	f000 fa1d 	bl	aa14 <__sinit>
    a5da:	4b25      	ldr	r3, [pc, #148]	; (a670 <_puts_r+0xb8>)
    a5dc:	429c      	cmp	r4, r3
    a5de:	d101      	bne.n	a5e4 <_puts_r+0x2c>
    a5e0:	686c      	ldr	r4, [r5, #4]
    a5e2:	e008      	b.n	a5f6 <_puts_r+0x3e>
    a5e4:	4b23      	ldr	r3, [pc, #140]	; (a674 <_puts_r+0xbc>)
    a5e6:	429c      	cmp	r4, r3
    a5e8:	d101      	bne.n	a5ee <_puts_r+0x36>
    a5ea:	68ac      	ldr	r4, [r5, #8]
    a5ec:	e003      	b.n	a5f6 <_puts_r+0x3e>
    a5ee:	4b22      	ldr	r3, [pc, #136]	; (a678 <_puts_r+0xc0>)
    a5f0:	429c      	cmp	r4, r3
    a5f2:	d100      	bne.n	a5f6 <_puts_r+0x3e>
    a5f4:	68ec      	ldr	r4, [r5, #12]
    a5f6:	89a3      	ldrh	r3, [r4, #12]
    a5f8:	071b      	lsls	r3, r3, #28
    a5fa:	d502      	bpl.n	a602 <_puts_r+0x4a>
    a5fc:	6923      	ldr	r3, [r4, #16]
    a5fe:	2b00      	cmp	r3, #0
    a600:	d111      	bne.n	a626 <_puts_r+0x6e>
    a602:	0021      	movs	r1, r4
    a604:	0028      	movs	r0, r5
    a606:	f000 f89b 	bl	a740 <__swsetup_r>
    a60a:	2800      	cmp	r0, #0
    a60c:	d00b      	beq.n	a626 <_puts_r+0x6e>
    a60e:	2001      	movs	r0, #1
    a610:	4240      	negs	r0, r0
    a612:	e02b      	b.n	a66c <_puts_r+0xb4>
    a614:	3b01      	subs	r3, #1
    a616:	3601      	adds	r6, #1
    a618:	60a3      	str	r3, [r4, #8]
    a61a:	2b00      	cmp	r3, #0
    a61c:	db08      	blt.n	a630 <_puts_r+0x78>
    a61e:	6823      	ldr	r3, [r4, #0]
    a620:	1c5a      	adds	r2, r3, #1
    a622:	6022      	str	r2, [r4, #0]
    a624:	7019      	strb	r1, [r3, #0]
    a626:	7831      	ldrb	r1, [r6, #0]
    a628:	68a3      	ldr	r3, [r4, #8]
    a62a:	2900      	cmp	r1, #0
    a62c:	d1f2      	bne.n	a614 <_puts_r+0x5c>
    a62e:	e00b      	b.n	a648 <_puts_r+0x90>
    a630:	69a2      	ldr	r2, [r4, #24]
    a632:	4293      	cmp	r3, r2
    a634:	db01      	blt.n	a63a <_puts_r+0x82>
    a636:	290a      	cmp	r1, #10
    a638:	d1f1      	bne.n	a61e <_puts_r+0x66>
    a63a:	0022      	movs	r2, r4
    a63c:	0028      	movs	r0, r5
    a63e:	f000 f827 	bl	a690 <__swbuf_r>
    a642:	1c43      	adds	r3, r0, #1
    a644:	d1ef      	bne.n	a626 <_puts_r+0x6e>
    a646:	e7e2      	b.n	a60e <_puts_r+0x56>
    a648:	3b01      	subs	r3, #1
    a64a:	60a3      	str	r3, [r4, #8]
    a64c:	2b00      	cmp	r3, #0
    a64e:	da08      	bge.n	a662 <_puts_r+0xaa>
    a650:	0022      	movs	r2, r4
    a652:	310a      	adds	r1, #10
    a654:	0028      	movs	r0, r5
    a656:	f000 f81b 	bl	a690 <__swbuf_r>
    a65a:	1c43      	adds	r3, r0, #1
    a65c:	d0d7      	beq.n	a60e <_puts_r+0x56>
    a65e:	200a      	movs	r0, #10
    a660:	e004      	b.n	a66c <_puts_r+0xb4>
    a662:	200a      	movs	r0, #10
    a664:	6823      	ldr	r3, [r4, #0]
    a666:	1c5a      	adds	r2, r3, #1
    a668:	6022      	str	r2, [r4, #0]
    a66a:	7018      	strb	r0, [r3, #0]
    a66c:	bd70      	pop	{r4, r5, r6, pc}
    a66e:	46c0      	nop			; (mov r8, r8)
    a670:	0000b09c 	.word	0x0000b09c
    a674:	0000b0bc 	.word	0x0000b0bc
    a678:	0000b0dc 	.word	0x0000b0dc

0000a67c <puts>:
    a67c:	b510      	push	{r4, lr}
    a67e:	4b03      	ldr	r3, [pc, #12]	; (a68c <puts+0x10>)
    a680:	0001      	movs	r1, r0
    a682:	6818      	ldr	r0, [r3, #0]
    a684:	f7ff ff98 	bl	a5b8 <_puts_r>
    a688:	bd10      	pop	{r4, pc}
    a68a:	46c0      	nop			; (mov r8, r8)
    a68c:	20000070 	.word	0x20000070

0000a690 <__swbuf_r>:
    a690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    a692:	0005      	movs	r5, r0
    a694:	000f      	movs	r7, r1
    a696:	0014      	movs	r4, r2
    a698:	2800      	cmp	r0, #0
    a69a:	d004      	beq.n	a6a6 <__swbuf_r+0x16>
    a69c:	6983      	ldr	r3, [r0, #24]
    a69e:	2b00      	cmp	r3, #0
    a6a0:	d101      	bne.n	a6a6 <__swbuf_r+0x16>
    a6a2:	f000 f9b7 	bl	aa14 <__sinit>
    a6a6:	4b23      	ldr	r3, [pc, #140]	; (a734 <__swbuf_r+0xa4>)
    a6a8:	429c      	cmp	r4, r3
    a6aa:	d101      	bne.n	a6b0 <__swbuf_r+0x20>
    a6ac:	686c      	ldr	r4, [r5, #4]
    a6ae:	e008      	b.n	a6c2 <__swbuf_r+0x32>
    a6b0:	4b21      	ldr	r3, [pc, #132]	; (a738 <__swbuf_r+0xa8>)
    a6b2:	429c      	cmp	r4, r3
    a6b4:	d101      	bne.n	a6ba <__swbuf_r+0x2a>
    a6b6:	68ac      	ldr	r4, [r5, #8]
    a6b8:	e003      	b.n	a6c2 <__swbuf_r+0x32>
    a6ba:	4b20      	ldr	r3, [pc, #128]	; (a73c <__swbuf_r+0xac>)
    a6bc:	429c      	cmp	r4, r3
    a6be:	d100      	bne.n	a6c2 <__swbuf_r+0x32>
    a6c0:	68ec      	ldr	r4, [r5, #12]
    a6c2:	69a3      	ldr	r3, [r4, #24]
    a6c4:	60a3      	str	r3, [r4, #8]
    a6c6:	89a3      	ldrh	r3, [r4, #12]
    a6c8:	071b      	lsls	r3, r3, #28
    a6ca:	d50a      	bpl.n	a6e2 <__swbuf_r+0x52>
    a6cc:	6923      	ldr	r3, [r4, #16]
    a6ce:	2b00      	cmp	r3, #0
    a6d0:	d007      	beq.n	a6e2 <__swbuf_r+0x52>
    a6d2:	6823      	ldr	r3, [r4, #0]
    a6d4:	6922      	ldr	r2, [r4, #16]
    a6d6:	b2fe      	uxtb	r6, r7
    a6d8:	1a98      	subs	r0, r3, r2
    a6da:	6963      	ldr	r3, [r4, #20]
    a6dc:	4298      	cmp	r0, r3
    a6de:	db0f      	blt.n	a700 <__swbuf_r+0x70>
    a6e0:	e008      	b.n	a6f4 <__swbuf_r+0x64>
    a6e2:	0021      	movs	r1, r4
    a6e4:	0028      	movs	r0, r5
    a6e6:	f000 f82b 	bl	a740 <__swsetup_r>
    a6ea:	2800      	cmp	r0, #0
    a6ec:	d0f1      	beq.n	a6d2 <__swbuf_r+0x42>
    a6ee:	2001      	movs	r0, #1
    a6f0:	4240      	negs	r0, r0
    a6f2:	e01d      	b.n	a730 <__swbuf_r+0xa0>
    a6f4:	0021      	movs	r1, r4
    a6f6:	0028      	movs	r0, r5
    a6f8:	f000 f91e 	bl	a938 <_fflush_r>
    a6fc:	2800      	cmp	r0, #0
    a6fe:	d1f6      	bne.n	a6ee <__swbuf_r+0x5e>
    a700:	68a3      	ldr	r3, [r4, #8]
    a702:	3001      	adds	r0, #1
    a704:	3b01      	subs	r3, #1
    a706:	60a3      	str	r3, [r4, #8]
    a708:	6823      	ldr	r3, [r4, #0]
    a70a:	1c5a      	adds	r2, r3, #1
    a70c:	6022      	str	r2, [r4, #0]
    a70e:	701f      	strb	r7, [r3, #0]
    a710:	6963      	ldr	r3, [r4, #20]
    a712:	4298      	cmp	r0, r3
    a714:	d005      	beq.n	a722 <__swbuf_r+0x92>
    a716:	89a3      	ldrh	r3, [r4, #12]
    a718:	0030      	movs	r0, r6
    a71a:	07db      	lsls	r3, r3, #31
    a71c:	d508      	bpl.n	a730 <__swbuf_r+0xa0>
    a71e:	2e0a      	cmp	r6, #10
    a720:	d106      	bne.n	a730 <__swbuf_r+0xa0>
    a722:	0021      	movs	r1, r4
    a724:	0028      	movs	r0, r5
    a726:	f000 f907 	bl	a938 <_fflush_r>
    a72a:	2800      	cmp	r0, #0
    a72c:	d1df      	bne.n	a6ee <__swbuf_r+0x5e>
    a72e:	0030      	movs	r0, r6
    a730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    a732:	46c0      	nop			; (mov r8, r8)
    a734:	0000b09c 	.word	0x0000b09c
    a738:	0000b0bc 	.word	0x0000b0bc
    a73c:	0000b0dc 	.word	0x0000b0dc

0000a740 <__swsetup_r>:
    a740:	4b36      	ldr	r3, [pc, #216]	; (a81c <__swsetup_r+0xdc>)
    a742:	b570      	push	{r4, r5, r6, lr}
    a744:	681d      	ldr	r5, [r3, #0]
    a746:	0006      	movs	r6, r0
    a748:	000c      	movs	r4, r1
    a74a:	2d00      	cmp	r5, #0
    a74c:	d005      	beq.n	a75a <__swsetup_r+0x1a>
    a74e:	69ab      	ldr	r3, [r5, #24]
    a750:	2b00      	cmp	r3, #0
    a752:	d102      	bne.n	a75a <__swsetup_r+0x1a>
    a754:	0028      	movs	r0, r5
    a756:	f000 f95d 	bl	aa14 <__sinit>
    a75a:	4b31      	ldr	r3, [pc, #196]	; (a820 <__swsetup_r+0xe0>)
    a75c:	429c      	cmp	r4, r3
    a75e:	d101      	bne.n	a764 <__swsetup_r+0x24>
    a760:	686c      	ldr	r4, [r5, #4]
    a762:	e008      	b.n	a776 <__swsetup_r+0x36>
    a764:	4b2f      	ldr	r3, [pc, #188]	; (a824 <__swsetup_r+0xe4>)
    a766:	429c      	cmp	r4, r3
    a768:	d101      	bne.n	a76e <__swsetup_r+0x2e>
    a76a:	68ac      	ldr	r4, [r5, #8]
    a76c:	e003      	b.n	a776 <__swsetup_r+0x36>
    a76e:	4b2e      	ldr	r3, [pc, #184]	; (a828 <__swsetup_r+0xe8>)
    a770:	429c      	cmp	r4, r3
    a772:	d100      	bne.n	a776 <__swsetup_r+0x36>
    a774:	68ec      	ldr	r4, [r5, #12]
    a776:	220c      	movs	r2, #12
    a778:	5ea3      	ldrsh	r3, [r4, r2]
    a77a:	b29a      	uxth	r2, r3
    a77c:	0711      	lsls	r1, r2, #28
    a77e:	d423      	bmi.n	a7c8 <__swsetup_r+0x88>
    a780:	06d1      	lsls	r1, r2, #27
    a782:	d407      	bmi.n	a794 <__swsetup_r+0x54>
    a784:	2209      	movs	r2, #9
    a786:	2001      	movs	r0, #1
    a788:	6032      	str	r2, [r6, #0]
    a78a:	3237      	adds	r2, #55	; 0x37
    a78c:	4313      	orrs	r3, r2
    a78e:	81a3      	strh	r3, [r4, #12]
    a790:	4240      	negs	r0, r0
    a792:	e042      	b.n	a81a <__swsetup_r+0xda>
    a794:	0753      	lsls	r3, r2, #29
    a796:	d513      	bpl.n	a7c0 <__swsetup_r+0x80>
    a798:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a79a:	2900      	cmp	r1, #0
    a79c:	d008      	beq.n	a7b0 <__swsetup_r+0x70>
    a79e:	0023      	movs	r3, r4
    a7a0:	3344      	adds	r3, #68	; 0x44
    a7a2:	4299      	cmp	r1, r3
    a7a4:	d002      	beq.n	a7ac <__swsetup_r+0x6c>
    a7a6:	0030      	movs	r0, r6
    a7a8:	f000 fa2c 	bl	ac04 <_free_r>
    a7ac:	2300      	movs	r3, #0
    a7ae:	6363      	str	r3, [r4, #52]	; 0x34
    a7b0:	2224      	movs	r2, #36	; 0x24
    a7b2:	89a3      	ldrh	r3, [r4, #12]
    a7b4:	4393      	bics	r3, r2
    a7b6:	81a3      	strh	r3, [r4, #12]
    a7b8:	2300      	movs	r3, #0
    a7ba:	6063      	str	r3, [r4, #4]
    a7bc:	6923      	ldr	r3, [r4, #16]
    a7be:	6023      	str	r3, [r4, #0]
    a7c0:	2208      	movs	r2, #8
    a7c2:	89a3      	ldrh	r3, [r4, #12]
    a7c4:	4313      	orrs	r3, r2
    a7c6:	81a3      	strh	r3, [r4, #12]
    a7c8:	6923      	ldr	r3, [r4, #16]
    a7ca:	2b00      	cmp	r3, #0
    a7cc:	d10b      	bne.n	a7e6 <__swsetup_r+0xa6>
    a7ce:	23a0      	movs	r3, #160	; 0xa0
    a7d0:	89a2      	ldrh	r2, [r4, #12]
    a7d2:	009b      	lsls	r3, r3, #2
    a7d4:	4013      	ands	r3, r2
    a7d6:	2280      	movs	r2, #128	; 0x80
    a7d8:	0092      	lsls	r2, r2, #2
    a7da:	4293      	cmp	r3, r2
    a7dc:	d003      	beq.n	a7e6 <__swsetup_r+0xa6>
    a7de:	0021      	movs	r1, r4
    a7e0:	0030      	movs	r0, r6
    a7e2:	f000 f9d1 	bl	ab88 <__smakebuf_r>
    a7e6:	2301      	movs	r3, #1
    a7e8:	89a2      	ldrh	r2, [r4, #12]
    a7ea:	4013      	ands	r3, r2
    a7ec:	d005      	beq.n	a7fa <__swsetup_r+0xba>
    a7ee:	2300      	movs	r3, #0
    a7f0:	60a3      	str	r3, [r4, #8]
    a7f2:	6963      	ldr	r3, [r4, #20]
    a7f4:	425b      	negs	r3, r3
    a7f6:	61a3      	str	r3, [r4, #24]
    a7f8:	e003      	b.n	a802 <__swsetup_r+0xc2>
    a7fa:	0792      	lsls	r2, r2, #30
    a7fc:	d400      	bmi.n	a800 <__swsetup_r+0xc0>
    a7fe:	6963      	ldr	r3, [r4, #20]
    a800:	60a3      	str	r3, [r4, #8]
    a802:	2000      	movs	r0, #0
    a804:	6923      	ldr	r3, [r4, #16]
    a806:	4283      	cmp	r3, r0
    a808:	d107      	bne.n	a81a <__swsetup_r+0xda>
    a80a:	220c      	movs	r2, #12
    a80c:	5ea3      	ldrsh	r3, [r4, r2]
    a80e:	061a      	lsls	r2, r3, #24
    a810:	d503      	bpl.n	a81a <__swsetup_r+0xda>
    a812:	2240      	movs	r2, #64	; 0x40
    a814:	4313      	orrs	r3, r2
    a816:	81a3      	strh	r3, [r4, #12]
    a818:	3801      	subs	r0, #1
    a81a:	bd70      	pop	{r4, r5, r6, pc}
    a81c:	20000070 	.word	0x20000070
    a820:	0000b09c 	.word	0x0000b09c
    a824:	0000b0bc 	.word	0x0000b0bc
    a828:	0000b0dc 	.word	0x0000b0dc

0000a82c <__sflush_r>:
    a82c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    a82e:	898a      	ldrh	r2, [r1, #12]
    a830:	0005      	movs	r5, r0
    a832:	000c      	movs	r4, r1
    a834:	0713      	lsls	r3, r2, #28
    a836:	d45a      	bmi.n	a8ee <__sflush_r+0xc2>
    a838:	684b      	ldr	r3, [r1, #4]
    a83a:	2b00      	cmp	r3, #0
    a83c:	dc02      	bgt.n	a844 <__sflush_r+0x18>
    a83e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    a840:	2b00      	cmp	r3, #0
    a842:	dd19      	ble.n	a878 <__sflush_r+0x4c>
    a844:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    a846:	2f00      	cmp	r7, #0
    a848:	d016      	beq.n	a878 <__sflush_r+0x4c>
    a84a:	2300      	movs	r3, #0
    a84c:	682e      	ldr	r6, [r5, #0]
    a84e:	602b      	str	r3, [r5, #0]
    a850:	2380      	movs	r3, #128	; 0x80
    a852:	015b      	lsls	r3, r3, #5
    a854:	401a      	ands	r2, r3
    a856:	d001      	beq.n	a85c <__sflush_r+0x30>
    a858:	6d60      	ldr	r0, [r4, #84]	; 0x54
    a85a:	e014      	b.n	a886 <__sflush_r+0x5a>
    a85c:	2301      	movs	r3, #1
    a85e:	6a21      	ldr	r1, [r4, #32]
    a860:	0028      	movs	r0, r5
    a862:	47b8      	blx	r7
    a864:	1c43      	adds	r3, r0, #1
    a866:	d10e      	bne.n	a886 <__sflush_r+0x5a>
    a868:	682b      	ldr	r3, [r5, #0]
    a86a:	2b00      	cmp	r3, #0
    a86c:	d00b      	beq.n	a886 <__sflush_r+0x5a>
    a86e:	2b1d      	cmp	r3, #29
    a870:	d001      	beq.n	a876 <__sflush_r+0x4a>
    a872:	2b16      	cmp	r3, #22
    a874:	d102      	bne.n	a87c <__sflush_r+0x50>
    a876:	602e      	str	r6, [r5, #0]
    a878:	2000      	movs	r0, #0
    a87a:	e05a      	b.n	a932 <__sflush_r+0x106>
    a87c:	2240      	movs	r2, #64	; 0x40
    a87e:	89a3      	ldrh	r3, [r4, #12]
    a880:	4313      	orrs	r3, r2
    a882:	81a3      	strh	r3, [r4, #12]
    a884:	e055      	b.n	a932 <__sflush_r+0x106>
    a886:	89a3      	ldrh	r3, [r4, #12]
    a888:	075b      	lsls	r3, r3, #29
    a88a:	d506      	bpl.n	a89a <__sflush_r+0x6e>
    a88c:	6863      	ldr	r3, [r4, #4]
    a88e:	1ac0      	subs	r0, r0, r3
    a890:	6b63      	ldr	r3, [r4, #52]	; 0x34
    a892:	2b00      	cmp	r3, #0
    a894:	d001      	beq.n	a89a <__sflush_r+0x6e>
    a896:	6c23      	ldr	r3, [r4, #64]	; 0x40
    a898:	1ac0      	subs	r0, r0, r3
    a89a:	2300      	movs	r3, #0
    a89c:	0002      	movs	r2, r0
    a89e:	6a21      	ldr	r1, [r4, #32]
    a8a0:	0028      	movs	r0, r5
    a8a2:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    a8a4:	47b8      	blx	r7
    a8a6:	89a3      	ldrh	r3, [r4, #12]
    a8a8:	1c42      	adds	r2, r0, #1
    a8aa:	d106      	bne.n	a8ba <__sflush_r+0x8e>
    a8ac:	6829      	ldr	r1, [r5, #0]
    a8ae:	291d      	cmp	r1, #29
    a8b0:	d83a      	bhi.n	a928 <__sflush_r+0xfc>
    a8b2:	4a20      	ldr	r2, [pc, #128]	; (a934 <__sflush_r+0x108>)
    a8b4:	40ca      	lsrs	r2, r1
    a8b6:	07d2      	lsls	r2, r2, #31
    a8b8:	d536      	bpl.n	a928 <__sflush_r+0xfc>
    a8ba:	2200      	movs	r2, #0
    a8bc:	6062      	str	r2, [r4, #4]
    a8be:	6922      	ldr	r2, [r4, #16]
    a8c0:	6022      	str	r2, [r4, #0]
    a8c2:	04db      	lsls	r3, r3, #19
    a8c4:	d505      	bpl.n	a8d2 <__sflush_r+0xa6>
    a8c6:	1c43      	adds	r3, r0, #1
    a8c8:	d102      	bne.n	a8d0 <__sflush_r+0xa4>
    a8ca:	682b      	ldr	r3, [r5, #0]
    a8cc:	2b00      	cmp	r3, #0
    a8ce:	d100      	bne.n	a8d2 <__sflush_r+0xa6>
    a8d0:	6560      	str	r0, [r4, #84]	; 0x54
    a8d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
    a8d4:	602e      	str	r6, [r5, #0]
    a8d6:	2900      	cmp	r1, #0
    a8d8:	d0ce      	beq.n	a878 <__sflush_r+0x4c>
    a8da:	0023      	movs	r3, r4
    a8dc:	3344      	adds	r3, #68	; 0x44
    a8de:	4299      	cmp	r1, r3
    a8e0:	d002      	beq.n	a8e8 <__sflush_r+0xbc>
    a8e2:	0028      	movs	r0, r5
    a8e4:	f000 f98e 	bl	ac04 <_free_r>
    a8e8:	2000      	movs	r0, #0
    a8ea:	6360      	str	r0, [r4, #52]	; 0x34
    a8ec:	e021      	b.n	a932 <__sflush_r+0x106>
    a8ee:	690f      	ldr	r7, [r1, #16]
    a8f0:	2f00      	cmp	r7, #0
    a8f2:	d0c1      	beq.n	a878 <__sflush_r+0x4c>
    a8f4:	680b      	ldr	r3, [r1, #0]
    a8f6:	600f      	str	r7, [r1, #0]
    a8f8:	1bdb      	subs	r3, r3, r7
    a8fa:	9301      	str	r3, [sp, #4]
    a8fc:	2300      	movs	r3, #0
    a8fe:	0792      	lsls	r2, r2, #30
    a900:	d100      	bne.n	a904 <__sflush_r+0xd8>
    a902:	694b      	ldr	r3, [r1, #20]
    a904:	60a3      	str	r3, [r4, #8]
    a906:	e003      	b.n	a910 <__sflush_r+0xe4>
    a908:	9b01      	ldr	r3, [sp, #4]
    a90a:	183f      	adds	r7, r7, r0
    a90c:	1a1b      	subs	r3, r3, r0
    a90e:	9301      	str	r3, [sp, #4]
    a910:	9b01      	ldr	r3, [sp, #4]
    a912:	2b00      	cmp	r3, #0
    a914:	ddb0      	ble.n	a878 <__sflush_r+0x4c>
    a916:	9b01      	ldr	r3, [sp, #4]
    a918:	003a      	movs	r2, r7
    a91a:	6a21      	ldr	r1, [r4, #32]
    a91c:	0028      	movs	r0, r5
    a91e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    a920:	47b0      	blx	r6
    a922:	2800      	cmp	r0, #0
    a924:	dcf0      	bgt.n	a908 <__sflush_r+0xdc>
    a926:	89a3      	ldrh	r3, [r4, #12]
    a928:	2240      	movs	r2, #64	; 0x40
    a92a:	2001      	movs	r0, #1
    a92c:	4313      	orrs	r3, r2
    a92e:	81a3      	strh	r3, [r4, #12]
    a930:	4240      	negs	r0, r0
    a932:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    a934:	20400001 	.word	0x20400001

0000a938 <_fflush_r>:
    a938:	690b      	ldr	r3, [r1, #16]
    a93a:	b570      	push	{r4, r5, r6, lr}
    a93c:	0005      	movs	r5, r0
    a93e:	000c      	movs	r4, r1
    a940:	2b00      	cmp	r3, #0
    a942:	d101      	bne.n	a948 <_fflush_r+0x10>
    a944:	2000      	movs	r0, #0
    a946:	e01c      	b.n	a982 <_fflush_r+0x4a>
    a948:	2800      	cmp	r0, #0
    a94a:	d004      	beq.n	a956 <_fflush_r+0x1e>
    a94c:	6983      	ldr	r3, [r0, #24]
    a94e:	2b00      	cmp	r3, #0
    a950:	d101      	bne.n	a956 <_fflush_r+0x1e>
    a952:	f000 f85f 	bl	aa14 <__sinit>
    a956:	4b0b      	ldr	r3, [pc, #44]	; (a984 <_fflush_r+0x4c>)
    a958:	429c      	cmp	r4, r3
    a95a:	d101      	bne.n	a960 <_fflush_r+0x28>
    a95c:	686c      	ldr	r4, [r5, #4]
    a95e:	e008      	b.n	a972 <_fflush_r+0x3a>
    a960:	4b09      	ldr	r3, [pc, #36]	; (a988 <_fflush_r+0x50>)
    a962:	429c      	cmp	r4, r3
    a964:	d101      	bne.n	a96a <_fflush_r+0x32>
    a966:	68ac      	ldr	r4, [r5, #8]
    a968:	e003      	b.n	a972 <_fflush_r+0x3a>
    a96a:	4b08      	ldr	r3, [pc, #32]	; (a98c <_fflush_r+0x54>)
    a96c:	429c      	cmp	r4, r3
    a96e:	d100      	bne.n	a972 <_fflush_r+0x3a>
    a970:	68ec      	ldr	r4, [r5, #12]
    a972:	220c      	movs	r2, #12
    a974:	5ea3      	ldrsh	r3, [r4, r2]
    a976:	2b00      	cmp	r3, #0
    a978:	d0e4      	beq.n	a944 <_fflush_r+0xc>
    a97a:	0021      	movs	r1, r4
    a97c:	0028      	movs	r0, r5
    a97e:	f7ff ff55 	bl	a82c <__sflush_r>
    a982:	bd70      	pop	{r4, r5, r6, pc}
    a984:	0000b09c 	.word	0x0000b09c
    a988:	0000b0bc 	.word	0x0000b0bc
    a98c:	0000b0dc 	.word	0x0000b0dc

0000a990 <_cleanup_r>:
    a990:	b510      	push	{r4, lr}
    a992:	4902      	ldr	r1, [pc, #8]	; (a99c <_cleanup_r+0xc>)
    a994:	f000 f8b0 	bl	aaf8 <_fwalk_reent>
    a998:	bd10      	pop	{r4, pc}
    a99a:	46c0      	nop			; (mov r8, r8)
    a99c:	0000a939 	.word	0x0000a939

0000a9a0 <std.isra.0>:
    a9a0:	2300      	movs	r3, #0
    a9a2:	b510      	push	{r4, lr}
    a9a4:	0004      	movs	r4, r0
    a9a6:	6003      	str	r3, [r0, #0]
    a9a8:	6043      	str	r3, [r0, #4]
    a9aa:	6083      	str	r3, [r0, #8]
    a9ac:	8181      	strh	r1, [r0, #12]
    a9ae:	6643      	str	r3, [r0, #100]	; 0x64
    a9b0:	81c2      	strh	r2, [r0, #14]
    a9b2:	6103      	str	r3, [r0, #16]
    a9b4:	6143      	str	r3, [r0, #20]
    a9b6:	6183      	str	r3, [r0, #24]
    a9b8:	0019      	movs	r1, r3
    a9ba:	2208      	movs	r2, #8
    a9bc:	305c      	adds	r0, #92	; 0x5c
    a9be:	f7ff fdf2 	bl	a5a6 <memset>
    a9c2:	4b05      	ldr	r3, [pc, #20]	; (a9d8 <std.isra.0+0x38>)
    a9c4:	6224      	str	r4, [r4, #32]
    a9c6:	6263      	str	r3, [r4, #36]	; 0x24
    a9c8:	4b04      	ldr	r3, [pc, #16]	; (a9dc <std.isra.0+0x3c>)
    a9ca:	62a3      	str	r3, [r4, #40]	; 0x28
    a9cc:	4b04      	ldr	r3, [pc, #16]	; (a9e0 <std.isra.0+0x40>)
    a9ce:	62e3      	str	r3, [r4, #44]	; 0x2c
    a9d0:	4b04      	ldr	r3, [pc, #16]	; (a9e4 <std.isra.0+0x44>)
    a9d2:	6323      	str	r3, [r4, #48]	; 0x30
    a9d4:	bd10      	pop	{r4, pc}
    a9d6:	46c0      	nop			; (mov r8, r8)
    a9d8:	0000ad61 	.word	0x0000ad61
    a9dc:	0000ad89 	.word	0x0000ad89
    a9e0:	0000adc1 	.word	0x0000adc1
    a9e4:	0000aded 	.word	0x0000aded

0000a9e8 <__sfmoreglue>:
    a9e8:	b570      	push	{r4, r5, r6, lr}
    a9ea:	2568      	movs	r5, #104	; 0x68
    a9ec:	1e4b      	subs	r3, r1, #1
    a9ee:	435d      	muls	r5, r3
    a9f0:	000e      	movs	r6, r1
    a9f2:	0029      	movs	r1, r5
    a9f4:	3174      	adds	r1, #116	; 0x74
    a9f6:	f000 f94b 	bl	ac90 <_malloc_r>
    a9fa:	1e04      	subs	r4, r0, #0
    a9fc:	d008      	beq.n	aa10 <__sfmoreglue+0x28>
    a9fe:	2100      	movs	r1, #0
    aa00:	002a      	movs	r2, r5
    aa02:	6001      	str	r1, [r0, #0]
    aa04:	6046      	str	r6, [r0, #4]
    aa06:	300c      	adds	r0, #12
    aa08:	60a0      	str	r0, [r4, #8]
    aa0a:	3268      	adds	r2, #104	; 0x68
    aa0c:	f7ff fdcb 	bl	a5a6 <memset>
    aa10:	0020      	movs	r0, r4
    aa12:	bd70      	pop	{r4, r5, r6, pc}

0000aa14 <__sinit>:
    aa14:	6983      	ldr	r3, [r0, #24]
    aa16:	b513      	push	{r0, r1, r4, lr}
    aa18:	0004      	movs	r4, r0
    aa1a:	2b00      	cmp	r3, #0
    aa1c:	d128      	bne.n	aa70 <__sinit+0x5c>
    aa1e:	6483      	str	r3, [r0, #72]	; 0x48
    aa20:	64c3      	str	r3, [r0, #76]	; 0x4c
    aa22:	6503      	str	r3, [r0, #80]	; 0x50
    aa24:	4b13      	ldr	r3, [pc, #76]	; (aa74 <__sinit+0x60>)
    aa26:	4a14      	ldr	r2, [pc, #80]	; (aa78 <__sinit+0x64>)
    aa28:	681b      	ldr	r3, [r3, #0]
    aa2a:	6282      	str	r2, [r0, #40]	; 0x28
    aa2c:	9301      	str	r3, [sp, #4]
    aa2e:	4298      	cmp	r0, r3
    aa30:	d101      	bne.n	aa36 <__sinit+0x22>
    aa32:	2301      	movs	r3, #1
    aa34:	6183      	str	r3, [r0, #24]
    aa36:	0020      	movs	r0, r4
    aa38:	f000 f820 	bl	aa7c <__sfp>
    aa3c:	6060      	str	r0, [r4, #4]
    aa3e:	0020      	movs	r0, r4
    aa40:	f000 f81c 	bl	aa7c <__sfp>
    aa44:	60a0      	str	r0, [r4, #8]
    aa46:	0020      	movs	r0, r4
    aa48:	f000 f818 	bl	aa7c <__sfp>
    aa4c:	2200      	movs	r2, #0
    aa4e:	60e0      	str	r0, [r4, #12]
    aa50:	2104      	movs	r1, #4
    aa52:	6860      	ldr	r0, [r4, #4]
    aa54:	f7ff ffa4 	bl	a9a0 <std.isra.0>
    aa58:	2201      	movs	r2, #1
    aa5a:	2109      	movs	r1, #9
    aa5c:	68a0      	ldr	r0, [r4, #8]
    aa5e:	f7ff ff9f 	bl	a9a0 <std.isra.0>
    aa62:	2202      	movs	r2, #2
    aa64:	2112      	movs	r1, #18
    aa66:	68e0      	ldr	r0, [r4, #12]
    aa68:	f7ff ff9a 	bl	a9a0 <std.isra.0>
    aa6c:	2301      	movs	r3, #1
    aa6e:	61a3      	str	r3, [r4, #24]
    aa70:	bd13      	pop	{r0, r1, r4, pc}
    aa72:	46c0      	nop			; (mov r8, r8)
    aa74:	0000b098 	.word	0x0000b098
    aa78:	0000a991 	.word	0x0000a991

0000aa7c <__sfp>:
    aa7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    aa7e:	4b1d      	ldr	r3, [pc, #116]	; (aaf4 <__sfp+0x78>)
    aa80:	0006      	movs	r6, r0
    aa82:	681d      	ldr	r5, [r3, #0]
    aa84:	69ab      	ldr	r3, [r5, #24]
    aa86:	2b00      	cmp	r3, #0
    aa88:	d102      	bne.n	aa90 <__sfp+0x14>
    aa8a:	0028      	movs	r0, r5
    aa8c:	f7ff ffc2 	bl	aa14 <__sinit>
    aa90:	3548      	adds	r5, #72	; 0x48
    aa92:	68ac      	ldr	r4, [r5, #8]
    aa94:	686b      	ldr	r3, [r5, #4]
    aa96:	3b01      	subs	r3, #1
    aa98:	d405      	bmi.n	aaa6 <__sfp+0x2a>
    aa9a:	220c      	movs	r2, #12
    aa9c:	5ea7      	ldrsh	r7, [r4, r2]
    aa9e:	2f00      	cmp	r7, #0
    aaa0:	d010      	beq.n	aac4 <__sfp+0x48>
    aaa2:	3468      	adds	r4, #104	; 0x68
    aaa4:	e7f7      	b.n	aa96 <__sfp+0x1a>
    aaa6:	682b      	ldr	r3, [r5, #0]
    aaa8:	2b00      	cmp	r3, #0
    aaaa:	d001      	beq.n	aab0 <__sfp+0x34>
    aaac:	682d      	ldr	r5, [r5, #0]
    aaae:	e7f0      	b.n	aa92 <__sfp+0x16>
    aab0:	2104      	movs	r1, #4
    aab2:	0030      	movs	r0, r6
    aab4:	f7ff ff98 	bl	a9e8 <__sfmoreglue>
    aab8:	6028      	str	r0, [r5, #0]
    aaba:	2800      	cmp	r0, #0
    aabc:	d1f6      	bne.n	aaac <__sfp+0x30>
    aabe:	230c      	movs	r3, #12
    aac0:	6033      	str	r3, [r6, #0]
    aac2:	e016      	b.n	aaf2 <__sfp+0x76>
    aac4:	2301      	movs	r3, #1
    aac6:	0020      	movs	r0, r4
    aac8:	425b      	negs	r3, r3
    aaca:	81e3      	strh	r3, [r4, #14]
    aacc:	3302      	adds	r3, #2
    aace:	81a3      	strh	r3, [r4, #12]
    aad0:	6667      	str	r7, [r4, #100]	; 0x64
    aad2:	6027      	str	r7, [r4, #0]
    aad4:	60a7      	str	r7, [r4, #8]
    aad6:	6067      	str	r7, [r4, #4]
    aad8:	6127      	str	r7, [r4, #16]
    aada:	6167      	str	r7, [r4, #20]
    aadc:	61a7      	str	r7, [r4, #24]
    aade:	305c      	adds	r0, #92	; 0x5c
    aae0:	2208      	movs	r2, #8
    aae2:	0039      	movs	r1, r7
    aae4:	f7ff fd5f 	bl	a5a6 <memset>
    aae8:	0020      	movs	r0, r4
    aaea:	6367      	str	r7, [r4, #52]	; 0x34
    aaec:	63a7      	str	r7, [r4, #56]	; 0x38
    aaee:	64a7      	str	r7, [r4, #72]	; 0x48
    aaf0:	64e7      	str	r7, [r4, #76]	; 0x4c
    aaf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aaf4:	0000b098 	.word	0x0000b098

0000aaf8 <_fwalk_reent>:
    aaf8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    aafa:	0004      	movs	r4, r0
    aafc:	0007      	movs	r7, r0
    aafe:	2600      	movs	r6, #0
    ab00:	9101      	str	r1, [sp, #4]
    ab02:	3448      	adds	r4, #72	; 0x48
    ab04:	2c00      	cmp	r4, #0
    ab06:	d016      	beq.n	ab36 <_fwalk_reent+0x3e>
    ab08:	6863      	ldr	r3, [r4, #4]
    ab0a:	68a5      	ldr	r5, [r4, #8]
    ab0c:	9300      	str	r3, [sp, #0]
    ab0e:	9b00      	ldr	r3, [sp, #0]
    ab10:	3b01      	subs	r3, #1
    ab12:	9300      	str	r3, [sp, #0]
    ab14:	d40d      	bmi.n	ab32 <_fwalk_reent+0x3a>
    ab16:	89ab      	ldrh	r3, [r5, #12]
    ab18:	2b01      	cmp	r3, #1
    ab1a:	d908      	bls.n	ab2e <_fwalk_reent+0x36>
    ab1c:	220e      	movs	r2, #14
    ab1e:	5eab      	ldrsh	r3, [r5, r2]
    ab20:	3301      	adds	r3, #1
    ab22:	d004      	beq.n	ab2e <_fwalk_reent+0x36>
    ab24:	0029      	movs	r1, r5
    ab26:	0038      	movs	r0, r7
    ab28:	9b01      	ldr	r3, [sp, #4]
    ab2a:	4798      	blx	r3
    ab2c:	4306      	orrs	r6, r0
    ab2e:	3568      	adds	r5, #104	; 0x68
    ab30:	e7ed      	b.n	ab0e <_fwalk_reent+0x16>
    ab32:	6824      	ldr	r4, [r4, #0]
    ab34:	e7e6      	b.n	ab04 <_fwalk_reent+0xc>
    ab36:	0030      	movs	r0, r6
    ab38:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

0000ab3c <__swhatbuf_r>:
    ab3c:	b570      	push	{r4, r5, r6, lr}
    ab3e:	000e      	movs	r6, r1
    ab40:	001d      	movs	r5, r3
    ab42:	230e      	movs	r3, #14
    ab44:	5ec9      	ldrsh	r1, [r1, r3]
    ab46:	b090      	sub	sp, #64	; 0x40
    ab48:	0014      	movs	r4, r2
    ab4a:	2900      	cmp	r1, #0
    ab4c:	da06      	bge.n	ab5c <__swhatbuf_r+0x20>
    ab4e:	2300      	movs	r3, #0
    ab50:	602b      	str	r3, [r5, #0]
    ab52:	89b3      	ldrh	r3, [r6, #12]
    ab54:	061b      	lsls	r3, r3, #24
    ab56:	d50f      	bpl.n	ab78 <__swhatbuf_r+0x3c>
    ab58:	2340      	movs	r3, #64	; 0x40
    ab5a:	e00f      	b.n	ab7c <__swhatbuf_r+0x40>
    ab5c:	aa01      	add	r2, sp, #4
    ab5e:	f000 f971 	bl	ae44 <_fstat_r>
    ab62:	2800      	cmp	r0, #0
    ab64:	dbf3      	blt.n	ab4e <__swhatbuf_r+0x12>
    ab66:	23f0      	movs	r3, #240	; 0xf0
    ab68:	9a02      	ldr	r2, [sp, #8]
    ab6a:	021b      	lsls	r3, r3, #8
    ab6c:	4013      	ands	r3, r2
    ab6e:	4a05      	ldr	r2, [pc, #20]	; (ab84 <__swhatbuf_r+0x48>)
    ab70:	189b      	adds	r3, r3, r2
    ab72:	425a      	negs	r2, r3
    ab74:	4153      	adcs	r3, r2
    ab76:	602b      	str	r3, [r5, #0]
    ab78:	2380      	movs	r3, #128	; 0x80
    ab7a:	00db      	lsls	r3, r3, #3
    ab7c:	2000      	movs	r0, #0
    ab7e:	6023      	str	r3, [r4, #0]
    ab80:	b010      	add	sp, #64	; 0x40
    ab82:	bd70      	pop	{r4, r5, r6, pc}
    ab84:	ffffe000 	.word	0xffffe000

0000ab88 <__smakebuf_r>:
    ab88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ab8a:	2602      	movs	r6, #2
    ab8c:	898b      	ldrh	r3, [r1, #12]
    ab8e:	0005      	movs	r5, r0
    ab90:	000c      	movs	r4, r1
    ab92:	4233      	tst	r3, r6
    ab94:	d110      	bne.n	abb8 <__smakebuf_r+0x30>
    ab96:	ab01      	add	r3, sp, #4
    ab98:	466a      	mov	r2, sp
    ab9a:	f7ff ffcf 	bl	ab3c <__swhatbuf_r>
    ab9e:	9900      	ldr	r1, [sp, #0]
    aba0:	0007      	movs	r7, r0
    aba2:	0028      	movs	r0, r5
    aba4:	f000 f874 	bl	ac90 <_malloc_r>
    aba8:	2800      	cmp	r0, #0
    abaa:	d10c      	bne.n	abc6 <__smakebuf_r+0x3e>
    abac:	220c      	movs	r2, #12
    abae:	5ea3      	ldrsh	r3, [r4, r2]
    abb0:	059a      	lsls	r2, r3, #22
    abb2:	d423      	bmi.n	abfc <__smakebuf_r+0x74>
    abb4:	4333      	orrs	r3, r6
    abb6:	81a3      	strh	r3, [r4, #12]
    abb8:	0023      	movs	r3, r4
    abba:	3347      	adds	r3, #71	; 0x47
    abbc:	6023      	str	r3, [r4, #0]
    abbe:	6123      	str	r3, [r4, #16]
    abc0:	2301      	movs	r3, #1
    abc2:	6163      	str	r3, [r4, #20]
    abc4:	e01a      	b.n	abfc <__smakebuf_r+0x74>
    abc6:	2280      	movs	r2, #128	; 0x80
    abc8:	4b0d      	ldr	r3, [pc, #52]	; (ac00 <__smakebuf_r+0x78>)
    abca:	62ab      	str	r3, [r5, #40]	; 0x28
    abcc:	89a3      	ldrh	r3, [r4, #12]
    abce:	6020      	str	r0, [r4, #0]
    abd0:	4313      	orrs	r3, r2
    abd2:	81a3      	strh	r3, [r4, #12]
    abd4:	9b00      	ldr	r3, [sp, #0]
    abd6:	6120      	str	r0, [r4, #16]
    abd8:	6163      	str	r3, [r4, #20]
    abda:	9b01      	ldr	r3, [sp, #4]
    abdc:	2b00      	cmp	r3, #0
    abde:	d00a      	beq.n	abf6 <__smakebuf_r+0x6e>
    abe0:	230e      	movs	r3, #14
    abe2:	5ee1      	ldrsh	r1, [r4, r3]
    abe4:	0028      	movs	r0, r5
    abe6:	f000 f93f 	bl	ae68 <_isatty_r>
    abea:	2800      	cmp	r0, #0
    abec:	d003      	beq.n	abf6 <__smakebuf_r+0x6e>
    abee:	2201      	movs	r2, #1
    abf0:	89a3      	ldrh	r3, [r4, #12]
    abf2:	4313      	orrs	r3, r2
    abf4:	81a3      	strh	r3, [r4, #12]
    abf6:	89a3      	ldrh	r3, [r4, #12]
    abf8:	431f      	orrs	r7, r3
    abfa:	81a7      	strh	r7, [r4, #12]
    abfc:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    abfe:	46c0      	nop			; (mov r8, r8)
    ac00:	0000a991 	.word	0x0000a991

0000ac04 <_free_r>:
    ac04:	b530      	push	{r4, r5, lr}
    ac06:	2900      	cmp	r1, #0
    ac08:	d03e      	beq.n	ac88 <_free_r+0x84>
    ac0a:	3904      	subs	r1, #4
    ac0c:	680b      	ldr	r3, [r1, #0]
    ac0e:	2b00      	cmp	r3, #0
    ac10:	da00      	bge.n	ac14 <_free_r+0x10>
    ac12:	18c9      	adds	r1, r1, r3
    ac14:	4a1d      	ldr	r2, [pc, #116]	; (ac8c <_free_r+0x88>)
    ac16:	6813      	ldr	r3, [r2, #0]
    ac18:	0014      	movs	r4, r2
    ac1a:	2b00      	cmp	r3, #0
    ac1c:	d102      	bne.n	ac24 <_free_r+0x20>
    ac1e:	604b      	str	r3, [r1, #4]
    ac20:	6011      	str	r1, [r2, #0]
    ac22:	e031      	b.n	ac88 <_free_r+0x84>
    ac24:	428b      	cmp	r3, r1
    ac26:	d90d      	bls.n	ac44 <_free_r+0x40>
    ac28:	680a      	ldr	r2, [r1, #0]
    ac2a:	1888      	adds	r0, r1, r2
    ac2c:	4283      	cmp	r3, r0
    ac2e:	d103      	bne.n	ac38 <_free_r+0x34>
    ac30:	6818      	ldr	r0, [r3, #0]
    ac32:	685b      	ldr	r3, [r3, #4]
    ac34:	1882      	adds	r2, r0, r2
    ac36:	600a      	str	r2, [r1, #0]
    ac38:	604b      	str	r3, [r1, #4]
    ac3a:	6021      	str	r1, [r4, #0]
    ac3c:	e024      	b.n	ac88 <_free_r+0x84>
    ac3e:	428a      	cmp	r2, r1
    ac40:	d803      	bhi.n	ac4a <_free_r+0x46>
    ac42:	0013      	movs	r3, r2
    ac44:	685a      	ldr	r2, [r3, #4]
    ac46:	2a00      	cmp	r2, #0
    ac48:	d1f9      	bne.n	ac3e <_free_r+0x3a>
    ac4a:	681d      	ldr	r5, [r3, #0]
    ac4c:	195c      	adds	r4, r3, r5
    ac4e:	428c      	cmp	r4, r1
    ac50:	d10b      	bne.n	ac6a <_free_r+0x66>
    ac52:	6809      	ldr	r1, [r1, #0]
    ac54:	1869      	adds	r1, r5, r1
    ac56:	1858      	adds	r0, r3, r1
    ac58:	6019      	str	r1, [r3, #0]
    ac5a:	4282      	cmp	r2, r0
    ac5c:	d114      	bne.n	ac88 <_free_r+0x84>
    ac5e:	6810      	ldr	r0, [r2, #0]
    ac60:	6852      	ldr	r2, [r2, #4]
    ac62:	1841      	adds	r1, r0, r1
    ac64:	6019      	str	r1, [r3, #0]
    ac66:	605a      	str	r2, [r3, #4]
    ac68:	e00e      	b.n	ac88 <_free_r+0x84>
    ac6a:	428c      	cmp	r4, r1
    ac6c:	d902      	bls.n	ac74 <_free_r+0x70>
    ac6e:	230c      	movs	r3, #12
    ac70:	6003      	str	r3, [r0, #0]
    ac72:	e009      	b.n	ac88 <_free_r+0x84>
    ac74:	6808      	ldr	r0, [r1, #0]
    ac76:	180c      	adds	r4, r1, r0
    ac78:	42a2      	cmp	r2, r4
    ac7a:	d103      	bne.n	ac84 <_free_r+0x80>
    ac7c:	6814      	ldr	r4, [r2, #0]
    ac7e:	6852      	ldr	r2, [r2, #4]
    ac80:	1820      	adds	r0, r4, r0
    ac82:	6008      	str	r0, [r1, #0]
    ac84:	604a      	str	r2, [r1, #4]
    ac86:	6059      	str	r1, [r3, #4]
    ac88:	bd30      	pop	{r4, r5, pc}
    ac8a:	46c0      	nop			; (mov r8, r8)
    ac8c:	200000e8 	.word	0x200000e8

0000ac90 <_malloc_r>:
    ac90:	2303      	movs	r3, #3
    ac92:	b570      	push	{r4, r5, r6, lr}
    ac94:	1ccd      	adds	r5, r1, #3
    ac96:	439d      	bics	r5, r3
    ac98:	3508      	adds	r5, #8
    ac9a:	0006      	movs	r6, r0
    ac9c:	2d0c      	cmp	r5, #12
    ac9e:	d201      	bcs.n	aca4 <_malloc_r+0x14>
    aca0:	250c      	movs	r5, #12
    aca2:	e005      	b.n	acb0 <_malloc_r+0x20>
    aca4:	2d00      	cmp	r5, #0
    aca6:	da03      	bge.n	acb0 <_malloc_r+0x20>
    aca8:	230c      	movs	r3, #12
    acaa:	2000      	movs	r0, #0
    acac:	6033      	str	r3, [r6, #0]
    acae:	e040      	b.n	ad32 <_malloc_r+0xa2>
    acb0:	42a9      	cmp	r1, r5
    acb2:	d8f9      	bhi.n	aca8 <_malloc_r+0x18>
    acb4:	4b1f      	ldr	r3, [pc, #124]	; (ad34 <_malloc_r+0xa4>)
    acb6:	681c      	ldr	r4, [r3, #0]
    acb8:	001a      	movs	r2, r3
    acba:	0021      	movs	r1, r4
    acbc:	2900      	cmp	r1, #0
    acbe:	d013      	beq.n	ace8 <_malloc_r+0x58>
    acc0:	680b      	ldr	r3, [r1, #0]
    acc2:	1b5b      	subs	r3, r3, r5
    acc4:	d40d      	bmi.n	ace2 <_malloc_r+0x52>
    acc6:	2b0b      	cmp	r3, #11
    acc8:	d902      	bls.n	acd0 <_malloc_r+0x40>
    acca:	600b      	str	r3, [r1, #0]
    accc:	18cc      	adds	r4, r1, r3
    acce:	e01e      	b.n	ad0e <_malloc_r+0x7e>
    acd0:	428c      	cmp	r4, r1
    acd2:	d102      	bne.n	acda <_malloc_r+0x4a>
    acd4:	6863      	ldr	r3, [r4, #4]
    acd6:	6013      	str	r3, [r2, #0]
    acd8:	e01a      	b.n	ad10 <_malloc_r+0x80>
    acda:	684b      	ldr	r3, [r1, #4]
    acdc:	6063      	str	r3, [r4, #4]
    acde:	000c      	movs	r4, r1
    ace0:	e016      	b.n	ad10 <_malloc_r+0x80>
    ace2:	000c      	movs	r4, r1
    ace4:	6849      	ldr	r1, [r1, #4]
    ace6:	e7e9      	b.n	acbc <_malloc_r+0x2c>
    ace8:	4c13      	ldr	r4, [pc, #76]	; (ad38 <_malloc_r+0xa8>)
    acea:	6823      	ldr	r3, [r4, #0]
    acec:	2b00      	cmp	r3, #0
    acee:	d103      	bne.n	acf8 <_malloc_r+0x68>
    acf0:	0030      	movs	r0, r6
    acf2:	f000 f823 	bl	ad3c <_sbrk_r>
    acf6:	6020      	str	r0, [r4, #0]
    acf8:	0029      	movs	r1, r5
    acfa:	0030      	movs	r0, r6
    acfc:	f000 f81e 	bl	ad3c <_sbrk_r>
    ad00:	1c43      	adds	r3, r0, #1
    ad02:	d0d1      	beq.n	aca8 <_malloc_r+0x18>
    ad04:	2303      	movs	r3, #3
    ad06:	1cc4      	adds	r4, r0, #3
    ad08:	439c      	bics	r4, r3
    ad0a:	42a0      	cmp	r0, r4
    ad0c:	d10a      	bne.n	ad24 <_malloc_r+0x94>
    ad0e:	6025      	str	r5, [r4, #0]
    ad10:	0020      	movs	r0, r4
    ad12:	2207      	movs	r2, #7
    ad14:	300b      	adds	r0, #11
    ad16:	1d23      	adds	r3, r4, #4
    ad18:	4390      	bics	r0, r2
    ad1a:	1ac3      	subs	r3, r0, r3
    ad1c:	d009      	beq.n	ad32 <_malloc_r+0xa2>
    ad1e:	425a      	negs	r2, r3
    ad20:	50e2      	str	r2, [r4, r3]
    ad22:	e006      	b.n	ad32 <_malloc_r+0xa2>
    ad24:	1a21      	subs	r1, r4, r0
    ad26:	0030      	movs	r0, r6
    ad28:	f000 f808 	bl	ad3c <_sbrk_r>
    ad2c:	1c43      	adds	r3, r0, #1
    ad2e:	d1ee      	bne.n	ad0e <_malloc_r+0x7e>
    ad30:	e7ba      	b.n	aca8 <_malloc_r+0x18>
    ad32:	bd70      	pop	{r4, r5, r6, pc}
    ad34:	200000e8 	.word	0x200000e8
    ad38:	200000e4 	.word	0x200000e4

0000ad3c <_sbrk_r>:
    ad3c:	2300      	movs	r3, #0
    ad3e:	b570      	push	{r4, r5, r6, lr}
    ad40:	4c06      	ldr	r4, [pc, #24]	; (ad5c <_sbrk_r+0x20>)
    ad42:	0005      	movs	r5, r0
    ad44:	0008      	movs	r0, r1
    ad46:	6023      	str	r3, [r4, #0]
    ad48:	f7fd faae 	bl	82a8 <_sbrk>
    ad4c:	1c43      	adds	r3, r0, #1
    ad4e:	d103      	bne.n	ad58 <_sbrk_r+0x1c>
    ad50:	6823      	ldr	r3, [r4, #0]
    ad52:	2b00      	cmp	r3, #0
    ad54:	d000      	beq.n	ad58 <_sbrk_r+0x1c>
    ad56:	602b      	str	r3, [r5, #0]
    ad58:	bd70      	pop	{r4, r5, r6, pc}
    ad5a:	46c0      	nop			; (mov r8, r8)
    ad5c:	20000170 	.word	0x20000170

0000ad60 <__sread>:
    ad60:	b570      	push	{r4, r5, r6, lr}
    ad62:	000c      	movs	r4, r1
    ad64:	250e      	movs	r5, #14
    ad66:	5f49      	ldrsh	r1, [r1, r5]
    ad68:	f000 f8a4 	bl	aeb4 <_read_r>
    ad6c:	2800      	cmp	r0, #0
    ad6e:	db03      	blt.n	ad78 <__sread+0x18>
    ad70:	6d63      	ldr	r3, [r4, #84]	; 0x54
    ad72:	181b      	adds	r3, r3, r0
    ad74:	6563      	str	r3, [r4, #84]	; 0x54
    ad76:	e003      	b.n	ad80 <__sread+0x20>
    ad78:	89a2      	ldrh	r2, [r4, #12]
    ad7a:	4b02      	ldr	r3, [pc, #8]	; (ad84 <__sread+0x24>)
    ad7c:	4013      	ands	r3, r2
    ad7e:	81a3      	strh	r3, [r4, #12]
    ad80:	bd70      	pop	{r4, r5, r6, pc}
    ad82:	46c0      	nop			; (mov r8, r8)
    ad84:	ffffefff 	.word	0xffffefff

0000ad88 <__swrite>:
    ad88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ad8a:	001f      	movs	r7, r3
    ad8c:	898b      	ldrh	r3, [r1, #12]
    ad8e:	0005      	movs	r5, r0
    ad90:	000c      	movs	r4, r1
    ad92:	0016      	movs	r6, r2
    ad94:	05db      	lsls	r3, r3, #23
    ad96:	d505      	bpl.n	ada4 <__swrite+0x1c>
    ad98:	230e      	movs	r3, #14
    ad9a:	5ec9      	ldrsh	r1, [r1, r3]
    ad9c:	2200      	movs	r2, #0
    ad9e:	2302      	movs	r3, #2
    ada0:	f000 f874 	bl	ae8c <_lseek_r>
    ada4:	89a2      	ldrh	r2, [r4, #12]
    ada6:	4b05      	ldr	r3, [pc, #20]	; (adbc <__swrite+0x34>)
    ada8:	0028      	movs	r0, r5
    adaa:	4013      	ands	r3, r2
    adac:	81a3      	strh	r3, [r4, #12]
    adae:	0032      	movs	r2, r6
    adb0:	230e      	movs	r3, #14
    adb2:	5ee1      	ldrsh	r1, [r4, r3]
    adb4:	003b      	movs	r3, r7
    adb6:	f000 f81f 	bl	adf8 <_write_r>
    adba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    adbc:	ffffefff 	.word	0xffffefff

0000adc0 <__sseek>:
    adc0:	b570      	push	{r4, r5, r6, lr}
    adc2:	000c      	movs	r4, r1
    adc4:	250e      	movs	r5, #14
    adc6:	5f49      	ldrsh	r1, [r1, r5]
    adc8:	f000 f860 	bl	ae8c <_lseek_r>
    adcc:	89a3      	ldrh	r3, [r4, #12]
    adce:	1c42      	adds	r2, r0, #1
    add0:	d103      	bne.n	adda <__sseek+0x1a>
    add2:	4a05      	ldr	r2, [pc, #20]	; (ade8 <__sseek+0x28>)
    add4:	4013      	ands	r3, r2
    add6:	81a3      	strh	r3, [r4, #12]
    add8:	e004      	b.n	ade4 <__sseek+0x24>
    adda:	2280      	movs	r2, #128	; 0x80
    addc:	0152      	lsls	r2, r2, #5
    adde:	4313      	orrs	r3, r2
    ade0:	81a3      	strh	r3, [r4, #12]
    ade2:	6560      	str	r0, [r4, #84]	; 0x54
    ade4:	bd70      	pop	{r4, r5, r6, pc}
    ade6:	46c0      	nop			; (mov r8, r8)
    ade8:	ffffefff 	.word	0xffffefff

0000adec <__sclose>:
    adec:	b510      	push	{r4, lr}
    adee:	230e      	movs	r3, #14
    adf0:	5ec9      	ldrsh	r1, [r1, r3]
    adf2:	f000 f815 	bl	ae20 <_close_r>
    adf6:	bd10      	pop	{r4, pc}

0000adf8 <_write_r>:
    adf8:	b570      	push	{r4, r5, r6, lr}
    adfa:	0005      	movs	r5, r0
    adfc:	0008      	movs	r0, r1
    adfe:	0011      	movs	r1, r2
    ae00:	2200      	movs	r2, #0
    ae02:	4c06      	ldr	r4, [pc, #24]	; (ae1c <_write_r+0x24>)
    ae04:	6022      	str	r2, [r4, #0]
    ae06:	001a      	movs	r2, r3
    ae08:	f7ff f9a4 	bl	a154 <_write>
    ae0c:	1c43      	adds	r3, r0, #1
    ae0e:	d103      	bne.n	ae18 <_write_r+0x20>
    ae10:	6823      	ldr	r3, [r4, #0]
    ae12:	2b00      	cmp	r3, #0
    ae14:	d000      	beq.n	ae18 <_write_r+0x20>
    ae16:	602b      	str	r3, [r5, #0]
    ae18:	bd70      	pop	{r4, r5, r6, pc}
    ae1a:	46c0      	nop			; (mov r8, r8)
    ae1c:	20000170 	.word	0x20000170

0000ae20 <_close_r>:
    ae20:	2300      	movs	r3, #0
    ae22:	b570      	push	{r4, r5, r6, lr}
    ae24:	4c06      	ldr	r4, [pc, #24]	; (ae40 <_close_r+0x20>)
    ae26:	0005      	movs	r5, r0
    ae28:	0008      	movs	r0, r1
    ae2a:	6023      	str	r3, [r4, #0]
    ae2c:	f7fd fa5a 	bl	82e4 <_close>
    ae30:	1c43      	adds	r3, r0, #1
    ae32:	d103      	bne.n	ae3c <_close_r+0x1c>
    ae34:	6823      	ldr	r3, [r4, #0]
    ae36:	2b00      	cmp	r3, #0
    ae38:	d000      	beq.n	ae3c <_close_r+0x1c>
    ae3a:	602b      	str	r3, [r5, #0]
    ae3c:	bd70      	pop	{r4, r5, r6, pc}
    ae3e:	46c0      	nop			; (mov r8, r8)
    ae40:	20000170 	.word	0x20000170

0000ae44 <_fstat_r>:
    ae44:	2300      	movs	r3, #0
    ae46:	b570      	push	{r4, r5, r6, lr}
    ae48:	4c06      	ldr	r4, [pc, #24]	; (ae64 <_fstat_r+0x20>)
    ae4a:	0005      	movs	r5, r0
    ae4c:	0008      	movs	r0, r1
    ae4e:	0011      	movs	r1, r2
    ae50:	6023      	str	r3, [r4, #0]
    ae52:	f7fd fa51 	bl	82f8 <_fstat>
    ae56:	1c43      	adds	r3, r0, #1
    ae58:	d103      	bne.n	ae62 <_fstat_r+0x1e>
    ae5a:	6823      	ldr	r3, [r4, #0]
    ae5c:	2b00      	cmp	r3, #0
    ae5e:	d000      	beq.n	ae62 <_fstat_r+0x1e>
    ae60:	602b      	str	r3, [r5, #0]
    ae62:	bd70      	pop	{r4, r5, r6, pc}
    ae64:	20000170 	.word	0x20000170

0000ae68 <_isatty_r>:
    ae68:	2300      	movs	r3, #0
    ae6a:	b570      	push	{r4, r5, r6, lr}
    ae6c:	4c06      	ldr	r4, [pc, #24]	; (ae88 <_isatty_r+0x20>)
    ae6e:	0005      	movs	r5, r0
    ae70:	0008      	movs	r0, r1
    ae72:	6023      	str	r3, [r4, #0]
    ae74:	f7fd fa4e 	bl	8314 <_isatty>
    ae78:	1c43      	adds	r3, r0, #1
    ae7a:	d103      	bne.n	ae84 <_isatty_r+0x1c>
    ae7c:	6823      	ldr	r3, [r4, #0]
    ae7e:	2b00      	cmp	r3, #0
    ae80:	d000      	beq.n	ae84 <_isatty_r+0x1c>
    ae82:	602b      	str	r3, [r5, #0]
    ae84:	bd70      	pop	{r4, r5, r6, pc}
    ae86:	46c0      	nop			; (mov r8, r8)
    ae88:	20000170 	.word	0x20000170

0000ae8c <_lseek_r>:
    ae8c:	b570      	push	{r4, r5, r6, lr}
    ae8e:	0005      	movs	r5, r0
    ae90:	0008      	movs	r0, r1
    ae92:	0011      	movs	r1, r2
    ae94:	2200      	movs	r2, #0
    ae96:	4c06      	ldr	r4, [pc, #24]	; (aeb0 <_lseek_r+0x24>)
    ae98:	6022      	str	r2, [r4, #0]
    ae9a:	001a      	movs	r2, r3
    ae9c:	f7fd fa44 	bl	8328 <_lseek>
    aea0:	1c43      	adds	r3, r0, #1
    aea2:	d103      	bne.n	aeac <_lseek_r+0x20>
    aea4:	6823      	ldr	r3, [r4, #0]
    aea6:	2b00      	cmp	r3, #0
    aea8:	d000      	beq.n	aeac <_lseek_r+0x20>
    aeaa:	602b      	str	r3, [r5, #0]
    aeac:	bd70      	pop	{r4, r5, r6, pc}
    aeae:	46c0      	nop			; (mov r8, r8)
    aeb0:	20000170 	.word	0x20000170

0000aeb4 <_read_r>:
    aeb4:	b570      	push	{r4, r5, r6, lr}
    aeb6:	0005      	movs	r5, r0
    aeb8:	0008      	movs	r0, r1
    aeba:	0011      	movs	r1, r2
    aebc:	2200      	movs	r2, #0
    aebe:	4c06      	ldr	r4, [pc, #24]	; (aed8 <_read_r+0x24>)
    aec0:	6022      	str	r2, [r4, #0]
    aec2:	001a      	movs	r2, r3
    aec4:	f7ff f91c 	bl	a100 <_read>
    aec8:	1c43      	adds	r3, r0, #1
    aeca:	d103      	bne.n	aed4 <_read_r+0x20>
    aecc:	6823      	ldr	r3, [r4, #0]
    aece:	2b00      	cmp	r3, #0
    aed0:	d000      	beq.n	aed4 <_read_r+0x20>
    aed2:	602b      	str	r3, [r5, #0]
    aed4:	bd70      	pop	{r4, r5, r6, pc}
    aed6:	46c0      	nop			; (mov r8, r8)
    aed8:	20000170 	.word	0x20000170
    aedc:	000085ea 	.word	0x000085ea
    aee0:	000085ee 	.word	0x000085ee
    aee4:	000085f2 	.word	0x000085f2
    aee8:	000085f6 	.word	0x000085f6
    aeec:	000085fa 	.word	0x000085fa
    aef0:	000085fe 	.word	0x000085fe
    aef4:	00008602 	.word	0x00008602
    aef8:	00008606 	.word	0x00008606
    aefc:	0000860a 	.word	0x0000860a
    af00:	0000860e 	.word	0x0000860e
    af04:	00008666 	.word	0x00008666
    af08:	0000866c 	.word	0x0000866c
    af0c:	00008672 	.word	0x00008672
    af10:	00008678 	.word	0x00008678
    af14:	00008678 	.word	0x00008678
    af18:	0000867e 	.word	0x0000867e
    af1c:	0000867e 	.word	0x0000867e
    af20:	0000867e 	.word	0x0000867e
    af24:	00008684 	.word	0x00008684
    af28:	0000868a 	.word	0x0000868a
    af2c:	00009118 	.word	0x00009118
    af30:	00009118 	.word	0x00009118
    af34:	0000910c 	.word	0x0000910c
    af38:	00009118 	.word	0x00009118
    af3c:	0000910c 	.word	0x0000910c
    af40:	000090e6 	.word	0x000090e6
    af44:	000090e6 	.word	0x000090e6
    af48:	00009118 	.word	0x00009118
    af4c:	00009118 	.word	0x00009118
    af50:	00009118 	.word	0x00009118
    af54:	00009118 	.word	0x00009118
    af58:	00009118 	.word	0x00009118
    af5c:	00009118 	.word	0x00009118
    af60:	00009118 	.word	0x00009118
    af64:	00009118 	.word	0x00009118
    af68:	00009118 	.word	0x00009118
    af6c:	00009118 	.word	0x00009118
    af70:	00009118 	.word	0x00009118
    af74:	00009118 	.word	0x00009118
    af78:	00009118 	.word	0x00009118
    af7c:	00009118 	.word	0x00009118
    af80:	00009118 	.word	0x00009118
    af84:	00009118 	.word	0x00009118
    af88:	00009118 	.word	0x00009118
    af8c:	00009118 	.word	0x00009118
    af90:	00009118 	.word	0x00009118
    af94:	00009118 	.word	0x00009118
    af98:	00009118 	.word	0x00009118
    af9c:	00009118 	.word	0x00009118
    afa0:	00009118 	.word	0x00009118
    afa4:	00009118 	.word	0x00009118
    afa8:	00009118 	.word	0x00009118
    afac:	00009118 	.word	0x00009118
    afb0:	00009118 	.word	0x00009118
    afb4:	00009118 	.word	0x00009118
    afb8:	00009118 	.word	0x00009118
    afbc:	00009118 	.word	0x00009118
    afc0:	00009118 	.word	0x00009118
    afc4:	00009118 	.word	0x00009118
    afc8:	00009118 	.word	0x00009118
    afcc:	00009118 	.word	0x00009118
    afd0:	00009118 	.word	0x00009118
    afd4:	00009118 	.word	0x00009118
    afd8:	00009118 	.word	0x00009118
    afdc:	00009118 	.word	0x00009118
    afe0:	00009118 	.word	0x00009118
    afe4:	00009118 	.word	0x00009118
    afe8:	00009118 	.word	0x00009118
    afec:	00009118 	.word	0x00009118
    aff0:	00009118 	.word	0x00009118
    aff4:	00009118 	.word	0x00009118
    aff8:	00009118 	.word	0x00009118
    affc:	00009118 	.word	0x00009118
    b000:	00009118 	.word	0x00009118
    b004:	00009118 	.word	0x00009118
    b008:	00009118 	.word	0x00009118
    b00c:	00009118 	.word	0x00009118
    b010:	00009118 	.word	0x00009118
    b014:	00009118 	.word	0x00009118
    b018:	00009118 	.word	0x00009118
    b01c:	00009118 	.word	0x00009118
    b020:	00009118 	.word	0x00009118
    b024:	00009118 	.word	0x00009118
    b028:	00009118 	.word	0x00009118
    b02c:	0000910c 	.word	0x0000910c
    b030:	0000910c 	.word	0x0000910c
    b034:	00009122 	.word	0x00009122
    b038:	00009122 	.word	0x00009122
    b03c:	00009122 	.word	0x00009122
    b040:	00009122 	.word	0x00009122
    b044:	00009a5c 	.word	0x00009a5c
    b048:	00009aac 	.word	0x00009aac
    b04c:	00009aac 	.word	0x00009aac
    b050:	00009aa8 	.word	0x00009aa8
    b054:	00009a4e 	.word	0x00009a4e
    b058:	00009a6e 	.word	0x00009a6e
    b05c:	00009a3e 	.word	0x00009a3e
    b060:	00009a80 	.word	0x00009a80
    b064:	00009a92 	.word	0x00009a92
    b068:	73616c46 	.word	0x73616c46
    b06c:	68432068 	.word	0x68432068
    b070:	64207069 	.word	0x64207069
    b074:	6e206469 	.word	0x6e206469
    b078:	7220746f 	.word	0x7220746f
    b07c:	6f707365 	.word	0x6f707365
    b080:	202e646e 	.word	0x202e646e
    b084:	6e776f44 	.word	0x6e776f44
    b088:	64616f6c 	.word	0x64616f6c
    b08c:	69616620 	.word	0x69616620
    b090:	2064656c 	.word	0x2064656c
    b094:	0021      	.short	0x0021
    b096:	0043      	.short	0x0043

0000b098 <_global_impure_ptr>:
    b098:	0010 2000                                   ... 

0000b09c <__sf_fake_stdin>:
	...

0000b0bc <__sf_fake_stdout>:
	...

0000b0dc <__sf_fake_stderr>:
	...

0000b0fc <_init>:
    b0fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b0fe:	46c0      	nop			; (mov r8, r8)
    b100:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b102:	bc08      	pop	{r3}
    b104:	469e      	mov	lr, r3
    b106:	4770      	bx	lr

0000b108 <__init_array_start>:
    b108:	000080dd 	.word	0x000080dd

0000b10c <_fini>:
    b10c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b10e:	46c0      	nop			; (mov r8, r8)
    b110:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b112:	bc08      	pop	{r3}
    b114:	469e      	mov	lr, r3
    b116:	4770      	bx	lr

0000b118 <__fini_array_start>:
    b118:	000080b5 	.word	0x000080b5
