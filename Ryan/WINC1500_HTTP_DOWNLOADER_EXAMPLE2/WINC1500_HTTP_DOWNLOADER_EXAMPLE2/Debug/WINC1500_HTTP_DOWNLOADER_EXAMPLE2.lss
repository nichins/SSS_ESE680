
WINC1500_HTTP_DOWNLOADER_EXAMPLE2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b7a0  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000098  20000000  0000b7a0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000458  20000098  0000b838  00020098  2**2
                  ALLOC
  3 .stack        00002000  200004f0  0000bc90  00020098  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020098  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000200c0  2**0
                  CONTENTS, READONLY
  6 .debug_info   0005cbfe  00000000  00000000  00020119  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00008487  00000000  00000000  0007cd17  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0001af10  00000000  00000000  0008519e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001380  00000000  00000000  000a00ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001778  00000000  00000000  000a142e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00026f5b  00000000  00000000  000a2ba6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00023938  00000000  00000000  000c9b01  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0009d3a8  00000000  00000000  000ed439  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000041a0  00000000  00000000  0018a7e4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	200024f0 	.word	0x200024f0
       4:	00006545 	.word	0x00006545
       8:	00006541 	.word	0x00006541
       c:	00006541 	.word	0x00006541
	...
      2c:	00006541 	.word	0x00006541
	...
      38:	00006541 	.word	0x00006541
      3c:	00006541 	.word	0x00006541
      40:	00006541 	.word	0x00006541
      44:	00006541 	.word	0x00006541
      48:	00006541 	.word	0x00006541
      4c:	000046a5 	.word	0x000046a5
      50:	00004485 	.word	0x00004485
      54:	00006541 	.word	0x00006541
      58:	00006541 	.word	0x00006541
      5c:	00006541 	.word	0x00006541
      60:	00006541 	.word	0x00006541
      64:	00004ad5 	.word	0x00004ad5
      68:	00004ae5 	.word	0x00004ae5
      6c:	00004af5 	.word	0x00004af5
      70:	00004b05 	.word	0x00004b05
      74:	00004b15 	.word	0x00004b15
      78:	00004b25 	.word	0x00004b25
      7c:	00006511 	.word	0x00006511
      80:	00006521 	.word	0x00006521
      84:	00006531 	.word	0x00006531
      88:	00006541 	.word	0x00006541
      8c:	00006541 	.word	0x00006541
      90:	00006541 	.word	0x00006541
	...
      9c:	00006541 	.word	0x00006541
      a0:	00006541 	.word	0x00006541
      a4:	00006541 	.word	0x00006541
      a8:	00006541 	.word	0x00006541
      ac:	00006541 	.word	0x00006541
      b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
      b4:	b510      	push	{r4, lr}
      b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
      b8:	7823      	ldrb	r3, [r4, #0]
      ba:	2b00      	cmp	r3, #0
      bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
      be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
      c0:	2b00      	cmp	r3, #0
      c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
      c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
      c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
      c8:	bf00      	nop
      ca:	2301      	movs	r3, #1
      cc:	7023      	strb	r3, [r4, #0]
      ce:	bd10      	pop	{r4, pc}
      d0:	20000098 	.word	0x20000098
      d4:	00000000 	.word	0x00000000
      d8:	0000b7a0 	.word	0x0000b7a0

000000dc <frame_dummy>:
      dc:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
      de:	b510      	push	{r4, lr}
      e0:	2b00      	cmp	r3, #0
      e2:	d003      	beq.n	ec <frame_dummy+0x10>
      e4:	4907      	ldr	r1, [pc, #28]	; (104 <frame_dummy+0x28>)
      e6:	4808      	ldr	r0, [pc, #32]	; (108 <frame_dummy+0x2c>)
      e8:	e000      	b.n	ec <frame_dummy+0x10>
      ea:	bf00      	nop
      ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
      ee:	6803      	ldr	r3, [r0, #0]
      f0:	2b00      	cmp	r3, #0
      f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
      f4:	bd10      	pop	{r4, pc}
      f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
      f8:	2b00      	cmp	r3, #0
      fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
      fc:	4798      	blx	r3
      fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
     100:	00000000 	.word	0x00000000
     104:	2000009c 	.word	0x2000009c
     108:	0000b7a0 	.word	0x0000b7a0
     10c:	0000b7a0 	.word	0x0000b7a0
     110:	00000000 	.word	0x00000000

00000114 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
     114:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
     116:	4b07      	ldr	r3, [pc, #28]	; (134 <sd_mmc_configure_slot+0x20>)
     118:	6819      	ldr	r1, [r3, #0]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
     11a:	2322      	movs	r3, #34	; 0x22
/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
     11c:	5ccb      	ldrb	r3, [r1, r3]
     11e:	1e5a      	subs	r2, r3, #1
     120:	4193      	sbcs	r3, r2
     122:	b2db      	uxtb	r3, r3
     124:	7c4a      	ldrb	r2, [r1, #17]
     126:	6809      	ldr	r1, [r1, #0]
     128:	4803      	ldr	r0, [pc, #12]	; (138 <sd_mmc_configure_slot+0x24>)
     12a:	7800      	ldrb	r0, [r0, #0]
     12c:	4c03      	ldr	r4, [pc, #12]	; (13c <sd_mmc_configure_slot+0x28>)
     12e:	47a0      	blx	r4
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
}
     130:	bd10      	pop	{r4, pc}
     132:	46c0      	nop			; (mov r8, r8)
     134:	200000b8 	.word	0x200000b8
     138:	200000be 	.word	0x200000be
     13c:	00000d4d 	.word	0x00000d4d

00000140 <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
     140:	b510      	push	{r4, lr}
	if (slot >= SD_MMC_MEM_CNT) {
		return SD_MMC_ERR_SLOT;
     142:	2304      	movs	r3, #4
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
     144:	2800      	cmp	r0, #0
     146:	d171      	bne.n	22c <sd_mmc_select_slot+0xec>
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (port_pin_get_input_level(sd_mmc_cards[slot].cd_gpio)
     148:	4b39      	ldr	r3, [pc, #228]	; (230 <sd_mmc_select_slot+0xf0>)
     14a:	7a1b      	ldrb	r3, [r3, #8]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     14c:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
     14e:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
     150:	2900      	cmp	r1, #0
     152:	d104      	bne.n	15e <sd_mmc_select_slot+0x1e>
		return &(ports[port_index]->Group[group_index]);
     154:	095a      	lsrs	r2, r3, #5
     156:	01d2      	lsls	r2, r2, #7
     158:	4936      	ldr	r1, [pc, #216]	; (234 <sd_mmc_select_slot+0xf4>)
     15a:	468c      	mov	ip, r1
     15c:	4462      	add	r2, ip
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->IN.reg & pin_mask);
     15e:	6a11      	ldr	r1, [r2, #32]
     160:	221f      	movs	r2, #31
     162:	4013      	ands	r3, r2
     164:	3a1e      	subs	r2, #30
     166:	409a      	lsls	r2, r3
     168:	4211      	tst	r1, r2
     16a:	d00f      	beq.n	18c <sd_mmc_select_slot+0x4c>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
     16c:	4b30      	ldr	r3, [pc, #192]	; (230 <sd_mmc_select_slot+0xf0>)
     16e:	7b9b      	ldrb	r3, [r3, #14]
     170:	2b01      	cmp	r3, #1
     172:	d106      	bne.n	182 <sd_mmc_select_slot+0x42>
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
     174:	4b30      	ldr	r3, [pc, #192]	; (238 <sd_mmc_select_slot+0xf8>)
     176:	781b      	ldrb	r3, [r3, #0]
     178:	2b00      	cmp	r3, #0
     17a:	d002      	beq.n	182 <sd_mmc_select_slot+0x42>
		SysTick->CTRL = 0;
     17c:	2200      	movs	r2, #0
     17e:	4b2f      	ldr	r3, [pc, #188]	; (23c <sd_mmc_select_slot+0xfc>)
     180:	601a      	str	r2, [r3, #0]
	if (port_pin_get_input_level(sd_mmc_cards[slot].cd_gpio)
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
     182:	2204      	movs	r2, #4
     184:	4b2a      	ldr	r3, [pc, #168]	; (230 <sd_mmc_select_slot+0xf0>)
     186:	739a      	strb	r2, [r3, #14]
		return SD_MMC_ERR_NO_CARD;
     188:	2302      	movs	r3, #2
     18a:	e04f      	b.n	22c <sd_mmc_select_slot+0xec>
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
     18c:	4b28      	ldr	r3, [pc, #160]	; (230 <sd_mmc_select_slot+0xf0>)
     18e:	7b9a      	ldrb	r2, [r3, #14]
     190:	2a04      	cmp	r2, #4
     192:	d120      	bne.n	1d6 <sd_mmc_select_slot+0x96>
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
     194:	3a03      	subs	r2, #3
     196:	739a      	strb	r2, [r3, #14]
	static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
     198:	4b28      	ldr	r3, [pc, #160]	; (23c <sd_mmc_select_slot+0xfc>)
     19a:	681b      	ldr	r3, [r3, #0]
     19c:	2b00      	cmp	r3, #0
     19e:	d111      	bne.n	1c4 <sd_mmc_select_slot+0x84>
		sd_mmc_sam_systick_used = true;
     1a0:	2401      	movs	r4, #1
     1a2:	4b25      	ldr	r3, [pc, #148]	; (238 <sd_mmc_select_slot+0xf8>)
     1a4:	701c      	strb	r4, [r3, #0]
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
     1a6:	2000      	movs	r0, #0
     1a8:	4b25      	ldr	r3, [pc, #148]	; (240 <sd_mmc_select_slot+0x100>)
     1aa:	4798      	blx	r3
				* SD_MMC_DEBOUNCE_TIMEOUT;
     1ac:	21fa      	movs	r1, #250	; 0xfa
     1ae:	0149      	lsls	r1, r1, #5
     1b0:	4b24      	ldr	r3, [pc, #144]	; (244 <sd_mmc_select_slot+0x104>)
     1b2:	4798      	blx	r3
     1b4:	23fa      	movs	r3, #250	; 0xfa
     1b6:	009b      	lsls	r3, r3, #2
     1b8:	4358      	muls	r0, r3

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
     1ba:	4b20      	ldr	r3, [pc, #128]	; (23c <sd_mmc_select_slot+0xfc>)
     1bc:	6058      	str	r0, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
     1be:	601c      	str	r4, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
     1c0:	2302      	movs	r3, #2
     1c2:	e033      	b.n	22c <sd_mmc_select_slot+0xec>
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (system_gclk_gen_get_hz(0) / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
     1c4:	2200      	movs	r2, #0
     1c6:	4b1c      	ldr	r3, [pc, #112]	; (238 <sd_mmc_select_slot+0xf8>)
     1c8:	701a      	strb	r2, [r3, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
     1ca:	20fa      	movs	r0, #250	; 0xfa
     1cc:	0080      	lsls	r0, r0, #2
     1ce:	4b1e      	ldr	r3, [pc, #120]	; (248 <sd_mmc_select_slot+0x108>)
     1d0:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
     1d2:	2302      	movs	r3, #2
     1d4:	e02a      	b.n	22c <sd_mmc_select_slot+0xec>
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
     1d6:	2a01      	cmp	r2, #1
     1d8:	d10c      	bne.n	1f4 <sd_mmc_select_slot+0xb4>
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
     1da:	4b17      	ldr	r3, [pc, #92]	; (238 <sd_mmc_select_slot+0xf8>)
     1dc:	781b      	ldrb	r3, [r3, #0]
     1de:	2b00      	cmp	r3, #0
     1e0:	d019      	beq.n	216 <sd_mmc_select_slot+0xd6>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
     1e2:	4b16      	ldr	r3, [pc, #88]	; (23c <sd_mmc_select_slot+0xfc>)
     1e4:	681a      	ldr	r2, [r3, #0]
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
     1e6:	2302      	movs	r3, #2
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
     1e8:	03d2      	lsls	r2, r2, #15
     1ea:	d51f      	bpl.n	22c <sd_mmc_select_slot+0xec>
		SysTick->CTRL = 0;
     1ec:	2200      	movs	r2, #0
     1ee:	4b13      	ldr	r3, [pc, #76]	; (23c <sd_mmc_select_slot+0xfc>)
     1f0:	601a      	str	r2, [r3, #0]
     1f2:	e010      	b.n	216 <sd_mmc_select_slot+0xd6>
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
     1f4:	2303      	movs	r3, #3
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
     1f6:	2a03      	cmp	r2, #3
     1f8:	d018      	beq.n	22c <sd_mmc_select_slot+0xec>
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
     1fa:	2200      	movs	r2, #0
     1fc:	4b13      	ldr	r3, [pc, #76]	; (24c <sd_mmc_select_slot+0x10c>)
     1fe:	701a      	strb	r2, [r3, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
     200:	4c0b      	ldr	r4, [pc, #44]	; (230 <sd_mmc_select_slot+0xf0>)
     202:	4b13      	ldr	r3, [pc, #76]	; (250 <sd_mmc_select_slot+0x110>)
     204:	601c      	str	r4, [r3, #0]
	sd_mmc_configure_slot();
     206:	4b13      	ldr	r3, [pc, #76]	; (254 <sd_mmc_select_slot+0x114>)
     208:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
     20a:	7ba3      	ldrb	r3, [r4, #14]
     20c:	3b02      	subs	r3, #2
     20e:	425a      	negs	r2, r3
     210:	4153      	adcs	r3, r2
     212:	b2db      	uxtb	r3, r3
     214:	e00a      	b.n	22c <sd_mmc_select_slot+0xec>
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
     216:	4b06      	ldr	r3, [pc, #24]	; (230 <sd_mmc_select_slot+0xf0>)
     218:	2202      	movs	r2, #2
     21a:	739a      	strb	r2, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
     21c:	4a0e      	ldr	r2, [pc, #56]	; (258 <sd_mmc_select_slot+0x118>)
     21e:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
     220:	2201      	movs	r2, #1
     222:	745a      	strb	r2, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
     224:	2100      	movs	r1, #0
     226:	3221      	adds	r2, #33	; 0x21
     228:	5499      	strb	r1, [r3, r2]
     22a:	e7e6      	b.n	1fa <sd_mmc_select_slot+0xba>
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
}
     22c:	0018      	movs	r0, r3
     22e:	bd10      	pop	{r4, pc}
     230:	20000000 	.word	0x20000000
     234:	41004400 	.word	0x41004400
     238:	200000b6 	.word	0x200000b6
     23c:	e000e010 	.word	0xe000e010
     240:	00005c85 	.word	0x00005c85
     244:	000082fd 	.word	0x000082fd
     248:	00001195 	.word	0x00001195
     24c:	200000be 	.word	0x200000be
     250:	200000b8 	.word	0x200000b8
     254:	00000115 	.word	0x00000115
     258:	00061a80 	.word	0x00061a80

0000025c <sd_mmc_cmd13>:
 * This function waits the clear of the busy flag
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd13(void)
{
     25c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     25e:	4d09      	ldr	r5, [pc, #36]	; (284 <sd_mmc_cmd13+0x28>)
	 * 200 000 * 8 cycles
	 */
	nec_timeout = 200000;
	do {
		if (sd_mmc_is_spi()) {
			if (!driver_send_cmd(SDMMC_SPI_CMD13_SEND_STATUS, 0)) {
     260:	4f09      	ldr	r7, [pc, #36]	; (288 <sd_mmc_cmd13+0x2c>)
				return false;
			}
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
     262:	4e0a      	ldr	r6, [pc, #40]	; (28c <sd_mmc_cmd13+0x30>)
	 * 200 000 * 8 cycles
	 */
	nec_timeout = 200000;
	do {
		if (sd_mmc_is_spi()) {
			if (!driver_send_cmd(SDMMC_SPI_CMD13_SEND_STATUS, 0)) {
     264:	2100      	movs	r1, #0
     266:	480a      	ldr	r0, [pc, #40]	; (290 <sd_mmc_cmd13+0x34>)
     268:	47b8      	blx	r7
     26a:	1e04      	subs	r4, r0, #0
     26c:	d007      	beq.n	27e <sd_mmc_cmd13+0x22>
				return false;
			}
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
     26e:	47b0      	blx	r6
     270:	23ff      	movs	r3, #255	; 0xff
     272:	4203      	tst	r3, r0
     274:	d003      	beq.n	27e <sd_mmc_cmd13+0x22>
     276:	3d01      	subs	r5, #1
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
				break;
			}
		}
		if (nec_timeout-- == 0) {
     278:	2d00      	cmp	r5, #0
     27a:	d1f3      	bne.n	264 <sd_mmc_cmd13+0x8>
			sd_mmc_debug("%s: CMD13 Busy timeout\n\r", __func__);
			return false;
     27c:	2400      	movs	r4, #0
		}
	} while (1);

	return true;
}
     27e:	0020      	movs	r0, r4
     280:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     282:	46c0      	nop			; (mov r8, r8)
     284:	00030d41 	.word	0x00030d41
     288:	00000f89 	.word	0x00000f89
     28c:	00000fa1 	.word	0x00000fa1
     290:	00001b0d 	.word	0x00001b0d

00000294 <sd_mmc_cmd9_spi>:
 * data (CSD) on the CMD line spi.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_spi(void)
{
     294:	b510      	push	{r4, lr}
     296:	b082      	sub	sp, #8
	if (!driver_adtc_start(SDMMC_SPI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16,
     298:	4b0b      	ldr	r3, [pc, #44]	; (2c8 <sd_mmc_cmd9_spi+0x34>)
     29a:	681b      	ldr	r3, [r3, #0]
     29c:	8999      	ldrh	r1, [r3, #12]
     29e:	0409      	lsls	r1, r1, #16
     2a0:	2301      	movs	r3, #1
     2a2:	9300      	str	r3, [sp, #0]
     2a4:	2210      	movs	r2, #16
     2a6:	4809      	ldr	r0, [pc, #36]	; (2cc <sd_mmc_cmd9_spi+0x38>)
     2a8:	4c09      	ldr	r4, [pc, #36]	; (2d0 <sd_mmc_cmd9_spi+0x3c>)
     2aa:	47a0      	blx	r4
     2ac:	2800      	cmp	r0, #0
     2ae:	d009      	beq.n	2c4 <sd_mmc_cmd9_spi+0x30>
			CSD_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(sd_mmc_card->csd, 1)) {
     2b0:	4b05      	ldr	r3, [pc, #20]	; (2c8 <sd_mmc_cmd9_spi+0x34>)
     2b2:	6818      	ldr	r0, [r3, #0]
     2b4:	3012      	adds	r0, #18
     2b6:	2101      	movs	r1, #1
     2b8:	4b06      	ldr	r3, [pc, #24]	; (2d4 <sd_mmc_cmd9_spi+0x40>)
     2ba:	4798      	blx	r3
     2bc:	2800      	cmp	r0, #0
     2be:	d001      	beq.n	2c4 <sd_mmc_cmd9_spi+0x30>
		return false;
	}
	return driver_wait_end_of_read_blocks();
     2c0:	4b05      	ldr	r3, [pc, #20]	; (2d8 <sd_mmc_cmd9_spi+0x44>)
     2c2:	4798      	blx	r3
}
     2c4:	b002      	add	sp, #8
     2c6:	bd10      	pop	{r4, pc}
     2c8:	200000b8 	.word	0x200000b8
     2cc:	00081109 	.word	0x00081109
     2d0:	00000e01 	.word	0x00000e01
     2d4:	00001021 	.word	0x00001021
     2d8:	000010a5 	.word	0x000010a5

000002dc <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
     2dc:	b510      	push	{r4, lr}
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
     2de:	4b04      	ldr	r3, [pc, #16]	; (2f0 <sd_mmc_deselect_slot+0x14>)
     2e0:	781b      	ldrb	r3, [r3, #0]
     2e2:	2b00      	cmp	r3, #0
     2e4:	d102      	bne.n	2ec <sd_mmc_deselect_slot+0x10>
		driver_deselect_device(sd_mmc_slot_sel);
     2e6:	2000      	movs	r0, #0
     2e8:	4b02      	ldr	r3, [pc, #8]	; (2f4 <sd_mmc_deselect_slot+0x18>)
     2ea:	4798      	blx	r3
	}
}
     2ec:	bd10      	pop	{r4, pc}
     2ee:	46c0      	nop			; (mov r8, r8)
     2f0:	200000be 	.word	0x200000be
     2f4:	00000da1 	.word	0x00000da1

000002f8 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
     2f8:	b5f0      	push	{r4, r5, r6, r7, lr}
     2fa:	b089      	sub	sp, #36	; 0x24
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
     2fc:	4bcd      	ldr	r3, [pc, #820]	; (634 <sd_mmc_check+0x33c>)
     2fe:	4798      	blx	r3
     300:	1e04      	subs	r4, r0, #0
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
     302:	2c01      	cmp	r4, #1
     304:	d003      	beq.n	30e <sd_mmc_check+0x16>
		sd_mmc_deselect_slot();
     306:	4bcc      	ldr	r3, [pc, #816]	; (638 <sd_mmc_check+0x340>)
     308:	4798      	blx	r3
		return sd_mmc_err;
     30a:	0020      	movs	r0, r4
     30c:	e23c      	b.n	788 <sd_mmc_check+0x490>
static bool sd_mmc_spi_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
     30e:	4bcb      	ldr	r3, [pc, #812]	; (63c <sd_mmc_check+0x344>)
     310:	681b      	ldr	r3, [r3, #0]
     312:	2201      	movs	r2, #1
     314:	73da      	strb	r2, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
     316:	2200      	movs	r2, #0
     318:	741a      	strb	r2, [r3, #16]
	sd_mmc_card->rca = 0;
     31a:	819a      	strh	r2, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
     31c:	4bc8      	ldr	r3, [pc, #800]	; (640 <sd_mmc_check+0x348>)
     31e:	4798      	blx	r3

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
     320:	2100      	movs	r1, #0
     322:	2088      	movs	r0, #136	; 0x88
     324:	0140      	lsls	r0, r0, #5
     326:	4bc7      	ldr	r3, [pc, #796]	; (644 <sd_mmc_check+0x34c>)
     328:	4798      	blx	r3
     32a:	2800      	cmp	r0, #0
     32c:	d100      	bne.n	330 <sd_mmc_check+0x38>
     32e:	e1dc      	b.n	6ea <sd_mmc_check+0x3f2>
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
     330:	21d5      	movs	r1, #213	; 0xd5
     332:	0049      	lsls	r1, r1, #1
     334:	48c4      	ldr	r0, [pc, #784]	; (648 <sd_mmc_check+0x350>)
     336:	4bc3      	ldr	r3, [pc, #780]	; (644 <sd_mmc_check+0x34c>)
     338:	4798      	blx	r3
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
     33a:	2500      	movs	r5, #0
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
     33c:	2800      	cmp	r0, #0
     33e:	d100      	bne.n	342 <sd_mmc_check+0x4a>
     340:	e1dc      	b.n	6fc <sd_mmc_check+0x404>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
     342:	4bc2      	ldr	r3, [pc, #776]	; (64c <sd_mmc_check+0x354>)
     344:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
     346:	1c43      	adds	r3, r0, #1
     348:	d100      	bne.n	34c <sd_mmc_check+0x54>
     34a:	e1d6      	b.n	6fa <sd_mmc_check+0x402>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
     34c:	0500      	lsls	r0, r0, #20
     34e:	0d00      	lsrs	r0, r0, #20
     350:	23d5      	movs	r3, #213	; 0xd5
     352:	005b      	lsls	r3, r3, #1
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
     354:	3501      	adds	r5, #1
	resp = driver_get_response();
	if (resp == 0xFFFFFFFF) {
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
     356:	4298      	cmp	r0, r3
     358:	d100      	bne.n	35c <sd_mmc_check+0x64>
     35a:	e1cf      	b.n	6fc <sd_mmc_check+0x404>
     35c:	e1c5      	b.n	6ea <sd_mmc_check+0x3f2>
	 */
	retry = 7150;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
     35e:	2100      	movs	r1, #0
     360:	48bb      	ldr	r0, [pc, #748]	; (650 <sd_mmc_check+0x358>)
     362:	47b0      	blx	r6
     364:	2800      	cmp	r0, #0
     366:	d100      	bne.n	36a <sd_mmc_check+0x72>
     368:	e1d6      	b.n	718 <sd_mmc_check+0x420>
		arg = 0;
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_SPI_ACMD41_SD_SEND_OP_COND, arg)) {
     36a:	9903      	ldr	r1, [sp, #12]
     36c:	48b9      	ldr	r0, [pc, #740]	; (654 <sd_mmc_check+0x35c>)
     36e:	47b8      	blx	r7
     370:	2800      	cmp	r0, #0
     372:	d100      	bne.n	376 <sd_mmc_check+0x7e>
     374:	e1d0      	b.n	718 <sd_mmc_check+0x420>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
     376:	47a8      	blx	r5
		if (!(resp & R1_SPI_IDLE)) {
     378:	07c3      	lsls	r3, r0, #31
     37a:	d503      	bpl.n	384 <sd_mmc_check+0x8c>
     37c:	3c01      	subs	r4, #1
			// Card is ready
			break;
		}
		if (retry-- == 0) {
     37e:	2c00      	cmp	r4, #0
     380:	d1ed      	bne.n	35e <sd_mmc_check+0x66>
     382:	e1c9      	b.n	718 <sd_mmc_check+0x420>
			return false;
		}
	} while (1);

	// Read OCR for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
     384:	2100      	movs	r1, #0
     386:	48b4      	ldr	r0, [pc, #720]	; (658 <sd_mmc_check+0x360>)
     388:	4bae      	ldr	r3, [pc, #696]	; (644 <sd_mmc_check+0x34c>)
     38a:	4798      	blx	r3
     38c:	2800      	cmp	r0, #0
     38e:	d100      	bne.n	392 <sd_mmc_check+0x9a>
     390:	e1c2      	b.n	718 <sd_mmc_check+0x420>
		sd_mmc_debug("%s: CMD58 Fail\n\r", __func__);
		return false;
	}
	if ((driver_get_response() & OCR_CCS) != 0) {
     392:	4bae      	ldr	r3, [pc, #696]	; (64c <sd_mmc_check+0x354>)
     394:	4798      	blx	r3
     396:	0043      	lsls	r3, r0, #1
     398:	d400      	bmi.n	39c <sd_mmc_check+0xa4>
     39a:	e1c9      	b.n	730 <sd_mmc_check+0x438>
		sd_mmc_card->type |= CARD_TYPE_HC;
     39c:	4ba7      	ldr	r3, [pc, #668]	; (63c <sd_mmc_check+0x344>)
     39e:	681a      	ldr	r2, [r3, #0]
     3a0:	7bd1      	ldrb	r1, [r2, #15]
     3a2:	2308      	movs	r3, #8
     3a4:	430b      	orrs	r3, r1
     3a6:	73d3      	strb	r3, [r2, #15]
     3a8:	e1c2      	b.n	730 <sd_mmc_check+0x438>
static bool sd_mmc_spi_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
     3aa:	4cac      	ldr	r4, [pc, #688]	; (65c <sd_mmc_check+0x364>)
	 * 6 = cmd byte size
	 * 1 = response byte size
	 */
	retry = 7150;
	do {
		if (!driver_send_cmd(MMC_SPI_CMD1_SEND_OP_COND, 0)) {
     3ac:	4dac      	ldr	r5, [pc, #688]	; (660 <sd_mmc_check+0x368>)
     3ae:	4ea5      	ldr	r6, [pc, #660]	; (644 <sd_mmc_check+0x34c>)
			sd_mmc_debug("%s: CMD1 SPI Fail - Busy retry %d\n\r",
					__func__, (int)(7150 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
     3b0:	4fa6      	ldr	r7, [pc, #664]	; (64c <sd_mmc_check+0x354>)
	 * 6 = cmd byte size
	 * 1 = response byte size
	 */
	retry = 7150;
	do {
		if (!driver_send_cmd(MMC_SPI_CMD1_SEND_OP_COND, 0)) {
     3b2:	2100      	movs	r1, #0
     3b4:	0028      	movs	r0, r5
     3b6:	47b0      	blx	r6
     3b8:	2800      	cmp	r0, #0
     3ba:	d100      	bne.n	3be <sd_mmc_check+0xc6>
     3bc:	e195      	b.n	6ea <sd_mmc_check+0x3f2>
			sd_mmc_debug("%s: CMD1 SPI Fail - Busy retry %d\n\r",
					__func__, (int)(7150 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
     3be:	47b8      	blx	r7
		if (!(resp & R1_SPI_IDLE)) {
     3c0:	07c3      	lsls	r3, r0, #31
     3c2:	d503      	bpl.n	3cc <sd_mmc_check+0xd4>
     3c4:	3c01      	subs	r4, #1
			break;
		}
		if (retry-- == 0) {
     3c6:	2c00      	cmp	r4, #0
     3c8:	d1f3      	bne.n	3b2 <sd_mmc_check+0xba>
     3ca:	e18e      	b.n	6ea <sd_mmc_check+0x3f2>
			return false;
		}
	} while (1);

	// Read OCR for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD58_READ_OCR, 0)) {
     3cc:	2100      	movs	r1, #0
     3ce:	48a2      	ldr	r0, [pc, #648]	; (658 <sd_mmc_check+0x360>)
     3d0:	4b9c      	ldr	r3, [pc, #624]	; (644 <sd_mmc_check+0x34c>)
     3d2:	4798      	blx	r3
     3d4:	2800      	cmp	r0, #0
     3d6:	d100      	bne.n	3da <sd_mmc_check+0xe2>
     3d8:	e187      	b.n	6ea <sd_mmc_check+0x3f2>
		sd_mmc_debug("%s: CMD58 Fail\n\r", __func__);
		return false;
	}
	// Check OCR value
	if ((driver_get_response() & OCR_ACCESS_MODE_MASK)
     3da:	4b9c      	ldr	r3, [pc, #624]	; (64c <sd_mmc_check+0x354>)
     3dc:	4798      	blx	r3
     3de:	23c0      	movs	r3, #192	; 0xc0
     3e0:	05db      	lsls	r3, r3, #23
     3e2:	4018      	ands	r0, r3
     3e4:	2380      	movs	r3, #128	; 0x80
     3e6:	05db      	lsls	r3, r3, #23
     3e8:	4298      	cmp	r0, r3
     3ea:	d000      	beq.n	3ee <sd_mmc_check+0xf6>
     3ec:	e1a8      	b.n	740 <sd_mmc_check+0x448>
			== OCR_ACCESS_MODE_SECTOR) {
		sd_mmc_card->type |= CARD_TYPE_HC;
     3ee:	4b93      	ldr	r3, [pc, #588]	; (63c <sd_mmc_check+0x344>)
     3f0:	681a      	ldr	r2, [r3, #0]
     3f2:	7bd3      	ldrb	r3, [r2, #15]
     3f4:	2108      	movs	r1, #8
     3f6:	430b      	orrs	r3, r1
     3f8:	73d3      	strb	r3, [r2, #15]
     3fa:	e1a1      	b.n	740 <sd_mmc_check+0x448>
	// Disable CRC check for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_spi()) {
     3fc:	4b99      	ldr	r3, [pc, #612]	; (664 <sd_mmc_check+0x36c>)
     3fe:	4798      	blx	r3
     400:	2800      	cmp	r0, #0
     402:	d100      	bne.n	406 <sd_mmc_check+0x10e>
     404:	e171      	b.n	6ea <sd_mmc_check+0x3f2>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
     406:	4b8d      	ldr	r3, [pc, #564]	; (63c <sd_mmc_check+0x344>)
     408:	6819      	ldr	r1, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     40a:	7c8b      	ldrb	r3, [r1, #18]
     40c:	069b      	lsls	r3, r3, #26
     40e:	0f1b      	lsrs	r3, r3, #28
     410:	2b02      	cmp	r3, #2
     412:	d00d      	beq.n	430 <sd_mmc_check+0x138>
     414:	d802      	bhi.n	41c <sd_mmc_check+0x124>
     416:	2b01      	cmp	r3, #1
     418:	d007      	beq.n	42a <sd_mmc_check+0x132>
     41a:	e003      	b.n	424 <sd_mmc_check+0x12c>
     41c:	2b03      	cmp	r3, #3
     41e:	d00a      	beq.n	436 <sd_mmc_check+0x13e>
     420:	2b04      	cmp	r3, #4
     422:	d00b      	beq.n	43c <sd_mmc_check+0x144>
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
     424:	2312      	movs	r3, #18
     426:	740b      	strb	r3, [r1, #16]
     428:	e00a      	b.n	440 <sd_mmc_check+0x148>
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
     42a:	2314      	movs	r3, #20
     42c:	740b      	strb	r3, [r1, #16]
     42e:	e007      	b.n	440 <sd_mmc_check+0x148>
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
     430:	2322      	movs	r3, #34	; 0x22
     432:	740b      	strb	r3, [r1, #16]
     434:	e004      	b.n	440 <sd_mmc_check+0x148>
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
     436:	2330      	movs	r3, #48	; 0x30
     438:	740b      	strb	r3, [r1, #16]
     43a:	e001      	b.n	440 <sd_mmc_check+0x148>
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
     43c:	2340      	movs	r3, #64	; 0x40
     43e:	740b      	strb	r3, [r1, #16]
     440:	7d48      	ldrb	r0, [r1, #21]
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
     442:	0642      	lsls	r2, r0, #25
     444:	0f12      	lsrs	r2, r2, #28
     446:	0092      	lsls	r2, r2, #2
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
     448:	2307      	movs	r3, #7
     44a:	4003      	ands	r3, r0
     44c:	009b      	lsls	r3, r3, #2
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
     44e:	4886      	ldr	r0, [pc, #536]	; (668 <sd_mmc_check+0x370>)
     450:	5818      	ldr	r0, [r3, r0]
     452:	23fa      	movs	r3, #250	; 0xfa
     454:	009b      	lsls	r3, r3, #2
     456:	4343      	muls	r3, r0
     458:	4884      	ldr	r0, [pc, #528]	; (66c <sd_mmc_check+0x374>)
     45a:	5812      	ldr	r2, [r2, r0]
     45c:	4353      	muls	r3, r2
     45e:	600b      	str	r3, [r1, #0]
     460:	7e8b      	ldrb	r3, [r1, #26]
     462:	119a      	asrs	r2, r3, #6
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
     464:	7e4b      	ldrb	r3, [r1, #25]
     466:	0098      	lsls	r0, r3, #2
     468:	7e0b      	ldrb	r3, [r1, #24]
     46a:	029b      	lsls	r3, r3, #10
     46c:	4303      	orrs	r3, r0
     46e:	4313      	orrs	r3, r2
	}
	value &=  ((uint32_t)1 << size) - 1;
     470:	051b      	lsls	r3, r3, #20
     472:	0d1b      	lsrs	r3, r3, #20
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
     474:	4a7e      	ldr	r2, [pc, #504]	; (670 <sd_mmc_check+0x378>)
     476:	4293      	cmp	r3, r2
     478:	d010      	beq.n	49c <sd_mmc_check+0x1a4>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     47a:	7f08      	ldrb	r0, [r1, #28]
     47c:	11c4      	asrs	r4, r0, #7
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
     47e:	7eca      	ldrb	r2, [r1, #27]
     480:	0052      	lsls	r2, r2, #1
     482:	4322      	orrs	r2, r4
     484:	0010      	movs	r0, r2
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
     486:	3301      	adds	r3, #1
     488:	2207      	movs	r2, #7
     48a:	4002      	ands	r2, r0
     48c:	3202      	adds	r2, #2
     48e:	4093      	lsls	r3, r2
     490:	7dc8      	ldrb	r0, [r1, #23]
     492:	220f      	movs	r2, #15
     494:	4002      	ands	r2, r0
     496:	4093      	lsls	r3, r2
     498:	0a9b      	lsrs	r3, r3, #10
     49a:	604b      	str	r3, [r1, #4]
	if (!sd_mmc_cmd9_spi()) {
		return false;
	}
	mmc_decode_csd();
	// For MMC 4.0 Higher version
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
     49c:	7c0b      	ldrb	r3, [r1, #16]
     49e:	2b3f      	cmp	r3, #63	; 0x3f
     4a0:	d93e      	bls.n	520 <sd_mmc_check+0x228>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
     4a2:	2100      	movs	r1, #0
     4a4:	9100      	str	r1, [sp, #0]
     4a6:	2301      	movs	r3, #1
     4a8:	2280      	movs	r2, #128	; 0x80
     4aa:	0092      	lsls	r2, r2, #2
     4ac:	4871      	ldr	r0, [pc, #452]	; (674 <sd_mmc_check+0x37c>)
     4ae:	4c72      	ldr	r4, [pc, #456]	; (678 <sd_mmc_check+0x380>)
     4b0:	47a0      	blx	r4
     4b2:	2800      	cmp	r0, #0
     4b4:	d100      	bne.n	4b8 <sd_mmc_check+0x1c0>
     4b6:	e118      	b.n	6ea <sd_mmc_check+0x3f2>
     4b8:	2400      	movs	r4, #0
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
     4ba:	4d70      	ldr	r5, [pc, #448]	; (67c <sd_mmc_check+0x384>)
     4bc:	a805      	add	r0, sp, #20
     4be:	47a8      	blx	r5
     4c0:	2800      	cmp	r0, #0
     4c2:	d100      	bne.n	4c6 <sd_mmc_check+0x1ce>
     4c4:	e111      	b.n	6ea <sd_mmc_check+0x3f2>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
     4c6:	3401      	adds	r4, #1
     4c8:	b2a4      	uxth	r4, r4
     4ca:	2c32      	cmp	r4, #50	; 0x32
     4cc:	d1f6      	bne.n	4bc <sd_mmc_check+0x1c4>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
     4ce:	4b5b      	ldr	r3, [pc, #364]	; (63c <sd_mmc_check+0x344>)
     4d0:	6818      	ldr	r0, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     4d2:	7e83      	ldrb	r3, [r0, #26]
     4d4:	119a      	asrs	r2, r3, #6
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
     4d6:	7e43      	ldrb	r3, [r0, #25]
     4d8:	0099      	lsls	r1, r3, #2
     4da:	7e03      	ldrb	r3, [r0, #24]
     4dc:	029b      	lsls	r3, r3, #10
     4de:	430b      	orrs	r3, r1
     4e0:	4313      	orrs	r3, r2
     4e2:	051b      	lsls	r3, r3, #20
     4e4:	0d1b      	lsrs	r3, r3, #20
     4e6:	4a62      	ldr	r2, [pc, #392]	; (670 <sd_mmc_check+0x378>)
     4e8:	4293      	cmp	r3, r2
     4ea:	d117      	bne.n	51c <sd_mmc_check+0x224>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
     4ec:	4d63      	ldr	r5, [pc, #396]	; (67c <sd_mmc_check+0x384>)
     4ee:	a806      	add	r0, sp, #24
     4f0:	47a8      	blx	r5
     4f2:	2800      	cmp	r0, #0
     4f4:	d100      	bne.n	4f8 <sd_mmc_check+0x200>
     4f6:	e0f8      	b.n	6ea <sd_mmc_check+0x3f2>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
     4f8:	3401      	adds	r4, #1
     4fa:	b2a4      	uxth	r4, r4
     4fc:	2c35      	cmp	r4, #53	; 0x35
     4fe:	d9f6      	bls.n	4ee <sd_mmc_check+0x1f6>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
     500:	4b4e      	ldr	r3, [pc, #312]	; (63c <sd_mmc_check+0x344>)
     502:	681a      	ldr	r2, [r3, #0]
     504:	9b06      	ldr	r3, [sp, #24]
     506:	085b      	lsrs	r3, r3, #1
     508:	6053      	str	r3, [r2, #4]
     50a:	e007      	b.n	51c <sd_mmc_check+0x224>
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
     50c:	a806      	add	r0, sp, #24
     50e:	4b5b      	ldr	r3, [pc, #364]	; (67c <sd_mmc_check+0x384>)
     510:	4798      	blx	r3
     512:	2800      	cmp	r0, #0
     514:	d100      	bne.n	518 <sd_mmc_check+0x220>
     516:	e0e8      	b.n	6ea <sd_mmc_check+0x3f2>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
     518:	3401      	adds	r4, #1
     51a:	b2a4      	uxth	r4, r4
     51c:	2c7f      	cmp	r4, #127	; 0x7f
     51e:	d9f5      	bls.n	50c <sd_mmc_check+0x214>
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
	}
	// Set default block size
	if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
     520:	2180      	movs	r1, #128	; 0x80
     522:	0089      	lsls	r1, r1, #2
     524:	4856      	ldr	r0, [pc, #344]	; (680 <sd_mmc_check+0x388>)
     526:	4b47      	ldr	r3, [pc, #284]	; (644 <sd_mmc_check+0x34c>)
     528:	4798      	blx	r3
     52a:	2800      	cmp	r0, #0
     52c:	d100      	bne.n	530 <sd_mmc_check+0x238>
     52e:	e0dc      	b.n	6ea <sd_mmc_check+0x3f2>
		return false;
	}
	// Check communication
	if (!sd_mmc_cmd13()) {
     530:	4b54      	ldr	r3, [pc, #336]	; (684 <sd_mmc_check+0x38c>)
     532:	4798      	blx	r3
     534:	2800      	cmp	r0, #0
     536:	d100      	bne.n	53a <sd_mmc_check+0x242>
     538:	e0d7      	b.n	6ea <sd_mmc_check+0x3f2>
		return false;
	}
	// Reinitialize the slot with the new speed
	sd_mmc_configure_slot();
     53a:	4b53      	ldr	r3, [pc, #332]	; (688 <sd_mmc_check+0x390>)
     53c:	4798      	blx	r3
     53e:	e113      	b.n	768 <sd_mmc_check+0x470>
		if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
			return false;
		}
	}
	// SD MEMORY
	if (sd_mmc_card->type & CARD_TYPE_SD) {
     540:	4b3e      	ldr	r3, [pc, #248]	; (63c <sd_mmc_check+0x344>)
     542:	681b      	ldr	r3, [r3, #0]
     544:	7bdb      	ldrb	r3, [r3, #15]
     546:	07da      	lsls	r2, r3, #31
     548:	d400      	bmi.n	54c <sd_mmc_check+0x254>
     54a:	e108      	b.n	75e <sd_mmc_check+0x466>
		// Get the Card-Specific Data
		if (!sd_mmc_cmd9_spi()) {
     54c:	4b45      	ldr	r3, [pc, #276]	; (664 <sd_mmc_check+0x36c>)
     54e:	4798      	blx	r3
     550:	2800      	cmp	r0, #0
     552:	d100      	bne.n	556 <sd_mmc_check+0x25e>
     554:	e0c9      	b.n	6ea <sd_mmc_check+0x3f2>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
     556:	4b39      	ldr	r3, [pc, #228]	; (63c <sd_mmc_check+0x344>)
     558:	681b      	ldr	r3, [r3, #0]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     55a:	7d5a      	ldrb	r2, [r3, #21]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
     55c:	0651      	lsls	r1, r2, #25
     55e:	0f09      	lsrs	r1, r1, #28
     560:	0089      	lsls	r1, r1, #2
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
     562:	2007      	movs	r0, #7
     564:	4002      	ands	r2, r0
     566:	0092      	lsls	r2, r2, #2
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
     568:	483f      	ldr	r0, [pc, #252]	; (668 <sd_mmc_check+0x370>)
     56a:	5810      	ldr	r0, [r2, r0]
     56c:	22fa      	movs	r2, #250	; 0xfa
     56e:	0092      	lsls	r2, r2, #2
     570:	4342      	muls	r2, r0
     572:	4846      	ldr	r0, [pc, #280]	; (68c <sd_mmc_check+0x394>)
     574:	5809      	ldr	r1, [r1, r0]
     576:	434a      	muls	r2, r1
     578:	601a      	str	r2, [r3, #0]
     57a:	7c9a      	ldrb	r2, [r3, #18]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
     57c:	1192      	asrs	r2, r2, #6
     57e:	d00e      	beq.n	59e <sd_mmc_check+0x2a6>
     580:	7ed9      	ldrb	r1, [r3, #27]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
     582:	7e9a      	ldrb	r2, [r3, #26]
     584:	0210      	lsls	r0, r2, #8
     586:	7e5a      	ldrb	r2, [r3, #25]
     588:	0412      	lsls	r2, r2, #16
     58a:	4302      	orrs	r2, r0
     58c:	430a      	orrs	r2, r1
		sd_mmc_card->capacity =
     58e:	0292      	lsls	r2, r2, #10
     590:	0852      	lsrs	r2, r2, #1
     592:	2180      	movs	r1, #128	; 0x80
     594:	0089      	lsls	r1, r1, #2
     596:	468c      	mov	ip, r1
     598:	4462      	add	r2, ip
     59a:	605a      	str	r2, [r3, #4]
     59c:	e019      	b.n	5d2 <sd_mmc_check+0x2da>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     59e:	7e9a      	ldrb	r2, [r3, #26]
     5a0:	1191      	asrs	r1, r2, #6
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
     5a2:	7e5a      	ldrb	r2, [r3, #25]
     5a4:	0090      	lsls	r0, r2, #2
     5a6:	7e1a      	ldrb	r2, [r3, #24]
     5a8:	0292      	lsls	r2, r2, #10
     5aa:	4302      	orrs	r2, r0
     5ac:	430a      	orrs	r2, r1
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     5ae:	7f19      	ldrb	r1, [r3, #28]
     5b0:	11c8      	asrs	r0, r1, #7
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
     5b2:	7ed9      	ldrb	r1, [r3, #27]
     5b4:	0049      	lsls	r1, r1, #1
     5b6:	4301      	orrs	r1, r0
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
     5b8:	0512      	lsls	r2, r2, #20
     5ba:	0d12      	lsrs	r2, r2, #20
     5bc:	3201      	adds	r2, #1
     5be:	2007      	movs	r0, #7
     5c0:	4001      	ands	r1, r0
     5c2:	3102      	adds	r1, #2
     5c4:	408a      	lsls	r2, r1
     5c6:	7dd9      	ldrb	r1, [r3, #23]
     5c8:	3008      	adds	r0, #8
     5ca:	4001      	ands	r1, r0
     5cc:	408a      	lsls	r2, r1
     5ce:	0a92      	lsrs	r2, r2, #10
     5d0:	605a      	str	r2, [r3, #4]
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
     5d2:	8999      	ldrh	r1, [r3, #12]
     5d4:	0409      	lsls	r1, r1, #16
     5d6:	481e      	ldr	r0, [pc, #120]	; (650 <sd_mmc_check+0x358>)
     5d8:	4b1a      	ldr	r3, [pc, #104]	; (644 <sd_mmc_check+0x34c>)
     5da:	4798      	blx	r3
     5dc:	2800      	cmp	r0, #0
     5de:	d100      	bne.n	5e2 <sd_mmc_check+0x2ea>
     5e0:	e083      	b.n	6ea <sd_mmc_check+0x3f2>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
     5e2:	2301      	movs	r3, #1
     5e4:	9300      	str	r3, [sp, #0]
     5e6:	2208      	movs	r2, #8
     5e8:	2100      	movs	r1, #0
     5ea:	4829      	ldr	r0, [pc, #164]	; (690 <sd_mmc_check+0x398>)
     5ec:	4c22      	ldr	r4, [pc, #136]	; (678 <sd_mmc_check+0x380>)
     5ee:	47a0      	blx	r4
     5f0:	2800      	cmp	r0, #0
     5f2:	d07a      	beq.n	6ea <sd_mmc_check+0x3f2>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
     5f4:	2101      	movs	r1, #1
     5f6:	a806      	add	r0, sp, #24
     5f8:	4b26      	ldr	r3, [pc, #152]	; (694 <sd_mmc_check+0x39c>)
     5fa:	4798      	blx	r3
     5fc:	2800      	cmp	r0, #0
     5fe:	d074      	beq.n	6ea <sd_mmc_check+0x3f2>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
     600:	4b25      	ldr	r3, [pc, #148]	; (698 <sd_mmc_check+0x3a0>)
     602:	4798      	blx	r3
     604:	2800      	cmp	r0, #0
     606:	d070      	beq.n	6ea <sd_mmc_check+0x3f2>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
     608:	ab06      	add	r3, sp, #24
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
     60a:	781a      	ldrb	r2, [r3, #0]
     60c:	230f      	movs	r3, #15
     60e:	4013      	ands	r3, r2
     610:	2b01      	cmp	r3, #1
     612:	d009      	beq.n	628 <sd_mmc_check+0x330>
     614:	2b00      	cmp	r3, #0
     616:	d002      	beq.n	61e <sd_mmc_check+0x326>
     618:	2b02      	cmp	r3, #2
     61a:	d03f      	beq.n	69c <sd_mmc_check+0x3a4>
     61c:	e04d      	b.n	6ba <sd_mmc_check+0x3c2>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
     61e:	4b07      	ldr	r3, [pc, #28]	; (63c <sd_mmc_check+0x344>)
     620:	681b      	ldr	r3, [r3, #0]
     622:	2210      	movs	r2, #16
     624:	741a      	strb	r2, [r3, #16]
     626:	e092      	b.n	74e <sd_mmc_check+0x456>
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
     628:	4b04      	ldr	r3, [pc, #16]	; (63c <sd_mmc_check+0x344>)
     62a:	681b      	ldr	r3, [r3, #0]
     62c:	221a      	movs	r2, #26
     62e:	741a      	strb	r2, [r3, #16]
     630:	e08d      	b.n	74e <sd_mmc_check+0x456>
     632:	46c0      	nop			; (mov r8, r8)
     634:	00000141 	.word	0x00000141
     638:	000002dd 	.word	0x000002dd
     63c:	200000b8 	.word	0x200000b8
     640:	00000dc9 	.word	0x00000dc9
     644:	00000f89 	.word	0x00000f89
     648:	00005508 	.word	0x00005508
     64c:	00000fa1 	.word	0x00000fa1
     650:	00001137 	.word	0x00001137
     654:	00001129 	.word	0x00001129
     658:	0000053a 	.word	0x0000053a
     65c:	00001bef 	.word	0x00001bef
     660:	00001101 	.word	0x00001101
     664:	00000295 	.word	0x00000295
     668:	00009dd8 	.word	0x00009dd8
     66c:	00009df4 	.word	0x00009df4
     670:	00000fff 	.word	0x00000fff
     674:	00081108 	.word	0x00081108
     678:	00000e01 	.word	0x00000e01
     67c:	00000fad 	.word	0x00000fad
     680:	00001110 	.word	0x00001110
     684:	0000025d 	.word	0x0000025d
     688:	00000115 	.word	0x00000115
     68c:	00009d98 	.word	0x00009d98
     690:	00081133 	.word	0x00081133
     694:	00001021 	.word	0x00001021
     698:	000010a5 	.word	0x000010a5
     69c:	ab06      	add	r3, sp, #24
     69e:	789b      	ldrb	r3, [r3, #2]
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
     6a0:	11db      	asrs	r3, r3, #7
     6a2:	2b01      	cmp	r3, #1
     6a4:	d104      	bne.n	6b0 <sd_mmc_check+0x3b8>
			sd_mmc_card->version = CARD_VER_SD_3_0;
     6a6:	4b39      	ldr	r3, [pc, #228]	; (78c <sd_mmc_check+0x494>)
     6a8:	681b      	ldr	r3, [r3, #0]
     6aa:	2230      	movs	r2, #48	; 0x30
     6ac:	741a      	strb	r2, [r3, #16]
     6ae:	e04e      	b.n	74e <sd_mmc_check+0x456>
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
     6b0:	4b36      	ldr	r3, [pc, #216]	; (78c <sd_mmc_check+0x494>)
     6b2:	681b      	ldr	r3, [r3, #0]
     6b4:	2220      	movs	r2, #32
     6b6:	741a      	strb	r2, [r3, #16]
     6b8:	e049      	b.n	74e <sd_mmc_check+0x456>
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
     6ba:	4b34      	ldr	r3, [pc, #208]	; (78c <sd_mmc_check+0x494>)
     6bc:	681b      	ldr	r3, [r3, #0]
     6be:	2210      	movs	r2, #16
     6c0:	741a      	strb	r2, [r3, #16]
     6c2:	e044      	b.n	74e <sd_mmc_check+0x456>
		}
	}
	// SD MEMORY not HC, Set default block size
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
			(0 == (sd_mmc_card->type & CARD_TYPE_HC))) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
     6c4:	2180      	movs	r1, #128	; 0x80
     6c6:	0089      	lsls	r1, r1, #2
     6c8:	4831      	ldr	r0, [pc, #196]	; (790 <sd_mmc_check+0x498>)
     6ca:	4b32      	ldr	r3, [pc, #200]	; (794 <sd_mmc_check+0x49c>)
     6cc:	4798      	blx	r3
     6ce:	2800      	cmp	r0, #0
     6d0:	d00b      	beq.n	6ea <sd_mmc_check+0x3f2>
			return false;
		}
	}
	// Check communication
	if (sd_mmc_card->type & CARD_TYPE_SD) {
     6d2:	4b2e      	ldr	r3, [pc, #184]	; (78c <sd_mmc_check+0x494>)
     6d4:	681b      	ldr	r3, [r3, #0]
     6d6:	7bdb      	ldrb	r3, [r3, #15]
     6d8:	07db      	lsls	r3, r3, #31
     6da:	d503      	bpl.n	6e4 <sd_mmc_check+0x3ec>
		if (!sd_mmc_cmd13()) {
     6dc:	4b2e      	ldr	r3, [pc, #184]	; (798 <sd_mmc_check+0x4a0>)
     6de:	4798      	blx	r3
     6e0:	2800      	cmp	r0, #0
     6e2:	d002      	beq.n	6ea <sd_mmc_check+0x3f2>
			return false;
		}
	}
	// Reinitialize the slot with the new speed
	sd_mmc_configure_slot();
     6e4:	4b2d      	ldr	r3, [pc, #180]	; (79c <sd_mmc_check+0x4a4>)
     6e6:	4798      	blx	r3
     6e8:	e03e      	b.n	768 <sd_mmc_check+0x470>
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
     6ea:	4b28      	ldr	r3, [pc, #160]	; (78c <sd_mmc_check+0x494>)
     6ec:	681b      	ldr	r3, [r3, #0]
     6ee:	2203      	movs	r2, #3
     6f0:	739a      	strb	r2, [r3, #14]
	sd_mmc_deselect_slot();
     6f2:	4b2b      	ldr	r3, [pc, #172]	; (7a0 <sd_mmc_check+0x4a8>)
     6f4:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
     6f6:	2003      	movs	r0, #3
     6f8:	e046      	b.n	788 <sd_mmc_check+0x490>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
     6fa:	2500      	movs	r5, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
     6fc:	4b23      	ldr	r3, [pc, #140]	; (78c <sd_mmc_check+0x494>)
     6fe:	681b      	ldr	r3, [r3, #0]
     700:	7bdb      	ldrb	r3, [r3, #15]
     702:	07db      	lsls	r3, r3, #31
     704:	d538      	bpl.n	778 <sd_mmc_check+0x480>
     706:	1e6b      	subs	r3, r5, #1
     708:	419d      	sbcs	r5, r3
     70a:	07ab      	lsls	r3, r5, #30
     70c:	9303      	str	r3, [sp, #12]
     70e:	4c25      	ldr	r4, [pc, #148]	; (7a4 <sd_mmc_check+0x4ac>)
	 */
	retry = 7150;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
     710:	4e20      	ldr	r6, [pc, #128]	; (794 <sd_mmc_check+0x49c>)
		arg = 0;
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_SPI_ACMD41_SD_SEND_OP_COND, arg)) {
     712:	0037      	movs	r7, r6
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
     714:	4d24      	ldr	r5, [pc, #144]	; (7a8 <sd_mmc_check+0x4b0>)
     716:	e622      	b.n	35e <sd_mmc_check+0x66>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_spi_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
     718:	4b1c      	ldr	r3, [pc, #112]	; (78c <sd_mmc_check+0x494>)
     71a:	681b      	ldr	r3, [r3, #0]
     71c:	2202      	movs	r2, #2
     71e:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_spi_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_SPI_CMD0_GO_IDLE_STATE, 0)) {
     720:	2100      	movs	r1, #0
     722:	2088      	movs	r0, #136	; 0x88
     724:	0140      	lsls	r0, r0, #5
     726:	4b1b      	ldr	r3, [pc, #108]	; (794 <sd_mmc_check+0x49c>)
     728:	4798      	blx	r3
     72a:	2800      	cmp	r0, #0
     72c:	d0dd      	beq.n	6ea <sd_mmc_check+0x3f2>
     72e:	e63c      	b.n	3aa <sd_mmc_check+0xb2>
		 * However, to be sure, the CRC OFF command is send.
		 * Unfortunately, specific SDIO card does not support it
		 * (H&D wireless card - HDG104 WiFi SIP)
		 * and the command is send only on SD card.
		 */
		if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
     730:	2100      	movs	r1, #0
     732:	481e      	ldr	r0, [pc, #120]	; (7ac <sd_mmc_check+0x4b4>)
     734:	4b17      	ldr	r3, [pc, #92]	; (794 <sd_mmc_check+0x49c>)
     736:	4798      	blx	r3
     738:	2800      	cmp	r0, #0
     73a:	d000      	beq.n	73e <sd_mmc_check+0x446>
     73c:	e700      	b.n	540 <sd_mmc_check+0x248>
     73e:	e7d4      	b.n	6ea <sd_mmc_check+0x3f2>
	if (!mmc_spi_op_cond()) {
		return false;
	}

	// Disable CRC check for SPI mode
	if (!driver_send_cmd(SDMMC_SPI_CMD59_CRC_ON_OFF, 0)) {
     740:	2100      	movs	r1, #0
     742:	481a      	ldr	r0, [pc, #104]	; (7ac <sd_mmc_check+0x4b4>)
     744:	4b13      	ldr	r3, [pc, #76]	; (794 <sd_mmc_check+0x49c>)
     746:	4798      	blx	r3
     748:	2800      	cmp	r0, #0
     74a:	d0ce      	beq.n	6ea <sd_mmc_check+0x3f2>
     74c:	e656      	b.n	3fc <sd_mmc_check+0x104>
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	// SD MEMORY not HC, Set default block size
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
     74e:	4b0f      	ldr	r3, [pc, #60]	; (78c <sd_mmc_check+0x494>)
     750:	681b      	ldr	r3, [r3, #0]
     752:	7bda      	ldrb	r2, [r3, #15]
     754:	2309      	movs	r3, #9
     756:	4013      	ands	r3, r2
     758:	2b01      	cmp	r3, #1
     75a:	d1ba      	bne.n	6d2 <sd_mmc_check+0x3da>
     75c:	e7b2      	b.n	6c4 <sd_mmc_check+0x3cc>
     75e:	2209      	movs	r2, #9
     760:	4013      	ands	r3, r2
     762:	2b01      	cmp	r3, #1
     764:	d1be      	bne.n	6e4 <sd_mmc_check+0x3ec>
     766:	e7ad      	b.n	6c4 <sd_mmc_check+0x3cc>

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			: sd_mmc_mci_card_init()) {
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
     768:	4b08      	ldr	r3, [pc, #32]	; (78c <sd_mmc_check+0x494>)
     76a:	681b      	ldr	r3, [r3, #0]
     76c:	2200      	movs	r2, #0
     76e:	739a      	strb	r2, [r3, #14]
		sd_mmc_deselect_slot();
     770:	4b0b      	ldr	r3, [pc, #44]	; (7a0 <sd_mmc_check+0x4a8>)
     772:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
     774:	2001      	movs	r0, #1
     776:	e007      	b.n	788 <sd_mmc_check+0x490>
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	// SD MEMORY not HC, Set default block size
	if ((sd_mmc_card->type & CARD_TYPE_SD) &&
     778:	4b04      	ldr	r3, [pc, #16]	; (78c <sd_mmc_check+0x494>)
     77a:	681b      	ldr	r3, [r3, #0]
     77c:	7bdb      	ldrb	r3, [r3, #15]
     77e:	2209      	movs	r2, #9
     780:	4013      	ands	r3, r2
     782:	2b01      	cmp	r3, #1
     784:	d09e      	beq.n	6c4 <sd_mmc_check+0x3cc>
     786:	e7ad      	b.n	6e4 <sd_mmc_check+0x3ec>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
     788:	b009      	add	sp, #36	; 0x24
     78a:	bdf0      	pop	{r4, r5, r6, r7, pc}
     78c:	200000b8 	.word	0x200000b8
     790:	00001110 	.word	0x00001110
     794:	00000f89 	.word	0x00000f89
     798:	0000025d 	.word	0x0000025d
     79c:	00000115 	.word	0x00000115
     7a0:	000002dd 	.word	0x000002dd
     7a4:	00001bef 	.word	0x00001bef
     7a8:	00000fa1 	.word	0x00000fa1
     7ac:	0000113b 	.word	0x0000113b

000007b0 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
     7b0:	b510      	push	{r4, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
     7b2:	4b06      	ldr	r3, [pc, #24]	; (7cc <sd_mmc_get_type+0x1c>)
     7b4:	4798      	blx	r3
		return CARD_TYPE_UNKNOWN;
     7b6:	2300      	movs	r3, #0
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
     7b8:	2800      	cmp	r0, #0
     7ba:	d104      	bne.n	7c6 <sd_mmc_get_type+0x16>
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
     7bc:	4b04      	ldr	r3, [pc, #16]	; (7d0 <sd_mmc_get_type+0x20>)
     7be:	4798      	blx	r3
	return sd_mmc_card->type;
     7c0:	4b04      	ldr	r3, [pc, #16]	; (7d4 <sd_mmc_get_type+0x24>)
     7c2:	681b      	ldr	r3, [r3, #0]
     7c4:	7bdb      	ldrb	r3, [r3, #15]
}
     7c6:	0018      	movs	r0, r3
     7c8:	bd10      	pop	{r4, pc}
     7ca:	46c0      	nop			; (mov r8, r8)
     7cc:	00000141 	.word	0x00000141
     7d0:	000002dd 	.word	0x000002dd
     7d4:	200000b8 	.word	0x200000b8

000007d8 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
     7d8:	b510      	push	{r4, lr}
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
     7da:	4b06      	ldr	r3, [pc, #24]	; (7f4 <sd_mmc_get_capacity+0x1c>)
     7dc:	4798      	blx	r3
		return 0;
     7de:	2300      	movs	r3, #0
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
     7e0:	2800      	cmp	r0, #0
     7e2:	d104      	bne.n	7ee <sd_mmc_get_capacity+0x16>
		return 0;
	}
	sd_mmc_deselect_slot();
     7e4:	4b04      	ldr	r3, [pc, #16]	; (7f8 <sd_mmc_get_capacity+0x20>)
     7e6:	4798      	blx	r3
	return sd_mmc_card->capacity;
     7e8:	4b04      	ldr	r3, [pc, #16]	; (7fc <sd_mmc_get_capacity+0x24>)
     7ea:	681b      	ldr	r3, [r3, #0]
     7ec:	685b      	ldr	r3, [r3, #4]
}
     7ee:	0018      	movs	r0, r3
     7f0:	bd10      	pop	{r4, pc}
     7f2:	46c0      	nop			; (mov r8, r8)
     7f4:	00000141 	.word	0x00000141
     7f8:	000002dd 	.word	0x000002dd
     7fc:	200000b8 	.word	0x200000b8

00000800 <sd_mmc_init_read_blocks>:
	return false;
}

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
     800:	b530      	push	{r4, r5, lr}
     802:	b083      	sub	sp, #12
     804:	000d      	movs	r5, r1
     806:	0014      	movs	r4, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
     808:	4b15      	ldr	r3, [pc, #84]	; (860 <sd_mmc_init_read_blocks+0x60>)
     80a:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
     80c:	2800      	cmp	r0, #0
     80e:	d125      	bne.n	85c <sd_mmc_init_read_blocks+0x5c>
		return sd_mmc_err;
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
     810:	4b14      	ldr	r3, [pc, #80]	; (864 <sd_mmc_init_read_blocks+0x64>)
     812:	4798      	blx	r3
     814:	2800      	cmp	r0, #0
     816:	d103      	bne.n	820 <sd_mmc_init_read_blocks+0x20>
		sd_mmc_deselect_slot();
     818:	4b13      	ldr	r3, [pc, #76]	; (868 <sd_mmc_init_read_blocks+0x68>)
     81a:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
     81c:	2005      	movs	r0, #5
     81e:	e01d      	b.n	85c <sd_mmc_init_read_blocks+0x5c>
	}

	if (nb_block > 1) {
     820:	2c01      	cmp	r4, #1
     822:	d801      	bhi.n	828 <sd_mmc_init_read_blocks+0x28>
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
     824:	4811      	ldr	r0, [pc, #68]	; (86c <sd_mmc_init_read_blocks+0x6c>)
     826:	e000      	b.n	82a <sd_mmc_init_read_blocks+0x2a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
     828:	4811      	ldr	r0, [pc, #68]	; (870 <sd_mmc_init_read_blocks+0x70>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
     82a:	4b12      	ldr	r3, [pc, #72]	; (874 <sd_mmc_init_read_blocks+0x74>)
     82c:	681b      	ldr	r3, [r3, #0]
     82e:	7bdb      	ldrb	r3, [r3, #15]
     830:	071b      	lsls	r3, r3, #28
     832:	d400      	bmi.n	836 <sd_mmc_init_read_blocks+0x36>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
     834:	026d      	lsls	r5, r5, #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
     836:	2301      	movs	r3, #1
     838:	9300      	str	r3, [sp, #0]
     83a:	0023      	movs	r3, r4
     83c:	2280      	movs	r2, #128	; 0x80
     83e:	0092      	lsls	r2, r2, #2
     840:	0029      	movs	r1, r5
     842:	4d0d      	ldr	r5, [pc, #52]	; (878 <sd_mmc_init_read_blocks+0x78>)
     844:	47a8      	blx	r5
     846:	2800      	cmp	r0, #0
     848:	d103      	bne.n	852 <sd_mmc_init_read_blocks+0x52>
		sd_mmc_deselect_slot();
     84a:	4b07      	ldr	r3, [pc, #28]	; (868 <sd_mmc_init_read_blocks+0x68>)
     84c:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
     84e:	2005      	movs	r0, #5
     850:	e004      	b.n	85c <sd_mmc_init_read_blocks+0x5c>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
     852:	4b0a      	ldr	r3, [pc, #40]	; (87c <sd_mmc_init_read_blocks+0x7c>)
     854:	801c      	strh	r4, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
     856:	4b0a      	ldr	r3, [pc, #40]	; (880 <sd_mmc_init_read_blocks+0x80>)
     858:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
     85a:	2000      	movs	r0, #0
}
     85c:	b003      	add	sp, #12
     85e:	bd30      	pop	{r4, r5, pc}
     860:	00000141 	.word	0x00000141
     864:	0000025d 	.word	0x0000025d
     868:	000002dd 	.word	0x000002dd
     86c:	00081111 	.word	0x00081111
     870:	00101112 	.word	0x00101112
     874:	200000b8 	.word	0x200000b8
     878:	00000e01 	.word	0x00000e01
     87c:	200000bc 	.word	0x200000bc
     880:	200000b4 	.word	0x200000b4

00000884 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
     884:	b510      	push	{r4, lr}
     886:	000c      	movs	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
     888:	4b07      	ldr	r3, [pc, #28]	; (8a8 <sd_mmc_start_read_blocks+0x24>)
     88a:	4798      	blx	r3
     88c:	2800      	cmp	r0, #0
     88e:	d104      	bne.n	89a <sd_mmc_start_read_blocks+0x16>
		sd_mmc_nb_block_remaining = 0;
     890:	2200      	movs	r2, #0
     892:	4b06      	ldr	r3, [pc, #24]	; (8ac <sd_mmc_start_read_blocks+0x28>)
     894:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
     896:	3005      	adds	r0, #5
     898:	e004      	b.n	8a4 <sd_mmc_start_read_blocks+0x20>
	}
	sd_mmc_nb_block_remaining -= nb_block;
     89a:	4a04      	ldr	r2, [pc, #16]	; (8ac <sd_mmc_start_read_blocks+0x28>)
     89c:	8813      	ldrh	r3, [r2, #0]
     89e:	1b1c      	subs	r4, r3, r4
     8a0:	8014      	strh	r4, [r2, #0]
	return SD_MMC_OK;
     8a2:	2000      	movs	r0, #0
}
     8a4:	bd10      	pop	{r4, pc}
     8a6:	46c0      	nop			; (mov r8, r8)
     8a8:	00001021 	.word	0x00001021
     8ac:	200000bc 	.word	0x200000bc

000008b0 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
     8b0:	b510      	push	{r4, lr}
     8b2:	0004      	movs	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
     8b4:	4b13      	ldr	r3, [pc, #76]	; (904 <sd_mmc_wait_end_of_read_blocks+0x54>)
     8b6:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
     8b8:	2305      	movs	r3, #5
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
     8ba:	2800      	cmp	r0, #0
     8bc:	d01f      	beq.n	8fe <sd_mmc_wait_end_of_read_blocks+0x4e>
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
     8be:	2c00      	cmp	r4, #0
     8c0:	d003      	beq.n	8ca <sd_mmc_wait_end_of_read_blocks+0x1a>
		sd_mmc_nb_block_remaining = 0;
     8c2:	2200      	movs	r2, #0
     8c4:	4b10      	ldr	r3, [pc, #64]	; (908 <sd_mmc_wait_end_of_read_blocks+0x58>)
     8c6:	801a      	strh	r2, [r3, #0]
     8c8:	e004      	b.n	8d4 <sd_mmc_wait_end_of_read_blocks+0x24>
	} else if (sd_mmc_nb_block_remaining) {
     8ca:	4b0f      	ldr	r3, [pc, #60]	; (908 <sd_mmc_wait_end_of_read_blocks+0x58>)
     8cc:	881a      	ldrh	r2, [r3, #0]
		return SD_MMC_OK;
     8ce:	2300      	movs	r3, #0
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
     8d0:	2a00      	cmp	r2, #0
     8d2:	d114      	bne.n	8fe <sd_mmc_wait_end_of_read_blocks+0x4e>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
     8d4:	4b0d      	ldr	r3, [pc, #52]	; (90c <sd_mmc_wait_end_of_read_blocks+0x5c>)
     8d6:	881b      	ldrh	r3, [r3, #0]
     8d8:	2b01      	cmp	r3, #1
     8da:	d103      	bne.n	8e4 <sd_mmc_wait_end_of_read_blocks+0x34>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
     8dc:	4b0c      	ldr	r3, [pc, #48]	; (910 <sd_mmc_wait_end_of_read_blocks+0x60>)
     8de:	4798      	blx	r3
		return SD_MMC_OK;
     8e0:	2300      	movs	r3, #0
     8e2:	e00c      	b.n	8fe <sd_mmc_wait_end_of_read_blocks+0x4e>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
     8e4:	2100      	movs	r1, #0
     8e6:	480b      	ldr	r0, [pc, #44]	; (914 <sd_mmc_wait_end_of_read_blocks+0x64>)
     8e8:	4b0b      	ldr	r3, [pc, #44]	; (918 <sd_mmc_wait_end_of_read_blocks+0x68>)
     8ea:	4798      	blx	r3
     8ec:	2800      	cmp	r0, #0
     8ee:	d103      	bne.n	8f8 <sd_mmc_wait_end_of_read_blocks+0x48>
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
     8f0:	2100      	movs	r1, #0
     8f2:	4808      	ldr	r0, [pc, #32]	; (914 <sd_mmc_wait_end_of_read_blocks+0x64>)
     8f4:	4b08      	ldr	r3, [pc, #32]	; (918 <sd_mmc_wait_end_of_read_blocks+0x68>)
     8f6:	4798      	blx	r3
	}
	sd_mmc_deselect_slot();
     8f8:	4b05      	ldr	r3, [pc, #20]	; (910 <sd_mmc_wait_end_of_read_blocks+0x60>)
     8fa:	4798      	blx	r3
	return SD_MMC_OK;
     8fc:	2300      	movs	r3, #0
}
     8fe:	0018      	movs	r0, r3
     900:	bd10      	pop	{r4, pc}
     902:	46c0      	nop			; (mov r8, r8)
     904:	000010a5 	.word	0x000010a5
     908:	200000bc 	.word	0x200000bc
     90c:	200000b4 	.word	0x200000b4
     910:	000002dd 	.word	0x000002dd
     914:	0000310c 	.word	0x0000310c
     918:	00000f89 	.word	0x00000f89

0000091c <sd_mmc_init_write_blocks>:

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
     91c:	b530      	push	{r4, r5, lr}
     91e:	b083      	sub	sp, #12
     920:	000d      	movs	r5, r1
     922:	0014      	movs	r4, r2
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
     924:	4b11      	ldr	r3, [pc, #68]	; (96c <sd_mmc_init_write_blocks+0x50>)
     926:	4798      	blx	r3
	if (sd_mmc_err != SD_MMC_OK) {
     928:	2800      	cmp	r0, #0
     92a:	d11d      	bne.n	968 <sd_mmc_init_write_blocks+0x4c>
	if (sd_mmc_is_write_protected(slot)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
     92c:	2c01      	cmp	r4, #1
     92e:	d801      	bhi.n	934 <sd_mmc_init_write_blocks+0x18>
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD24_WRITE_BLOCK;
     930:	480f      	ldr	r0, [pc, #60]	; (970 <sd_mmc_init_write_blocks+0x54>)
     932:	e000      	b.n	936 <sd_mmc_init_write_blocks+0x1a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
     934:	480f      	ldr	r0, [pc, #60]	; (974 <sd_mmc_init_write_blocks+0x58>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
     936:	4b10      	ldr	r3, [pc, #64]	; (978 <sd_mmc_init_write_blocks+0x5c>)
     938:	681b      	ldr	r3, [r3, #0]
     93a:	7bdb      	ldrb	r3, [r3, #15]
     93c:	071b      	lsls	r3, r3, #28
     93e:	d400      	bmi.n	942 <sd_mmc_init_write_blocks+0x26>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
     940:	026d      	lsls	r5, r5, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
     942:	2301      	movs	r3, #1
     944:	9300      	str	r3, [sp, #0]
     946:	0023      	movs	r3, r4
     948:	2280      	movs	r2, #128	; 0x80
     94a:	0092      	lsls	r2, r2, #2
     94c:	0029      	movs	r1, r5
     94e:	4d0b      	ldr	r5, [pc, #44]	; (97c <sd_mmc_init_write_blocks+0x60>)
     950:	47a8      	blx	r5
     952:	2800      	cmp	r0, #0
     954:	d103      	bne.n	95e <sd_mmc_init_write_blocks+0x42>
		sd_mmc_deselect_slot();
     956:	4b0a      	ldr	r3, [pc, #40]	; (980 <sd_mmc_init_write_blocks+0x64>)
     958:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
     95a:	2005      	movs	r0, #5
     95c:	e004      	b.n	968 <sd_mmc_init_write_blocks+0x4c>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
     95e:	4b09      	ldr	r3, [pc, #36]	; (984 <sd_mmc_init_write_blocks+0x68>)
     960:	801c      	strh	r4, [r3, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
     962:	4b09      	ldr	r3, [pc, #36]	; (988 <sd_mmc_init_write_blocks+0x6c>)
     964:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
     966:	2000      	movs	r0, #0
}
     968:	b003      	add	sp, #12
     96a:	bd30      	pop	{r4, r5, pc}
     96c:	00000141 	.word	0x00000141
     970:	00089118 	.word	0x00089118
     974:	00109119 	.word	0x00109119
     978:	200000b8 	.word	0x200000b8
     97c:	00000e01 	.word	0x00000e01
     980:	000002dd 	.word	0x000002dd
     984:	200000bc 	.word	0x200000bc
     988:	200000b4 	.word	0x200000b4

0000098c <sd_mmc_start_write_blocks>:

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
     98c:	b510      	push	{r4, lr}
     98e:	000c      	movs	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
     990:	4b07      	ldr	r3, [pc, #28]	; (9b0 <sd_mmc_start_write_blocks+0x24>)
     992:	4798      	blx	r3
     994:	2800      	cmp	r0, #0
     996:	d104      	bne.n	9a2 <sd_mmc_start_write_blocks+0x16>
		sd_mmc_nb_block_remaining = 0;
     998:	2200      	movs	r2, #0
     99a:	4b06      	ldr	r3, [pc, #24]	; (9b4 <sd_mmc_start_write_blocks+0x28>)
     99c:	801a      	strh	r2, [r3, #0]
		return SD_MMC_ERR_COMM;
     99e:	3005      	adds	r0, #5
     9a0:	e004      	b.n	9ac <sd_mmc_start_write_blocks+0x20>
	}
	sd_mmc_nb_block_remaining -= nb_block;
     9a2:	4a04      	ldr	r2, [pc, #16]	; (9b4 <sd_mmc_start_write_blocks+0x28>)
     9a4:	8813      	ldrh	r3, [r2, #0]
     9a6:	1b1c      	subs	r4, r3, r4
     9a8:	8014      	strh	r4, [r2, #0]
	return SD_MMC_OK;
     9aa:	2000      	movs	r0, #0
}
     9ac:	bd10      	pop	{r4, pc}
     9ae:	46c0      	nop			; (mov r8, r8)
     9b0:	000010a9 	.word	0x000010a9
     9b4:	200000bc 	.word	0x200000bc

000009b8 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
     9b8:	b510      	push	{r4, lr}
     9ba:	0004      	movs	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
     9bc:	4b0e      	ldr	r3, [pc, #56]	; (9f8 <sd_mmc_wait_end_of_write_blocks+0x40>)
     9be:	4798      	blx	r3
		return SD_MMC_ERR_COMM;
     9c0:	2305      	movs	r3, #5
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
     9c2:	2800      	cmp	r0, #0
     9c4:	d015      	beq.n	9f2 <sd_mmc_wait_end_of_write_blocks+0x3a>
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
     9c6:	2c00      	cmp	r4, #0
     9c8:	d003      	beq.n	9d2 <sd_mmc_wait_end_of_write_blocks+0x1a>
		sd_mmc_nb_block_remaining = 0;
     9ca:	2200      	movs	r2, #0
     9cc:	4b0b      	ldr	r3, [pc, #44]	; (9fc <sd_mmc_wait_end_of_write_blocks+0x44>)
     9ce:	801a      	strh	r2, [r3, #0]
     9d0:	e004      	b.n	9dc <sd_mmc_wait_end_of_write_blocks+0x24>
	} else if (sd_mmc_nb_block_remaining) {
     9d2:	4b0a      	ldr	r3, [pc, #40]	; (9fc <sd_mmc_wait_end_of_write_blocks+0x44>)
     9d4:	881a      	ldrh	r2, [r3, #0]
		return SD_MMC_OK;
     9d6:	2300      	movs	r3, #0
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
     9d8:	2a00      	cmp	r2, #0
     9da:	d10a      	bne.n	9f2 <sd_mmc_wait_end_of_write_blocks+0x3a>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
     9dc:	4b08      	ldr	r3, [pc, #32]	; (a00 <sd_mmc_wait_end_of_write_blocks+0x48>)
     9de:	881b      	ldrh	r3, [r3, #0]
     9e0:	2b01      	cmp	r3, #1
     9e2:	d103      	bne.n	9ec <sd_mmc_wait_end_of_write_blocks+0x34>
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
     9e4:	4b07      	ldr	r3, [pc, #28]	; (a04 <sd_mmc_wait_end_of_write_blocks+0x4c>)
     9e6:	4798      	blx	r3
		return SD_MMC_OK;
     9e8:	2300      	movs	r3, #0
     9ea:	e002      	b.n	9f2 <sd_mmc_wait_end_of_write_blocks+0x3a>
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_deselect_slot();
     9ec:	4b05      	ldr	r3, [pc, #20]	; (a04 <sd_mmc_wait_end_of_write_blocks+0x4c>)
     9ee:	4798      	blx	r3
	return SD_MMC_OK;
     9f0:	2300      	movs	r3, #0
}
     9f2:	0018      	movs	r0, r3
     9f4:	bd10      	pop	{r4, pc}
     9f6:	46c0      	nop			; (mov r8, r8)
     9f8:	00001131 	.word	0x00001131
     9fc:	200000bc 	.word	0x200000bc
     a00:	200000b4 	.word	0x200000b4
     a04:	000002dd 	.word	0x000002dd

00000a08 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
     a08:	b510      	push	{r4, lr}
     a0a:	0004      	movs	r4, r0
	switch (sd_mmc_check(slot))
     a0c:	4b0f      	ldr	r3, [pc, #60]	; (a4c <sd_mmc_test_unit_ready+0x44>)
     a0e:	4798      	blx	r3
     a10:	2801      	cmp	r0, #1
     a12:	d018      	beq.n	a46 <sd_mmc_test_unit_ready+0x3e>
     a14:	2800      	cmp	r0, #0
     a16:	d003      	beq.n	a20 <sd_mmc_test_unit_ready+0x18>
     a18:	2802      	cmp	r0, #2
     a1a:	d00f      	beq.n	a3c <sd_mmc_test_unit_ready+0x34>
	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
     a1c:	2001      	movs	r0, #1
     a1e:	e013      	b.n	a48 <sd_mmc_test_unit_ready+0x40>
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
     a20:	4b0b      	ldr	r3, [pc, #44]	; (a50 <sd_mmc_test_unit_ready+0x48>)
     a22:	5d1b      	ldrb	r3, [r3, r4]
			return CTRL_NO_PRESENT;
     a24:	2002      	movs	r0, #2
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
     a26:	2b00      	cmp	r3, #0
     a28:	d10e      	bne.n	a48 <sd_mmc_test_unit_ready+0x40>
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
     a2a:	0020      	movs	r0, r4
     a2c:	4b09      	ldr	r3, [pc, #36]	; (a54 <sd_mmc_test_unit_ready+0x4c>)
     a2e:	4798      	blx	r3
     a30:	2303      	movs	r3, #3
     a32:	4018      	ands	r0, r3
			return CTRL_GOOD;
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;
     a34:	4243      	negs	r3, r0
     a36:	4158      	adcs	r0, r3
     a38:	0040      	lsls	r0, r0, #1
     a3a:	e005      	b.n	a48 <sd_mmc_test_unit_ready+0x40>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
     a3c:	2200      	movs	r2, #0
     a3e:	4b04      	ldr	r3, [pc, #16]	; (a50 <sd_mmc_test_unit_ready+0x48>)
     a40:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
     a42:	2002      	movs	r0, #2
     a44:	e000      	b.n	a48 <sd_mmc_test_unit_ready+0x40>
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
     a46:	2003      	movs	r0, #3
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
     a48:	bd10      	pop	{r4, pc}
     a4a:	46c0      	nop			; (mov r8, r8)
     a4c:	000002f9 	.word	0x000002f9
     a50:	200000c0 	.word	0x200000c0
     a54:	000007b1 	.word	0x000007b1

00000a58 <sd_mmc_test_unit_ready_0>:

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
     a58:	b510      	push	{r4, lr}
	return sd_mmc_test_unit_ready(0);
     a5a:	2000      	movs	r0, #0
     a5c:	4b01      	ldr	r3, [pc, #4]	; (a64 <sd_mmc_test_unit_ready_0+0xc>)
     a5e:	4798      	blx	r3
}
     a60:	bd10      	pop	{r4, pc}
     a62:	46c0      	nop			; (mov r8, r8)
     a64:	00000a09 	.word	0x00000a09

00000a68 <sd_mmc_read_capacity>:
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
     a68:	b570      	push	{r4, r5, r6, lr}
     a6a:	0004      	movs	r4, r0
     a6c:	000d      	movs	r5, r1
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
     a6e:	4b04      	ldr	r3, [pc, #16]	; (a80 <sd_mmc_read_capacity+0x18>)
     a70:	4798      	blx	r3
     a72:	0040      	lsls	r0, r0, #1
     a74:	3801      	subs	r0, #1
     a76:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
     a78:	0020      	movs	r0, r4
     a7a:	4b02      	ldr	r3, [pc, #8]	; (a84 <sd_mmc_read_capacity+0x1c>)
     a7c:	4798      	blx	r3
}
     a7e:	bd70      	pop	{r4, r5, r6, pc}
     a80:	000007d9 	.word	0x000007d9
     a84:	00000a09 	.word	0x00000a09

00000a88 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
     a88:	b510      	push	{r4, lr}
     a8a:	0001      	movs	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
     a8c:	2000      	movs	r0, #0
     a8e:	4b01      	ldr	r3, [pc, #4]	; (a94 <sd_mmc_read_capacity_0+0xc>)
     a90:	4798      	blx	r3
}
     a92:	bd10      	pop	{r4, pc}
     a94:	00000a69 	.word	0x00000a69

00000a98 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
     a98:	b510      	push	{r4, lr}
     a9a:	0014      	movs	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
     a9c:	2201      	movs	r2, #1
     a9e:	4b0c      	ldr	r3, [pc, #48]	; (ad0 <sd_mmc_mem_2_ram+0x38>)
     aa0:	4798      	blx	r3
     aa2:	2800      	cmp	r0, #0
     aa4:	d004      	beq.n	ab0 <sd_mmc_mem_2_ram+0x18>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
     aa6:	3802      	subs	r0, #2
     aa8:	4243      	negs	r3, r0
     aaa:	4158      	adcs	r0, r3
     aac:	3001      	adds	r0, #1
     aae:	e00d      	b.n	acc <sd_mmc_mem_2_ram+0x34>
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
     ab0:	2101      	movs	r1, #1
     ab2:	0020      	movs	r0, r4
     ab4:	4b07      	ldr	r3, [pc, #28]	; (ad4 <sd_mmc_mem_2_ram+0x3c>)
     ab6:	4798      	blx	r3
     ab8:	0003      	movs	r3, r0
		return CTRL_FAIL;
     aba:	2001      	movs	r0, #1
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
     abc:	2b00      	cmp	r3, #0
     abe:	d105      	bne.n	acc <sd_mmc_mem_2_ram+0x34>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
     ac0:	2000      	movs	r0, #0
     ac2:	4b05      	ldr	r3, [pc, #20]	; (ad8 <sd_mmc_mem_2_ram+0x40>)
     ac4:	4798      	blx	r3
{
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
     ac6:	1e43      	subs	r3, r0, #1
     ac8:	4198      	sbcs	r0, r3
     aca:	b2c0      	uxtb	r0, r0
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
     acc:	bd10      	pop	{r4, pc}
     ace:	46c0      	nop			; (mov r8, r8)
     ad0:	00000801 	.word	0x00000801
     ad4:	00000885 	.word	0x00000885
     ad8:	000008b1 	.word	0x000008b1

00000adc <sd_mmc_mem_2_ram_0>:

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
     adc:	b510      	push	{r4, lr}
     ade:	000a      	movs	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
     ae0:	0001      	movs	r1, r0
     ae2:	2000      	movs	r0, #0
     ae4:	4b01      	ldr	r3, [pc, #4]	; (aec <sd_mmc_mem_2_ram_0+0x10>)
     ae6:	4798      	blx	r3
}
     ae8:	bd10      	pop	{r4, pc}
     aea:	46c0      	nop			; (mov r8, r8)
     aec:	00000a99 	.word	0x00000a99

00000af0 <sd_mmc_ram_2_mem>:
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
     af0:	b510      	push	{r4, lr}
     af2:	0014      	movs	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
     af4:	2201      	movs	r2, #1
     af6:	4b0c      	ldr	r3, [pc, #48]	; (b28 <sd_mmc_ram_2_mem+0x38>)
     af8:	4798      	blx	r3
     afa:	2800      	cmp	r0, #0
     afc:	d004      	beq.n	b08 <sd_mmc_ram_2_mem+0x18>
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
     afe:	3802      	subs	r0, #2
     b00:	4243      	negs	r3, r0
     b02:	4158      	adcs	r0, r3
     b04:	3001      	adds	r0, #1
     b06:	e00d      	b.n	b24 <sd_mmc_ram_2_mem+0x34>
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
     b08:	2101      	movs	r1, #1
     b0a:	0020      	movs	r0, r4
     b0c:	4b07      	ldr	r3, [pc, #28]	; (b2c <sd_mmc_ram_2_mem+0x3c>)
     b0e:	4798      	blx	r3
     b10:	0003      	movs	r3, r0
		return CTRL_FAIL;
     b12:	2001      	movs	r0, #1
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
     b14:	2b00      	cmp	r3, #0
     b16:	d105      	bne.n	b24 <sd_mmc_ram_2_mem+0x34>
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
     b18:	2000      	movs	r0, #0
     b1a:	4b05      	ldr	r3, [pc, #20]	; (b30 <sd_mmc_ram_2_mem+0x40>)
     b1c:	4798      	blx	r3
{
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
     b1e:	1e43      	subs	r3, r0, #1
     b20:	4198      	sbcs	r0, r3
     b22:	b2c0      	uxtb	r0, r0
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
     b24:	bd10      	pop	{r4, pc}
     b26:	46c0      	nop			; (mov r8, r8)
     b28:	0000091d 	.word	0x0000091d
     b2c:	0000098d 	.word	0x0000098d
     b30:	000009b9 	.word	0x000009b9

00000b34 <sd_mmc_ram_2_mem_0>:

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
     b34:	b510      	push	{r4, lr}
     b36:	000a      	movs	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
     b38:	0001      	movs	r1, r0
     b3a:	2000      	movs	r0, #0
     b3c:	4b01      	ldr	r3, [pc, #4]	; (b44 <sd_mmc_ram_2_mem_0+0x10>)
     b3e:	4798      	blx	r3
}
     b40:	bd10      	pop	{r4, pc}
     b42:	46c0      	nop			; (mov r8, r8)
     b44:	00000af1 	.word	0x00000af1

00000b48 <sd_mmc_spi_start_write_block>:

/**
 * \brief Sends the correct TOKEN on the line to start a write block transfer
 */
static void sd_mmc_spi_start_write_block(void)
{
     b48:	b500      	push	{lr}
     b4a:	b083      	sub	sp, #12
	uint8_t dummy = 0xFF;
     b4c:	466b      	mov	r3, sp
     b4e:	1dd9      	adds	r1, r3, #7
     b50:	23ff      	movs	r3, #255	; 0xff
     b52:	700b      	strb	r3, [r1, #0]
	Assert(!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size));
	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	spi_write_buffer_wait(&sd_mmc_master,&dummy, 1);
     b54:	2201      	movs	r2, #1
     b56:	480b      	ldr	r0, [pc, #44]	; (b84 <sd_mmc_spi_start_write_block+0x3c>)
     b58:	4b0b      	ldr	r3, [pc, #44]	; (b88 <sd_mmc_spi_start_write_block+0x40>)
     b5a:	4798      	blx	r3
	// Send start token
	uint8_t token;
	if (1 == sd_mmc_spi_nb_block) {
     b5c:	4b0b      	ldr	r3, [pc, #44]	; (b8c <sd_mmc_spi_start_write_block+0x44>)
     b5e:	881b      	ldrh	r3, [r3, #0]
     b60:	2b01      	cmp	r3, #1
     b62:	d103      	bne.n	b6c <sd_mmc_spi_start_write_block+0x24>
		token = SPI_TOKEN_SINGLE_WRITE;
     b64:	22fe      	movs	r2, #254	; 0xfe
     b66:	466b      	mov	r3, sp
     b68:	719a      	strb	r2, [r3, #6]
     b6a:	e002      	b.n	b72 <sd_mmc_spi_start_write_block+0x2a>
	} else {
		token = SPI_TOKEN_MULTI_WRITE;
     b6c:	22fc      	movs	r2, #252	; 0xfc
     b6e:	466b      	mov	r3, sp
     b70:	719a      	strb	r2, [r3, #6]
	}
	spi_write_buffer_wait(&sd_mmc_master,&token, 1);
     b72:	2201      	movs	r2, #1
     b74:	466b      	mov	r3, sp
     b76:	1d99      	adds	r1, r3, #6
     b78:	4802      	ldr	r0, [pc, #8]	; (b84 <sd_mmc_spi_start_write_block+0x3c>)
     b7a:	4b03      	ldr	r3, [pc, #12]	; (b88 <sd_mmc_spi_start_write_block+0x40>)
     b7c:	4798      	blx	r3
}
     b7e:	b003      	add	sp, #12
     b80:	bd00      	pop	{pc}
     b82:	46c0      	nop			; (mov r8, r8)
     b84:	200000c4 	.word	0x200000c4
     b88:	00004f55 	.word	0x00004f55
     b8c:	200000c2 	.word	0x200000c2

00000b90 <sd_mmc_spi_wait_busy>:
 * \brief Wait the end of busy on DAT0 line
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_spi_wait_busy(void)
{
     b90:	b5f0      	push	{r4, r5, r6, r7, lr}
     b92:	b083      	sub	sp, #12
	uint8_t line = 0xFF;
     b94:	466b      	mov	r3, sp
     b96:	1ddc      	adds	r4, r3, #7
     b98:	23ff      	movs	r3, #255	; 0xff
     b9a:	7023      	strb	r3, [r4, #0]
	uint16_t dummy = 0xFF;

	/* Delay before check busy
	 * Nbr timing minimum = 8 cylces
	 */
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
     b9c:	4e12      	ldr	r6, [pc, #72]	; (be8 <sd_mmc_spi_wait_busy+0x58>)
     b9e:	2201      	movs	r2, #1
     ba0:	0021      	movs	r1, r4
     ba2:	0030      	movs	r0, r6
     ba4:	4d11      	ldr	r5, [pc, #68]	; (bec <sd_mmc_spi_wait_busy+0x5c>)
     ba6:	47a8      	blx	r5
	 * Nec timing: 0 to unlimited
	 * However a timeout is used.
	 * 200 000 * 8 cycles
	 */
	uint32_t nec_timeout = 200000;
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
     ba8:	23ff      	movs	r3, #255	; 0xff
     baa:	2201      	movs	r2, #1
     bac:	0021      	movs	r1, r4
     bae:	0030      	movs	r0, r6
     bb0:	47a8      	blx	r5
			dummy);
	do {
		spi_read_buffer_wait(&sd_mmc_master, &line, 1,
     bb2:	23ff      	movs	r3, #255	; 0xff
     bb4:	2201      	movs	r2, #1
     bb6:	0021      	movs	r1, r4
     bb8:	0030      	movs	r0, r6
     bba:	47a8      	blx	r5
     bbc:	4c0c      	ldr	r4, [pc, #48]	; (bf0 <sd_mmc_spi_wait_busy+0x60>)
			dummy);
		if (!(nec_timeout--)) {
			return false;
		}
	} while (line != 0xFF);
     bbe:	466b      	mov	r3, sp
     bc0:	1ddd      	adds	r5, r3, #7
	 */
	uint32_t nec_timeout = 200000;
	spi_read_buffer_wait(&sd_mmc_master, &line, 1,
			dummy);
	do {
		spi_read_buffer_wait(&sd_mmc_master, &line, 1,
     bc2:	4e09      	ldr	r6, [pc, #36]	; (be8 <sd_mmc_spi_wait_busy+0x58>)
     bc4:	4f09      	ldr	r7, [pc, #36]	; (bec <sd_mmc_spi_wait_busy+0x5c>)
     bc6:	e007      	b.n	bd8 <sd_mmc_spi_wait_busy+0x48>
     bc8:	23ff      	movs	r3, #255	; 0xff
     bca:	2201      	movs	r2, #1
     bcc:	0029      	movs	r1, r5
     bce:	0030      	movs	r0, r6
     bd0:	47b8      	blx	r7
     bd2:	3c01      	subs	r4, #1
			dummy);
		if (!(nec_timeout--)) {
     bd4:	2c00      	cmp	r4, #0
     bd6:	d004      	beq.n	be2 <sd_mmc_spi_wait_busy+0x52>
			return false;
		}
	} while (line != 0xFF);
     bd8:	782b      	ldrb	r3, [r5, #0]
     bda:	2bff      	cmp	r3, #255	; 0xff
     bdc:	d1f4      	bne.n	bc8 <sd_mmc_spi_wait_busy+0x38>
	return true;
     bde:	2001      	movs	r0, #1
     be0:	e000      	b.n	be4 <sd_mmc_spi_wait_busy+0x54>
			dummy);
	do {
		spi_read_buffer_wait(&sd_mmc_master, &line, 1,
			dummy);
		if (!(nec_timeout--)) {
			return false;
     be2:	2000      	movs	r0, #0
		}
	} while (line != 0xFF);
	return true;
}
     be4:	b003      	add	sp, #12
     be6:	bdf0      	pop	{r4, r5, r6, r7, pc}
     be8:	200000c4 	.word	0x200000c4
     bec:	00004db5 	.word	0x00004db5
     bf0:	00030d40 	.word	0x00030d40

00000bf4 <sd_mmc_spi_stop_multiwrite_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_multiwrite_block(void)
{
     bf4:	b570      	push	{r4, r5, r6, lr}
     bf6:	b082      	sub	sp, #8
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
     bf8:	4b14      	ldr	r3, [pc, #80]	; (c4c <sd_mmc_spi_stop_multiwrite_block+0x58>)
     bfa:	881c      	ldrh	r4, [r3, #0]
     bfc:	2c01      	cmp	r4, #1
     bfe:	d020      	beq.n	c42 <sd_mmc_spi_stop_multiwrite_block+0x4e>
		return true; // Single block write
	}
	if (sd_mmc_spi_nb_block >
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
     c00:	4b13      	ldr	r3, [pc, #76]	; (c50 <sd_mmc_spi_stop_multiwrite_block+0x5c>)
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
		return true; // Single block write
	}
	if (sd_mmc_spi_nb_block >
     c02:	8819      	ldrh	r1, [r3, #0]
     c04:	4b13      	ldr	r3, [pc, #76]	; (c54 <sd_mmc_spi_stop_multiwrite_block+0x60>)
     c06:	6818      	ldr	r0, [r3, #0]
     c08:	4b13      	ldr	r3, [pc, #76]	; (c58 <sd_mmc_spi_stop_multiwrite_block+0x64>)
     c0a:	4798      	blx	r3
		(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size)) {
		return true; // It is not the End of multi write
     c0c:	2301      	movs	r3, #1
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
		return true; // Single block write
	}
	if (sd_mmc_spi_nb_block >
     c0e:	4284      	cmp	r4, r0
     c10:	d818      	bhi.n	c44 <sd_mmc_spi_stop_multiwrite_block+0x50>
		return true; // It is not the End of multi write
	}

	// Delay before start write block:
	// Nwr timing minimum = 8 cylces
	value = 0xFF;
     c12:	466b      	mov	r3, sp
     c14:	1ddc      	adds	r4, r3, #7
     c16:	23ff      	movs	r3, #255	; 0xff
     c18:	7023      	strb	r3, [r4, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
     c1a:	4e10      	ldr	r6, [pc, #64]	; (c5c <sd_mmc_spi_stop_multiwrite_block+0x68>)
     c1c:	2201      	movs	r2, #1
     c1e:	0021      	movs	r1, r4
     c20:	0030      	movs	r0, r6
     c22:	4d0f      	ldr	r5, [pc, #60]	; (c60 <sd_mmc_spi_stop_multiwrite_block+0x6c>)
     c24:	47a8      	blx	r5
	// Send stop token
	value = SPI_TOKEN_STOP_TRAN;
     c26:	23fd      	movs	r3, #253	; 0xfd
     c28:	7023      	strb	r3, [r4, #0]
	spi_write_buffer_wait(&sd_mmc_master, &value, 1);
     c2a:	2201      	movs	r2, #1
     c2c:	0021      	movs	r1, r4
     c2e:	0030      	movs	r0, r6
     c30:	47a8      	blx	r5
	// Wait busy
	if (!sd_mmc_spi_wait_busy()) {
     c32:	4b0c      	ldr	r3, [pc, #48]	; (c64 <sd_mmc_spi_stop_multiwrite_block+0x70>)
     c34:	4798      	blx	r3
     c36:	1e03      	subs	r3, r0, #0
     c38:	d104      	bne.n	c44 <sd_mmc_spi_stop_multiwrite_block+0x50>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
     c3a:	2105      	movs	r1, #5
     c3c:	4a0a      	ldr	r2, [pc, #40]	; (c68 <sd_mmc_spi_stop_multiwrite_block+0x74>)
     c3e:	7011      	strb	r1, [r2, #0]
		sd_mmc_spi_debug("%s: Stop write blocks timeout\n\r",
				__func__);
		return false;
     c40:	e000      	b.n	c44 <sd_mmc_spi_stop_multiwrite_block+0x50>
static bool sd_mmc_spi_stop_multiwrite_block(void)
{
	uint8_t value;

	if (1 == sd_mmc_spi_nb_block) {
		return true; // Single block write
     c42:	2301      	movs	r3, #1
		sd_mmc_spi_debug("%s: Stop write blocks timeout\n\r",
				__func__);
		return false;
	}
	return true;
}
     c44:	0018      	movs	r0, r3
     c46:	b002      	add	sp, #8
     c48:	bd70      	pop	{r4, r5, r6, pc}
     c4a:	46c0      	nop			; (mov r8, r8)
     c4c:	200000c2 	.word	0x200000c2
     c50:	20000104 	.word	0x20000104
     c54:	20000100 	.word	0x20000100
     c58:	000082fd 	.word	0x000082fd
     c5c:	200000c4 	.word	0x200000c4
     c60:	00004f55 	.word	0x00004f55
     c64:	00000b91 	.word	0x00000b91
     c68:	20000106 	.word	0x20000106

00000c6c <sd_mmc_spi_start_read_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_start_read_block(void)
{
     c6c:	b5f0      	push	{r4, r5, r6, r7, lr}
     c6e:	b083      	sub	sp, #12
	 * Compute the maximum timeout:
	 * Frequency maximum = 25MHz
	 * 1 byte = 8 cycles
	 * 100ms = 312500 x spi_read_buffer_wait() maximum
	 */
	token = 0;
     c70:	2200      	movs	r2, #0
     c72:	466b      	mov	r3, sp
     c74:	71da      	strb	r2, [r3, #7]
     c76:	4c15      	ldr	r4, [pc, #84]	; (ccc <sd_mmc_spi_start_read_block+0x60>)
		if (i-- == 0) {
			sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_TIMEOUT;
			sd_mmc_spi_debug("%s: Read blocks timeout\n\r", __func__);
			return false;
		}
		spi_read_buffer_wait(&sd_mmc_master, &token, 1,
     c78:	466b      	mov	r3, sp
     c7a:	1ddd      	adds	r5, r3, #7
     c7c:	4e14      	ldr	r6, [pc, #80]	; (cd0 <sd_mmc_spi_start_read_block+0x64>)
     c7e:	4f15      	ldr	r7, [pc, #84]	; (cd4 <sd_mmc_spi_start_read_block+0x68>)
     c80:	e007      	b.n	c92 <sd_mmc_spi_start_read_block+0x26>
     c82:	3c01      	subs	r4, #1
	 * 100ms = 312500 x spi_read_buffer_wait() maximum
	 */
	token = 0;
	i = 500000;
	do {
		if (i-- == 0) {
     c84:	2c00      	cmp	r4, #0
     c86:	d104      	bne.n	c92 <sd_mmc_spi_start_read_block+0x26>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_TIMEOUT;
     c88:	2204      	movs	r2, #4
     c8a:	4b13      	ldr	r3, [pc, #76]	; (cd8 <sd_mmc_spi_start_read_block+0x6c>)
     c8c:	701a      	strb	r2, [r3, #0]
			sd_mmc_spi_debug("%s: Read blocks timeout\n\r", __func__);
			return false;
     c8e:	2000      	movs	r0, #0
     c90:	e019      	b.n	cc6 <sd_mmc_spi_start_read_block+0x5a>
		}
		spi_read_buffer_wait(&sd_mmc_master, &token, 1,
     c92:	23ff      	movs	r3, #255	; 0xff
     c94:	2201      	movs	r2, #1
     c96:	0029      	movs	r1, r5
     c98:	0030      	movs	r0, r6
     c9a:	47b8      	blx	r7
			dummy);
		if (SPI_TOKEN_DATA_ERROR_VALID(token)) {
     c9c:	782b      	ldrb	r3, [r5, #0]
     c9e:	220f      	movs	r2, #15
     ca0:	0019      	movs	r1, r3
     ca2:	4391      	bics	r1, r2
     ca4:	1e0a      	subs	r2, r1, #0
     ca6:	d10b      	bne.n	cc0 <sd_mmc_spi_start_read_block+0x54>
			Assert(SPI_TOKEN_DATA_ERROR_ERRORS & token);
			if (token & (SPI_TOKEN_DATA_ERROR_ERROR
     ca8:	075b      	lsls	r3, r3, #29
     caa:	d004      	beq.n	cb6 <sd_mmc_spi_start_read_block+0x4a>
					| SPI_TOKEN_DATA_ERROR_ECC_ERROR
					| SPI_TOKEN_DATA_ERROR_CC_ERROR)) {
				sd_mmc_spi_debug("%s: CRC data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_CRC;
     cac:	3207      	adds	r2, #7
     cae:	4b0a      	ldr	r3, [pc, #40]	; (cd8 <sd_mmc_spi_start_read_block+0x6c>)
     cb0:	701a      	strb	r2, [r3, #0]
			} else {
				sd_mmc_spi_debug("%s: Out of range data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_OUT_OF_RANGE;
			}
			return false;
     cb2:	2000      	movs	r0, #0
     cb4:	e007      	b.n	cc6 <sd_mmc_spi_start_read_block+0x5a>
					| SPI_TOKEN_DATA_ERROR_CC_ERROR)) {
				sd_mmc_spi_debug("%s: CRC data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_READ_CRC;
			} else {
				sd_mmc_spi_debug("%s: Out of range data error token\n\r", __func__);
				sd_mmc_spi_err = SD_MMC_SPI_ERR_OUT_OF_RANGE;
     cb6:	220b      	movs	r2, #11
     cb8:	4b07      	ldr	r3, [pc, #28]	; (cd8 <sd_mmc_spi_start_read_block+0x6c>)
     cba:	701a      	strb	r2, [r3, #0]
			}
			return false;
     cbc:	2000      	movs	r0, #0
     cbe:	e002      	b.n	cc6 <sd_mmc_spi_start_read_block+0x5a>
		}
	} while (token != SPI_TOKEN_SINGLE_MULTI_READ);
     cc0:	2bfe      	cmp	r3, #254	; 0xfe
     cc2:	d1de      	bne.n	c82 <sd_mmc_spi_start_read_block+0x16>

	return true;
     cc4:	2001      	movs	r0, #1
}
     cc6:	b003      	add	sp, #12
     cc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cca:	46c0      	nop			; (mov r8, r8)
     ccc:	0007a120 	.word	0x0007a120
     cd0:	200000c4 	.word	0x200000c4
     cd4:	00004db5 	.word	0x00004db5
     cd8:	20000106 	.word	0x20000106

00000cdc <sd_mmc_spi_stop_write_block>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_spi_err.
 */
static bool sd_mmc_spi_stop_write_block(void)
{
     cdc:	b530      	push	{r4, r5, lr}
     cde:	b083      	sub	sp, #12
	uint8_t resp;
	uint16_t crc;
	uint16_t dummy = 0xFF;

	// Send CRC
	crc = 0xFFFF; /// CRC is disabled in SPI mode
     ce0:	a901      	add	r1, sp, #4
     ce2:	2301      	movs	r3, #1
     ce4:	425b      	negs	r3, r3
     ce6:	800b      	strh	r3, [r1, #0]
	spi_write_buffer_wait(&sd_mmc_master, (uint8_t *)&crc, 2);
     ce8:	4d14      	ldr	r5, [pc, #80]	; (d3c <sd_mmc_spi_stop_write_block+0x60>)
     cea:	2202      	movs	r2, #2
     cec:	0028      	movs	r0, r5
     cee:	4b14      	ldr	r3, [pc, #80]	; (d40 <sd_mmc_spi_stop_write_block+0x64>)
     cf0:	4798      	blx	r3
	// Receiv data response token
	spi_read_buffer_wait(&sd_mmc_master, &resp, 1,
     cf2:	466b      	mov	r3, sp
     cf4:	1ddc      	adds	r4, r3, #7
     cf6:	23ff      	movs	r3, #255	; 0xff
     cf8:	2201      	movs	r2, #1
     cfa:	0021      	movs	r1, r4
     cfc:	0028      	movs	r0, r5
     cfe:	4d11      	ldr	r5, [pc, #68]	; (d44 <sd_mmc_spi_stop_write_block+0x68>)
     d00:	47a8      	blx	r5
			dummy);
	if (!SPI_TOKEN_DATA_RESP_VALID(resp)) {
     d02:	7822      	ldrb	r2, [r4, #0]
     d04:	2311      	movs	r3, #17
     d06:	4013      	ands	r3, r2
     d08:	2b01      	cmp	r3, #1
     d0a:	d004      	beq.n	d16 <sd_mmc_spi_stop_write_block+0x3a>
		sd_mmc_spi_err = SD_MMC_SPI_ERR;
     d0c:	2201      	movs	r2, #1
     d0e:	4b0e      	ldr	r3, [pc, #56]	; (d48 <sd_mmc_spi_stop_write_block+0x6c>)
     d10:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Invalid Data Response Token 0x%x\n\r", __func__, resp);
		return false;
     d12:	2000      	movs	r0, #0
     d14:	e010      	b.n	d38 <sd_mmc_spi_stop_write_block+0x5c>
	}
	// Check data response
	switch (SPI_TOKEN_DATA_RESP_CODE(resp)) {
     d16:	231e      	movs	r3, #30
     d18:	401a      	ands	r2, r3
     d1a:	2a04      	cmp	r2, #4
     d1c:	d00b      	beq.n	d36 <sd_mmc_spi_stop_write_block+0x5a>
     d1e:	2a0a      	cmp	r2, #10
     d20:	d104      	bne.n	d2c <sd_mmc_spi_stop_write_block+0x50>
	case SPI_TOKEN_DATA_RESP_ACCEPTED:
		break;
	case SPI_TOKEN_DATA_RESP_CRC_ERR:
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_CRC;
     d22:	3a02      	subs	r2, #2
     d24:	4b08      	ldr	r3, [pc, #32]	; (d48 <sd_mmc_spi_stop_write_block+0x6c>)
     d26:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks, SD_MMC_SPI_ERR_CRC, resp 0x%x\n\r",
				__func__, resp);
		return false;
     d28:	2000      	movs	r0, #0
     d2a:	e005      	b.n	d38 <sd_mmc_spi_stop_write_block+0x5c>
	case SPI_TOKEN_DATA_RESP_WRITE_ERR:
	default:
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE;
     d2c:	220a      	movs	r2, #10
     d2e:	4b06      	ldr	r3, [pc, #24]	; (d48 <sd_mmc_spi_stop_write_block+0x6c>)
     d30:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks SD_MMC_SPI_ERR_WR, resp 0x%x\n\r",
				__func__, resp);
		return false;
     d32:	2000      	movs	r0, #0
     d34:	e000      	b.n	d38 <sd_mmc_spi_stop_write_block+0x5c>
	}
	return true;
     d36:	2001      	movs	r0, #1
}
     d38:	b003      	add	sp, #12
     d3a:	bd30      	pop	{r4, r5, pc}
     d3c:	200000c4 	.word	0x200000c4
     d40:	00004f55 	.word	0x00004f55
     d44:	00004db5 	.word	0x00004db5
     d48:	20000106 	.word	0x20000106

00000d4c <sd_mmc_spi_select_device>:
	spi_attach_slave(&sd_mmc_spi_devices[0], &slave_configs[0]);
}

void sd_mmc_spi_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width,
		bool high_speed)
{
     d4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     d4e:	0007      	movs	r7, r0
	UNUSED(bus_width);
	UNUSED(high_speed);
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
     d50:	2200      	movs	r2, #0
     d52:	4b0d      	ldr	r3, [pc, #52]	; (d88 <sd_mmc_spi_select_device+0x3c>)
     d54:	701a      	strb	r2, [r3, #0]
     d56:	1e0c      	subs	r4, r1, #0
     d58:	4b0c      	ldr	r3, [pc, #48]	; (d8c <sd_mmc_spi_select_device+0x40>)
     d5a:	429c      	cmp	r4, r3
     d5c:	d900      	bls.n	d60 <sd_mmc_spi_select_device+0x14>
     d5e:	001c      	movs	r4, r3
#ifdef SD_MMC_SPI_MAX_CLOCK
	if (clock > SD_MMC_SPI_MAX_CLOCK) {
		clock = SD_MMC_SPI_MAX_CLOCK;
	}
#endif
	while (STATUS_ERR_INVALID_ARG == spi_set_baudrate(&sd_mmc_master, clock)) {
     d60:	4d0b      	ldr	r5, [pc, #44]	; (d90 <sd_mmc_spi_select_device+0x44>)
     d62:	4e0c      	ldr	r6, [pc, #48]	; (d94 <sd_mmc_spi_select_device+0x48>)
     d64:	e001      	b.n	d6a <sd_mmc_spi_select_device+0x1e>
		clock -= clock / 8;
     d66:	08e3      	lsrs	r3, r4, #3
     d68:	1ae4      	subs	r4, r4, r3
#ifdef SD_MMC_SPI_MAX_CLOCK
	if (clock > SD_MMC_SPI_MAX_CLOCK) {
		clock = SD_MMC_SPI_MAX_CLOCK;
	}
#endif
	while (STATUS_ERR_INVALID_ARG == spi_set_baudrate(&sd_mmc_master, clock)) {
     d6a:	0021      	movs	r1, r4
     d6c:	0028      	movs	r0, r5
     d6e:	47b0      	blx	r6
     d70:	2817      	cmp	r0, #23
     d72:	d0f8      	beq.n	d66 <sd_mmc_spi_select_device+0x1a>
		clock -= clock / 8;
	}
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], true);
     d74:	0079      	lsls	r1, r7, #1
     d76:	19cf      	adds	r7, r1, r7
     d78:	4907      	ldr	r1, [pc, #28]	; (d98 <sd_mmc_spi_select_device+0x4c>)
     d7a:	19c9      	adds	r1, r1, r7
     d7c:	2201      	movs	r2, #1
     d7e:	4804      	ldr	r0, [pc, #16]	; (d90 <sd_mmc_spi_select_device+0x44>)
     d80:	4b06      	ldr	r3, [pc, #24]	; (d9c <sd_mmc_spi_select_device+0x50>)
     d82:	4798      	blx	r3
}
     d84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     d86:	46c0      	nop			; (mov r8, r8)
     d88:	20000106 	.word	0x20000106
     d8c:	00989680 	.word	0x00989680
     d90:	200000c4 	.word	0x200000c4
     d94:	00004b35 	.word	0x00004b35
     d98:	20000108 	.word	0x20000108
     d9c:	00004e65 	.word	0x00004e65

00000da0 <sd_mmc_spi_deselect_device>:

void sd_mmc_spi_deselect_device(uint8_t slot)
{
     da0:	b510      	push	{r4, lr}
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
     da2:	2200      	movs	r2, #0
     da4:	4b04      	ldr	r3, [pc, #16]	; (db8 <sd_mmc_spi_deselect_device+0x18>)
     da6:	701a      	strb	r2, [r3, #0]
	spi_select_slave(&sd_mmc_master, &sd_mmc_spi_devices[slot], false);
     da8:	0041      	lsls	r1, r0, #1
     daa:	1808      	adds	r0, r1, r0
     dac:	4903      	ldr	r1, [pc, #12]	; (dbc <sd_mmc_spi_deselect_device+0x1c>)
     dae:	1809      	adds	r1, r1, r0
     db0:	4803      	ldr	r0, [pc, #12]	; (dc0 <sd_mmc_spi_deselect_device+0x20>)
     db2:	4b04      	ldr	r3, [pc, #16]	; (dc4 <sd_mmc_spi_deselect_device+0x24>)
     db4:	4798      	blx	r3
}
     db6:	bd10      	pop	{r4, pc}
     db8:	20000106 	.word	0x20000106
     dbc:	20000108 	.word	0x20000108
     dc0:	200000c4 	.word	0x200000c4
     dc4:	00004e65 	.word	0x00004e65

00000dc8 <sd_mmc_spi_send_clock>:

void sd_mmc_spi_send_clock(void)
{
     dc8:	b570      	push	{r4, r5, r6, lr}
     dca:	b082      	sub	sp, #8
	uint8_t i;
	uint8_t dummy = 0xFF;
     dcc:	22ff      	movs	r2, #255	; 0xff
     dce:	466b      	mov	r3, sp
     dd0:	71da      	strb	r2, [r3, #7]

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
     dd2:	2200      	movs	r2, #0
     dd4:	4b07      	ldr	r3, [pc, #28]	; (df4 <sd_mmc_spi_send_clock+0x2c>)
     dd6:	701a      	strb	r2, [r3, #0]
     dd8:	240a      	movs	r4, #10
	//! Send 80 cycles
	for (i = 0; i < 10; i++) {
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
     dda:	4e07      	ldr	r6, [pc, #28]	; (df8 <sd_mmc_spi_send_clock+0x30>)
     ddc:	4d07      	ldr	r5, [pc, #28]	; (dfc <sd_mmc_spi_send_clock+0x34>)
     dde:	2201      	movs	r2, #1
     de0:	466b      	mov	r3, sp
     de2:	1dd9      	adds	r1, r3, #7
     de4:	0030      	movs	r0, r6
     de6:	47a8      	blx	r5
     de8:	3c01      	subs	r4, #1
     dea:	b2e4      	uxtb	r4, r4
	uint8_t i;
	uint8_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	//! Send 80 cycles
	for (i = 0; i < 10; i++) {
     dec:	2c00      	cmp	r4, #0
     dee:	d1f6      	bne.n	dde <sd_mmc_spi_send_clock+0x16>
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
	}
}
     df0:	b002      	add	sp, #8
     df2:	bd70      	pop	{r4, r5, r6, pc}
     df4:	20000106 	.word	0x20000106
     df8:	200000c4 	.word	0x200000c4
     dfc:	00004f55 	.word	0x00004f55

00000e00 <sd_mmc_spi_adtc_start>:
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
}

bool sd_mmc_spi_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg,
		uint16_t block_size, uint16_t nb_block, bool access_block)
{
     e00:	b5f0      	push	{r4, r5, r6, r7, lr}
     e02:	4647      	mov	r7, r8
     e04:	b480      	push	{r7}
     e06:	b086      	sub	sp, #24
     e08:	4680      	mov	r8, r0
     e0a:	9200      	str	r2, [sp, #0]
     e0c:	9301      	str	r3, [sp, #4]
	uint8_t dummy = 0xFF;
     e0e:	22ff      	movs	r2, #255	; 0xff
     e10:	230f      	movs	r3, #15
     e12:	a802      	add	r0, sp, #8
     e14:	4684      	mov	ip, r0
     e16:	4463      	add	r3, ip
     e18:	701a      	strb	r2, [r3, #0]
	uint8_t r1; //! R1 response
	uint16_t dummy2 = 0xFF;

	UNUSED(access_block);
	Assert(cmd & SDMMC_RESP_PRESENT); // Always a response in SPI mode
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
     e1a:	2200      	movs	r2, #0
     e1c:	4b51      	ldr	r3, [pc, #324]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     e1e:	701a      	strb	r2, [r3, #0]

	// Encode SPI command
	cmd_token[0] = SPI_CMD_ENCODE(SDMMC_CMD_GET_INDEX(cmd));
     e20:	ab04      	add	r3, sp, #16
     e22:	323f      	adds	r2, #63	; 0x3f
     e24:	4640      	mov	r0, r8
     e26:	4002      	ands	r2, r0
     e28:	2040      	movs	r0, #64	; 0x40
     e2a:	4302      	orrs	r2, r0
     e2c:	701a      	strb	r2, [r3, #0]
	cmd_token[1] = arg >> 24;
     e2e:	0e0a      	lsrs	r2, r1, #24
     e30:	705a      	strb	r2, [r3, #1]
	cmd_token[2] = arg >> 16;
     e32:	0c0a      	lsrs	r2, r1, #16
     e34:	709a      	strb	r2, [r3, #2]
	cmd_token[3] = arg >> 8;
     e36:	0a0a      	lsrs	r2, r1, #8
     e38:	70da      	strb	r2, [r3, #3]
	cmd_token[4] = arg;
     e3a:	7119      	strb	r1, [r3, #4]
     e3c:	2600      	movs	r6, #0
 */
static uint8_t sd_mmc_spi_crc7(uint8_t * buf, uint8_t size)
{
	uint8_t crc, value, i;

	crc = 0;
     e3e:	2300      	movs	r3, #0
	while (size--) {
		value = *buf++;
     e40:	2108      	movs	r1, #8
		for (i = 0; i < 8; i++) {
			crc <<= 1;
			if ((value & 0x80) ^ (crc & 0x80)) {
				crc ^= 0x09;
     e42:	2709      	movs	r7, #9
{
	uint8_t crc, value, i;

	crc = 0;
	while (size--) {
		value = *buf++;
     e44:	aa04      	add	r2, sp, #16
     e46:	5cb0      	ldrb	r0, [r6, r2]
     e48:	000a      	movs	r2, r1
		for (i = 0; i < 8; i++) {
			crc <<= 1;
     e4a:	005b      	lsls	r3, r3, #1
     e4c:	b2db      	uxtb	r3, r3
			if ((value & 0x80) ^ (crc & 0x80)) {
     e4e:	001c      	movs	r4, r3
     e50:	4044      	eors	r4, r0
     e52:	0624      	lsls	r4, r4, #24
     e54:	d501      	bpl.n	e5a <sd_mmc_spi_adtc_start+0x5a>
				crc ^= 0x09;
     e56:	407b      	eors	r3, r7
     e58:	b2db      	uxtb	r3, r3
			}
			value <<= 1;
     e5a:	0040      	lsls	r0, r0, #1
     e5c:	b2c0      	uxtb	r0, r0
     e5e:	3a01      	subs	r2, #1
     e60:	b2d2      	uxtb	r2, r2
	uint8_t crc, value, i;

	crc = 0;
	while (size--) {
		value = *buf++;
		for (i = 0; i < 8; i++) {
     e62:	2a00      	cmp	r2, #0
     e64:	d1f1      	bne.n	e4a <sd_mmc_spi_adtc_start+0x4a>
     e66:	3601      	adds	r6, #1
static uint8_t sd_mmc_spi_crc7(uint8_t * buf, uint8_t size)
{
	uint8_t crc, value, i;

	crc = 0;
	while (size--) {
     e68:	2e05      	cmp	r6, #5
     e6a:	d1eb      	bne.n	e44 <sd_mmc_spi_adtc_start+0x44>
				crc ^= 0x09;
			}
			value <<= 1;
		}
	}
	crc = (crc << 1) | 1;
     e6c:	005b      	lsls	r3, r3, #1
     e6e:	2201      	movs	r2, #1
     e70:	4313      	orrs	r3, r2
	cmd_token[0] = SPI_CMD_ENCODE(SDMMC_CMD_GET_INDEX(cmd));
	cmd_token[1] = arg >> 24;
	cmd_token[2] = arg >> 16;
	cmd_token[3] = arg >> 8;
	cmd_token[4] = arg;
	cmd_token[5] = sd_mmc_spi_crc7(cmd_token, 5);
     e72:	ac04      	add	r4, sp, #16
     e74:	7163      	strb	r3, [r4, #5]

	// 8 cycles to respect Ncs timing
	// Note: This byte does not include start bit "0",
	// thus it is ignored by card.
	spi_write_buffer_wait(&sd_mmc_master, &dummy, 1);
     e76:	4e3c      	ldr	r6, [pc, #240]	; (f68 <sd_mmc_spi_adtc_start+0x168>)
     e78:	2201      	movs	r2, #1
     e7a:	210f      	movs	r1, #15
     e7c:	ab02      	add	r3, sp, #8
     e7e:	469c      	mov	ip, r3
     e80:	4461      	add	r1, ip
     e82:	0030      	movs	r0, r6
     e84:	4f39      	ldr	r7, [pc, #228]	; (f6c <sd_mmc_spi_adtc_start+0x16c>)
     e86:	47b8      	blx	r7
	// Send command
	spi_write_buffer_wait(&sd_mmc_master, cmd_token, sizeof(cmd_token));
     e88:	2206      	movs	r2, #6
     e8a:	0021      	movs	r1, r4
     e8c:	0030      	movs	r0, r6
     e8e:	47b8      	blx	r7

	// Wait for response
	// Two retry will be done to manage the Ncr timing between command and reponse
	// Ncr: Min. 1x8 clock  cycle, Max. 8x8 clock cycles
	// WORKAROUND for no compliance card (Atmel Internal ref. SD13):
	r1 = 0xFF;
     e90:	ab02      	add	r3, sp, #8
     e92:	1dd9      	adds	r1, r3, #7
     e94:	23ff      	movs	r3, #255	; 0xff
     e96:	700b      	strb	r3, [r1, #0]
	// Ignore first byte because Ncr min. = 8 clock cylces
	spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
     e98:	2201      	movs	r2, #1
     e9a:	0030      	movs	r0, r6
     e9c:	4e34      	ldr	r6, [pc, #208]	; (f70 <sd_mmc_spi_adtc_start+0x170>)
     e9e:	47b0      	blx	r6
     ea0:	2407      	movs	r4, #7
			dummy2);
	ncr_timeout = 7;
	while (1) {
		spi_read_buffer_wait(&sd_mmc_master, &r1, 1,
     ea2:	ab02      	add	r3, sp, #8
     ea4:	1dde      	adds	r6, r3, #7
     ea6:	4f30      	ldr	r7, [pc, #192]	; (f68 <sd_mmc_spi_adtc_start+0x168>)
     ea8:	4d31      	ldr	r5, [pc, #196]	; (f70 <sd_mmc_spi_adtc_start+0x170>)
     eaa:	23ff      	movs	r3, #255	; 0xff
     eac:	2201      	movs	r2, #1
     eae:	0031      	movs	r1, r6
     eb0:	0038      	movs	r0, r7
     eb2:	47a8      	blx	r5
			dummy2); // 8 cycles
		if ((r1 & R1_SPI_ERROR) == 0) {
     eb4:	7833      	ldrb	r3, [r6, #0]
     eb6:	b25a      	sxtb	r2, r3
     eb8:	2a00      	cmp	r2, #0
     eba:	da08      	bge.n	ece <sd_mmc_spi_adtc_start+0xce>
     ebc:	1e63      	subs	r3, r4, #1
     ebe:	b2dc      	uxtb	r4, r3
			// Valid R1 response
			break;
		}
		if (--ncr_timeout == 0) {
     ec0:	2c00      	cmp	r4, #0
     ec2:	d1f2      	bne.n	eaa <sd_mmc_spi_adtc_start+0xaa>
			// Here Valid R1 response received
			sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lX, R1 timeout\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg);
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_TIMEOUT;
     ec4:	2202      	movs	r2, #2
     ec6:	4b27      	ldr	r3, [pc, #156]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     ec8:	701a      	strb	r2, [r3, #0]
			return false;
     eca:	2000      	movs	r0, #0
     ecc:	e045      	b.n	f5a <sd_mmc_spi_adtc_start+0x15a>
		}
	}

	// Save R1 (Specific to SPI interface) in 32 bit response
	// The R1_SPI_IDLE bit can be checked by high level
	sd_mmc_spi_response_32 = r1;
     ece:	4a29      	ldr	r2, [pc, #164]	; (f74 <sd_mmc_spi_adtc_start+0x174>)
     ed0:	6013      	str	r3, [r2, #0]

	// Manage error in R1
	if (r1 & R1_SPI_COM_CRC) {
     ed2:	071a      	lsls	r2, r3, #28
     ed4:	d504      	bpl.n	ee0 <sd_mmc_spi_adtc_start+0xe0>
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%02x, R1_SPI_COM_CRC\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_CRC;
     ed6:	2206      	movs	r2, #6
     ed8:	4b22      	ldr	r3, [pc, #136]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     eda:	701a      	strb	r2, [r3, #0]
		return false;
     edc:	2000      	movs	r0, #0
     ede:	e03c      	b.n	f5a <sd_mmc_spi_adtc_start+0x15a>
	}
	if (r1 & R1_SPI_ILLEGAL_COMMAND) {
     ee0:	075a      	lsls	r2, r3, #29
     ee2:	d504      	bpl.n	eee <sd_mmc_spi_adtc_start+0xee>
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%x, R1 ILLEGAL_COMMAND\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR_ILLEGAL_COMMAND;
     ee4:	2209      	movs	r2, #9
     ee6:	4b1f      	ldr	r3, [pc, #124]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     ee8:	701a      	strb	r2, [r3, #0]
		return false;
     eea:	2000      	movs	r0, #0
     eec:	e035      	b.n	f5a <sd_mmc_spi_adtc_start+0x15a>
	}
	if (r1 & ~R1_SPI_IDLE) {
     eee:	2201      	movs	r2, #1
     ef0:	4393      	bics	r3, r2
     ef2:	d003      	beq.n	efc <sd_mmc_spi_adtc_start+0xfc>
		// Other error
		sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, r1 0x%x, R1 error\n\r",
				__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg, r1);
		sd_mmc_spi_err = SD_MMC_SPI_ERR;
     ef4:	4b1b      	ldr	r3, [pc, #108]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     ef6:	701a      	strb	r2, [r3, #0]
		return false;
     ef8:	2000      	movs	r0, #0
     efa:	e02e      	b.n	f5a <sd_mmc_spi_adtc_start+0x15a>
	}

	// Manage other responses
	if (cmd & SDMMC_RESP_BUSY) {
     efc:	4643      	mov	r3, r8
     efe:	049b      	lsls	r3, r3, #18
     f00:	d507      	bpl.n	f12 <sd_mmc_spi_adtc_start+0x112>
		if (!sd_mmc_spi_wait_busy()) {
     f02:	4b1d      	ldr	r3, [pc, #116]	; (f78 <sd_mmc_spi_adtc_start+0x178>)
     f04:	4798      	blx	r3
     f06:	2800      	cmp	r0, #0
     f08:	d103      	bne.n	f12 <sd_mmc_spi_adtc_start+0x112>
			sd_mmc_spi_err = SD_MMC_SPI_ERR_RESP_BUSY_TIMEOUT;
     f0a:	2203      	movs	r2, #3
     f0c:	4b15      	ldr	r3, [pc, #84]	; (f64 <sd_mmc_spi_adtc_start+0x164>)
     f0e:	701a      	strb	r2, [r3, #0]
			sd_mmc_spi_debug("%s: cmd %02d, arg 0x%08lx, Busy signal always high\n\r",
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), arg);
			return false;
     f10:	e023      	b.n	f5a <sd_mmc_spi_adtc_start+0x15a>
		}
	}
	if (cmd & SDMMC_RESP_8) {
     f12:	4643      	mov	r3, r8
     f14:	059b      	lsls	r3, r3, #22
     f16:	d507      	bpl.n	f28 <sd_mmc_spi_adtc_start+0x128>
		sd_mmc_spi_response_32 = 0;
     f18:	4916      	ldr	r1, [pc, #88]	; (f74 <sd_mmc_spi_adtc_start+0x174>)
     f1a:	2300      	movs	r3, #0
     f1c:	600b      	str	r3, [r1, #0]
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 1,
     f1e:	33ff      	adds	r3, #255	; 0xff
     f20:	2201      	movs	r2, #1
     f22:	4811      	ldr	r0, [pc, #68]	; (f68 <sd_mmc_spi_adtc_start+0x168>)
     f24:	4e12      	ldr	r6, [pc, #72]	; (f70 <sd_mmc_spi_adtc_start+0x170>)
     f26:	47b0      	blx	r6
			dummy2);
		sd_mmc_spi_response_32 = le32_to_cpu(sd_mmc_spi_response_32);
	}
	if (cmd & SDMMC_RESP_32) {
     f28:	4643      	mov	r3, r8
     f2a:	055b      	lsls	r3, r3, #21
     f2c:	d509      	bpl.n	f42 <sd_mmc_spi_adtc_start+0x142>
		spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&sd_mmc_spi_response_32, 4,
     f2e:	4e11      	ldr	r6, [pc, #68]	; (f74 <sd_mmc_spi_adtc_start+0x174>)
     f30:	23ff      	movs	r3, #255	; 0xff
     f32:	2204      	movs	r2, #4
     f34:	0031      	movs	r1, r6
     f36:	480c      	ldr	r0, [pc, #48]	; (f68 <sd_mmc_spi_adtc_start+0x168>)
     f38:	4f0d      	ldr	r7, [pc, #52]	; (f70 <sd_mmc_spi_adtc_start+0x170>)
     f3a:	47b8      	blx	r7
			dummy2);
		sd_mmc_spi_response_32 = be32_to_cpu(sd_mmc_spi_response_32);
     f3c:	6833      	ldr	r3, [r6, #0]
     f3e:	ba1b      	rev	r3, r3
     f40:	6033      	str	r3, [r6, #0]
	}

	sd_mmc_spi_block_size = block_size;
     f42:	4b0e      	ldr	r3, [pc, #56]	; (f7c <sd_mmc_spi_adtc_start+0x17c>)
     f44:	466a      	mov	r2, sp
     f46:	8812      	ldrh	r2, [r2, #0]
     f48:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_nb_block = nb_block;
     f4a:	4b0d      	ldr	r3, [pc, #52]	; (f80 <sd_mmc_spi_adtc_start+0x180>)
     f4c:	466a      	mov	r2, sp
     f4e:	8892      	ldrh	r2, [r2, #4]
     f50:	801a      	strh	r2, [r3, #0]
	sd_mmc_spi_transfert_pos = 0;
     f52:	2200      	movs	r2, #0
     f54:	4b0b      	ldr	r3, [pc, #44]	; (f84 <sd_mmc_spi_adtc_start+0x184>)
     f56:	601a      	str	r2, [r3, #0]
	return true; // Command complete
     f58:	2001      	movs	r0, #1
}
     f5a:	b006      	add	sp, #24
     f5c:	bc04      	pop	{r2}
     f5e:	4690      	mov	r8, r2
     f60:	bdf0      	pop	{r4, r5, r6, r7, pc}
     f62:	46c0      	nop			; (mov r8, r8)
     f64:	20000106 	.word	0x20000106
     f68:	200000c4 	.word	0x200000c4
     f6c:	00004f55 	.word	0x00004f55
     f70:	00004db5 	.word	0x00004db5
     f74:	2000010c 	.word	0x2000010c
     f78:	00000b91 	.word	0x00000b91
     f7c:	20000104 	.word	0x20000104
     f80:	200000c2 	.word	0x200000c2
     f84:	20000100 	.word	0x20000100

00000f88 <sd_mmc_spi_send_cmd>:
		spi_write_buffer_wait(&sd_mmc_master, &dummy, 1); // 8 cycles
	}
}

bool sd_mmc_spi_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
     f88:	b510      	push	{r4, lr}
     f8a:	b082      	sub	sp, #8
	return sd_mmc_spi_adtc_start(cmd, arg, 0, 0, false);
     f8c:	2300      	movs	r3, #0
     f8e:	9300      	str	r3, [sp, #0]
     f90:	2200      	movs	r2, #0
     f92:	4c02      	ldr	r4, [pc, #8]	; (f9c <sd_mmc_spi_send_cmd+0x14>)
     f94:	47a0      	blx	r4
}
     f96:	b002      	add	sp, #8
     f98:	bd10      	pop	{r4, pc}
     f9a:	46c0      	nop			; (mov r8, r8)
     f9c:	00000e01 	.word	0x00000e01

00000fa0 <sd_mmc_spi_get_response>:
	return true; // Command complete
}

uint32_t sd_mmc_spi_get_response(void)
{
	return sd_mmc_spi_response_32;
     fa0:	4b01      	ldr	r3, [pc, #4]	; (fa8 <sd_mmc_spi_get_response+0x8>)
     fa2:	6818      	ldr	r0, [r3, #0]
}
     fa4:	4770      	bx	lr
     fa6:	46c0      	nop			; (mov r8, r8)
     fa8:	2000010c 	.word	0x2000010c

00000fac <sd_mmc_spi_read_word>:

bool sd_mmc_spi_read_word(uint32_t* value)
{
     fac:	b510      	push	{r4, lr}
     fae:	b084      	sub	sp, #16
     fb0:	9001      	str	r0, [sp, #4]
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
     fb2:	2200      	movs	r2, #0
     fb4:	4b13      	ldr	r3, [pc, #76]	; (1004 <sd_mmc_spi_read_word+0x58>)
     fb6:	701a      	strb	r2, [r3, #0]
	Assert(sd_mmc_spi_nb_block >
			(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
     fb8:	4b13      	ldr	r3, [pc, #76]	; (1008 <sd_mmc_spi_read_word+0x5c>)
     fba:	8819      	ldrh	r1, [r3, #0]
     fbc:	4b13      	ldr	r3, [pc, #76]	; (100c <sd_mmc_spi_read_word+0x60>)
     fbe:	6818      	ldr	r0, [r3, #0]
     fc0:	4b13      	ldr	r3, [pc, #76]	; (1010 <sd_mmc_spi_read_word+0x64>)
     fc2:	4798      	blx	r3
     fc4:	2900      	cmp	r1, #0
     fc6:	d103      	bne.n	fd0 <sd_mmc_spi_read_word+0x24>
		// New block
		if (!sd_mmc_spi_start_read_block()) {
     fc8:	4b12      	ldr	r3, [pc, #72]	; (1014 <sd_mmc_spi_read_word+0x68>)
     fca:	4798      	blx	r3
     fcc:	2800      	cmp	r0, #0
     fce:	d017      	beq.n	1000 <sd_mmc_spi_read_word+0x54>
			return false;
		}
	}
	// Read data
	spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&value, 4,
     fd0:	23ff      	movs	r3, #255	; 0xff
     fd2:	2204      	movs	r2, #4
     fd4:	a901      	add	r1, sp, #4
     fd6:	4810      	ldr	r0, [pc, #64]	; (1018 <sd_mmc_spi_read_word+0x6c>)
     fd8:	4c10      	ldr	r4, [pc, #64]	; (101c <sd_mmc_spi_read_word+0x70>)
     fda:	47a0      	blx	r4
			dummy);
	*value = le32_to_cpu(*value);
	sd_mmc_spi_transfert_pos += 4;
     fdc:	4b0b      	ldr	r3, [pc, #44]	; (100c <sd_mmc_spi_read_word+0x60>)
     fde:	681a      	ldr	r2, [r3, #0]
     fe0:	1d10      	adds	r0, r2, #4
     fe2:	6018      	str	r0, [r3, #0]

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
     fe4:	4b08      	ldr	r3, [pc, #32]	; (1008 <sd_mmc_spi_read_word+0x5c>)
     fe6:	8819      	ldrh	r1, [r3, #0]
     fe8:	4b09      	ldr	r3, [pc, #36]	; (1010 <sd_mmc_spi_read_word+0x64>)
     fea:	4798      	blx	r3
		// End of block
		sd_mmc_spi_stop_read_block();
	}
	return true;
     fec:	2001      	movs	r0, #1
	spi_read_buffer_wait(&sd_mmc_master, (uint8_t *)&value, 4,
			dummy);
	*value = le32_to_cpu(*value);
	sd_mmc_spi_transfert_pos += 4;

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
     fee:	2900      	cmp	r1, #0
     ff0:	d106      	bne.n	1000 <sd_mmc_spi_read_word+0x54>
static void sd_mmc_spi_stop_read_block(void)
{
	uint8_t crc[2];
	uint16_t dummy = 0xFF;
	// Read 16-bit CRC (not cheked)
	spi_read_buffer_wait(&sd_mmc_master, crc, 2,
     ff2:	23ff      	movs	r3, #255	; 0xff
     ff4:	2202      	movs	r2, #2
     ff6:	a903      	add	r1, sp, #12
     ff8:	4807      	ldr	r0, [pc, #28]	; (1018 <sd_mmc_spi_read_word+0x6c>)
     ffa:	4c08      	ldr	r4, [pc, #32]	; (101c <sd_mmc_spi_read_word+0x70>)
     ffc:	47a0      	blx	r4

	if (!(sd_mmc_spi_transfert_pos % sd_mmc_spi_block_size)) {
		// End of block
		sd_mmc_spi_stop_read_block();
	}
	return true;
     ffe:	2001      	movs	r0, #1
}
    1000:	b004      	add	sp, #16
    1002:	bd10      	pop	{r4, pc}
    1004:	20000106 	.word	0x20000106
    1008:	20000104 	.word	0x20000104
    100c:	20000100 	.word	0x20000100
    1010:	00008409 	.word	0x00008409
    1014:	00000c6d 	.word	0x00000c6d
    1018:	200000c4 	.word	0x200000c4
    101c:	00004db5 	.word	0x00004db5

00001020 <sd_mmc_spi_start_read_blocks>:
	}
	return sd_mmc_spi_stop_multiwrite_block();
}

bool sd_mmc_spi_start_read_blocks(void *dest, uint16_t nb_block)
{
    1020:	b5f0      	push	{r4, r5, r6, r7, lr}
    1022:	465f      	mov	r7, fp
    1024:	4656      	mov	r6, sl
    1026:	4645      	mov	r5, r8
    1028:	b4e0      	push	{r5, r6, r7}
    102a:	b082      	sub	sp, #8
    102c:	4683      	mov	fp, r0
	uint32_t pos;
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
    102e:	2200      	movs	r2, #0
    1030:	4b16      	ldr	r3, [pc, #88]	; (108c <sd_mmc_spi_start_read_blocks+0x6c>)
    1032:	701a      	strb	r2, [r3, #0]
	pos = 0;
	while (nb_block--) {
    1034:	2900      	cmp	r1, #0
    1036:	d020      	beq.n	107a <sd_mmc_spi_start_read_blocks+0x5a>
    1038:	000c      	movs	r4, r1
    103a:	2600      	movs	r6, #0
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		if (!sd_mmc_spi_start_read_block()) {
    103c:	4b14      	ldr	r3, [pc, #80]	; (1090 <sd_mmc_spi_start_read_blocks+0x70>)
    103e:	469a      	mov	sl, r3
			return false;
		}

		// Read block
		spi_read_buffer_wait(&sd_mmc_master, &((uint8_t*)dest)[pos],
    1040:	4f14      	ldr	r7, [pc, #80]	; (1094 <sd_mmc_spi_start_read_blocks+0x74>)
	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		if (!sd_mmc_spi_start_read_block()) {
    1042:	47d0      	blx	sl
    1044:	4680      	mov	r8, r0
    1046:	2800      	cmp	r0, #0
    1048:	d019      	beq.n	107e <sd_mmc_spi_start_read_blocks+0x5e>
			return false;
		}

		// Read block
		spi_read_buffer_wait(&sd_mmc_master, &((uint8_t*)dest)[pos],
    104a:	883a      	ldrh	r2, [r7, #0]
    104c:	465b      	mov	r3, fp
    104e:	1999      	adds	r1, r3, r6
    1050:	23ff      	movs	r3, #255	; 0xff
    1052:	4811      	ldr	r0, [pc, #68]	; (1098 <sd_mmc_spi_start_read_blocks+0x78>)
    1054:	4d11      	ldr	r5, [pc, #68]	; (109c <sd_mmc_spi_start_read_blocks+0x7c>)
    1056:	47a8      	blx	r5
			sd_mmc_spi_block_size, dummy);
		pos += sd_mmc_spi_block_size;
    1058:	883b      	ldrh	r3, [r7, #0]
    105a:	18f6      	adds	r6, r6, r3
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
    105c:	4a10      	ldr	r2, [pc, #64]	; (10a0 <sd_mmc_spi_start_read_blocks+0x80>)
    105e:	6811      	ldr	r1, [r2, #0]
    1060:	468c      	mov	ip, r1
    1062:	4463      	add	r3, ip
    1064:	6013      	str	r3, [r2, #0]
static void sd_mmc_spi_stop_read_block(void)
{
	uint8_t crc[2];
	uint16_t dummy = 0xFF;
	// Read 16-bit CRC (not cheked)
	spi_read_buffer_wait(&sd_mmc_master, crc, 2,
    1066:	23ff      	movs	r3, #255	; 0xff
    1068:	2202      	movs	r2, #2
    106a:	a901      	add	r1, sp, #4
    106c:	480a      	ldr	r0, [pc, #40]	; (1098 <sd_mmc_spi_start_read_blocks+0x78>)
    106e:	47a8      	blx	r5
    1070:	3c01      	subs	r4, #1
    1072:	b2a4      	uxth	r4, r4
	uint32_t pos;
	uint16_t dummy = 0xFF;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
    1074:	2c00      	cmp	r4, #0
    1076:	d1e4      	bne.n	1042 <sd_mmc_spi_start_read_blocks+0x22>
    1078:	e001      	b.n	107e <sd_mmc_spi_start_read_blocks+0x5e>
		pos += sd_mmc_spi_block_size;
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;

		sd_mmc_spi_stop_read_block();
	}
	return true;
    107a:	2301      	movs	r3, #1
    107c:	4698      	mov	r8, r3
}
    107e:	4640      	mov	r0, r8
    1080:	b002      	add	sp, #8
    1082:	bc1c      	pop	{r2, r3, r4}
    1084:	4690      	mov	r8, r2
    1086:	469a      	mov	sl, r3
    1088:	46a3      	mov	fp, r4
    108a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    108c:	20000106 	.word	0x20000106
    1090:	00000c6d 	.word	0x00000c6d
    1094:	20000104 	.word	0x20000104
    1098:	200000c4 	.word	0x200000c4
    109c:	00004db5 	.word	0x00004db5
    10a0:	20000100 	.word	0x20000100

000010a4 <sd_mmc_spi_wait_end_of_read_blocks>:

bool sd_mmc_spi_wait_end_of_read_blocks(void)
{
	return true;
}
    10a4:	2001      	movs	r0, #1
    10a6:	4770      	bx	lr

000010a8 <sd_mmc_spi_start_write_blocks>:

bool sd_mmc_spi_start_write_blocks(const void *src, uint16_t nb_block)
{
    10a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    10aa:	4647      	mov	r7, r8
    10ac:	b480      	push	{r7}
    10ae:	4680      	mov	r8, r0
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
    10b0:	2200      	movs	r2, #0
    10b2:	4b16      	ldr	r3, [pc, #88]	; (110c <sd_mmc_spi_start_write_blocks+0x64>)
    10b4:	701a      	strb	r2, [r3, #0]
    10b6:	3901      	subs	r1, #1
    10b8:	b28c      	uxth	r4, r1
	pos = 0;
    10ba:	2500      	movs	r5, #0
	while (nb_block--) {
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		sd_mmc_spi_start_write_block();
    10bc:	4f14      	ldr	r7, [pc, #80]	; (1110 <sd_mmc_spi_start_write_blocks+0x68>)

		// Write block
		spi_write_buffer_wait(&sd_mmc_master, &((uint8_t*)src)[pos],
    10be:	4e15      	ldr	r6, [pc, #84]	; (1114 <sd_mmc_spi_start_write_blocks+0x6c>)
{
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
    10c0:	e01d      	b.n	10fe <sd_mmc_spi_start_write_blocks+0x56>
		Assert(sd_mmc_spi_nb_block >
				(sd_mmc_spi_transfert_pos / sd_mmc_spi_block_size));
		sd_mmc_spi_start_write_block();
    10c2:	47b8      	blx	r7

		// Write block
		spi_write_buffer_wait(&sd_mmc_master, &((uint8_t*)src)[pos],
    10c4:	8832      	ldrh	r2, [r6, #0]
    10c6:	4643      	mov	r3, r8
    10c8:	1959      	adds	r1, r3, r5
    10ca:	4813      	ldr	r0, [pc, #76]	; (1118 <sd_mmc_spi_start_write_blocks+0x70>)
    10cc:	4b13      	ldr	r3, [pc, #76]	; (111c <sd_mmc_spi_start_write_blocks+0x74>)
    10ce:	4798      	blx	r3
				sd_mmc_spi_block_size);
		pos += sd_mmc_spi_block_size;
    10d0:	8833      	ldrh	r3, [r6, #0]
    10d2:	18ed      	adds	r5, r5, r3
		sd_mmc_spi_transfert_pos += sd_mmc_spi_block_size;
    10d4:	4a12      	ldr	r2, [pc, #72]	; (1120 <sd_mmc_spi_start_write_blocks+0x78>)
    10d6:	6811      	ldr	r1, [r2, #0]
    10d8:	468c      	mov	ip, r1
    10da:	4463      	add	r3, ip
    10dc:	6013      	str	r3, [r2, #0]

		if (!sd_mmc_spi_stop_write_block()) {
    10de:	4b11      	ldr	r3, [pc, #68]	; (1124 <sd_mmc_spi_start_write_blocks+0x7c>)
    10e0:	4798      	blx	r3
    10e2:	2800      	cmp	r0, #0
    10e4:	d00f      	beq.n	1106 <sd_mmc_spi_start_write_blocks+0x5e>
			return false;
		}
		// Do not check busy of last block
		// but delay it to mci_wait_end_of_write_blocks()
		if (nb_block) {
    10e6:	2c00      	cmp	r4, #0
    10e8:	d007      	beq.n	10fa <sd_mmc_spi_start_write_blocks+0x52>
			// Wait busy due to data programmation
			if (!sd_mmc_spi_wait_busy()) {
    10ea:	4b0f      	ldr	r3, [pc, #60]	; (1128 <sd_mmc_spi_start_write_blocks+0x80>)
    10ec:	4798      	blx	r3
    10ee:	2800      	cmp	r0, #0
    10f0:	d103      	bne.n	10fa <sd_mmc_spi_start_write_blocks+0x52>
				sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
    10f2:	2205      	movs	r2, #5
    10f4:	4b05      	ldr	r3, [pc, #20]	; (110c <sd_mmc_spi_start_write_blocks+0x64>)
    10f6:	701a      	strb	r2, [r3, #0]
				sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
				return false;
    10f8:	e005      	b.n	1106 <sd_mmc_spi_start_write_blocks+0x5e>
    10fa:	3c01      	subs	r4, #1
    10fc:	b2a4      	uxth	r4, r4
{
	uint32_t pos;

	sd_mmc_spi_err = SD_MMC_SPI_NO_ERR;
	pos = 0;
	while (nb_block--) {
    10fe:	4b0b      	ldr	r3, [pc, #44]	; (112c <sd_mmc_spi_start_write_blocks+0x84>)
    1100:	429c      	cmp	r4, r3
    1102:	d1de      	bne.n	10c2 <sd_mmc_spi_start_write_blocks+0x1a>
				sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
				return false;
			}
		}
	}
	return true;
    1104:	2001      	movs	r0, #1
}
    1106:	bc04      	pop	{r2}
    1108:	4690      	mov	r8, r2
    110a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    110c:	20000106 	.word	0x20000106
    1110:	00000b49 	.word	0x00000b49
    1114:	20000104 	.word	0x20000104
    1118:	200000c4 	.word	0x200000c4
    111c:	00004f55 	.word	0x00004f55
    1120:	20000100 	.word	0x20000100
    1124:	00000cdd 	.word	0x00000cdd
    1128:	00000b91 	.word	0x00000b91
    112c:	0000ffff 	.word	0x0000ffff

00001130 <sd_mmc_spi_wait_end_of_write_blocks>:

bool sd_mmc_spi_wait_end_of_write_blocks(void)
{
    1130:	b510      	push	{r4, lr}
	// Wait busy due to data programmation of last block writed
	if (!sd_mmc_spi_wait_busy()) {
    1132:	4b05      	ldr	r3, [pc, #20]	; (1148 <sd_mmc_spi_wait_end_of_write_blocks+0x18>)
    1134:	4798      	blx	r3
    1136:	2800      	cmp	r0, #0
    1138:	d103      	bne.n	1142 <sd_mmc_spi_wait_end_of_write_blocks+0x12>
		sd_mmc_spi_err = SD_MMC_SPI_ERR_WRITE_TIMEOUT;
    113a:	2205      	movs	r2, #5
    113c:	4b03      	ldr	r3, [pc, #12]	; (114c <sd_mmc_spi_wait_end_of_write_blocks+0x1c>)
    113e:	701a      	strb	r2, [r3, #0]
		sd_mmc_spi_debug("%s: Write blocks timeout\n\r", __func__);
		return false;
    1140:	e001      	b.n	1146 <sd_mmc_spi_wait_end_of_write_blocks+0x16>
	}
	return sd_mmc_spi_stop_multiwrite_block();
    1142:	4b03      	ldr	r3, [pc, #12]	; (1150 <sd_mmc_spi_wait_end_of_write_blocks+0x20>)
    1144:	4798      	blx	r3
}
    1146:	bd10      	pop	{r4, pc}
    1148:	00000b91 	.word	0x00000b91
    114c:	20000106 	.word	0x20000106
    1150:	00000bf5 	.word	0x00000bf5

00001154 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    1154:	b570      	push	{r4, r5, r6, lr}
	cycles_per_ms = system_gclk_gen_get_hz(0);
    1156:	2000      	movs	r0, #0
    1158:	4b08      	ldr	r3, [pc, #32]	; (117c <delay_init+0x28>)
    115a:	4798      	blx	r3
    115c:	0005      	movs	r5, r0
	cycles_per_ms /= 1000;
    115e:	4c08      	ldr	r4, [pc, #32]	; (1180 <delay_init+0x2c>)
    1160:	21fa      	movs	r1, #250	; 0xfa
    1162:	0089      	lsls	r1, r1, #2
    1164:	47a0      	blx	r4
    1166:	4b07      	ldr	r3, [pc, #28]	; (1184 <delay_init+0x30>)
    1168:	6018      	str	r0, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    116a:	4907      	ldr	r1, [pc, #28]	; (1188 <delay_init+0x34>)
    116c:	0028      	movs	r0, r5
    116e:	47a0      	blx	r4
    1170:	4b06      	ldr	r3, [pc, #24]	; (118c <delay_init+0x38>)
    1172:	6018      	str	r0, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    1174:	2205      	movs	r2, #5
    1176:	4b06      	ldr	r3, [pc, #24]	; (1190 <delay_init+0x3c>)
    1178:	601a      	str	r2, [r3, #0]
}
    117a:	bd70      	pop	{r4, r5, r6, pc}
    117c:	00005c85 	.word	0x00005c85
    1180:	000082fd 	.word	0x000082fd
    1184:	20000028 	.word	0x20000028
    1188:	000f4240 	.word	0x000f4240
    118c:	20000024 	.word	0x20000024
    1190:	e000e010 	.word	0xe000e010

00001194 <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    1194:	b530      	push	{r4, r5, lr}
	while (n--) {
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    1196:	4b08      	ldr	r3, [pc, #32]	; (11b8 <delay_cycles_ms+0x24>)
    1198:	681c      	ldr	r4, [r3, #0]
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
		SysTick->LOAD = n;
    119a:	4a08      	ldr	r2, [pc, #32]	; (11bc <delay_cycles_ms+0x28>)
		SysTick->VAL = 0;
    119c:	2500      	movs	r5, #0

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    119e:	2180      	movs	r1, #128	; 0x80
    11a0:	0249      	lsls	r1, r1, #9
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
    11a2:	e006      	b.n	11b2 <delay_cycles_ms+0x1e>
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
	if (n > 0) {
    11a4:	2c00      	cmp	r4, #0
    11a6:	d004      	beq.n	11b2 <delay_cycles_ms+0x1e>
		SysTick->LOAD = n;
    11a8:	6054      	str	r4, [r2, #4]
		SysTick->VAL = 0;
    11aa:	6095      	str	r5, [r2, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    11ac:	6813      	ldr	r3, [r2, #0]
    11ae:	420b      	tst	r3, r1
    11b0:	d0fc      	beq.n	11ac <delay_cycles_ms+0x18>
    11b2:	3801      	subs	r0, #1
    11b4:	d2f6      	bcs.n	11a4 <delay_cycles_ms+0x10>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
    11b6:	bd30      	pop	{r4, r5, pc}
    11b8:	20000028 	.word	0x20000028
    11bc:	e000e010 	.word	0xe000e010

000011c0 <chip_isr>:
#include "conf_winc.h"

static tpfNmBspIsr gpfIsr;

static void chip_isr(void)
{
    11c0:	b510      	push	{r4, lr}
	if (gpfIsr) {
    11c2:	4b03      	ldr	r3, [pc, #12]	; (11d0 <chip_isr+0x10>)
    11c4:	681b      	ldr	r3, [r3, #0]
    11c6:	2b00      	cmp	r3, #0
    11c8:	d000      	beq.n	11cc <chip_isr+0xc>
		gpfIsr();
    11ca:	4798      	blx	r3
	}
}
    11cc:	bd10      	pop	{r4, pc}
    11ce:	46c0      	nop			; (mov r8, r8)
    11d0:	20000110 	.word	0x20000110

000011d4 <nm_bsp_sleep>:
 *	@brief	Sleep in units of mSec
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
    11d4:	b570      	push	{r4, r5, r6, lr}
	while (u32TimeMsec--) {
    11d6:	2800      	cmp	r0, #0
    11d8:	d006      	beq.n	11e8 <nm_bsp_sleep+0x14>
    11da:	0004      	movs	r4, r0
		delay_ms(1);
    11dc:	4d03      	ldr	r5, [pc, #12]	; (11ec <nm_bsp_sleep+0x18>)
    11de:	2001      	movs	r0, #1
    11e0:	47a8      	blx	r5
    11e2:	3c01      	subs	r4, #1
 *	@param[IN]	u32TimeMsec
 *				Time in milliseconds
 */
void nm_bsp_sleep(uint32 u32TimeMsec)
{
	while (u32TimeMsec--) {
    11e4:	2c00      	cmp	r4, #0
    11e6:	d1fa      	bne.n	11de <nm_bsp_sleep+0xa>
		delay_ms(1);
	}
}
    11e8:	bd70      	pop	{r4, r5, r6, pc}
    11ea:	46c0      	nop			; (mov r8, r8)
    11ec:	00001195 	.word	0x00001195

000011f0 <nm_bsp_reset>:
 *	@fn		nm_bsp_reset
 *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
 *           CHIP_EN high then RESET_N high
 */
void nm_bsp_reset(void)
{
    11f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    11f2:	4c08      	ldr	r4, [pc, #32]	; (1214 <nm_bsp_reset+0x24>)
    11f4:	2780      	movs	r7, #128	; 0x80
    11f6:	057f      	lsls	r7, r7, #21
    11f8:	6167      	str	r7, [r4, #20]
    11fa:	2680      	movs	r6, #128	; 0x80
    11fc:	0536      	lsls	r6, r6, #20
    11fe:	6166      	str	r6, [r4, #20]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
	nm_bsp_sleep(100);
    1200:	2064      	movs	r0, #100	; 0x64
    1202:	4d05      	ldr	r5, [pc, #20]	; (1218 <nm_bsp_reset+0x28>)
    1204:	47a8      	blx	r5
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1206:	61a7      	str	r7, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
	nm_bsp_sleep(100);
    1208:	2064      	movs	r0, #100	; 0x64
    120a:	47a8      	blx	r5
    120c:	61a6      	str	r6, [r4, #24]
	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
	nm_bsp_sleep(100);
    120e:	2064      	movs	r0, #100	; 0x64
    1210:	47a8      	blx	r5
}
    1212:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1214:	41004400 	.word	0x41004400
    1218:	000011d5 	.word	0x000011d5

0000121c <nm_bsp_init>:
 *	@fn		nm_bsp_init
 *	@brief	Initialize BSP
 *	@return	0 in case of success and -1 in case of failure
 */
sint8 nm_bsp_init(void)
{
    121c:	b570      	push	{r4, r5, r6, lr}
    121e:	b082      	sub	sp, #8
	gpfIsr = NULL;
    1220:	2300      	movs	r3, #0
    1222:	4a16      	ldr	r2, [pc, #88]	; (127c <nm_bsp_init+0x60>)
    1224:	6013      	str	r3, [r2, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1226:	ac01      	add	r4, sp, #4
    1228:	2501      	movs	r5, #1
    122a:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    122c:	70a3      	strb	r3, [r4, #2]
	struct port_config pin_conf;

	port_get_config_defaults(&pin_conf);

	/* Configure control pins as output. */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    122e:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
    1230:	0021      	movs	r1, r4
    1232:	201b      	movs	r0, #27
    1234:	4e12      	ldr	r6, [pc, #72]	; (1280 <nm_bsp_init+0x64>)
    1236:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
    1238:	0021      	movs	r1, r4
    123a:	201c      	movs	r0, #28
    123c:	47b0      	blx	r6
	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
    123e:	0021      	movs	r1, r4
    1240:	2028      	movs	r0, #40	; 0x28
    1242:	47b0      	blx	r6

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    1244:	4b0f      	ldr	r3, [pc, #60]	; (1284 <nm_bsp_init+0x68>)
    1246:	2280      	movs	r2, #128	; 0x80
    1248:	0552      	lsls	r2, r2, #21
    124a:	615a      	str	r2, [r3, #20]
    124c:	2280      	movs	r2, #128	; 0x80
    124e:	0512      	lsls	r2, r2, #20
    1250:	615a      	str	r2, [r3, #20]

	/* Initialize chip IOs. */
	init_chip_pins();

    /* Make sure a 1ms Systick is configured. */
    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
    1252:	4b0d      	ldr	r3, [pc, #52]	; (1288 <nm_bsp_init+0x6c>)
    1254:	681b      	ldr	r3, [r3, #0]
    1256:	421d      	tst	r5, r3
    1258:	d003      	beq.n	1262 <nm_bsp_init+0x46>
    125a:	4b0b      	ldr	r3, [pc, #44]	; (1288 <nm_bsp_init+0x6c>)
    125c:	681b      	ldr	r3, [r3, #0]
    125e:	079b      	lsls	r3, r3, #30
    1260:	d401      	bmi.n	1266 <nm_bsp_init+0x4a>
	    delay_init();
    1262:	4b0a      	ldr	r3, [pc, #40]	; (128c <nm_bsp_init+0x70>)
    1264:	4798      	blx	r3
    }

	/* Perform chip reset. */
	nm_bsp_reset();
    1266:	4b0a      	ldr	r3, [pc, #40]	; (1290 <nm_bsp_init+0x74>)
    1268:	4798      	blx	r3
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
	cpu_irq_enable();
    126a:	2201      	movs	r2, #1
    126c:	4b09      	ldr	r3, [pc, #36]	; (1294 <nm_bsp_init+0x78>)
    126e:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1270:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    1274:	b662      	cpsie	i

	system_interrupt_enable_global();

	return M2M_SUCCESS;
}
    1276:	2000      	movs	r0, #0
    1278:	b002      	add	sp, #8
    127a:	bd70      	pop	{r4, r5, r6, pc}
    127c:	20000110 	.word	0x20000110
    1280:	000045f9 	.word	0x000045f9
    1284:	41004400 	.word	0x41004400
    1288:	e000e010 	.word	0xe000e010
    128c:	00001155 	.word	0x00001155
    1290:	000011f1 	.word	0x000011f1
    1294:	2000002e 	.word	0x2000002e

00001298 <nm_bsp_register_isr>:
 *	@brief	Register interrupt service routine
 *	@param[IN]	pfIsr
 *				Pointer to ISR handler
 */
void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
{
    1298:	b510      	push	{r4, lr}
    129a:	b084      	sub	sp, #16
	struct extint_chan_conf config_extint_chan;

	gpfIsr = pfIsr;
    129c:	4b0e      	ldr	r3, [pc, #56]	; (12d8 <nm_bsp_register_isr+0x40>)
    129e:	6018      	str	r0, [r3, #0]

	extint_chan_get_config_defaults(&config_extint_chan);
    12a0:	ac01      	add	r4, sp, #4
    12a2:	0020      	movs	r0, r4
    12a4:	4b0d      	ldr	r3, [pc, #52]	; (12dc <nm_bsp_register_isr+0x44>)
    12a6:	4798      	blx	r3
	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
    12a8:	2329      	movs	r3, #41	; 0x29
    12aa:	9301      	str	r3, [sp, #4]
	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
    12ac:	2300      	movs	r3, #0
    12ae:	6063      	str	r3, [r4, #4]
	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
    12b0:	3301      	adds	r3, #1
    12b2:	7223      	strb	r3, [r4, #8]
	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
    12b4:	3301      	adds	r3, #1
    12b6:	72e3      	strb	r3, [r4, #11]

	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
    12b8:	0021      	movs	r1, r4
    12ba:	2009      	movs	r0, #9
    12bc:	4b08      	ldr	r3, [pc, #32]	; (12e0 <nm_bsp_register_isr+0x48>)
    12be:	4798      	blx	r3
	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
    12c0:	2200      	movs	r2, #0
    12c2:	2109      	movs	r1, #9
    12c4:	4807      	ldr	r0, [pc, #28]	; (12e4 <nm_bsp_register_isr+0x4c>)
    12c6:	4b08      	ldr	r3, [pc, #32]	; (12e8 <nm_bsp_register_isr+0x50>)
    12c8:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    12ca:	2100      	movs	r1, #0
    12cc:	2009      	movs	r0, #9
    12ce:	4b07      	ldr	r3, [pc, #28]	; (12ec <nm_bsp_register_isr+0x54>)
    12d0:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
    12d2:	b004      	add	sp, #16
    12d4:	bd10      	pop	{r4, pc}
    12d6:	46c0      	nop			; (mov r8, r8)
    12d8:	20000110 	.word	0x20000110
    12dc:	00004571 	.word	0x00004571
    12e0:	00004585 	.word	0x00004585
    12e4:	000011c1 	.word	0x000011c1
    12e8:	00004419 	.word	0x00004419
    12ec:	00004445 	.word	0x00004445

000012f0 <nm_bsp_interrupt_ctrl>:
 *	@brief	Enable/Disable interrupts
 *	@param[IN]	u8Enable
 *				'0' disable interrupts. '1' enable interrupts
 */
void nm_bsp_interrupt_ctrl(uint8 u8Enable)
{
    12f0:	b510      	push	{r4, lr}
	if (u8Enable) {
    12f2:	2800      	cmp	r0, #0
    12f4:	d004      	beq.n	1300 <nm_bsp_interrupt_ctrl+0x10>
		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
    12f6:	2100      	movs	r1, #0
    12f8:	2009      	movs	r0, #9
    12fa:	4b04      	ldr	r3, [pc, #16]	; (130c <nm_bsp_interrupt_ctrl+0x1c>)
    12fc:	4798      	blx	r3
    12fe:	e003      	b.n	1308 <nm_bsp_interrupt_ctrl+0x18>
				EXTINT_CALLBACK_TYPE_DETECT);
	} else {
		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
    1300:	2100      	movs	r1, #0
    1302:	2009      	movs	r0, #9
    1304:	4b02      	ldr	r3, [pc, #8]	; (1310 <nm_bsp_interrupt_ctrl+0x20>)
    1306:	4798      	blx	r3
				EXTINT_CALLBACK_TYPE_DETECT);
	}
}
    1308:	bd10      	pop	{r4, pc}
    130a:	46c0      	nop			; (mov r8, r8)
    130c:	00004445 	.word	0x00004445
    1310:	00004465 	.word	0x00004465

00001314 <nm_bus_init>:
*	@fn		nm_bus_init
*	@brief	Initialize the bus wrapper
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*/
sint8 nm_bus_init(void *pvinit)
{
    1314:	b530      	push	{r4, r5, lr}
    1316:	b091      	sub	sp, #68	; 0x44
		const struct spi_slave_inst_config *const config)
{
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    1318:	4c30      	ldr	r4, [pc, #192]	; (13dc <nm_bus_init+0xc8>)
    131a:	230e      	movs	r3, #14
    131c:	7023      	strb	r3, [r4, #0]
	slave->address_enabled = config->address_enabled;
    131e:	2300      	movs	r3, #0
    1320:	7063      	strb	r3, [r4, #1]
	slave->address         = config->address;
    1322:	70a3      	strb	r3, [r4, #2]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    1324:	a901      	add	r1, sp, #4
    1326:	2201      	movs	r2, #1
    1328:	704a      	strb	r2, [r1, #1]
	config->powersave  = false;
    132a:	708b      	strb	r3, [r1, #2]
	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    132c:	700a      	strb	r2, [r1, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    132e:	200e      	movs	r0, #14
    1330:	4b2b      	ldr	r3, [pc, #172]	; (13e0 <nm_bus_init+0xcc>)
    1332:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    1334:	7823      	ldrb	r3, [r4, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    1336:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    1338:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    133a:	2900      	cmp	r1, #0
    133c:	d104      	bne.n	1348 <nm_bus_init+0x34>
		return &(ports[port_index]->Group[group_index]);
    133e:	095a      	lsrs	r2, r3, #5
    1340:	01d2      	lsls	r2, r2, #7
    1342:	4928      	ldr	r1, [pc, #160]	; (13e4 <nm_bus_init+0xd0>)
    1344:	468c      	mov	ip, r1
    1346:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1348:	211f      	movs	r1, #31
    134a:	400b      	ands	r3, r1
    134c:	391e      	subs	r1, #30
    134e:	0008      	movs	r0, r1
    1350:	4098      	lsls	r0, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    1352:	6190      	str	r0, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    1354:	ac02      	add	r4, sp, #8
    1356:	7021      	strb	r1, [r4, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    1358:	2300      	movs	r3, #0
    135a:	9303      	str	r3, [sp, #12]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    135c:	9304      	str	r3, [sp, #16]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    135e:	22c0      	movs	r2, #192	; 0xc0
    1360:	0392      	lsls	r2, r2, #14
    1362:	9205      	str	r2, [sp, #20]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    1364:	7423      	strb	r3, [r4, #16]
	config->run_in_standby   = false;
    1366:	7463      	strb	r3, [r4, #17]
	config->receiver_enable  = true;
    1368:	74a1      	strb	r1, [r4, #18]
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	config->select_slave_low_detect_enable= true;
    136a:	74e1      	strb	r1, [r4, #19]
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
    136c:	7523      	strb	r3, [r4, #20]
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    136e:	2224      	movs	r2, #36	; 0x24
    1370:	54a3      	strb	r3, [r4, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    1372:	3a18      	subs	r2, #24
    1374:	2100      	movs	r1, #0
    1376:	a808      	add	r0, sp, #32
    1378:	4b1b      	ldr	r3, [pc, #108]	; (13e8 <nm_bus_init+0xd4>)
    137a:	4798      	blx	r3
	spi_attach_slave(&slave_inst, &slave_config);

	/* Configure the SPI master. */
	spi_get_config_defaults(&config);
	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
    137c:	4b1b      	ldr	r3, [pc, #108]	; (13ec <nm_bus_init+0xd8>)
    137e:	62a3      	str	r3, [r4, #40]	; 0x28
	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
    1380:	4b1b      	ldr	r3, [pc, #108]	; (13f0 <nm_bus_init+0xdc>)
    1382:	62e3      	str	r3, [r4, #44]	; 0x2c
	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
    1384:	2301      	movs	r3, #1
    1386:	425b      	negs	r3, r3
    1388:	6323      	str	r3, [r4, #48]	; 0x30
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
    138a:	4b1a      	ldr	r3, [pc, #104]	; (13f4 <nm_bus_init+0xe0>)
    138c:	6363      	str	r3, [r4, #52]	; 0x34
	config.master_slave_select_enable = false;
	
	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
    138e:	4b1a      	ldr	r3, [pc, #104]	; (13f8 <nm_bus_init+0xe4>)
    1390:	61a3      	str	r3, [r4, #24]
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
    1392:	0022      	movs	r2, r4
    1394:	4919      	ldr	r1, [pc, #100]	; (13fc <nm_bus_init+0xe8>)
    1396:	481a      	ldr	r0, [pc, #104]	; (1400 <nm_bus_init+0xec>)
    1398:	4b1a      	ldr	r3, [pc, #104]	; (1404 <nm_bus_init+0xf0>)
    139a:	4798      	blx	r3
    139c:	2800      	cmp	r0, #0
    139e:	d119      	bne.n	13d4 <nm_bus_init+0xc0>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    13a0:	4d17      	ldr	r5, [pc, #92]	; (1400 <nm_bus_init+0xec>)
    13a2:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    13a4:	0020      	movs	r0, r4
    13a6:	4b18      	ldr	r3, [pc, #96]	; (1408 <nm_bus_init+0xf4>)
    13a8:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    13aa:	231f      	movs	r3, #31
    13ac:	4018      	ands	r0, r3
    13ae:	3b1e      	subs	r3, #30
    13b0:	4083      	lsls	r3, r0
    13b2:	4a16      	ldr	r2, [pc, #88]	; (140c <nm_bus_init+0xf8>)
    13b4:	6013      	str	r3, [r2, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    13b6:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    13b8:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    13ba:	2b00      	cmp	r3, #0
    13bc:	d1fc      	bne.n	13b8 <nm_bus_init+0xa4>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    13be:	6822      	ldr	r2, [r4, #0]
    13c0:	3302      	adds	r3, #2
    13c2:	4313      	orrs	r3, r2
    13c4:	6023      	str	r3, [r4, #0]
	}

	/* Enable the SPI master. */
	spi_enable(&master);

	nm_bsp_reset();
    13c6:	4b12      	ldr	r3, [pc, #72]	; (1410 <nm_bus_init+0xfc>)
    13c8:	4798      	blx	r3
	nm_bsp_sleep(1);
    13ca:	2001      	movs	r0, #1
    13cc:	4b11      	ldr	r3, [pc, #68]	; (1414 <nm_bus_init+0x100>)
    13ce:	4798      	blx	r3
#endif
	return result;
    13d0:	2000      	movs	r0, #0
    13d2:	e001      	b.n	13d8 <nm_bus_init+0xc4>
	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
	config.master_slave_select_enable = false;
	
	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
		return M2M_ERR_BUS_FAIL;
    13d4:	2006      	movs	r0, #6
    13d6:	4240      	negs	r0, r0

	nm_bsp_reset();
	nm_bsp_sleep(1);
#endif
	return result;
}
    13d8:	b011      	add	sp, #68	; 0x44
    13da:	bd30      	pop	{r4, r5, pc}
    13dc:	200001f4 	.word	0x200001f4
    13e0:	000045f9 	.word	0x000045f9
    13e4:	41004400 	.word	0x41004400
    13e8:	000086fd 	.word	0x000086fd
    13ec:	000c0002 	.word	0x000c0002
    13f0:	000d0002 	.word	0x000d0002
    13f4:	000f0002 	.word	0x000f0002
    13f8:	00b71b00 	.word	0x00b71b00
    13fc:	42001000 	.word	0x42001000
    1400:	200001f8 	.word	0x200001f8
    1404:	00004be9 	.word	0x00004be9
    1408:	00004aa9 	.word	0x00004aa9
    140c:	e000e100 	.word	0xe000e100
    1410:	000011f1 	.word	0x000011f1
    1414:	000011d5 	.word	0x000011d5

00001418 <nm_bus_ioctl>:
*					Arbitrary parameter depenging on IOCTL
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@note	For SPI only, it's important to be able to send/receive at the same time
*/
sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
{
    1418:	b5f0      	push	{r4, r5, r6, r7, lr}
    141a:	465f      	mov	r7, fp
    141c:	4656      	mov	r6, sl
    141e:	464d      	mov	r5, r9
    1420:	4644      	mov	r4, r8
    1422:	b4f0      	push	{r4, r5, r6, r7}
    1424:	b085      	sub	sp, #20
	sint8 s8Ret = 0;
	switch(u8Cmd)
    1426:	2803      	cmp	r0, #3
    1428:	d15c      	bne.n	14e4 <nm_bus_ioctl+0xcc>
		}
		break;
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
    142a:	680f      	ldr	r7, [r1, #0]
    142c:	684e      	ldr	r6, [r1, #4]
    142e:	890d      	ldrh	r5, [r1, #8]
struct spi_module master;
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
    1430:	2200      	movs	r2, #0
    1432:	ab02      	add	r3, sp, #8
    1434:	71da      	strb	r2, [r3, #7]
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
    1436:	2e00      	cmp	r6, #0
    1438:	d102      	bne.n	1440 <nm_bus_ioctl+0x28>
    143a:	2f00      	cmp	r7, #0
    143c:	d174      	bne.n	1528 <nm_bus_ioctl+0x110>
    143e:	e048      	b.n	14d2 <nm_bus_ioctl+0xba>
    1440:	2d00      	cmp	r5, #0
    1442:	d049      	beq.n	14d8 <nm_bus_ioctl+0xc0>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    1444:	2300      	movs	r3, #0
    1446:	4698      	mov	r8, r3

	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
    1448:	2f00      	cmp	r7, #0
    144a:	d103      	bne.n	1454 <nm_bus_ioctl+0x3c>
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
    144c:	3301      	adds	r3, #1
    144e:	4698      	mov	r8, r3
	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
	}

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
    1450:	ab02      	add	r3, sp, #8
    1452:	1ddf      	adds	r7, r3, #7
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    1454:	2400      	movs	r4, #0

	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
    1456:	2e00      	cmp	r6, #0
    1458:	d153      	bne.n	1502 <nm_bus_ioctl+0xea>
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
    145a:	3401      	adds	r4, #1
	if (pu8Mosi == NULL) {
		pu8Mosi = &u8Dummy;
		u8SkipMosi = 1;
	}
	if(pu8Miso == NULL) {
		pu8Miso = &u8Dummy;
    145c:	ab02      	add	r3, sp, #8
    145e:	1dde      	adds	r6, r3, #7
    1460:	e04f      	b.n	1502 <nm_bus_ioctl+0xea>
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
		txd_data = *pu8Mosi;
    1462:	783c      	ldrb	r4, [r7, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1464:	4653      	mov	r3, sl
    1466:	681b      	ldr	r3, [r3, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    1468:	7e19      	ldrb	r1, [r3, #24]
		while (!spi_is_ready_to_write(&master))
    146a:	4201      	tst	r1, r0
    146c:	d0fc      	beq.n	1468 <nm_bus_ioctl+0x50>
    146e:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    1470:	4201      	tst	r1, r0
    1472:	d0fc      	beq.n	146e <nm_bus_ioctl+0x56>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    1474:	629c      	str	r4, [r3, #40]	; 0x28
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1476:	7e19      	ldrb	r1, [r3, #24]
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    1478:	4211      	tst	r1, r2
    147a:	d0fc      	beq.n	1476 <nm_bus_ioctl+0x5e>
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    147c:	4649      	mov	r1, r9
    147e:	798c      	ldrb	r4, [r1, #6]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    1480:	7e19      	ldrb	r1, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    1482:	4211      	tst	r1, r2
    1484:	d0fc      	beq.n	1480 <nm_bus_ioctl+0x68>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    1486:	8b59      	ldrh	r1, [r3, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    1488:	2500      	movs	r5, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    148a:	4211      	tst	r1, r2
    148c:	d001      	beq.n	1492 <nm_bus_ioctl+0x7a>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    148e:	835a      	strh	r2, [r3, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    1490:	351e      	adds	r5, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1492:	2c01      	cmp	r4, #1
    1494:	d103      	bne.n	149e <nm_bus_ioctl+0x86>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    1496:	6a99      	ldr	r1, [r3, #40]	; 0x28
    1498:	05c9      	lsls	r1, r1, #23
    149a:	0dc9      	lsrs	r1, r1, #23
    149c:	e001      	b.n	14a2 <nm_bus_ioctl+0x8a>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    149e:	6a99      	ldr	r1, [r3, #40]	; 0x28
    14a0:	b2c9      	uxtb	r1, r1
			;
		while (spi_read(&master, &rxd_data) != STATUS_OK)
    14a2:	2d00      	cmp	r5, #0
    14a4:	d1ec      	bne.n	1480 <nm_bus_ioctl+0x68>
			;
		*pu8Miso = rxd_data;
    14a6:	7031      	strb	r1, [r6, #0]
			
		u16Sz--;
    14a8:	9d01      	ldr	r5, [sp, #4]
    14aa:	3d01      	subs	r5, #1
    14ac:	b2ab      	uxth	r3, r5
    14ae:	9301      	str	r3, [sp, #4]
		if (!u8SkipMiso)
			pu8Miso++;
    14b0:	445e      	add	r6, fp
		if (!u8SkipMosi)
			pu8Mosi++;
    14b2:	4447      	add	r7, r8
		u8SkipMiso = 1;
	}

	spi_select_slave(&master, &slave_inst, true);

	while (u16Sz) {
    14b4:	2b00      	cmp	r3, #0
    14b6:	d1d4      	bne.n	1462 <nm_bus_ioctl+0x4a>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    14b8:	4b21      	ldr	r3, [pc, #132]	; (1540 <nm_bus_ioctl+0x128>)
    14ba:	6819      	ldr	r1, [r3, #0]
			pu8Miso++;
		if (!u8SkipMosi)
			pu8Mosi++;
	}

	while (!spi_is_write_complete(&master))
    14bc:	2202      	movs	r2, #2

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    14be:	7e0b      	ldrb	r3, [r1, #24]
    14c0:	4213      	tst	r3, r2
    14c2:	d0fc      	beq.n	14be <nm_bus_ioctl+0xa6>
		;

	spi_select_slave(&master, &slave_inst, false);
    14c4:	2200      	movs	r2, #0
    14c6:	491f      	ldr	r1, [pc, #124]	; (1544 <nm_bus_ioctl+0x12c>)
    14c8:	481d      	ldr	r0, [pc, #116]	; (1540 <nm_bus_ioctl+0x128>)
    14ca:	4b1f      	ldr	r3, [pc, #124]	; (1548 <nm_bus_ioctl+0x130>)
    14cc:	4798      	blx	r3

	return M2M_SUCCESS;
    14ce:	2000      	movs	r0, #0
    14d0:	e02f      	b.n	1532 <nm_bus_ioctl+0x11a>
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
		return M2M_ERR_INVALID_ARG;
    14d2:	200f      	movs	r0, #15
    14d4:	4240      	negs	r0, r0
    14d6:	e02c      	b.n	1532 <nm_bus_ioctl+0x11a>
    14d8:	200f      	movs	r0, #15
    14da:	4240      	negs	r0, r0
    14dc:	e029      	b.n	1532 <nm_bus_ioctl+0x11a>
    14de:	200f      	movs	r0, #15
    14e0:	4240      	negs	r0, r0
#elif defined CONF_WINC_USE_SPI
		case NM_BUS_IOCTL_RW: {
			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
    14e2:	e026      	b.n	1532 <nm_bus_ioctl+0x11a>
#endif
		default:
			s8Ret = -1;
			M2M_ERR("invalide ioclt cmd\n");
    14e4:	220e      	movs	r2, #14
    14e6:	32ff      	adds	r2, #255	; 0xff
    14e8:	4918      	ldr	r1, [pc, #96]	; (154c <nm_bus_ioctl+0x134>)
    14ea:	4819      	ldr	r0, [pc, #100]	; (1550 <nm_bus_ioctl+0x138>)
    14ec:	4b19      	ldr	r3, [pc, #100]	; (1554 <nm_bus_ioctl+0x13c>)
    14ee:	4798      	blx	r3
    14f0:	4819      	ldr	r0, [pc, #100]	; (1558 <nm_bus_ioctl+0x140>)
    14f2:	4b1a      	ldr	r3, [pc, #104]	; (155c <nm_bus_ioctl+0x144>)
    14f4:	4798      	blx	r3
    14f6:	200d      	movs	r0, #13
    14f8:	4b19      	ldr	r3, [pc, #100]	; (1560 <nm_bus_ioctl+0x148>)
    14fa:	4798      	blx	r3
			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
		}
		break;
#endif
		default:
			s8Ret = -1;
    14fc:	2001      	movs	r0, #1
    14fe:	4240      	negs	r0, r0
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
    1500:	e017      	b.n	1532 <nm_bus_ioctl+0x11a>
	if(pu8Miso == NULL) {
		pu8Miso = &u8Dummy;
		u8SkipMiso = 1;
	}

	spi_select_slave(&master, &slave_inst, true);
    1502:	2201      	movs	r2, #1
    1504:	490f      	ldr	r1, [pc, #60]	; (1544 <nm_bus_ioctl+0x12c>)
    1506:	480e      	ldr	r0, [pc, #56]	; (1540 <nm_bus_ioctl+0x128>)
    1508:	4b0f      	ldr	r3, [pc, #60]	; (1548 <nm_bus_ioctl+0x130>)
    150a:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    150c:	4b0c      	ldr	r3, [pc, #48]	; (1540 <nm_bus_ioctl+0x128>)
    150e:	469a      	mov	sl, r3

	while (u16Sz) {
		txd_data = *pu8Mosi;
		while (!spi_is_ready_to_write(&master))
    1510:	2001      	movs	r0, #1
			;
		while(spi_write(&master, txd_data) != STATUS_OK)
			;

		/* Read SPI master data register. */
		while (!spi_is_ready_to_read(&master))
    1512:	2204      	movs	r2, #4
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    1514:	4699      	mov	r9, r3
			;
		*pu8Miso = rxd_data;
			
		u16Sz--;
		if (!u8SkipMiso)
			pu8Miso++;
    1516:	4263      	negs	r3, r4
    1518:	4163      	adcs	r3, r4
    151a:	469b      	mov	fp, r3
		if (!u8SkipMosi)
			pu8Mosi++;
    151c:	4641      	mov	r1, r8
    151e:	424b      	negs	r3, r1
    1520:	4159      	adcs	r1, r3
    1522:	4688      	mov	r8, r1
    1524:	9501      	str	r5, [sp, #4]
    1526:	e79c      	b.n	1462 <nm_bus_ioctl+0x4a>
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
	uint16_t txd_data = 0;
	uint16_t rxd_data = 0;

	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
    1528:	2d00      	cmp	r5, #0
    152a:	d0d8      	beq.n	14de <nm_bus_ioctl+0xc6>
struct spi_slave_inst slave_inst;

static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
{
	uint8 u8Dummy = 0;
	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
    152c:	2300      	movs	r3, #0
    152e:	4698      	mov	r8, r3
    1530:	e790      	b.n	1454 <nm_bus_ioctl+0x3c>
			M2M_ERR("invalide ioclt cmd\n");
			break;
	}

	return s8Ret;
}
    1532:	b005      	add	sp, #20
    1534:	bc3c      	pop	{r2, r3, r4, r5}
    1536:	4690      	mov	r8, r2
    1538:	4699      	mov	r9, r3
    153a:	46a2      	mov	sl, r4
    153c:	46ab      	mov	fp, r5
    153e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1540:	200001f8 	.word	0x200001f8
    1544:	200001f4 	.word	0x200001f4
    1548:	00004e65 	.word	0x00004e65
    154c:	00009e34 	.word	0x00009e34
    1550:	00009e44 	.word	0x00009e44
    1554:	00008845 	.word	0x00008845
    1558:	00009e58 	.word	0x00009e58
    155c:	00008965 	.word	0x00008965
    1560:	00008879 	.word	0x00008879

00001564 <nm_bus_deinit>:
/*
*	@fn		nm_bus_deinit
*	@brief	De-initialize the bus wrapper
*/
sint8 nm_bus_deinit(void)
{
    1564:	b530      	push	{r4, r5, lr}
    1566:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    1568:	ab01      	add	r3, sp, #4
    156a:	2200      	movs	r2, #0
    156c:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
	config->powersave  = false;
    156e:	709a      	strb	r2, [r3, #2]
	struct port_config pin_conf;
		
	port_get_config_defaults(&pin_conf);
	/* Configure control pins as input no pull up. */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	pin_conf.input_pull = PORT_PIN_PULL_NONE;
    1570:	705a      	strb	r2, [r3, #1]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1572:	4d13      	ldr	r5, [pc, #76]	; (15c0 <nm_bus_deinit+0x5c>)
    1574:	682c      	ldr	r4, [r5, #0]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    1576:	0020      	movs	r0, r4
    1578:	4b12      	ldr	r3, [pc, #72]	; (15c4 <nm_bus_deinit+0x60>)
    157a:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    157c:	231f      	movs	r3, #31
    157e:	4018      	ands	r0, r3
    1580:	3b1e      	subs	r3, #30
    1582:	4083      	lsls	r3, r0
    1584:	2280      	movs	r2, #128	; 0x80
    1586:	4910      	ldr	r1, [pc, #64]	; (15c8 <nm_bus_deinit+0x64>)
    1588:	508b      	str	r3, [r1, r2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    158a:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    158c:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    158e:	2b00      	cmp	r3, #0
    1590:	d1fc      	bne.n	158c <nm_bus_deinit+0x28>
		/* Wait until the synchronization is complete */
	}

	/* Disbale interrupt */
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
    1592:	338f      	adds	r3, #143	; 0x8f
    1594:	7523      	strb	r3, [r4, #20]
	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SERCOM_SPI_INTFLAG_MASK;
    1596:	7623      	strb	r3, [r4, #24]

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    1598:	6823      	ldr	r3, [r4, #0]
    159a:	2202      	movs	r2, #2
    159c:	4393      	bics	r3, r2
    159e:	6023      	str	r3, [r4, #0]
	port_pin_set_config(CONF_WINC_I2C_SCL, &pin_conf);
	port_pin_set_config(CONF_WINC_I2C_SDA, &pin_conf);
#endif /* CONF_WINC_USE_I2C */
#ifdef CONF_WINC_USE_SPI
	spi_disable(&master);
	port_pin_set_config(CONF_WINC_SPI_MOSI, &pin_conf);
    15a0:	a901      	add	r1, sp, #4
    15a2:	200c      	movs	r0, #12
    15a4:	4c09      	ldr	r4, [pc, #36]	; (15cc <nm_bus_deinit+0x68>)
    15a6:	47a0      	blx	r4
	port_pin_set_config(CONF_WINC_SPI_MISO, &pin_conf);
    15a8:	a901      	add	r1, sp, #4
    15aa:	200f      	movs	r0, #15
    15ac:	47a0      	blx	r4
	port_pin_set_config(CONF_WINC_SPI_SCK,  &pin_conf);
    15ae:	a901      	add	r1, sp, #4
    15b0:	200d      	movs	r0, #13
    15b2:	47a0      	blx	r4
	port_pin_set_config(CONF_WINC_SPI_SS,   &pin_conf);
    15b4:	a901      	add	r1, sp, #4
    15b6:	200e      	movs	r0, #14
    15b8:	47a0      	blx	r4
	//port_pin_set_output_level(CONF_WINC_SPI_MISO, false);
	//port_pin_set_output_level(CONF_WINC_SPI_SCK,  false);
	//port_pin_set_output_level(CONF_WINC_SPI_SS,   false);
#endif /* CONF_WINC_USE_SPI */
	return result;
}
    15ba:	2000      	movs	r0, #0
    15bc:	b003      	add	sp, #12
    15be:	bd30      	pop	{r4, r5, pc}
    15c0:	200001f8 	.word	0x200001f8
    15c4:	00004aa9 	.word	0x00004aa9
    15c8:	e000e100 	.word	0xe000e100
    15cc:	000045f9 	.word	0x000045f9

000015d0 <m2m_memcpy>:
 */
#include "common/include/nm_common.h"

void m2m_memcpy(uint8* pDst,uint8* pSrc,uint32 sz)
{
	if(sz == 0) return;
    15d0:	2a00      	cmp	r2, #0
    15d2:	d006      	beq.n	15e2 <m2m_memcpy+0x12>
    15d4:	1882      	adds	r2, r0, r2
	do
	{
		*pDst = *pSrc;
    15d6:	780b      	ldrb	r3, [r1, #0]
    15d8:	7003      	strb	r3, [r0, #0]
		pDst++;
    15da:	3001      	adds	r0, #1
		pSrc++;
    15dc:	3101      	adds	r1, #1
	}while(--sz);
    15de:	4290      	cmp	r0, r2
    15e0:	d1f9      	bne.n	15d6 <m2m_memcpy+0x6>
}
    15e2:	4770      	bx	lr

000015e4 <m2m_memset>:
	return cs;
}

void m2m_memset(uint8* pBuf,uint8 val,uint32 sz)
{
	if(sz == 0) return;
    15e4:	2a00      	cmp	r2, #0
    15e6:	d004      	beq.n	15f2 <m2m_memset+0xe>
    15e8:	1882      	adds	r2, r0, r2
	do
	{
		*pBuf = val;
    15ea:	7001      	strb	r1, [r0, #0]
		pBuf++;
    15ec:	3001      	adds	r0, #1
	}while(--sz);
    15ee:	4290      	cmp	r0, r2
    15f0:	d1fb      	bne.n	15ea <m2m_memset+0x6>
}
    15f2:	4770      	bx	lr

000015f4 <m2m_strlen>:

uint16 m2m_strlen(uint8 * pcStr)
{
    15f4:	0003      	movs	r3, r0
	uint16	u16StrLen = 0;
	while(*pcStr)
    15f6:	7802      	ldrb	r2, [r0, #0]
    15f8:	2a00      	cmp	r2, #0
    15fa:	d007      	beq.n	160c <m2m_strlen+0x18>
    15fc:	2000      	movs	r0, #0
	{
		u16StrLen ++;
    15fe:	3001      	adds	r0, #1
    1600:	b280      	uxth	r0, r0
		pcStr++;
    1602:	3301      	adds	r3, #1
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
	while(*pcStr)
    1604:	781a      	ldrb	r2, [r3, #0]
    1606:	2a00      	cmp	r2, #0
    1608:	d1f9      	bne.n	15fe <m2m_strlen+0xa>
    160a:	e000      	b.n	160e <m2m_strlen+0x1a>
	}while(--sz);
}

uint16 m2m_strlen(uint8 * pcStr)
{
	uint16	u16StrLen = 0;
    160c:	2000      	movs	r0, #0
	{
		u16StrLen ++;
		pcStr++;
	}
	return u16StrLen;
}
    160e:	4770      	bx	lr

00001610 <isr>:

volatile tstrHifContext gstrHifCxt;

static void isr(void)
{
	gstrHifCxt.u8Interrupt++;
    1610:	4a02      	ldr	r2, [pc, #8]	; (161c <isr+0xc>)
    1612:	78d3      	ldrb	r3, [r2, #3]
    1614:	3301      	adds	r3, #1
    1616:	b2db      	uxtb	r3, r3
    1618:	70d3      	strb	r3, [r2, #3]
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
    161a:	4770      	bx	lr
    161c:	20000234 	.word	0x20000234

00001620 <m2m_hif_cb>:
*/
static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{


}
    1620:	4770      	bx	lr
    1622:	46c0      	nop			; (mov r8, r8)

00001624 <hif_set_rx_done>:
#ifdef NM_LEVEL_INTERRUPT
	nm_bsp_interrupt_ctrl(0);
#endif
}
static sint8 hif_set_rx_done(void)
{
    1624:	b500      	push	{lr}
    1626:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;

	gstrHifCxt.u8HifRXDone = 0;
    1628:	2200      	movs	r2, #0
    162a:	4b0a      	ldr	r3, [pc, #40]	; (1654 <hif_set_rx_done+0x30>)
    162c:	709a      	strb	r2, [r3, #2]
#ifdef NM_EDGE_INTERRUPT
	nm_bsp_interrupt_ctrl(1);
    162e:	2001      	movs	r0, #1
    1630:	4b09      	ldr	r3, [pc, #36]	; (1658 <hif_set_rx_done+0x34>)
    1632:	4798      	blx	r3
#endif
	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
    1634:	a901      	add	r1, sp, #4
    1636:	4809      	ldr	r0, [pc, #36]	; (165c <hif_set_rx_done+0x38>)
    1638:	4b09      	ldr	r3, [pc, #36]	; (1660 <hif_set_rx_done+0x3c>)
    163a:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    163c:	2800      	cmp	r0, #0
    163e:	d106      	bne.n	164e <hif_set_rx_done+0x2a>
	/* Set RX Done */
	reg |= NBIT1;
    1640:	2102      	movs	r1, #2
    1642:	9b01      	ldr	r3, [sp, #4]
    1644:	4319      	orrs	r1, r3
    1646:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    1648:	4804      	ldr	r0, [pc, #16]	; (165c <hif_set_rx_done+0x38>)
    164a:	4b06      	ldr	r3, [pc, #24]	; (1664 <hif_set_rx_done+0x40>)
    164c:	4798      	blx	r3
	nm_bsp_interrupt_ctrl(1);
#endif
ERR1:
	return ret;

}
    164e:	b003      	add	sp, #12
    1650:	bd00      	pop	{pc}
    1652:	46c0      	nop			; (mov r8, r8)
    1654:	20000234 	.word	0x20000234
    1658:	000012f1 	.word	0x000012f1
    165c:	00001070 	.word	0x00001070
    1660:	00002a01 	.word	0x00002a01
    1664:	00002a0d 	.word	0x00002a0d

00001668 <hif_chip_wake>:
*	@brief	To Wakeup the chip.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_wake(void)
{
    1668:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
    166a:	4b0c      	ldr	r3, [pc, #48]	; (169c <hif_chip_wake+0x34>)
    166c:	789b      	ldrb	r3, [r3, #2]
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
    166e:	2000      	movs	r0, #0
*/

sint8 hif_chip_wake(void)
{
	sint8 ret = M2M_SUCCESS;
	if(gstrHifCxt.u8HifRXDone)
    1670:	2b00      	cmp	r3, #0
    1672:	d111      	bne.n	1698 <hif_chip_wake+0x30>
	{
		/*chip already wake for the rx not done no need to send wake request*/
		return ret;
	}
	if(gstrHifCxt.u8ChipSleep == 0)
    1674:	4b09      	ldr	r3, [pc, #36]	; (169c <hif_chip_wake+0x34>)
    1676:	785b      	ldrb	r3, [r3, #1]
    1678:	2b00      	cmp	r3, #0
    167a:	d107      	bne.n	168c <hif_chip_wake+0x24>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
    167c:	4b07      	ldr	r3, [pc, #28]	; (169c <hif_chip_wake+0x34>)
    167e:	781b      	ldrb	r3, [r3, #0]
    1680:	2b00      	cmp	r3, #0
    1682:	d003      	beq.n	168c <hif_chip_wake+0x24>
		{
			ret = chip_wake();
    1684:	4b06      	ldr	r3, [pc, #24]	; (16a0 <hif_chip_wake+0x38>)
    1686:	4798      	blx	r3
			if(ret != M2M_SUCCESS)goto ERR1;
    1688:	2800      	cmp	r0, #0
    168a:	d105      	bne.n	1698 <hif_chip_wake+0x30>
		}
		else
		{
		}
	}
	gstrHifCxt.u8ChipSleep++;
    168c:	4a03      	ldr	r2, [pc, #12]	; (169c <hif_chip_wake+0x34>)
    168e:	7853      	ldrb	r3, [r2, #1]
    1690:	3301      	adds	r3, #1
    1692:	b2db      	uxtb	r3, r3
    1694:	7053      	strb	r3, [r2, #1]
    1696:	2000      	movs	r0, #0
ERR1:
	return ret;
}
    1698:	bd10      	pop	{r4, pc}
    169a:	46c0      	nop			; (mov r8, r8)
    169c:	20000234 	.word	0x20000234
    16a0:	000026e9 	.word	0x000026e9

000016a4 <hif_chip_sleep_sc>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep_sc(void)
{
	if(gstrHifCxt.u8ChipSleep >= 1)
    16a4:	4b05      	ldr	r3, [pc, #20]	; (16bc <hif_chip_sleep_sc+0x18>)
    16a6:	785b      	ldrb	r3, [r3, #1]
    16a8:	2b00      	cmp	r3, #0
    16aa:	d004      	beq.n	16b6 <hif_chip_sleep_sc+0x12>
	{
		gstrHifCxt.u8ChipSleep--;
    16ac:	4a03      	ldr	r2, [pc, #12]	; (16bc <hif_chip_sleep_sc+0x18>)
    16ae:	7853      	ldrb	r3, [r2, #1]
    16b0:	3b01      	subs	r3, #1
    16b2:	b2db      	uxtb	r3, r3
    16b4:	7053      	strb	r3, [r2, #1]
	}
	return M2M_SUCCESS;
}
    16b6:	2000      	movs	r0, #0
    16b8:	4770      	bx	lr
    16ba:	46c0      	nop			; (mov r8, r8)
    16bc:	20000234 	.word	0x20000234

000016c0 <hif_chip_sleep>:
*	@brief	To make the chip sleep.
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
    16c0:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;

	if(gstrHifCxt.u8ChipSleep >= 1)
    16c2:	4b0a      	ldr	r3, [pc, #40]	; (16ec <hif_chip_sleep+0x2c>)
    16c4:	785b      	ldrb	r3, [r3, #1]
    16c6:	2b00      	cmp	r3, #0
    16c8:	d004      	beq.n	16d4 <hif_chip_sleep+0x14>
	{
		gstrHifCxt.u8ChipSleep--;
    16ca:	4a08      	ldr	r2, [pc, #32]	; (16ec <hif_chip_sleep+0x2c>)
    16cc:	7853      	ldrb	r3, [r2, #1]
    16ce:	3b01      	subs	r3, #1
    16d0:	b2db      	uxtb	r3, r3
    16d2:	7053      	strb	r3, [r2, #1]
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
    16d4:	4b05      	ldr	r3, [pc, #20]	; (16ec <hif_chip_sleep+0x2c>)
    16d6:	785b      	ldrb	r3, [r3, #1]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_chip_sleep(void)
{
	sint8 ret = M2M_SUCCESS;
    16d8:	2000      	movs	r0, #0
	if(gstrHifCxt.u8ChipSleep >= 1)
	{
		gstrHifCxt.u8ChipSleep--;
	}
	
	if(gstrHifCxt.u8ChipSleep == 0)
    16da:	2b00      	cmp	r3, #0
    16dc:	d105      	bne.n	16ea <hif_chip_sleep+0x2a>
	{
		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
    16de:	4b03      	ldr	r3, [pc, #12]	; (16ec <hif_chip_sleep+0x2c>)
    16e0:	781b      	ldrb	r3, [r3, #0]
    16e2:	2b00      	cmp	r3, #0
    16e4:	d001      	beq.n	16ea <hif_chip_sleep+0x2a>
		{
			ret = chip_sleep();
    16e6:	4b02      	ldr	r3, [pc, #8]	; (16f0 <hif_chip_sleep+0x30>)
    16e8:	4798      	blx	r3
		{
		}
	}
ERR1:
	return ret;
}
    16ea:	bd10      	pop	{r4, pc}
    16ec:	20000234 	.word	0x20000234
    16f0:	00002685 	.word	0x00002685

000016f4 <hif_send>:
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
{
    16f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    16f6:	465f      	mov	r7, fp
    16f8:	4656      	mov	r6, sl
    16fa:	b4c0      	push	{r6, r7}
    16fc:	b08b      	sub	sp, #44	; 0x2c
    16fe:	4683      	mov	fp, r0
    1700:	000c      	movs	r4, r1
    1702:	9203      	str	r2, [sp, #12]
    1704:	9302      	str	r3, [sp, #8]
    1706:	ab12      	add	r3, sp, #72	; 0x48
    1708:	cb80      	ldmia	r3!, {r7}
    170a:	881e      	ldrh	r6, [r3, #0]
    170c:	ab14      	add	r3, sp, #80	; 0x50
    170e:	881d      	ldrh	r5, [r3, #0]
	sint8		ret = M2M_ERR_SEND;
	volatile tstrHifHdr	strHif;

	strHif.u8Opcode		= u8Opcode&(~NBIT7);
    1710:	227f      	movs	r2, #127	; 0x7f
    1712:	400a      	ands	r2, r1
    1714:	ab09      	add	r3, sp, #36	; 0x24
    1716:	705a      	strb	r2, [r3, #1]
	strHif.u8Gid		= u8Gid;
    1718:	7018      	strb	r0, [r3, #0]
	strHif.u16Length	= M2M_HIF_HDR_OFFSET;
    171a:	2208      	movs	r2, #8
    171c:	805a      	strh	r2, [r3, #2]
	if(pu8DataBuf != NULL)
    171e:	2f00      	cmp	r7, #0
    1720:	d005      	beq.n	172e <hif_send+0x3a>
	{
		strHif.u16Length += u16DataOffset + u16DataSize;
    1722:	885a      	ldrh	r2, [r3, #2]
    1724:	1992      	adds	r2, r2, r6
    1726:	18aa      	adds	r2, r5, r2
    1728:	b292      	uxth	r2, r2
    172a:	805a      	strh	r2, [r3, #2]
    172c:	e006      	b.n	173c <hif_send+0x48>
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
    172e:	ab09      	add	r3, sp, #36	; 0x24
    1730:	885a      	ldrh	r2, [r3, #2]
    1732:	9902      	ldr	r1, [sp, #8]
    1734:	468c      	mov	ip, r1
    1736:	4462      	add	r2, ip
    1738:	b292      	uxth	r2, r2
    173a:	805a      	strh	r2, [r3, #2]
	}
	ret = hif_chip_wake();
    173c:	4b66      	ldr	r3, [pc, #408]	; (18d8 <hif_send+0x1e4>)
    173e:	4798      	blx	r3
    1740:	9001      	str	r0, [sp, #4]
	if(ret == M2M_SUCCESS)
    1742:	2800      	cmp	r0, #0
    1744:	d000      	beq.n	1748 <hif_send+0x54>
    1746:	e0ad      	b.n	18a4 <hif_send+0x1b0>
	{
		volatile uint32 reg, dma_addr = 0;
    1748:	9007      	str	r0, [sp, #28]
		volatile uint16 cnt = 0;
    174a:	aa04      	add	r2, sp, #16
    174c:	80d0      	strh	r0, [r2, #6]
//#define OPTIMIZE_BUS 
/*please define in firmware also*/
#ifndef OPTIMIZE_BUS
		reg = 0UL;
    174e:	9006      	str	r0, [sp, #24]
		reg |= (uint32)u8Gid;
    1750:	9b06      	ldr	r3, [sp, #24]
    1752:	465a      	mov	r2, fp
    1754:	431a      	orrs	r2, r3
    1756:	9206      	str	r2, [sp, #24]
		reg |= ((uint32)u8Opcode<<8);
    1758:	9a06      	ldr	r2, [sp, #24]
    175a:	0223      	lsls	r3, r4, #8
    175c:	4313      	orrs	r3, r2
    175e:	9306      	str	r3, [sp, #24]
		reg |= ((uint32)strHif.u16Length<<16);
    1760:	ab09      	add	r3, sp, #36	; 0x24
    1762:	885b      	ldrh	r3, [r3, #2]
    1764:	9a06      	ldr	r2, [sp, #24]
    1766:	041b      	lsls	r3, r3, #16
    1768:	4313      	orrs	r3, r2
    176a:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(NMI_STATE_REG,reg);
    176c:	9906      	ldr	r1, [sp, #24]
    176e:	485b      	ldr	r0, [pc, #364]	; (18dc <hif_send+0x1e8>)
    1770:	4b5b      	ldr	r3, [pc, #364]	; (18e0 <hif_send+0x1ec>)
    1772:	4798      	blx	r3
    1774:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
    1776:	d000      	beq.n	177a <hif_send+0x86>
    1778:	e0a5      	b.n	18c6 <hif_send+0x1d2>

		reg = 0UL;
    177a:	2300      	movs	r3, #0
    177c:	9306      	str	r3, [sp, #24]
		reg |= NBIT1;
    177e:	9a06      	ldr	r2, [sp, #24]
    1780:	3302      	adds	r3, #2
    1782:	4313      	orrs	r3, r2
    1784:	9306      	str	r3, [sp, #24]
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
    1786:	9906      	ldr	r1, [sp, #24]
    1788:	4856      	ldr	r0, [pc, #344]	; (18e4 <hif_send+0x1f0>)
    178a:	4b55      	ldr	r3, [pc, #340]	; (18e0 <hif_send+0x1ec>)
    178c:	4798      	blx	r3
    178e:	1e04      	subs	r4, r0, #0
		if(M2M_SUCCESS != ret) goto ERR1;
    1790:	d000      	beq.n	1794 <hif_send+0xa0>
    1792:	e098      	b.n	18c6 <hif_send+0x1d2>
		reg |= (u8Gid == M2M_REQ_GROUP_IP) ? (NBIT3):(0); /*IP = 1 or non IP*/
		reg |= ((uint32)strHif.u16Length << 4); /*length of pkt max = 4096*/
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
    1794:	2200      	movs	r2, #0
    1796:	9207      	str	r2, [sp, #28]
		
		for(cnt = 0; cnt < 1000; cnt ++)
    1798:	ab04      	add	r3, sp, #16
    179a:	80da      	strh	r2, [r3, #6]
    179c:	3306      	adds	r3, #6
    179e:	881b      	ldrh	r3, [r3, #0]
    17a0:	b29b      	uxth	r3, r3
    17a2:	4a51      	ldr	r2, [pc, #324]	; (18e8 <hif_send+0x1f4>)
    17a4:	4293      	cmp	r3, r2
    17a6:	d838      	bhi.n	181a <hif_send+0x126>
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    17a8:	4c50      	ldr	r4, [pc, #320]	; (18ec <hif_send+0x1f8>)
			 */
			if(cnt >= 500) {
				if(cnt < 501) {
					M2M_INFO("Slowing down...\n");
				}
				nm_bsp_sleep(1);
    17aa:	4b51      	ldr	r3, [pc, #324]	; (18f0 <hif_send+0x1fc>)
    17ac:	469a      	mov	sl, r3
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
		{
			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
    17ae:	a906      	add	r1, sp, #24
    17b0:	484c      	ldr	r0, [pc, #304]	; (18e4 <hif_send+0x1f0>)
    17b2:	47a0      	blx	r4
			if(ret != M2M_SUCCESS) break;
    17b4:	2800      	cmp	r0, #0
    17b6:	d130      	bne.n	181a <hif_send+0x126>
			/*
			 * If it takes too long to get a response, the slow down to 
			 * avoid back-to-back register read operations.
			 */
			if(cnt >= 500) {
    17b8:	ab04      	add	r3, sp, #16
    17ba:	3306      	adds	r3, #6
    17bc:	881b      	ldrh	r3, [r3, #0]
    17be:	b29b      	uxth	r3, r3
    17c0:	22f4      	movs	r2, #244	; 0xf4
    17c2:	32ff      	adds	r2, #255	; 0xff
    17c4:	4293      	cmp	r3, r2
    17c6:	d911      	bls.n	17ec <hif_send+0xf8>
				if(cnt < 501) {
    17c8:	ab04      	add	r3, sp, #16
    17ca:	3306      	adds	r3, #6
    17cc:	881b      	ldrh	r3, [r3, #0]
    17ce:	b29b      	uxth	r3, r3
    17d0:	3201      	adds	r2, #1
    17d2:	4293      	cmp	r3, r2
    17d4:	d808      	bhi.n	17e8 <hif_send+0xf4>
					M2M_INFO("Slowing down...\n");
    17d6:	4847      	ldr	r0, [pc, #284]	; (18f4 <hif_send+0x200>)
    17d8:	4b47      	ldr	r3, [pc, #284]	; (18f8 <hif_send+0x204>)
    17da:	4798      	blx	r3
    17dc:	4847      	ldr	r0, [pc, #284]	; (18fc <hif_send+0x208>)
    17de:	4b48      	ldr	r3, [pc, #288]	; (1900 <hif_send+0x20c>)
    17e0:	4798      	blx	r3
    17e2:	200d      	movs	r0, #13
    17e4:	4b47      	ldr	r3, [pc, #284]	; (1904 <hif_send+0x210>)
    17e6:	4798      	blx	r3
				}
				nm_bsp_sleep(1);
    17e8:	2001      	movs	r0, #1
    17ea:	47d0      	blx	sl
			}
			if (!(reg & NBIT1))
    17ec:	9b06      	ldr	r3, [sp, #24]
    17ee:	079b      	lsls	r3, r3, #30
    17f0:	d408      	bmi.n	1804 <hif_send+0x110>
			{
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
    17f2:	a907      	add	r1, sp, #28
    17f4:	4844      	ldr	r0, [pc, #272]	; (1908 <hif_send+0x214>)
    17f6:	4b3d      	ldr	r3, [pc, #244]	; (18ec <hif_send+0x1f8>)
    17f8:	4798      	blx	r3
    17fa:	1e04      	subs	r4, r0, #0
				if(ret != M2M_SUCCESS) {
    17fc:	d00d      	beq.n	181a <hif_send+0x126>
					/*in case of read error clear the DMA address and return error*/
					dma_addr = 0;
    17fe:	2300      	movs	r3, #0
    1800:	9307      	str	r3, [sp, #28]
					goto ERR1;
    1802:	e060      	b.n	18c6 <hif_send+0x1d2>
		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
		if(M2M_SUCCESS != ret) goto ERR1;
#endif
		dma_addr = 0;
		
		for(cnt = 0; cnt < 1000; cnt ++)
    1804:	ab04      	add	r3, sp, #16
    1806:	88da      	ldrh	r2, [r3, #6]
    1808:	3201      	adds	r2, #1
    180a:	b292      	uxth	r2, r2
    180c:	80da      	strh	r2, [r3, #6]
    180e:	3306      	adds	r3, #6
    1810:	881b      	ldrh	r3, [r3, #0]
    1812:	b29b      	uxth	r3, r3
    1814:	4a34      	ldr	r2, [pc, #208]	; (18e8 <hif_send+0x1f4>)
    1816:	4293      	cmp	r3, r2
    1818:	d9c9      	bls.n	17ae <hif_send+0xba>
				/*in case of success break */
				break;
			}
		}

		if (dma_addr != 0)
    181a:	9b07      	ldr	r3, [sp, #28]
    181c:	2b00      	cmp	r3, #0
    181e:	d03c      	beq.n	189a <hif_send+0x1a6>
		{
			volatile uint32	u32CurrAddr;
			u32CurrAddr = dma_addr;
    1820:	9b07      	ldr	r3, [sp, #28]
    1822:	9308      	str	r3, [sp, #32]
			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
    1824:	a909      	add	r1, sp, #36	; 0x24
    1826:	884b      	ldrh	r3, [r1, #2]
    1828:	b29b      	uxth	r3, r3
    182a:	804b      	strh	r3, [r1, #2]
			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
    182c:	9808      	ldr	r0, [sp, #32]
    182e:	2208      	movs	r2, #8
    1830:	4b36      	ldr	r3, [pc, #216]	; (190c <hif_send+0x218>)
    1832:	4798      	blx	r3
    1834:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
    1836:	d146      	bne.n	18c6 <hif_send+0x1d2>
			u32CurrAddr += M2M_HIF_HDR_OFFSET;
    1838:	9b08      	ldr	r3, [sp, #32]
    183a:	3308      	adds	r3, #8
    183c:	9308      	str	r3, [sp, #32]
			if(pu8CtrlBuf != NULL)
    183e:	9b03      	ldr	r3, [sp, #12]
    1840:	2b00      	cmp	r3, #0
    1842:	d00b      	beq.n	185c <hif_send+0x168>
			{
				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
    1844:	9808      	ldr	r0, [sp, #32]
    1846:	9a02      	ldr	r2, [sp, #8]
    1848:	0019      	movs	r1, r3
    184a:	4b30      	ldr	r3, [pc, #192]	; (190c <hif_send+0x218>)
    184c:	4798      	blx	r3
    184e:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
    1850:	d139      	bne.n	18c6 <hif_send+0x1d2>
				u32CurrAddr += u16CtrlBufSize;
    1852:	9b08      	ldr	r3, [sp, #32]
    1854:	9a02      	ldr	r2, [sp, #8]
    1856:	4694      	mov	ip, r2
    1858:	4463      	add	r3, ip
    185a:	9308      	str	r3, [sp, #32]
			}
			if(pu8DataBuf != NULL)
    185c:	2f00      	cmp	r7, #0
    185e:	d00e      	beq.n	187e <hif_send+0x18a>
			{
				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
    1860:	9b08      	ldr	r3, [sp, #32]
    1862:	9a02      	ldr	r2, [sp, #8]
    1864:	1aad      	subs	r5, r5, r2
    1866:	18ed      	adds	r5, r5, r3
    1868:	9508      	str	r5, [sp, #32]
				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
    186a:	9808      	ldr	r0, [sp, #32]
    186c:	0032      	movs	r2, r6
    186e:	0039      	movs	r1, r7
    1870:	4b26      	ldr	r3, [pc, #152]	; (190c <hif_send+0x218>)
    1872:	4798      	blx	r3
    1874:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret) goto ERR1;
    1876:	d126      	bne.n	18c6 <hif_send+0x1d2>
				u32CurrAddr += u16DataSize;
    1878:	9b08      	ldr	r3, [sp, #32]
    187a:	18f3      	adds	r3, r6, r3
    187c:	9308      	str	r3, [sp, #32]
			}

			reg = dma_addr << 2;
    187e:	9b07      	ldr	r3, [sp, #28]
    1880:	009b      	lsls	r3, r3, #2
    1882:	9306      	str	r3, [sp, #24]
			reg |= NBIT1;
    1884:	9a06      	ldr	r2, [sp, #24]
    1886:	2302      	movs	r3, #2
    1888:	4313      	orrs	r3, r2
    188a:	9306      	str	r3, [sp, #24]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
    188c:	9906      	ldr	r1, [sp, #24]
    188e:	4820      	ldr	r0, [pc, #128]	; (1910 <hif_send+0x21c>)
    1890:	4b13      	ldr	r3, [pc, #76]	; (18e0 <hif_send+0x1ec>)
    1892:	4798      	blx	r3
    1894:	1e04      	subs	r4, r0, #0
			if(M2M_SUCCESS != ret) goto ERR1;
    1896:	d116      	bne.n	18c6 <hif_send+0x1d2>
    1898:	e012      	b.n	18c0 <hif_send+0x1cc>
		}
		else
		{
			ret = hif_chip_sleep();
    189a:	4b1e      	ldr	r3, [pc, #120]	; (1914 <hif_send+0x220>)
    189c:	4798      	blx	r3
			M2M_DBG("Failed to alloc rx size %d\r",ret);
			ret = M2M_ERR_MEM_ALLOC;
    189e:	2003      	movs	r0, #3
    18a0:	4240      	negs	r0, r0
			goto ERR2;
    18a2:	e013      	b.n	18cc <hif_send+0x1d8>
		}

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
    18a4:	22cb      	movs	r2, #203	; 0xcb
    18a6:	0052      	lsls	r2, r2, #1
    18a8:	491b      	ldr	r1, [pc, #108]	; (1918 <hif_send+0x224>)
    18aa:	481c      	ldr	r0, [pc, #112]	; (191c <hif_send+0x228>)
    18ac:	4b12      	ldr	r3, [pc, #72]	; (18f8 <hif_send+0x204>)
    18ae:	4798      	blx	r3
    18b0:	481b      	ldr	r0, [pc, #108]	; (1920 <hif_send+0x22c>)
    18b2:	4b13      	ldr	r3, [pc, #76]	; (1900 <hif_send+0x20c>)
    18b4:	4798      	blx	r3
    18b6:	200d      	movs	r0, #13
    18b8:	4b12      	ldr	r3, [pc, #72]	; (1904 <hif_send+0x210>)
    18ba:	4798      	blx	r3
	}
	else
	{
		strHif.u16Length += u16CtrlBufSize;
	}
	ret = hif_chip_wake();
    18bc:	9801      	ldr	r0, [sp, #4]

	}
	else
	{
		M2M_ERR("(HIF)Fail to wakup the chip\n");
		goto ERR2;
    18be:	e005      	b.n	18cc <hif_send+0x1d8>
	}
	/*actual sleep ret = M2M_SUCCESS*/
 	ret = hif_chip_sleep();
    18c0:	4b14      	ldr	r3, [pc, #80]	; (1914 <hif_send+0x220>)
    18c2:	4798      	blx	r3
	return ret;
    18c4:	e002      	b.n	18cc <hif_send+0x1d8>
ERR1:
	/*reset the count but no actual sleep as it already bus error*/
	hif_chip_sleep_sc();
    18c6:	4b17      	ldr	r3, [pc, #92]	; (1924 <hif_send+0x230>)
    18c8:	4798      	blx	r3
    18ca:	0020      	movs	r0, r4
ERR2:
	/*logical error*/
	return ret;
}
    18cc:	b00b      	add	sp, #44	; 0x2c
    18ce:	bc0c      	pop	{r2, r3}
    18d0:	4692      	mov	sl, r2
    18d2:	469b      	mov	fp, r3
    18d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    18d6:	46c0      	nop			; (mov r8, r8)
    18d8:	00001669 	.word	0x00001669
    18dc:	0000108c 	.word	0x0000108c
    18e0:	00002a0d 	.word	0x00002a0d
    18e4:	00001078 	.word	0x00001078
    18e8:	000003e7 	.word	0x000003e7
    18ec:	00002a01 	.word	0x00002a01
    18f0:	000011d5 	.word	0x000011d5
    18f4:	00009ea8 	.word	0x00009ea8
    18f8:	00008845 	.word	0x00008845
    18fc:	00009eb4 	.word	0x00009eb4
    1900:	00008965 	.word	0x00008965
    1904:	00008879 	.word	0x00008879
    1908:	00150400 	.word	0x00150400
    190c:	00002a81 	.word	0x00002a81
    1910:	0000106c 	.word	0x0000106c
    1914:	000016c1 	.word	0x000016c1
    1918:	0000a188 	.word	0x0000a188
    191c:	00009e44 	.word	0x00009e44
    1920:	00009ec4 	.word	0x00009ec4
    1924:	000016a5 	.word	0x000016a5

00001928 <hif_handle_isr>:
*	@brief	Handle interrupt received from NMC1500 firmware.
*   @return     The function SHALL return 0 for success and a negative value otherwise.
*/

sint8 hif_handle_isr(void)
{
    1928:	b5f0      	push	{r4, r5, r6, r7, lr}
    192a:	464f      	mov	r7, r9
    192c:	4646      	mov	r6, r8
    192e:	b4c0      	push	{r6, r7}
    1930:	b087      	sub	sp, #28
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    1932:	4bcd      	ldr	r3, [pc, #820]	; (1c68 <hif_handle_isr+0x340>)
    1934:	4698      	mov	r8, r3
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
    1936:	4699      	mov	r9, r3
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    1938:	4ecc      	ldr	r6, [pc, #816]	; (1c6c <hif_handle_isr+0x344>)
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    193a:	e1d9      	b.n	1cf0 <hif_handle_isr+0x3c8>
		/*must be at that place because of the race of interrupt increment and that decrement*/
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
    193c:	464b      	mov	r3, r9
    193e:	78db      	ldrb	r3, [r3, #3]
    1940:	3b01      	subs	r3, #1
    1942:	b2db      	uxtb	r3, r3
    1944:	464a      	mov	r2, r9
    1946:	70d3      	strb	r3, [r2, #3]
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg;
	volatile tstrHifHdr strHif;

	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
    1948:	a903      	add	r1, sp, #12
    194a:	48c9      	ldr	r0, [pc, #804]	; (1c70 <hif_handle_isr+0x348>)
    194c:	47b0      	blx	r6
    194e:	1e04      	subs	r4, r0, #0
	if(M2M_SUCCESS == ret)
    1950:	d000      	beq.n	1954 <hif_handle_isr+0x2c>
    1952:	e16f      	b.n	1c34 <hif_handle_isr+0x30c>
	{
		if(reg & 0x1)	/* New interrupt has been received */
    1954:	9b03      	ldr	r3, [sp, #12]
    1956:	07db      	lsls	r3, r3, #31
    1958:	d400      	bmi.n	195c <hif_handle_isr+0x34>
    195a:	e15c      	b.n	1c16 <hif_handle_isr+0x2ee>
		{
			uint16 size;

			nm_bsp_interrupt_ctrl(0);
    195c:	2000      	movs	r0, #0
    195e:	4bc5      	ldr	r3, [pc, #788]	; (1c74 <hif_handle_isr+0x34c>)
    1960:	4798      	blx	r3
			/*Clearing RX interrupt*/
			reg &= ~NBIT0;
    1962:	2301      	movs	r3, #1
    1964:	9903      	ldr	r1, [sp, #12]
    1966:	4399      	bics	r1, r3
    1968:	9103      	str	r1, [sp, #12]
			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
    196a:	48c1      	ldr	r0, [pc, #772]	; (1c70 <hif_handle_isr+0x348>)
    196c:	4bc2      	ldr	r3, [pc, #776]	; (1c78 <hif_handle_isr+0x350>)
    196e:	4798      	blx	r3
    1970:	1e04      	subs	r4, r0, #0
			if(ret != M2M_SUCCESS)goto ERR1;
    1972:	d000      	beq.n	1976 <hif_handle_isr+0x4e>
    1974:	e16c      	b.n	1c50 <hif_handle_isr+0x328>
			gstrHifCxt.u8HifRXDone = 1;
    1976:	2201      	movs	r2, #1
    1978:	4bbb      	ldr	r3, [pc, #748]	; (1c68 <hif_handle_isr+0x340>)
    197a:	709a      	strb	r2, [r3, #2]
			size = (uint16)((reg >> 2) & 0xfff);
    197c:	9b03      	ldr	r3, [sp, #12]
    197e:	0499      	lsls	r1, r3, #18
    1980:	0d0f      	lsrs	r7, r1, #20
			if (size > 0) {
    1982:	d100      	bne.n	1986 <hif_handle_isr+0x5e>
    1984:	e138      	b.n	1bf8 <hif_handle_isr+0x2d0>
				uint32 address = 0;
    1986:	2300      	movs	r3, #0
    1988:	9305      	str	r3, [sp, #20]
				/**
				start bus transfer
				**/
				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
    198a:	a905      	add	r1, sp, #20
    198c:	48bb      	ldr	r0, [pc, #748]	; (1c7c <hif_handle_isr+0x354>)
    198e:	4bb7      	ldr	r3, [pc, #732]	; (1c6c <hif_handle_isr+0x344>)
    1990:	4798      	blx	r3
    1992:	1e04      	subs	r4, r0, #0
				if(M2M_SUCCESS != ret)
    1994:	d00f      	beq.n	19b6 <hif_handle_isr+0x8e>
				{
					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
    1996:	22c8      	movs	r2, #200	; 0xc8
    1998:	32ff      	adds	r2, #255	; 0xff
    199a:	49b9      	ldr	r1, [pc, #740]	; (1c80 <hif_handle_isr+0x358>)
    199c:	48b9      	ldr	r0, [pc, #740]	; (1c84 <hif_handle_isr+0x35c>)
    199e:	4bba      	ldr	r3, [pc, #744]	; (1c88 <hif_handle_isr+0x360>)
    19a0:	4798      	blx	r3
    19a2:	48ba      	ldr	r0, [pc, #744]	; (1c8c <hif_handle_isr+0x364>)
    19a4:	4bba      	ldr	r3, [pc, #744]	; (1c90 <hif_handle_isr+0x368>)
    19a6:	4798      	blx	r3
    19a8:	200d      	movs	r0, #13
    19aa:	4bba      	ldr	r3, [pc, #744]	; (1c94 <hif_handle_isr+0x36c>)
    19ac:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
    19ae:	2001      	movs	r0, #1
    19b0:	4bb0      	ldr	r3, [pc, #704]	; (1c74 <hif_handle_isr+0x34c>)
    19b2:	4798      	blx	r3
    19b4:	e14a      	b.n	1c4c <hif_handle_isr+0x324>
					goto ERR1;
				}
				gstrHifCxt.u32RxAddr = address;
    19b6:	4bac      	ldr	r3, [pc, #688]	; (1c68 <hif_handle_isr+0x340>)
    19b8:	9a05      	ldr	r2, [sp, #20]
    19ba:	605a      	str	r2, [r3, #4]
				gstrHifCxt.u32RxSize = size;
    19bc:	609f      	str	r7, [r3, #8]
				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
    19be:	ad04      	add	r5, sp, #16
    19c0:	2204      	movs	r2, #4
    19c2:	0029      	movs	r1, r5
    19c4:	9805      	ldr	r0, [sp, #20]
    19c6:	4bb4      	ldr	r3, [pc, #720]	; (1c98 <hif_handle_isr+0x370>)
    19c8:	4798      	blx	r3
    19ca:	0004      	movs	r4, r0
				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
    19cc:	886b      	ldrh	r3, [r5, #2]
    19ce:	b29b      	uxth	r3, r3
    19d0:	806b      	strh	r3, [r5, #2]
				if(M2M_SUCCESS != ret)
    19d2:	2800      	cmp	r0, #0
    19d4:	d00f      	beq.n	19f6 <hif_handle_isr+0xce>
				{
					M2M_ERR("(hif) address bus fail\n");
    19d6:	22d2      	movs	r2, #210	; 0xd2
    19d8:	32ff      	adds	r2, #255	; 0xff
    19da:	49a9      	ldr	r1, [pc, #676]	; (1c80 <hif_handle_isr+0x358>)
    19dc:	48a9      	ldr	r0, [pc, #676]	; (1c84 <hif_handle_isr+0x35c>)
    19de:	4baa      	ldr	r3, [pc, #680]	; (1c88 <hif_handle_isr+0x360>)
    19e0:	4798      	blx	r3
    19e2:	48ae      	ldr	r0, [pc, #696]	; (1c9c <hif_handle_isr+0x374>)
    19e4:	4baa      	ldr	r3, [pc, #680]	; (1c90 <hif_handle_isr+0x368>)
    19e6:	4798      	blx	r3
    19e8:	200d      	movs	r0, #13
    19ea:	4baa      	ldr	r3, [pc, #680]	; (1c94 <hif_handle_isr+0x36c>)
    19ec:	4798      	blx	r3
					nm_bsp_interrupt_ctrl(1);
    19ee:	2001      	movs	r0, #1
    19f0:	4ba0      	ldr	r3, [pc, #640]	; (1c74 <hif_handle_isr+0x34c>)
    19f2:	4798      	blx	r3
    19f4:	e12a      	b.n	1c4c <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(strHif.u16Length != size)
    19f6:	ab04      	add	r3, sp, #16
    19f8:	885b      	ldrh	r3, [r3, #2]
    19fa:	b29b      	uxth	r3, r3
    19fc:	429f      	cmp	r7, r3
    19fe:	d01d      	beq.n	1a3c <hif_handle_isr+0x114>
				{
					if((size - strHif.u16Length) > 4)
    1a00:	ab04      	add	r3, sp, #16
    1a02:	885b      	ldrh	r3, [r3, #2]
    1a04:	1afb      	subs	r3, r7, r3
    1a06:	2b04      	cmp	r3, #4
    1a08:	dd18      	ble.n	1a3c <hif_handle_isr+0x114>
					{
						M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
    1a0a:	22ed      	movs	r2, #237	; 0xed
    1a0c:	0052      	lsls	r2, r2, #1
    1a0e:	499c      	ldr	r1, [pc, #624]	; (1c80 <hif_handle_isr+0x358>)
    1a10:	489c      	ldr	r0, [pc, #624]	; (1c84 <hif_handle_isr+0x35c>)
    1a12:	4c9d      	ldr	r4, [pc, #628]	; (1c88 <hif_handle_isr+0x360>)
    1a14:	47a0      	blx	r4
    1a16:	a904      	add	r1, sp, #16
    1a18:	884a      	ldrh	r2, [r1, #2]
    1a1a:	b292      	uxth	r2, r2
    1a1c:	780b      	ldrb	r3, [r1, #0]
    1a1e:	b2db      	uxtb	r3, r3
    1a20:	7849      	ldrb	r1, [r1, #1]
    1a22:	9100      	str	r1, [sp, #0]
    1a24:	0039      	movs	r1, r7
    1a26:	489e      	ldr	r0, [pc, #632]	; (1ca0 <hif_handle_isr+0x378>)
    1a28:	47a0      	blx	r4
    1a2a:	200d      	movs	r0, #13
    1a2c:	4b99      	ldr	r3, [pc, #612]	; (1c94 <hif_handle_isr+0x36c>)
    1a2e:	4798      	blx	r3
							size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
						nm_bsp_interrupt_ctrl(1);
    1a30:	2001      	movs	r0, #1
    1a32:	4b90      	ldr	r3, [pc, #576]	; (1c74 <hif_handle_isr+0x34c>)
    1a34:	4798      	blx	r3
						ret = M2M_ERR_BUS_FAIL;
    1a36:	2406      	movs	r4, #6
    1a38:	4264      	negs	r4, r4
    1a3a:	e107      	b.n	1c4c <hif_handle_isr+0x324>
						goto ERR1;
					}
				}

				if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
    1a3c:	ab04      	add	r3, sp, #16
    1a3e:	781b      	ldrb	r3, [r3, #0]
    1a40:	2b01      	cmp	r3, #1
    1a42:	d11c      	bne.n	1a7e <hif_handle_isr+0x156>
				{
					if(gstrHifCxt.pfWifiCb)
    1a44:	4b88      	ldr	r3, [pc, #544]	; (1c68 <hif_handle_isr+0x340>)
    1a46:	68db      	ldr	r3, [r3, #12]
    1a48:	2b00      	cmp	r3, #0
    1a4a:	d00b      	beq.n	1a64 <hif_handle_isr+0x13c>
						gstrHifCxt.pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1a4c:	4b86      	ldr	r3, [pc, #536]	; (1c68 <hif_handle_isr+0x340>)
    1a4e:	68db      	ldr	r3, [r3, #12]
    1a50:	aa04      	add	r2, sp, #16
    1a52:	7850      	ldrb	r0, [r2, #1]
    1a54:	b2c0      	uxtb	r0, r0
    1a56:	8851      	ldrh	r1, [r2, #2]
    1a58:	9a05      	ldr	r2, [sp, #20]
    1a5a:	3208      	adds	r2, #8
    1a5c:	3908      	subs	r1, #8
    1a5e:	b289      	uxth	r1, r1
    1a60:	4798      	blx	r3
    1a62:	e0b0      	b.n	1bc6 <hif_handle_isr+0x29e>
					else
						M2M_ERR("WIFI callback is not registered\n");
    1a64:	22f3      	movs	r2, #243	; 0xf3
    1a66:	0052      	lsls	r2, r2, #1
    1a68:	4985      	ldr	r1, [pc, #532]	; (1c80 <hif_handle_isr+0x358>)
    1a6a:	4886      	ldr	r0, [pc, #536]	; (1c84 <hif_handle_isr+0x35c>)
    1a6c:	4b86      	ldr	r3, [pc, #536]	; (1c88 <hif_handle_isr+0x360>)
    1a6e:	4798      	blx	r3
    1a70:	488c      	ldr	r0, [pc, #560]	; (1ca4 <hif_handle_isr+0x37c>)
    1a72:	4b87      	ldr	r3, [pc, #540]	; (1c90 <hif_handle_isr+0x368>)
    1a74:	4798      	blx	r3
    1a76:	200d      	movs	r0, #13
    1a78:	4b86      	ldr	r3, [pc, #536]	; (1c94 <hif_handle_isr+0x36c>)
    1a7a:	4798      	blx	r3
    1a7c:	e0a3      	b.n	1bc6 <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
    1a7e:	ab04      	add	r3, sp, #16
    1a80:	781b      	ldrb	r3, [r3, #0]
    1a82:	2b02      	cmp	r3, #2
    1a84:	d11c      	bne.n	1ac0 <hif_handle_isr+0x198>
				{
					if(gstrHifCxt.pfIpCb)
    1a86:	4b78      	ldr	r3, [pc, #480]	; (1c68 <hif_handle_isr+0x340>)
    1a88:	691b      	ldr	r3, [r3, #16]
    1a8a:	2b00      	cmp	r3, #0
    1a8c:	d00b      	beq.n	1aa6 <hif_handle_isr+0x17e>
						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1a8e:	4b76      	ldr	r3, [pc, #472]	; (1c68 <hif_handle_isr+0x340>)
    1a90:	691b      	ldr	r3, [r3, #16]
    1a92:	aa04      	add	r2, sp, #16
    1a94:	7850      	ldrb	r0, [r2, #1]
    1a96:	b2c0      	uxtb	r0, r0
    1a98:	8851      	ldrh	r1, [r2, #2]
    1a9a:	9a05      	ldr	r2, [sp, #20]
    1a9c:	3208      	adds	r2, #8
    1a9e:	3908      	subs	r1, #8
    1aa0:	b289      	uxth	r1, r1
    1aa2:	4798      	blx	r3
    1aa4:	e08f      	b.n	1bc6 <hif_handle_isr+0x29e>
					else
						M2M_ERR("Scoket callback is not registered\n");
    1aa6:	22f7      	movs	r2, #247	; 0xf7
    1aa8:	0052      	lsls	r2, r2, #1
    1aaa:	4975      	ldr	r1, [pc, #468]	; (1c80 <hif_handle_isr+0x358>)
    1aac:	4875      	ldr	r0, [pc, #468]	; (1c84 <hif_handle_isr+0x35c>)
    1aae:	4b76      	ldr	r3, [pc, #472]	; (1c88 <hif_handle_isr+0x360>)
    1ab0:	4798      	blx	r3
    1ab2:	487d      	ldr	r0, [pc, #500]	; (1ca8 <hif_handle_isr+0x380>)
    1ab4:	4b76      	ldr	r3, [pc, #472]	; (1c90 <hif_handle_isr+0x368>)
    1ab6:	4798      	blx	r3
    1ab8:	200d      	movs	r0, #13
    1aba:	4b76      	ldr	r3, [pc, #472]	; (1c94 <hif_handle_isr+0x36c>)
    1abc:	4798      	blx	r3
    1abe:	e082      	b.n	1bc6 <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
    1ac0:	ab04      	add	r3, sp, #16
    1ac2:	781b      	ldrb	r3, [r3, #0]
    1ac4:	2b04      	cmp	r3, #4
    1ac6:	d11c      	bne.n	1b02 <hif_handle_isr+0x1da>
				{
					if(gstrHifCxt.pfOtaCb)
    1ac8:	4b67      	ldr	r3, [pc, #412]	; (1c68 <hif_handle_isr+0x340>)
    1aca:	695b      	ldr	r3, [r3, #20]
    1acc:	2b00      	cmp	r3, #0
    1ace:	d00b      	beq.n	1ae8 <hif_handle_isr+0x1c0>
						gstrHifCxt.pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1ad0:	4b65      	ldr	r3, [pc, #404]	; (1c68 <hif_handle_isr+0x340>)
    1ad2:	695b      	ldr	r3, [r3, #20]
    1ad4:	aa04      	add	r2, sp, #16
    1ad6:	7850      	ldrb	r0, [r2, #1]
    1ad8:	b2c0      	uxtb	r0, r0
    1ada:	8851      	ldrh	r1, [r2, #2]
    1adc:	9a05      	ldr	r2, [sp, #20]
    1ade:	3208      	adds	r2, #8
    1ae0:	3908      	subs	r1, #8
    1ae2:	b289      	uxth	r1, r1
    1ae4:	4798      	blx	r3
    1ae6:	e06e      	b.n	1bc6 <hif_handle_isr+0x29e>
					else
						M2M_ERR("Ota callback is not registered\n");
    1ae8:	22fb      	movs	r2, #251	; 0xfb
    1aea:	0052      	lsls	r2, r2, #1
    1aec:	4964      	ldr	r1, [pc, #400]	; (1c80 <hif_handle_isr+0x358>)
    1aee:	4865      	ldr	r0, [pc, #404]	; (1c84 <hif_handle_isr+0x35c>)
    1af0:	4b65      	ldr	r3, [pc, #404]	; (1c88 <hif_handle_isr+0x360>)
    1af2:	4798      	blx	r3
    1af4:	486d      	ldr	r0, [pc, #436]	; (1cac <hif_handle_isr+0x384>)
    1af6:	4b66      	ldr	r3, [pc, #408]	; (1c90 <hif_handle_isr+0x368>)
    1af8:	4798      	blx	r3
    1afa:	200d      	movs	r0, #13
    1afc:	4b65      	ldr	r3, [pc, #404]	; (1c94 <hif_handle_isr+0x36c>)
    1afe:	4798      	blx	r3
    1b00:	e061      	b.n	1bc6 <hif_handle_isr+0x29e>

				}
				else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
    1b02:	ab04      	add	r3, sp, #16
    1b04:	781b      	ldrb	r3, [r3, #0]
    1b06:	2b06      	cmp	r3, #6
    1b08:	d11b      	bne.n	1b42 <hif_handle_isr+0x21a>
				{
					if(gstrHifCxt.pfCryptoCb)
    1b0a:	4b57      	ldr	r3, [pc, #348]	; (1c68 <hif_handle_isr+0x340>)
    1b0c:	6a1b      	ldr	r3, [r3, #32]
    1b0e:	2b00      	cmp	r3, #0
    1b10:	d00b      	beq.n	1b2a <hif_handle_isr+0x202>
						gstrHifCxt.pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1b12:	4b55      	ldr	r3, [pc, #340]	; (1c68 <hif_handle_isr+0x340>)
    1b14:	6a1b      	ldr	r3, [r3, #32]
    1b16:	aa04      	add	r2, sp, #16
    1b18:	7850      	ldrb	r0, [r2, #1]
    1b1a:	b2c0      	uxtb	r0, r0
    1b1c:	8851      	ldrh	r1, [r2, #2]
    1b1e:	9a05      	ldr	r2, [sp, #20]
    1b20:	3208      	adds	r2, #8
    1b22:	3908      	subs	r1, #8
    1b24:	b289      	uxth	r1, r1
    1b26:	4798      	blx	r3
    1b28:	e04d      	b.n	1bc6 <hif_handle_isr+0x29e>

					else
						M2M_ERR("Crypto callback is not registered\n");
    1b2a:	4a61      	ldr	r2, [pc, #388]	; (1cb0 <hif_handle_isr+0x388>)
    1b2c:	4954      	ldr	r1, [pc, #336]	; (1c80 <hif_handle_isr+0x358>)
    1b2e:	4855      	ldr	r0, [pc, #340]	; (1c84 <hif_handle_isr+0x35c>)
    1b30:	4b55      	ldr	r3, [pc, #340]	; (1c88 <hif_handle_isr+0x360>)
    1b32:	4798      	blx	r3
    1b34:	485f      	ldr	r0, [pc, #380]	; (1cb4 <hif_handle_isr+0x38c>)
    1b36:	4b56      	ldr	r3, [pc, #344]	; (1c90 <hif_handle_isr+0x368>)
    1b38:	4798      	blx	r3
    1b3a:	200d      	movs	r0, #13
    1b3c:	4b55      	ldr	r3, [pc, #340]	; (1c94 <hif_handle_isr+0x36c>)
    1b3e:	4798      	blx	r3
    1b40:	e041      	b.n	1bc6 <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
    1b42:	ab04      	add	r3, sp, #16
    1b44:	781b      	ldrb	r3, [r3, #0]
    1b46:	2b07      	cmp	r3, #7
    1b48:	d11b      	bne.n	1b82 <hif_handle_isr+0x25a>
				{
					if(gstrHifCxt.pfSigmaCb)
    1b4a:	4b47      	ldr	r3, [pc, #284]	; (1c68 <hif_handle_isr+0x340>)
    1b4c:	699b      	ldr	r3, [r3, #24]
    1b4e:	2b00      	cmp	r3, #0
    1b50:	d00b      	beq.n	1b6a <hif_handle_isr+0x242>
						gstrHifCxt.pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1b52:	4b45      	ldr	r3, [pc, #276]	; (1c68 <hif_handle_isr+0x340>)
    1b54:	699b      	ldr	r3, [r3, #24]
    1b56:	aa04      	add	r2, sp, #16
    1b58:	7850      	ldrb	r0, [r2, #1]
    1b5a:	b2c0      	uxtb	r0, r0
    1b5c:	8851      	ldrh	r1, [r2, #2]
    1b5e:	9a05      	ldr	r2, [sp, #20]
    1b60:	3208      	adds	r2, #8
    1b62:	3908      	subs	r1, #8
    1b64:	b289      	uxth	r1, r1
    1b66:	4798      	blx	r3
    1b68:	e02d      	b.n	1bc6 <hif_handle_isr+0x29e>
					else
						M2M_ERR("Sigma callback is not registered\n");
    1b6a:	4a53      	ldr	r2, [pc, #332]	; (1cb8 <hif_handle_isr+0x390>)
    1b6c:	4944      	ldr	r1, [pc, #272]	; (1c80 <hif_handle_isr+0x358>)
    1b6e:	4845      	ldr	r0, [pc, #276]	; (1c84 <hif_handle_isr+0x35c>)
    1b70:	4b45      	ldr	r3, [pc, #276]	; (1c88 <hif_handle_isr+0x360>)
    1b72:	4798      	blx	r3
    1b74:	4851      	ldr	r0, [pc, #324]	; (1cbc <hif_handle_isr+0x394>)
    1b76:	4b46      	ldr	r3, [pc, #280]	; (1c90 <hif_handle_isr+0x368>)
    1b78:	4798      	blx	r3
    1b7a:	200d      	movs	r0, #13
    1b7c:	4b45      	ldr	r3, [pc, #276]	; (1c94 <hif_handle_isr+0x36c>)
    1b7e:	4798      	blx	r3
    1b80:	e021      	b.n	1bc6 <hif_handle_isr+0x29e>
				}
				else if(M2M_REQ_GROUP_SSL == strHif.u8Gid)
    1b82:	ab04      	add	r3, sp, #16
    1b84:	781b      	ldrb	r3, [r3, #0]
    1b86:	2b05      	cmp	r3, #5
    1b88:	d10f      	bne.n	1baa <hif_handle_isr+0x282>
				{
				    if(gstrHifCxt.pfSslCb)
    1b8a:	4b37      	ldr	r3, [pc, #220]	; (1c68 <hif_handle_isr+0x340>)
    1b8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1b8e:	2b00      	cmp	r3, #0
    1b90:	d019      	beq.n	1bc6 <hif_handle_isr+0x29e>
						gstrHifCxt.pfSslCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
    1b92:	4b35      	ldr	r3, [pc, #212]	; (1c68 <hif_handle_isr+0x340>)
    1b94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1b96:	aa04      	add	r2, sp, #16
    1b98:	7850      	ldrb	r0, [r2, #1]
    1b9a:	b2c0      	uxtb	r0, r0
    1b9c:	8851      	ldrh	r1, [r2, #2]
    1b9e:	9a05      	ldr	r2, [sp, #20]
    1ba0:	3208      	adds	r2, #8
    1ba2:	3908      	subs	r1, #8
    1ba4:	b289      	uxth	r1, r1
    1ba6:	4798      	blx	r3
    1ba8:	e00d      	b.n	1bc6 <hif_handle_isr+0x29e>
				}
				else
				{
					M2M_ERR("(hif) invalid group ID\n");
    1baa:	4a45      	ldr	r2, [pc, #276]	; (1cc0 <hif_handle_isr+0x398>)
    1bac:	4934      	ldr	r1, [pc, #208]	; (1c80 <hif_handle_isr+0x358>)
    1bae:	4835      	ldr	r0, [pc, #212]	; (1c84 <hif_handle_isr+0x35c>)
    1bb0:	4b35      	ldr	r3, [pc, #212]	; (1c88 <hif_handle_isr+0x360>)
    1bb2:	4798      	blx	r3
    1bb4:	4843      	ldr	r0, [pc, #268]	; (1cc4 <hif_handle_isr+0x39c>)
    1bb6:	4b36      	ldr	r3, [pc, #216]	; (1c90 <hif_handle_isr+0x368>)
    1bb8:	4798      	blx	r3
    1bba:	200d      	movs	r0, #13
    1bbc:	4b35      	ldr	r3, [pc, #212]	; (1c94 <hif_handle_isr+0x36c>)
    1bbe:	4798      	blx	r3
					ret = M2M_ERR_BUS_FAIL;
    1bc0:	2406      	movs	r4, #6
    1bc2:	4264      	negs	r4, r4
    1bc4:	e042      	b.n	1c4c <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
    1bc6:	4b28      	ldr	r3, [pc, #160]	; (1c68 <hif_handle_isr+0x340>)
    1bc8:	789b      	ldrb	r3, [r3, #2]
    1bca:	2b00      	cmp	r3, #0
    1bcc:	d03e      	beq.n	1c4c <hif_handle_isr+0x324>
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
    1bce:	4a3e      	ldr	r2, [pc, #248]	; (1cc8 <hif_handle_isr+0x3a0>)
    1bd0:	492b      	ldr	r1, [pc, #172]	; (1c80 <hif_handle_isr+0x358>)
    1bd2:	482c      	ldr	r0, [pc, #176]	; (1c84 <hif_handle_isr+0x35c>)
    1bd4:	4d2c      	ldr	r5, [pc, #176]	; (1c88 <hif_handle_isr+0x360>)
    1bd6:	47a8      	blx	r5
    1bd8:	ab04      	add	r3, sp, #16
    1bda:	7819      	ldrb	r1, [r3, #0]
    1bdc:	b2c9      	uxtb	r1, r1
    1bde:	785a      	ldrb	r2, [r3, #1]
    1be0:	b2d2      	uxtb	r2, r2
    1be2:	483a      	ldr	r0, [pc, #232]	; (1ccc <hif_handle_isr+0x3a4>)
    1be4:	47a8      	blx	r5
    1be6:	200d      	movs	r0, #13
    1be8:	4b2a      	ldr	r3, [pc, #168]	; (1c94 <hif_handle_isr+0x36c>)
    1bea:	4798      	blx	r3
					ret = hif_set_rx_done();
    1bec:	4b38      	ldr	r3, [pc, #224]	; (1cd0 <hif_handle_isr+0x3a8>)
    1bee:	4798      	blx	r3
					if(ret != M2M_SUCCESS) goto ERR1;
    1bf0:	2800      	cmp	r0, #0
    1bf2:	d02b      	beq.n	1c4c <hif_handle_isr+0x324>
					goto ERR1;
				}
				if(gstrHifCxt.u8HifRXDone)
				{
					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
					ret = hif_set_rx_done();
    1bf4:	0004      	movs	r4, r0
    1bf6:	e029      	b.n	1c4c <hif_handle_isr+0x324>
					if(ret != M2M_SUCCESS) goto ERR1;
				}
			}
			else
			{
				M2M_ERR("(hif) Wrong Size\n");
    1bf8:	2287      	movs	r2, #135	; 0x87
    1bfa:	0092      	lsls	r2, r2, #2
    1bfc:	4920      	ldr	r1, [pc, #128]	; (1c80 <hif_handle_isr+0x358>)
    1bfe:	4821      	ldr	r0, [pc, #132]	; (1c84 <hif_handle_isr+0x35c>)
    1c00:	4b21      	ldr	r3, [pc, #132]	; (1c88 <hif_handle_isr+0x360>)
    1c02:	4798      	blx	r3
    1c04:	4833      	ldr	r0, [pc, #204]	; (1cd4 <hif_handle_isr+0x3ac>)
    1c06:	4b22      	ldr	r3, [pc, #136]	; (1c90 <hif_handle_isr+0x368>)
    1c08:	4798      	blx	r3
    1c0a:	200d      	movs	r0, #13
    1c0c:	4b21      	ldr	r3, [pc, #132]	; (1c94 <hif_handle_isr+0x36c>)
    1c0e:	4798      	blx	r3
				ret = M2M_ERR_RCV;
    1c10:	2402      	movs	r4, #2
    1c12:	4264      	negs	r4, r4
    1c14:	e01c      	b.n	1c50 <hif_handle_isr+0x328>
			}
		}
		else
		{
#ifndef WIN32
			M2M_ERR("(hif) False interrupt %lx",reg);
    1c16:	2289      	movs	r2, #137	; 0x89
    1c18:	0092      	lsls	r2, r2, #2
    1c1a:	4919      	ldr	r1, [pc, #100]	; (1c80 <hif_handle_isr+0x358>)
    1c1c:	4819      	ldr	r0, [pc, #100]	; (1c84 <hif_handle_isr+0x35c>)
    1c1e:	4c1a      	ldr	r4, [pc, #104]	; (1c88 <hif_handle_isr+0x360>)
    1c20:	47a0      	blx	r4
    1c22:	9903      	ldr	r1, [sp, #12]
    1c24:	482c      	ldr	r0, [pc, #176]	; (1cd8 <hif_handle_isr+0x3b0>)
    1c26:	47a0      	blx	r4
    1c28:	200d      	movs	r0, #13
    1c2a:	4b1a      	ldr	r3, [pc, #104]	; (1c94 <hif_handle_isr+0x36c>)
    1c2c:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    1c2e:	240c      	movs	r4, #12
    1c30:	4264      	negs	r4, r4
    1c32:	e00d      	b.n	1c50 <hif_handle_isr+0x328>
#endif
		}
	}
	else
	{
		M2M_ERR("(hif) Fail to Read interrupt reg\n");
    1c34:	4a29      	ldr	r2, [pc, #164]	; (1cdc <hif_handle_isr+0x3b4>)
    1c36:	4912      	ldr	r1, [pc, #72]	; (1c80 <hif_handle_isr+0x358>)
    1c38:	4812      	ldr	r0, [pc, #72]	; (1c84 <hif_handle_isr+0x35c>)
    1c3a:	4b13      	ldr	r3, [pc, #76]	; (1c88 <hif_handle_isr+0x360>)
    1c3c:	4798      	blx	r3
    1c3e:	4828      	ldr	r0, [pc, #160]	; (1ce0 <hif_handle_isr+0x3b8>)
    1c40:	4b13      	ldr	r3, [pc, #76]	; (1c90 <hif_handle_isr+0x368>)
    1c42:	4798      	blx	r3
    1c44:	200d      	movs	r0, #13
    1c46:	4b13      	ldr	r3, [pc, #76]	; (1c94 <hif_handle_isr+0x36c>)
    1c48:	4798      	blx	r3
    1c4a:	e001      	b.n	1c50 <hif_handle_isr+0x328>
		/*when the interrupt enabled*/
		gstrHifCxt.u8Interrupt--;
		while(1)
		{
			ret = hif_isr();
			if(ret == M2M_SUCCESS) {
    1c4c:	2c00      	cmp	r4, #0
    1c4e:	d04f      	beq.n	1cf0 <hif_handle_isr+0x3c8>
				/*we will try forever untill we get that interrupt*/
				/*Fail return errors here due to bus errors (reading expected values)*/
				break;
			} else {
				M2M_ERR("(HIF) Fail to handle interrupt %d try Again..\n",ret);
    1c50:	4a24      	ldr	r2, [pc, #144]	; (1ce4 <hif_handle_isr+0x3bc>)
    1c52:	4925      	ldr	r1, [pc, #148]	; (1ce8 <hif_handle_isr+0x3c0>)
    1c54:	480b      	ldr	r0, [pc, #44]	; (1c84 <hif_handle_isr+0x35c>)
    1c56:	4d0c      	ldr	r5, [pc, #48]	; (1c88 <hif_handle_isr+0x360>)
    1c58:	47a8      	blx	r5
    1c5a:	0021      	movs	r1, r4
    1c5c:	4823      	ldr	r0, [pc, #140]	; (1cec <hif_handle_isr+0x3c4>)
    1c5e:	47a8      	blx	r5
    1c60:	200d      	movs	r0, #13
    1c62:	4b0c      	ldr	r3, [pc, #48]	; (1c94 <hif_handle_isr+0x36c>)
    1c64:	4798      	blx	r3
			}
		}
    1c66:	e66f      	b.n	1948 <hif_handle_isr+0x20>
    1c68:	20000234 	.word	0x20000234
    1c6c:	00002a01 	.word	0x00002a01
    1c70:	00001070 	.word	0x00001070
    1c74:	000012f1 	.word	0x000012f1
    1c78:	00002a0d 	.word	0x00002a0d
    1c7c:	00001084 	.word	0x00001084
    1c80:	0000a194 	.word	0x0000a194
    1c84:	00009e44 	.word	0x00009e44
    1c88:	00008845 	.word	0x00008845
    1c8c:	00009ee0 	.word	0x00009ee0
    1c90:	00008965 	.word	0x00008965
    1c94:	00008879 	.word	0x00008879
    1c98:	00002a19 	.word	0x00002a19
    1c9c:	00009f04 	.word	0x00009f04
    1ca0:	00009f1c 	.word	0x00009f1c
    1ca4:	00009f5c 	.word	0x00009f5c
    1ca8:	00009f7c 	.word	0x00009f7c
    1cac:	00009fa0 	.word	0x00009fa0
    1cb0:	000001ff 	.word	0x000001ff
    1cb4:	00009fc0 	.word	0x00009fc0
    1cb8:	00000206 	.word	0x00000206
    1cbc:	00009fe4 	.word	0x00009fe4
    1cc0:	0000020f 	.word	0x0000020f
    1cc4:	0000a008 	.word	0x0000a008
    1cc8:	00000215 	.word	0x00000215
    1ccc:	0000a020 	.word	0x0000a020
    1cd0:	00001625 	.word	0x00001625
    1cd4:	0000a04c 	.word	0x0000a04c
    1cd8:	0000a060 	.word	0x0000a060
    1cdc:	0000022d 	.word	0x0000022d
    1ce0:	0000a07c 	.word	0x0000a07c
    1ce4:	0000024a 	.word	0x0000024a
    1ce8:	0000a19c 	.word	0x0000a19c
    1cec:	0000a0a0 	.word	0x0000a0a0
*/

sint8 hif_handle_isr(void)
{
	sint8 ret = M2M_SUCCESS;	
	while (gstrHifCxt.u8Interrupt) {
    1cf0:	4643      	mov	r3, r8
    1cf2:	78db      	ldrb	r3, [r3, #3]
    1cf4:	2b00      	cmp	r3, #0
    1cf6:	d000      	beq.n	1cfa <hif_handle_isr+0x3d2>
    1cf8:	e620      	b.n	193c <hif_handle_isr+0x14>
			}
		}
	}

	return ret;
}
    1cfa:	2000      	movs	r0, #0
    1cfc:	b007      	add	sp, #28
    1cfe:	bc0c      	pop	{r2, r3}
    1d00:	4690      	mov	r8, r2
    1d02:	4699      	mov	r9, r3
    1d04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1d06:	46c0      	nop			; (mov r8, r8)

00001d08 <hif_receive>:
*	@param [in]	isDone
*				If you don't need any more packets send True otherwise send false
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/
sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
{
    1d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1d0a:	0014      	movs	r4, r2
    1d0c:	001d      	movs	r5, r3
	sint8 ret = M2M_SUCCESS;
	if((u32Addr == 0)||(pu8Buf == NULL) || (u16Sz == 0))
    1d0e:	2800      	cmp	r0, #0
    1d10:	d003      	beq.n	1d1a <hif_receive+0x12>
    1d12:	2900      	cmp	r1, #0
    1d14:	d001      	beq.n	1d1a <hif_receive+0x12>
    1d16:	2a00      	cmp	r2, #0
    1d18:	d112      	bne.n	1d40 <hif_receive+0x38>
	{
		if(isDone)
    1d1a:	2d00      	cmp	r5, #0
    1d1c:	d002      	beq.n	1d24 <hif_receive+0x1c>
		{			
			/* set RX done */
			ret = hif_set_rx_done();
    1d1e:	4b27      	ldr	r3, [pc, #156]	; (1dbc <hif_receive+0xb4>)
    1d20:	4798      	blx	r3
    1d22:	e049      	b.n	1db8 <hif_receive+0xb0>
		}
		else
		{
			ret = M2M_ERR_FAIL;
			M2M_ERR(" hif_receive: Invalid argument\n");
    1d24:	4a26      	ldr	r2, [pc, #152]	; (1dc0 <hif_receive+0xb8>)
    1d26:	4927      	ldr	r1, [pc, #156]	; (1dc4 <hif_receive+0xbc>)
    1d28:	4827      	ldr	r0, [pc, #156]	; (1dc8 <hif_receive+0xc0>)
    1d2a:	4b28      	ldr	r3, [pc, #160]	; (1dcc <hif_receive+0xc4>)
    1d2c:	4798      	blx	r3
    1d2e:	4828      	ldr	r0, [pc, #160]	; (1dd0 <hif_receive+0xc8>)
    1d30:	4b28      	ldr	r3, [pc, #160]	; (1dd4 <hif_receive+0xcc>)
    1d32:	4798      	blx	r3
    1d34:	200d      	movs	r0, #13
    1d36:	4b28      	ldr	r3, [pc, #160]	; (1dd8 <hif_receive+0xd0>)
    1d38:	4798      	blx	r3
			/* set RX done */
			ret = hif_set_rx_done();
		}
		else
		{
			ret = M2M_ERR_FAIL;
    1d3a:	200c      	movs	r0, #12
    1d3c:	4240      	negs	r0, r0
    1d3e:	e03b      	b.n	1db8 <hif_receive+0xb0>
			M2M_ERR(" hif_receive: Invalid argument\n");
		}
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
    1d40:	4b26      	ldr	r3, [pc, #152]	; (1ddc <hif_receive+0xd4>)
    1d42:	689b      	ldr	r3, [r3, #8]
    1d44:	429a      	cmp	r2, r3
    1d46:	d90f      	bls.n	1d68 <hif_receive+0x60>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
    1d48:	4a25      	ldr	r2, [pc, #148]	; (1de0 <hif_receive+0xd8>)
    1d4a:	491e      	ldr	r1, [pc, #120]	; (1dc4 <hif_receive+0xbc>)
    1d4c:	481e      	ldr	r0, [pc, #120]	; (1dc8 <hif_receive+0xc0>)
    1d4e:	4d1f      	ldr	r5, [pc, #124]	; (1dcc <hif_receive+0xc4>)
    1d50:	47a8      	blx	r5
    1d52:	4b22      	ldr	r3, [pc, #136]	; (1ddc <hif_receive+0xd4>)
    1d54:	689a      	ldr	r2, [r3, #8]
    1d56:	0021      	movs	r1, r4
    1d58:	4822      	ldr	r0, [pc, #136]	; (1de4 <hif_receive+0xdc>)
    1d5a:	47a8      	blx	r5
    1d5c:	200d      	movs	r0, #13
    1d5e:	4b1e      	ldr	r3, [pc, #120]	; (1dd8 <hif_receive+0xd0>)
    1d60:	4798      	blx	r3
		goto ERR1;
	}

	if(u16Sz > gstrHifCxt.u32RxSize)
	{
		ret = M2M_ERR_FAIL;
    1d62:	200c      	movs	r0, #12
    1d64:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
    1d66:	e027      	b.n	1db8 <hif_receive+0xb0>
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
    1d68:	4b1c      	ldr	r3, [pc, #112]	; (1ddc <hif_receive+0xd4>)
    1d6a:	685b      	ldr	r3, [r3, #4]
    1d6c:	4298      	cmp	r0, r3
    1d6e:	d306      	bcc.n	1d7e <hif_receive+0x76>
    1d70:	1886      	adds	r6, r0, r2
    1d72:	4a1a      	ldr	r2, [pc, #104]	; (1ddc <hif_receive+0xd4>)
    1d74:	6857      	ldr	r7, [r2, #4]
    1d76:	6893      	ldr	r3, [r2, #8]
    1d78:	18fb      	adds	r3, r7, r3
    1d7a:	429e      	cmp	r6, r3
    1d7c:	d90d      	bls.n	1d9a <hif_receive+0x92>
	{
		ret = M2M_ERR_FAIL;
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
    1d7e:	4a1a      	ldr	r2, [pc, #104]	; (1de8 <hif_receive+0xe0>)
    1d80:	4910      	ldr	r1, [pc, #64]	; (1dc4 <hif_receive+0xbc>)
    1d82:	4811      	ldr	r0, [pc, #68]	; (1dc8 <hif_receive+0xc0>)
    1d84:	4b11      	ldr	r3, [pc, #68]	; (1dcc <hif_receive+0xc4>)
    1d86:	4798      	blx	r3
    1d88:	4818      	ldr	r0, [pc, #96]	; (1dec <hif_receive+0xe4>)
    1d8a:	4b12      	ldr	r3, [pc, #72]	; (1dd4 <hif_receive+0xcc>)
    1d8c:	4798      	blx	r3
    1d8e:	200d      	movs	r0, #13
    1d90:	4b11      	ldr	r3, [pc, #68]	; (1dd8 <hif_receive+0xd0>)
    1d92:	4798      	blx	r3
		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
		goto ERR1;
	}
	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
	{
		ret = M2M_ERR_FAIL;
    1d94:	200c      	movs	r0, #12
    1d96:	4240      	negs	r0, r0
		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
		goto ERR1;
    1d98:	e00e      	b.n	1db8 <hif_receive+0xb0>
	}
	
	/* Receive the payload */
	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
    1d9a:	0022      	movs	r2, r4
    1d9c:	4b14      	ldr	r3, [pc, #80]	; (1df0 <hif_receive+0xe8>)
    1d9e:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    1da0:	2800      	cmp	r0, #0
    1da2:	d109      	bne.n	1db8 <hif_receive+0xb0>

	/* check if this is the last packet */
	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
    1da4:	4a0d      	ldr	r2, [pc, #52]	; (1ddc <hif_receive+0xd4>)
    1da6:	6851      	ldr	r1, [r2, #4]
    1da8:	6893      	ldr	r3, [r2, #8]
    1daa:	18cb      	adds	r3, r1, r3
    1dac:	429e      	cmp	r6, r3
    1dae:	d001      	beq.n	1db4 <hif_receive+0xac>
    1db0:	2d00      	cmp	r5, #0
    1db2:	d001      	beq.n	1db8 <hif_receive+0xb0>
	{
		/* set RX done */
		ret = hif_set_rx_done();
    1db4:	4b01      	ldr	r3, [pc, #4]	; (1dbc <hif_receive+0xb4>)
    1db6:	4798      	blx	r3
	}

ERR1:
	return ret;
}
    1db8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1dba:	46c0      	nop			; (mov r8, r8)
    1dbc:	00001625 	.word	0x00001625
    1dc0:	0000026b 	.word	0x0000026b
    1dc4:	00009e8c 	.word	0x00009e8c
    1dc8:	00009e44 	.word	0x00009e44
    1dcc:	00008845 	.word	0x00008845
    1dd0:	0000a0d0 	.word	0x0000a0d0
    1dd4:	00008965 	.word	0x00008965
    1dd8:	00008879 	.word	0x00008879
    1ddc:	20000234 	.word	0x20000234
    1de0:	00000273 	.word	0x00000273
    1de4:	0000a0f0 	.word	0x0000a0f0
    1de8:	00000279 	.word	0x00000279
    1dec:	0000a138 	.word	0x0000a138
    1df0:	00002a19 	.word	0x00002a19

00001df4 <hif_register_cb>:
*				function to be set
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
    1df4:	b570      	push	{r4, r5, r6, lr}
    1df6:	1e04      	subs	r4, r0, #0
	sint8 ret = M2M_SUCCESS;
	switch(u8Grp)
    1df8:	2c07      	cmp	r4, #7
    1dfa:	d81f      	bhi.n	1e3c <hif_register_cb+0x48>
    1dfc:	0083      	lsls	r3, r0, #2
    1dfe:	4a16      	ldr	r2, [pc, #88]	; (1e58 <hif_register_cb+0x64>)
    1e00:	58d3      	ldr	r3, [r2, r3]
    1e02:	469f      	mov	pc, r3
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
    1e04:	4b15      	ldr	r3, [pc, #84]	; (1e5c <hif_register_cb+0x68>)
    1e06:	6119      	str	r1, [r3, #16]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e08:	2000      	movs	r0, #0
	switch(u8Grp)
	{
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
    1e0a:	e024      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
    1e0c:	4b13      	ldr	r3, [pc, #76]	; (1e5c <hif_register_cb+0x68>)
    1e0e:	60d9      	str	r1, [r3, #12]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e10:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_IP:
			gstrHifCxt.pfIpCb = fn;
			break;
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
    1e12:	e020      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
    1e14:	4b11      	ldr	r3, [pc, #68]	; (1e5c <hif_register_cb+0x68>)
    1e16:	6159      	str	r1, [r3, #20]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e18:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_WIFI:
			gstrHifCxt.pfWifiCb = fn;
			break;
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
    1e1a:	e01c      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
    1e1c:	4b0f      	ldr	r3, [pc, #60]	; (1e5c <hif_register_cb+0x68>)
    1e1e:	61d9      	str	r1, [r3, #28]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e20:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_OTA:
			gstrHifCxt.pfOtaCb = fn;
			break;
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
    1e22:	e018      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
    1e24:	4b0d      	ldr	r3, [pc, #52]	; (1e5c <hif_register_cb+0x68>)
    1e26:	6219      	str	r1, [r3, #32]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e28:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_HIF:
			gstrHifCxt.pfHifCb = fn;
			break;
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
    1e2a:	e014      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
    1e2c:	4b0b      	ldr	r3, [pc, #44]	; (1e5c <hif_register_cb+0x68>)
    1e2e:	6199      	str	r1, [r3, #24]
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e30:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_CRYPTO:
			gstrHifCxt.pfCryptoCb = fn;
			break;
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
    1e32:	e010      	b.n	1e56 <hif_register_cb+0x62>
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
    1e34:	4b09      	ldr	r3, [pc, #36]	; (1e5c <hif_register_cb+0x68>)
    1e36:	6259      	str	r1, [r3, #36]	; 0x24
*    @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
{
	sint8 ret = M2M_SUCCESS;
    1e38:	2000      	movs	r0, #0
		case M2M_REQ_GROUP_SIGMA:
			gstrHifCxt.pfSigmaCb = fn;
			break;
		case M2M_REQ_GROUP_SSL:
			gstrHifCxt.pfSslCb = fn;
			break;
    1e3a:	e00c      	b.n	1e56 <hif_register_cb+0x62>
		default:
			M2M_ERR("GRp ? %d\n",u8Grp);
    1e3c:	4a08      	ldr	r2, [pc, #32]	; (1e60 <hif_register_cb+0x6c>)
    1e3e:	4909      	ldr	r1, [pc, #36]	; (1e64 <hif_register_cb+0x70>)
    1e40:	4809      	ldr	r0, [pc, #36]	; (1e68 <hif_register_cb+0x74>)
    1e42:	4d0a      	ldr	r5, [pc, #40]	; (1e6c <hif_register_cb+0x78>)
    1e44:	47a8      	blx	r5
    1e46:	0021      	movs	r1, r4
    1e48:	4809      	ldr	r0, [pc, #36]	; (1e70 <hif_register_cb+0x7c>)
    1e4a:	47a8      	blx	r5
    1e4c:	200d      	movs	r0, #13
    1e4e:	4b09      	ldr	r3, [pc, #36]	; (1e74 <hif_register_cb+0x80>)
    1e50:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    1e52:	200c      	movs	r0, #12
    1e54:	4240      	negs	r0, r0
			break;
	}
	return ret;
}
    1e56:	bd70      	pop	{r4, r5, r6, pc}
    1e58:	00009e6c 	.word	0x00009e6c
    1e5c:	20000234 	.word	0x20000234
    1e60:	000002b1 	.word	0x000002b1
    1e64:	00009e98 	.word	0x00009e98
    1e68:	00009e44 	.word	0x00009e44
    1e6c:	00008845 	.word	0x00008845
    1e70:	0000a17c 	.word	0x0000a17c
    1e74:	00008879 	.word	0x00008879

00001e78 <hif_init>:
*				Pointer to the arguments.
*   @return		The function shall return ZERO for successful operation and a negative value otherwise.
*/

sint8 hif_init(void * arg)
{
    1e78:	b510      	push	{r4, lr}
	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
    1e7a:	2228      	movs	r2, #40	; 0x28
    1e7c:	2100      	movs	r1, #0
    1e7e:	4806      	ldr	r0, [pc, #24]	; (1e98 <hif_init+0x20>)
    1e80:	4b06      	ldr	r3, [pc, #24]	; (1e9c <hif_init+0x24>)
    1e82:	4798      	blx	r3
	nm_bsp_register_isr(isr);
    1e84:	4806      	ldr	r0, [pc, #24]	; (1ea0 <hif_init+0x28>)
    1e86:	4b07      	ldr	r3, [pc, #28]	; (1ea4 <hif_init+0x2c>)
    1e88:	4798      	blx	r3
	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
    1e8a:	4907      	ldr	r1, [pc, #28]	; (1ea8 <hif_init+0x30>)
    1e8c:	2003      	movs	r0, #3
    1e8e:	4b07      	ldr	r3, [pc, #28]	; (1eac <hif_init+0x34>)
    1e90:	4798      	blx	r3
	return M2M_SUCCESS;
}
    1e92:	2000      	movs	r0, #0
    1e94:	bd10      	pop	{r4, pc}
    1e96:	46c0      	nop			; (mov r8, r8)
    1e98:	20000234 	.word	0x20000234
    1e9c:	000015e5 	.word	0x000015e5
    1ea0:	00001611 	.word	0x00001611
    1ea4:	00001299 	.word	0x00001299
    1ea8:	00001621 	.word	0x00001621
    1eac:	00001df5 	.word	0x00001df5

00001eb0 <m2m_wifi_cb>:
*	@author
*	@date
*	@version	1.0
*/
static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
{
    1eb0:	b530      	push	{r4, r5, lr}
    1eb2:	b09f      	sub	sp, #124	; 0x7c
    1eb4:	0004      	movs	r4, r0
    1eb6:	0015      	movs	r5, r2
	uint8 rx_buf[8];
	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
    1eb8:	282c      	cmp	r0, #44	; 0x2c
    1eba:	d111      	bne.n	1ee0 <m2m_wifi_cb+0x30>
	{
		tstrM2mWifiStateChanged strState;
		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
    1ebc:	2300      	movs	r3, #0
    1ebe:	2204      	movs	r2, #4
    1ec0:	a903      	add	r1, sp, #12
    1ec2:	0028      	movs	r0, r5
    1ec4:	4c94      	ldr	r4, [pc, #592]	; (2118 <STACK_SIZE+0x118>)
    1ec6:	47a0      	blx	r4
    1ec8:	2800      	cmp	r0, #0
    1eca:	d000      	beq.n	1ece <m2m_wifi_cb+0x1e>
    1ecc:	e122      	b.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    1ece:	4b93      	ldr	r3, [pc, #588]	; (211c <STACK_SIZE+0x11c>)
    1ed0:	681b      	ldr	r3, [r3, #0]
    1ed2:	2b00      	cmp	r3, #0
    1ed4:	d100      	bne.n	1ed8 <m2m_wifi_cb+0x28>
    1ed6:	e11d      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
    1ed8:	a903      	add	r1, sp, #12
    1eda:	302c      	adds	r0, #44	; 0x2c
    1edc:	4798      	blx	r3
    1ede:	e119      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
    1ee0:	281b      	cmp	r0, #27
    1ee2:	d111      	bne.n	1f08 <m2m_wifi_cb+0x58>
	{
		tstrSystemTime strSysTime;
		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
    1ee4:	2300      	movs	r3, #0
    1ee6:	2208      	movs	r2, #8
    1ee8:	a903      	add	r1, sp, #12
    1eea:	0028      	movs	r0, r5
    1eec:	4c8a      	ldr	r4, [pc, #552]	; (2118 <STACK_SIZE+0x118>)
    1eee:	47a0      	blx	r4
    1ef0:	2800      	cmp	r0, #0
    1ef2:	d000      	beq.n	1ef6 <m2m_wifi_cb+0x46>
    1ef4:	e10e      	b.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    1ef6:	4b89      	ldr	r3, [pc, #548]	; (211c <STACK_SIZE+0x11c>)
    1ef8:	681b      	ldr	r3, [r3, #0]
    1efa:	2b00      	cmp	r3, #0
    1efc:	d100      	bne.n	1f00 <m2m_wifi_cb+0x50>
    1efe:	e109      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
    1f00:	a903      	add	r1, sp, #12
    1f02:	301b      	adds	r0, #27
    1f04:	4798      	blx	r3
    1f06:	e105      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
    1f08:	2806      	cmp	r0, #6
    1f0a:	d111      	bne.n	1f30 <m2m_wifi_cb+0x80>
	{
		tstrM2MConnInfo		strConnInfo;
		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
    1f0c:	2301      	movs	r3, #1
    1f0e:	2230      	movs	r2, #48	; 0x30
    1f10:	a903      	add	r1, sp, #12
    1f12:	0028      	movs	r0, r5
    1f14:	4c80      	ldr	r4, [pc, #512]	; (2118 <STACK_SIZE+0x118>)
    1f16:	47a0      	blx	r4
    1f18:	2800      	cmp	r0, #0
    1f1a:	d000      	beq.n	1f1e <m2m_wifi_cb+0x6e>
    1f1c:	e0fa      	b.n	2114 <STACK_SIZE+0x114>
		{
			if(gpfAppWifiCb)
    1f1e:	4b7f      	ldr	r3, [pc, #508]	; (211c <STACK_SIZE+0x11c>)
    1f20:	681b      	ldr	r3, [r3, #0]
    1f22:	2b00      	cmp	r3, #0
    1f24:	d100      	bne.n	1f28 <m2m_wifi_cb+0x78>
    1f26:	e0f5      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
    1f28:	a903      	add	r1, sp, #12
    1f2a:	3006      	adds	r0, #6
    1f2c:	4798      	blx	r3
    1f2e:	e0f1      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
    1f30:	280e      	cmp	r0, #14
    1f32:	d100      	bne.n	1f36 <m2m_wifi_cb+0x86>
    1f34:	e0ee      	b.n	2114 <STACK_SIZE+0x114>
			if (app_wifi_recover_cb)
				app_wifi_recover_cb(strState.u8CurrState);
		}
#endif
	}
	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
    1f36:	2832      	cmp	r0, #50	; 0x32
    1f38:	d111      	bne.n	1f5e <m2m_wifi_cb+0xae>
	{
		tstrM2MIPConfig strIpConfig;
		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
    1f3a:	2300      	movs	r3, #0
    1f3c:	2214      	movs	r2, #20
    1f3e:	a903      	add	r1, sp, #12
    1f40:	0028      	movs	r0, r5
    1f42:	4c75      	ldr	r4, [pc, #468]	; (2118 <STACK_SIZE+0x118>)
    1f44:	47a0      	blx	r4
    1f46:	2800      	cmp	r0, #0
    1f48:	d000      	beq.n	1f4c <m2m_wifi_cb+0x9c>
    1f4a:	e0e3      	b.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    1f4c:	4b73      	ldr	r3, [pc, #460]	; (211c <STACK_SIZE+0x11c>)
    1f4e:	681b      	ldr	r3, [r3, #0]
    1f50:	2b00      	cmp	r3, #0
    1f52:	d100      	bne.n	1f56 <m2m_wifi_cb+0xa6>
    1f54:	e0de      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
    1f56:	a903      	add	r1, sp, #12
    1f58:	3032      	adds	r0, #50	; 0x32
    1f5a:	4798      	blx	r3
    1f5c:	e0da      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_REQ_WPS)
    1f5e:	282f      	cmp	r0, #47	; 0x2f
    1f60:	d116      	bne.n	1f90 <m2m_wifi_cb+0xe0>
	{
		tstrM2MWPSInfo strWps;
		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
    1f62:	2264      	movs	r2, #100	; 0x64
    1f64:	2100      	movs	r1, #0
    1f66:	a803      	add	r0, sp, #12
    1f68:	4b6d      	ldr	r3, [pc, #436]	; (2120 <STACK_SIZE+0x120>)
    1f6a:	4798      	blx	r3
		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
    1f6c:	2300      	movs	r3, #0
    1f6e:	2264      	movs	r2, #100	; 0x64
    1f70:	a903      	add	r1, sp, #12
    1f72:	0028      	movs	r0, r5
    1f74:	4c68      	ldr	r4, [pc, #416]	; (2118 <STACK_SIZE+0x118>)
    1f76:	47a0      	blx	r4
    1f78:	2800      	cmp	r0, #0
    1f7a:	d000      	beq.n	1f7e <m2m_wifi_cb+0xce>
    1f7c:	e0ca      	b.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    1f7e:	4b67      	ldr	r3, [pc, #412]	; (211c <STACK_SIZE+0x11c>)
    1f80:	681b      	ldr	r3, [r3, #0]
    1f82:	2b00      	cmp	r3, #0
    1f84:	d100      	bne.n	1f88 <m2m_wifi_cb+0xd8>
    1f86:	e0c5      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
    1f88:	a903      	add	r1, sp, #12
    1f8a:	302f      	adds	r0, #47	; 0x2f
    1f8c:	4798      	blx	r3
    1f8e:	e0c1      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
    1f90:	2834      	cmp	r0, #52	; 0x34
    1f92:	d122      	bne.n	1fda <m2m_wifi_cb+0x12a>
	{
		uint32  u32ConflictedIP;
		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
    1f94:	2300      	movs	r3, #0
    1f96:	2204      	movs	r2, #4
    1f98:	a903      	add	r1, sp, #12
    1f9a:	0028      	movs	r0, r5
    1f9c:	4c5e      	ldr	r4, [pc, #376]	; (2118 <STACK_SIZE+0x118>)
    1f9e:	47a0      	blx	r4
    1fa0:	2800      	cmp	r0, #0
    1fa2:	d000      	beq.n	1fa6 <m2m_wifi_cb+0xf6>
    1fa4:	e0b6      	b.n	2114 <STACK_SIZE+0x114>
		{
			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
    1fa6:	485f      	ldr	r0, [pc, #380]	; (2124 <STACK_SIZE+0x124>)
    1fa8:	4c5f      	ldr	r4, [pc, #380]	; (2128 <STACK_SIZE+0x128>)
    1faa:	47a0      	blx	r4
    1fac:	9803      	ldr	r0, [sp, #12]
    1fae:	0c03      	lsrs	r3, r0, #16
    1fb0:	21ff      	movs	r1, #255	; 0xff
    1fb2:	400b      	ands	r3, r1
    1fb4:	0a02      	lsrs	r2, r0, #8
    1fb6:	400a      	ands	r2, r1
    1fb8:	4001      	ands	r1, r0
    1fba:	0e00      	lsrs	r0, r0, #24
    1fbc:	9000      	str	r0, [sp, #0]
    1fbe:	485b      	ldr	r0, [pc, #364]	; (212c <STACK_SIZE+0x12c>)
    1fc0:	47a0      	blx	r4
    1fc2:	200d      	movs	r0, #13
    1fc4:	4b5a      	ldr	r3, [pc, #360]	; (2130 <STACK_SIZE+0x130>)
    1fc6:	4798      	blx	r3
				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
			if (gpfAppWifiCb)
    1fc8:	4b54      	ldr	r3, [pc, #336]	; (211c <STACK_SIZE+0x11c>)
    1fca:	681b      	ldr	r3, [r3, #0]
    1fcc:	2b00      	cmp	r3, #0
    1fce:	d100      	bne.n	1fd2 <m2m_wifi_cb+0x122>
    1fd0:	e0a0      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
    1fd2:	2100      	movs	r1, #0
    1fd4:	2034      	movs	r0, #52	; 0x34
    1fd6:	4798      	blx	r3
    1fd8:	e09c      	b.n	2114 <STACK_SIZE+0x114>

		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_DONE)
    1fda:	2811      	cmp	r0, #17
    1fdc:	d118      	bne.n	2010 <STACK_SIZE+0x10>
	{
		tstrM2mScanDone strState;
		gu8scanInProgress = 0;
    1fde:	2200      	movs	r2, #0
    1fe0:	4b54      	ldr	r3, [pc, #336]	; (2134 <STACK_SIZE+0x134>)
    1fe2:	701a      	strb	r2, [r3, #0]
		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
    1fe4:	2300      	movs	r3, #0
    1fe6:	3204      	adds	r2, #4
    1fe8:	a903      	add	r1, sp, #12
    1fea:	0028      	movs	r0, r5
    1fec:	4c4a      	ldr	r4, [pc, #296]	; (2118 <STACK_SIZE+0x118>)
    1fee:	47a0      	blx	r4
    1ff0:	2800      	cmp	r0, #0
    1ff2:	d000      	beq.n	1ff6 <m2m_wifi_cb+0x146>
    1ff4:	e08e      	b.n	2114 <STACK_SIZE+0x114>
		{
			gu8ChNum = strState.u8NumofCh;
    1ff6:	ab03      	add	r3, sp, #12
    1ff8:	781a      	ldrb	r2, [r3, #0]
    1ffa:	4b4f      	ldr	r3, [pc, #316]	; (2138 <STACK_SIZE+0x138>)
    1ffc:	701a      	strb	r2, [r3, #0]
			if (gpfAppWifiCb)
    1ffe:	4b47      	ldr	r3, [pc, #284]	; (211c <STACK_SIZE+0x11c>)
    2000:	681b      	ldr	r3, [r3, #0]
    2002:	2b00      	cmp	r3, #0
    2004:	d100      	bne.n	2008 <STACK_SIZE+0x8>
    2006:	e085      	b.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
    2008:	a903      	add	r1, sp, #12
    200a:	3011      	adds	r0, #17
    200c:	4798      	blx	r3
    200e:	e081      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
    2010:	2813      	cmp	r0, #19
    2012:	d10f      	bne.n	2034 <STACK_SIZE+0x34>
	{
		tstrM2mWifiscanResult strScanResult;
		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
    2014:	2300      	movs	r3, #0
    2016:	222c      	movs	r2, #44	; 0x2c
    2018:	a903      	add	r1, sp, #12
    201a:	0028      	movs	r0, r5
    201c:	4c3e      	ldr	r4, [pc, #248]	; (2118 <STACK_SIZE+0x118>)
    201e:	47a0      	blx	r4
    2020:	2800      	cmp	r0, #0
    2022:	d177      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    2024:	4b3d      	ldr	r3, [pc, #244]	; (211c <STACK_SIZE+0x11c>)
    2026:	681b      	ldr	r3, [r3, #0]
    2028:	2b00      	cmp	r3, #0
    202a:	d073      	beq.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
    202c:	a903      	add	r1, sp, #12
    202e:	3013      	adds	r0, #19
    2030:	4798      	blx	r3
    2032:	e06f      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
    2034:	2804      	cmp	r0, #4
    2036:	d10f      	bne.n	2058 <STACK_SIZE+0x58>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    2038:	2300      	movs	r3, #0
    203a:	2204      	movs	r2, #4
    203c:	a91c      	add	r1, sp, #112	; 0x70
    203e:	0028      	movs	r0, r5
    2040:	4c35      	ldr	r4, [pc, #212]	; (2118 <STACK_SIZE+0x118>)
    2042:	47a0      	blx	r4
    2044:	2800      	cmp	r0, #0
    2046:	d165      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    2048:	4b34      	ldr	r3, [pc, #208]	; (211c <STACK_SIZE+0x11c>)
    204a:	681b      	ldr	r3, [r3, #0]
    204c:	2b00      	cmp	r3, #0
    204e:	d061      	beq.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
    2050:	a91c      	add	r1, sp, #112	; 0x70
    2052:	3004      	adds	r0, #4
    2054:	4798      	blx	r3
    2056:	e05d      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
    2058:	2865      	cmp	r0, #101	; 0x65
    205a:	d10f      	bne.n	207c <STACK_SIZE+0x7c>
	{
		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
    205c:	2300      	movs	r3, #0
    205e:	2204      	movs	r2, #4
    2060:	a91c      	add	r1, sp, #112	; 0x70
    2062:	0028      	movs	r0, r5
    2064:	4c2c      	ldr	r4, [pc, #176]	; (2118 <STACK_SIZE+0x118>)
    2066:	47a0      	blx	r4
    2068:	2800      	cmp	r0, #0
    206a:	d153      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if (gpfAppWifiCb)
    206c:	4b2b      	ldr	r3, [pc, #172]	; (211c <STACK_SIZE+0x11c>)
    206e:	681b      	ldr	r3, [r3, #0]
    2070:	2b00      	cmp	r3, #0
    2072:	d04f      	beq.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
    2074:	a91c      	add	r1, sp, #112	; 0x70
    2076:	3065      	adds	r0, #101	; 0x65
    2078:	4798      	blx	r3
    207a:	e04b      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
    207c:	2809      	cmp	r0, #9
    207e:	d10f      	bne.n	20a0 <STACK_SIZE+0xa0>
	{
		tstrM2MProvisionInfo	strProvInfo;
		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
    2080:	2301      	movs	r3, #1
    2082:	2264      	movs	r2, #100	; 0x64
    2084:	a903      	add	r1, sp, #12
    2086:	0028      	movs	r0, r5
    2088:	4c23      	ldr	r4, [pc, #140]	; (2118 <STACK_SIZE+0x118>)
    208a:	47a0      	blx	r4
    208c:	2800      	cmp	r0, #0
    208e:	d141      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if(gpfAppWifiCb)
    2090:	4b22      	ldr	r3, [pc, #136]	; (211c <STACK_SIZE+0x11c>)
    2092:	681b      	ldr	r3, [r3, #0]
    2094:	2b00      	cmp	r3, #0
    2096:	d03d      	beq.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
    2098:	a903      	add	r1, sp, #12
    209a:	3009      	adds	r0, #9
    209c:	4798      	blx	r3
    209e:	e039      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
    20a0:	282a      	cmp	r0, #42	; 0x2a
    20a2:	d10f      	bne.n	20c4 <STACK_SIZE+0xc4>
	{
		tstrM2MDefaultConnResp	strResp;
		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
    20a4:	2301      	movs	r3, #1
    20a6:	2204      	movs	r2, #4
    20a8:	a903      	add	r1, sp, #12
    20aa:	0028      	movs	r0, r5
    20ac:	4c1a      	ldr	r4, [pc, #104]	; (2118 <STACK_SIZE+0x118>)
    20ae:	47a0      	blx	r4
    20b0:	2800      	cmp	r0, #0
    20b2:	d12f      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if(gpfAppWifiCb)
    20b4:	4b19      	ldr	r3, [pc, #100]	; (211c <STACK_SIZE+0x11c>)
    20b6:	681b      	ldr	r3, [r3, #0]
    20b8:	2b00      	cmp	r3, #0
    20ba:	d02b      	beq.n	2114 <STACK_SIZE+0x114>
				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
    20bc:	a903      	add	r1, sp, #12
    20be:	302a      	adds	r0, #42	; 0x2a
    20c0:	4798      	blx	r3
    20c2:	e027      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
	
	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
    20c4:	2820      	cmp	r0, #32
    20c6:	d119      	bne.n	20fc <STACK_SIZE+0xfc>
	{
		tstrPrng strPrng;
		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
    20c8:	2300      	movs	r3, #0
    20ca:	2208      	movs	r2, #8
    20cc:	a903      	add	r1, sp, #12
    20ce:	0028      	movs	r0, r5
    20d0:	4c11      	ldr	r4, [pc, #68]	; (2118 <STACK_SIZE+0x118>)
    20d2:	47a0      	blx	r4
    20d4:	2800      	cmp	r0, #0
    20d6:	d11d      	bne.n	2114 <STACK_SIZE+0x114>
		{
			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
    20d8:	ab03      	add	r3, sp, #12
    20da:	889a      	ldrh	r2, [r3, #4]
    20dc:	0028      	movs	r0, r5
    20de:	3008      	adds	r0, #8
    20e0:	2301      	movs	r3, #1
    20e2:	9903      	ldr	r1, [sp, #12]
    20e4:	4c0c      	ldr	r4, [pc, #48]	; (2118 <STACK_SIZE+0x118>)
    20e6:	47a0      	blx	r4
    20e8:	2800      	cmp	r0, #0
    20ea:	d113      	bne.n	2114 <STACK_SIZE+0x114>
			{
				if(gpfAppWifiCb)
    20ec:	4b0b      	ldr	r3, [pc, #44]	; (211c <STACK_SIZE+0x11c>)
    20ee:	681b      	ldr	r3, [r3, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d00f      	beq.n	2114 <STACK_SIZE+0x114>
					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
    20f4:	a903      	add	r1, sp, #12
    20f6:	3020      	adds	r0, #32
    20f8:	4798      	blx	r3
    20fa:	e00b      	b.n	2114 <STACK_SIZE+0x114>
		}
	}
#endif
	else
	{
		M2M_ERR("REQ Not defined %d\n",u8OpCode);
    20fc:	2292      	movs	r2, #146	; 0x92
    20fe:	0052      	lsls	r2, r2, #1
    2100:	490e      	ldr	r1, [pc, #56]	; (213c <STACK_SIZE+0x13c>)
    2102:	480f      	ldr	r0, [pc, #60]	; (2140 <STACK_SIZE+0x140>)
    2104:	4d08      	ldr	r5, [pc, #32]	; (2128 <STACK_SIZE+0x128>)
    2106:	47a8      	blx	r5
    2108:	0021      	movs	r1, r4
    210a:	480e      	ldr	r0, [pc, #56]	; (2144 <STACK_SIZE+0x144>)
    210c:	47a8      	blx	r5
    210e:	200d      	movs	r0, #13
    2110:	4b07      	ldr	r3, [pc, #28]	; (2130 <STACK_SIZE+0x130>)
    2112:	4798      	blx	r3
	}
}
    2114:	b01f      	add	sp, #124	; 0x7c
    2116:	bd30      	pop	{r4, r5, pc}
    2118:	00001d09 	.word	0x00001d09
    211c:	20000114 	.word	0x20000114
    2120:	000015e5 	.word	0x000015e5
    2124:	00009ea8 	.word	0x00009ea8
    2128:	00008845 	.word	0x00008845
    212c:	0000a1dc 	.word	0x0000a1dc
    2130:	00008879 	.word	0x00008879
    2134:	20000118 	.word	0x20000118
    2138:	20000119 	.word	0x20000119
    213c:	0000a1bc 	.word	0x0000a1bc
    2140:	00009e44 	.word	0x00009e44
    2144:	0000a1fc 	.word	0x0000a1fc

00002148 <m2m_wifi_init>:
	s8Ret = hif_send(M2M_REQ_GROUP_SSL, M2M_SSL_IND_CRL|M2M_REQ_DATA_PKT, NULL, 0, (uint8*)pCRL, sizeof(tstrTlsCrlInfo), 0);
	return s8Ret;
}

sint8 m2m_wifi_init(tstrWifiInitParam * param)
{
    2148:	b5f0      	push	{r4, r5, r6, r7, lr}
    214a:	b08f      	sub	sp, #60	; 0x3c
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
    214c:	2201      	movs	r2, #1
    214e:	230f      	movs	r3, #15
    2150:	446b      	add	r3, sp
    2152:	701a      	strb	r2, [r3, #0]
	
	if(param == NULL) {
    2154:	2800      	cmp	r0, #0
    2156:	d05e      	beq.n	2216 <m2m_wifi_init+0xce>
		ret = M2M_ERR_FAIL;
		goto _EXIT0;
	}
	
	gpfAppWifiCb = param->pfAppWifiCb;
    2158:	6802      	ldr	r2, [r0, #0]
    215a:	4b31      	ldr	r3, [pc, #196]	; (2220 <m2m_wifi_init+0xd8>)
    215c:	601a      	str	r2, [r3, #0]
#endif /* ETH_MODE */

#ifdef CONF_MGMT
	gpfAppMonCb  = param->pfAppMonCb;
#endif
	gu8scanInProgress = 0;
    215e:	2200      	movs	r2, #0
    2160:	4b30      	ldr	r3, [pc, #192]	; (2224 <m2m_wifi_init+0xdc>)
    2162:	701a      	strb	r2, [r3, #0]
	/* Apply device specific initialization. */
	ret = nm_drv_init(&u8WifiMode);
    2164:	200f      	movs	r0, #15
    2166:	4468      	add	r0, sp
    2168:	4b2f      	ldr	r3, [pc, #188]	; (2228 <m2m_wifi_init+0xe0>)
    216a:	4798      	blx	r3
    216c:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT0;
    216e:	d154      	bne.n	221a <m2m_wifi_init+0xd2>
	/* Initialize host interface module */
	ret = hif_init(NULL);
    2170:	2000      	movs	r0, #0
    2172:	4b2e      	ldr	r3, [pc, #184]	; (222c <m2m_wifi_init+0xe4>)
    2174:	4798      	blx	r3
    2176:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS) 	goto _EXIT1;
    2178:	d149      	bne.n	220e <m2m_wifi_init+0xc6>

	hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb);
    217a:	492d      	ldr	r1, [pc, #180]	; (2230 <m2m_wifi_init+0xe8>)
    217c:	2001      	movs	r0, #1
    217e:	4b2d      	ldr	r3, [pc, #180]	; (2234 <m2m_wifi_init+0xec>)
    2180:	4798      	blx	r3

	ret = nm_get_firmware_full_info(&strtmp);
    2182:	ae04      	add	r6, sp, #16
    2184:	0030      	movs	r0, r6
    2186:	4b2c      	ldr	r3, [pc, #176]	; (2238 <m2m_wifi_init+0xf0>)
    2188:	4798      	blx	r3
    218a:	0004      	movs	r4, r0

	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
    218c:	482b      	ldr	r0, [pc, #172]	; (223c <m2m_wifi_init+0xf4>)
    218e:	4d2c      	ldr	r5, [pc, #176]	; (2240 <m2m_wifi_init+0xf8>)
    2190:	47a8      	blx	r5
    2192:	79b3      	ldrb	r3, [r6, #6]
    2194:	7972      	ldrb	r2, [r6, #5]
    2196:	7931      	ldrb	r1, [r6, #4]
    2198:	8c30      	ldrh	r0, [r6, #32]
    219a:	9000      	str	r0, [sp, #0]
    219c:	4829      	ldr	r0, [pc, #164]	; (2244 <m2m_wifi_init+0xfc>)
    219e:	47a8      	blx	r5
    21a0:	200d      	movs	r0, #13
    21a2:	4f29      	ldr	r7, [pc, #164]	; (2248 <m2m_wifi_init+0x100>)
    21a4:	47b8      	blx	r7
	M2M_INFO("Firmware Build %s Time %s\n",strtmp.BuildDate,strtmp.BuildTime);
    21a6:	4825      	ldr	r0, [pc, #148]	; (223c <m2m_wifi_init+0xf4>)
    21a8:	47a8      	blx	r5
    21aa:	2226      	movs	r2, #38	; 0x26
    21ac:	446a      	add	r2, sp
    21ae:	211a      	movs	r1, #26
    21b0:	4469      	add	r1, sp
    21b2:	4826      	ldr	r0, [pc, #152]	; (224c <m2m_wifi_init+0x104>)
    21b4:	47a8      	blx	r5
    21b6:	200d      	movs	r0, #13
    21b8:	47b8      	blx	r7
	M2M_INFO("Firmware Min driver ver : %u.%u.%u\n", strtmp.u8DriverMajor, strtmp.u8DriverMinor, strtmp.u8DriverPatch);
    21ba:	4820      	ldr	r0, [pc, #128]	; (223c <m2m_wifi_init+0xf4>)
    21bc:	47a8      	blx	r5
    21be:	7a73      	ldrb	r3, [r6, #9]
    21c0:	7a32      	ldrb	r2, [r6, #8]
    21c2:	79f1      	ldrb	r1, [r6, #7]
    21c4:	4822      	ldr	r0, [pc, #136]	; (2250 <m2m_wifi_init+0x108>)
    21c6:	47a8      	blx	r5
    21c8:	200d      	movs	r0, #13
    21ca:	47b8      	blx	r7
	M2M_INFO("Driver ver: %u.%u.%u\n", M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
    21cc:	481b      	ldr	r0, [pc, #108]	; (223c <m2m_wifi_init+0xf4>)
    21ce:	47a8      	blx	r5
    21d0:	2302      	movs	r3, #2
    21d2:	2205      	movs	r2, #5
    21d4:	2113      	movs	r1, #19
    21d6:	481f      	ldr	r0, [pc, #124]	; (2254 <m2m_wifi_init+0x10c>)
    21d8:	47a8      	blx	r5
    21da:	200d      	movs	r0, #13
    21dc:	47b8      	blx	r7
	M2M_INFO("Driver built at %s\t%s\n",__DATE__,__TIME__);
    21de:	4817      	ldr	r0, [pc, #92]	; (223c <m2m_wifi_init+0xf4>)
    21e0:	47a8      	blx	r5
    21e2:	4a1d      	ldr	r2, [pc, #116]	; (2258 <m2m_wifi_init+0x110>)
    21e4:	491d      	ldr	r1, [pc, #116]	; (225c <m2m_wifi_init+0x114>)
    21e6:	481e      	ldr	r0, [pc, #120]	; (2260 <m2m_wifi_init+0x118>)
    21e8:	47a8      	blx	r5
    21ea:	200d      	movs	r0, #13
    21ec:	47b8      	blx	r7
	if(M2M_ERR_FW_VER_MISMATCH == ret)
    21ee:	0023      	movs	r3, r4
    21f0:	330d      	adds	r3, #13
    21f2:	d112      	bne.n	221a <m2m_wifi_init+0xd2>
	{
		M2M_ERR("Mismatch Firmawre Version\n");
    21f4:	22e8      	movs	r2, #232	; 0xe8
    21f6:	32ff      	adds	r2, #255	; 0xff
    21f8:	491a      	ldr	r1, [pc, #104]	; (2264 <m2m_wifi_init+0x11c>)
    21fa:	481b      	ldr	r0, [pc, #108]	; (2268 <m2m_wifi_init+0x120>)
    21fc:	4b10      	ldr	r3, [pc, #64]	; (2240 <m2m_wifi_init+0xf8>)
    21fe:	4798      	blx	r3
    2200:	481a      	ldr	r0, [pc, #104]	; (226c <m2m_wifi_init+0x124>)
    2202:	4b1b      	ldr	r3, [pc, #108]	; (2270 <m2m_wifi_init+0x128>)
    2204:	4798      	blx	r3
    2206:	200d      	movs	r0, #13
    2208:	4b0f      	ldr	r3, [pc, #60]	; (2248 <m2m_wifi_init+0x100>)
    220a:	4798      	blx	r3
    220c:	e005      	b.n	221a <m2m_wifi_init+0xd2>
	}

	goto _EXIT0;

_EXIT1:
	nm_drv_deinit(NULL);
    220e:	2000      	movs	r0, #0
    2210:	4b18      	ldr	r3, [pc, #96]	; (2274 <m2m_wifi_init+0x12c>)
    2212:	4798      	blx	r3
    2214:	e001      	b.n	221a <m2m_wifi_init+0xd2>
	tstrM2mRev strtmp;
	sint8 ret = M2M_SUCCESS;
	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
	
	if(param == NULL) {
		ret = M2M_ERR_FAIL;
    2216:	240c      	movs	r4, #12
    2218:	4264      	negs	r4, r4

_EXIT1:
	nm_drv_deinit(NULL);
_EXIT0:
	return ret;
}
    221a:	0020      	movs	r0, r4
    221c:	b00f      	add	sp, #60	; 0x3c
    221e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2220:	20000114 	.word	0x20000114
    2224:	20000118 	.word	0x20000118
    2228:	00002bcd 	.word	0x00002bcd
    222c:	00001e79 	.word	0x00001e79
    2230:	00001eb1 	.word	0x00001eb1
    2234:	00001df5 	.word	0x00001df5
    2238:	00002ae9 	.word	0x00002ae9
    223c:	00009ea8 	.word	0x00009ea8
    2240:	00008845 	.word	0x00008845
    2244:	0000a2c8 	.word	0x0000a2c8
    2248:	00008879 	.word	0x00008879
    224c:	0000a2f0 	.word	0x0000a2f0
    2250:	0000a30c 	.word	0x0000a30c
    2254:	0000a330 	.word	0x0000a330
    2258:	0000a348 	.word	0x0000a348
    225c:	0000a354 	.word	0x0000a354
    2260:	0000a360 	.word	0x0000a360
    2264:	0000a1ac 	.word	0x0000a1ac
    2268:	00009e44 	.word	0x00009e44
    226c:	0000a378 	.word	0x0000a378
    2270:	00008965 	.word	0x00008965
    2274:	00002ca1 	.word	0x00002ca1

00002278 <m2m_wifi_handle_events>:
	return M2M_SUCCESS;
}


sint8 m2m_wifi_handle_events(void * arg)
{
    2278:	b510      	push	{r4, lr}
	return hif_handle_isr();
    227a:	4b01      	ldr	r3, [pc, #4]	; (2280 <m2m_wifi_handle_events+0x8>)
    227c:	4798      	blx	r3
}
    227e:	bd10      	pop	{r4, pc}
    2280:	00001929 	.word	0x00001929

00002284 <m2m_wifi_connect_sc>:
sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
}
sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
{
    2284:	b5f0      	push	{r4, r5, r6, r7, lr}
    2286:	464f      	mov	r7, r9
    2288:	4646      	mov	r6, r8
    228a:	b4c0      	push	{r6, r7}
    228c:	b0a3      	sub	sp, #140	; 0x8c
    228e:	9005      	str	r0, [sp, #20]
    2290:	000c      	movs	r4, r1
    2292:	0015      	movs	r5, r2
    2294:	001f      	movs	r7, r3
    2296:	ab2a      	add	r3, sp, #168	; 0xa8
    2298:	881b      	ldrh	r3, [r3, #0]
    229a:	4699      	mov	r9, r3
    229c:	ab2b      	add	r3, sp, #172	; 0xac
    229e:	781b      	ldrb	r3, [r3, #0]
    22a0:	4698      	mov	r8, r3
	sint8				ret = M2M_SUCCESS;
	tstrM2mWifiConnect	strConnect;
	tstrM2MWifiSecInfo	*pstrAuthInfo;

	if(u8SecType != M2M_WIFI_SEC_OPEN)
    22a2:	2a01      	cmp	r2, #1
    22a4:	d040      	beq.n	2328 <m2m_wifi_connect_sc+0xa4>
	{
		if(pvAuthInfo == NULL)
    22a6:	2f00      	cmp	r7, #0
    22a8:	d10d      	bne.n	22c6 <m2m_wifi_connect_sc+0x42>
		{
			M2M_ERR("Key is not valid\n");
    22aa:	4a80      	ldr	r2, [pc, #512]	; (24ac <m2m_wifi_connect_sc+0x228>)
    22ac:	4980      	ldr	r1, [pc, #512]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    22ae:	4881      	ldr	r0, [pc, #516]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    22b0:	4b81      	ldr	r3, [pc, #516]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    22b2:	4798      	blx	r3
    22b4:	4881      	ldr	r0, [pc, #516]	; (24bc <m2m_wifi_connect_sc+0x238>)
    22b6:	4b82      	ldr	r3, [pc, #520]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    22b8:	4798      	blx	r3
    22ba:	200d      	movs	r0, #13
    22bc:	4b81      	ldr	r3, [pc, #516]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    22be:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    22c0:	200c      	movs	r0, #12
    22c2:	4240      	negs	r0, r0
			goto ERR1;
    22c4:	e0ec      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
    22c6:	2a02      	cmp	r2, #2
    22c8:	d12e      	bne.n	2328 <m2m_wifi_connect_sc+0xa4>
    22ca:	0038      	movs	r0, r7
    22cc:	4b7e      	ldr	r3, [pc, #504]	; (24c8 <m2m_wifi_connect_sc+0x244>)
    22ce:	4798      	blx	r3
    22d0:	2840      	cmp	r0, #64	; 0x40
    22d2:	d129      	bne.n	2328 <m2m_wifi_connect_sc+0xa4>
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
			{
				if(pu8Psk[i]<'0' || (pu8Psk[i]>'9' && pu8Psk[i] < 'A')|| (pu8Psk[i]>'F' && pu8Psk[i] < 'a') || pu8Psk[i] > 'f')
    22d4:	783b      	ldrb	r3, [r7, #0]
    22d6:	001a      	movs	r2, r3
    22d8:	3a30      	subs	r2, #48	; 0x30
    22da:	2a36      	cmp	r2, #54	; 0x36
    22dc:	d813      	bhi.n	2306 <m2m_wifi_connect_sc+0x82>
    22de:	3a0a      	subs	r2, #10
    22e0:	2a06      	cmp	r2, #6
    22e2:	d910      	bls.n	2306 <m2m_wifi_connect_sc+0x82>
    22e4:	3b47      	subs	r3, #71	; 0x47
    22e6:	2b19      	cmp	r3, #25
    22e8:	d90d      	bls.n	2306 <m2m_wifi_connect_sc+0x82>
    22ea:	1c7a      	adds	r2, r7, #1
    22ec:	0038      	movs	r0, r7
    22ee:	3040      	adds	r0, #64	; 0x40
    22f0:	7813      	ldrb	r3, [r2, #0]
    22f2:	0019      	movs	r1, r3
    22f4:	3930      	subs	r1, #48	; 0x30
    22f6:	2936      	cmp	r1, #54	; 0x36
    22f8:	d805      	bhi.n	2306 <m2m_wifi_connect_sc+0x82>
    22fa:	390a      	subs	r1, #10
    22fc:	2906      	cmp	r1, #6
    22fe:	d902      	bls.n	2306 <m2m_wifi_connect_sc+0x82>
    2300:	3b47      	subs	r3, #71	; 0x47
    2302:	2b19      	cmp	r3, #25
    2304:	d80d      	bhi.n	2322 <m2m_wifi_connect_sc+0x9e>
				{
					M2M_ERR("Invalid Key\n");
    2306:	4a71      	ldr	r2, [pc, #452]	; (24cc <m2m_wifi_connect_sc+0x248>)
    2308:	4969      	ldr	r1, [pc, #420]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    230a:	486a      	ldr	r0, [pc, #424]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    230c:	4b6a      	ldr	r3, [pc, #424]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    230e:	4798      	blx	r3
    2310:	486f      	ldr	r0, [pc, #444]	; (24d0 <m2m_wifi_connect_sc+0x24c>)
    2312:	4b6b      	ldr	r3, [pc, #428]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    2314:	4798      	blx	r3
    2316:	200d      	movs	r0, #13
    2318:	4b6a      	ldr	r3, [pc, #424]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    231a:	4798      	blx	r3
					ret = M2M_ERR_FAIL;
    231c:	200c      	movs	r0, #12
    231e:	4240      	negs	r0, r0
					goto ERR1;
    2320:	e0be      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
    2322:	3201      	adds	r2, #1
		}
		if((u8SecType == M2M_WIFI_SEC_WPA_PSK) && (m2m_strlen(pvAuthInfo) == (M2M_MAX_PSK_LEN-1)))
		{
			uint8 i = 0;
			uint8* pu8Psk = (uint8*)pvAuthInfo;
			while(i < (M2M_MAX_PSK_LEN-1))
    2324:	4282      	cmp	r2, r0
    2326:	d1e3      	bne.n	22f0 <m2m_wifi_connect_sc+0x6c>
				}
				i++;
			}
		}
	}
	if((u8SsidLen<=0)||(u8SsidLen>=M2M_MAX_SSID_LEN))
    2328:	1e63      	subs	r3, r4, #1
    232a:	2b1f      	cmp	r3, #31
    232c:	d90d      	bls.n	234a <m2m_wifi_connect_sc+0xc6>
	{
		M2M_ERR("SSID LEN INVALID\n");
    232e:	4a69      	ldr	r2, [pc, #420]	; (24d4 <m2m_wifi_connect_sc+0x250>)
    2330:	495f      	ldr	r1, [pc, #380]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    2332:	4860      	ldr	r0, [pc, #384]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    2334:	4b60      	ldr	r3, [pc, #384]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    2336:	4798      	blx	r3
    2338:	4867      	ldr	r0, [pc, #412]	; (24d8 <m2m_wifi_connect_sc+0x254>)
    233a:	4b61      	ldr	r3, [pc, #388]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    233c:	4798      	blx	r3
    233e:	200d      	movs	r0, #13
    2340:	4b60      	ldr	r3, [pc, #384]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    2342:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    2344:	200c      	movs	r0, #12
    2346:	4240      	negs	r0, r0
		goto ERR1;
    2348:	e0aa      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
	}

	if(u16Ch < M2M_WIFI_CH_1|| u16Ch > M2M_WIFI_CH_14)
    234a:	464b      	mov	r3, r9
    234c:	3b01      	subs	r3, #1
    234e:	b29b      	uxth	r3, r3
    2350:	2b0d      	cmp	r3, #13
    2352:	d911      	bls.n	2378 <m2m_wifi_connect_sc+0xf4>
	{
		if(u16Ch!=M2M_WIFI_CH_ALL)
    2354:	464b      	mov	r3, r9
    2356:	2bff      	cmp	r3, #255	; 0xff
    2358:	d00e      	beq.n	2378 <m2m_wifi_connect_sc+0xf4>
		{
			M2M_ERR("CH INVALID\n");
    235a:	228d      	movs	r2, #141	; 0x8d
    235c:	0092      	lsls	r2, r2, #2
    235e:	4954      	ldr	r1, [pc, #336]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    2360:	4854      	ldr	r0, [pc, #336]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    2362:	4b55      	ldr	r3, [pc, #340]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    2364:	4798      	blx	r3
    2366:	485d      	ldr	r0, [pc, #372]	; (24dc <m2m_wifi_connect_sc+0x258>)
    2368:	4b55      	ldr	r3, [pc, #340]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    236a:	4798      	blx	r3
    236c:	200d      	movs	r0, #13
    236e:	4b55      	ldr	r3, [pc, #340]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    2370:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    2372:	200c      	movs	r0, #12
    2374:	4240      	negs	r0, r0
			goto ERR1;
    2376:	e093      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
		}
	}


	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
    2378:	ae07      	add	r6, sp, #28
    237a:	0022      	movs	r2, r4
    237c:	9905      	ldr	r1, [sp, #20]
    237e:	205a      	movs	r0, #90	; 0x5a
    2380:	ab02      	add	r3, sp, #8
    2382:	469c      	mov	ip, r3
    2384:	4460      	add	r0, ip
    2386:	4b56      	ldr	r3, [pc, #344]	; (24e0 <m2m_wifi_connect_sc+0x25c>)
    2388:	4798      	blx	r3
	strConnect.au8SSID[u8SsidLen]	= 0;
    238a:	1934      	adds	r4, r6, r4
    238c:	3446      	adds	r4, #70	; 0x46
    238e:	2300      	movs	r3, #0
    2390:	7023      	strb	r3, [r4, #0]
	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
    2392:	3344      	adds	r3, #68	; 0x44
    2394:	464a      	mov	r2, r9
    2396:	52f2      	strh	r2, [r6, r3]
	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
    2398:	4643      	mov	r3, r8
    239a:	1e5a      	subs	r2, r3, #1
    239c:	4193      	sbcs	r3, r2
    239e:	2267      	movs	r2, #103	; 0x67
    23a0:	54b3      	strb	r3, [r6, r2]
	pstrAuthInfo = &strConnect.strSec;
	pstrAuthInfo->u8SecType		= u8SecType;
    23a2:	2341      	movs	r3, #65	; 0x41
    23a4:	54f5      	strb	r5, [r6, r3]

	if(u8SecType == M2M_WIFI_SEC_WEP)
    23a6:	2d03      	cmp	r5, #3
    23a8:	d13b      	bne.n	2422 <m2m_wifi_connect_sc+0x19e>
	{
		tstrM2mWifiWepParams	* pstrWepParams = (tstrM2mWifiWepParams*)pvAuthInfo;
		tstrM2mWifiWepParams	*pstrWep = &pstrAuthInfo->uniAuth.strWepInfo;
		pstrWep->u8KeyIndx =pstrWepParams->u8KeyIndx-1;
    23aa:	783b      	ldrb	r3, [r7, #0]
    23ac:	3b01      	subs	r3, #1
    23ae:	b2db      	uxtb	r3, r3
    23b0:	aa07      	add	r2, sp, #28
    23b2:	7013      	strb	r3, [r2, #0]

		if(pstrWep->u8KeyIndx >= WEP_KEY_MAX_INDEX)
    23b4:	2b03      	cmp	r3, #3
    23b6:	d90e      	bls.n	23d6 <m2m_wifi_connect_sc+0x152>
		{
			M2M_ERR("Invalid Wep key index %d\n", pstrWep->u8KeyIndx);
    23b8:	4a4a      	ldr	r2, [pc, #296]	; (24e4 <m2m_wifi_connect_sc+0x260>)
    23ba:	493d      	ldr	r1, [pc, #244]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    23bc:	483d      	ldr	r0, [pc, #244]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    23be:	4c3e      	ldr	r4, [pc, #248]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    23c0:	47a0      	blx	r4
    23c2:	ab07      	add	r3, sp, #28
    23c4:	7819      	ldrb	r1, [r3, #0]
    23c6:	4848      	ldr	r0, [pc, #288]	; (24e8 <m2m_wifi_connect_sc+0x264>)
    23c8:	47a0      	blx	r4
    23ca:	200d      	movs	r0, #13
    23cc:	4b3d      	ldr	r3, [pc, #244]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    23ce:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    23d0:	200c      	movs	r0, #12
    23d2:	4240      	negs	r0, r0
			goto ERR1;
    23d4:	e064      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
		}
		pstrWep->u8KeySz = pstrWepParams->u8KeySz-1;
    23d6:	787a      	ldrb	r2, [r7, #1]
    23d8:	1e51      	subs	r1, r2, #1
    23da:	ab07      	add	r3, sp, #28
    23dc:	7059      	strb	r1, [r3, #1]
		if ((pstrWep->u8KeySz != WEP_40_KEY_STRING_SIZE)&& (pstrWep->u8KeySz != WEP_104_KEY_STRING_SIZE))
    23de:	2310      	movs	r3, #16
    23e0:	0011      	movs	r1, r2
    23e2:	4399      	bics	r1, r3
    23e4:	290b      	cmp	r1, #11
    23e6:	d00e      	beq.n	2406 <m2m_wifi_connect_sc+0x182>
		{
			M2M_ERR("Invalid Wep key length %d\n", pstrWep->u8KeySz);
    23e8:	4a40      	ldr	r2, [pc, #256]	; (24ec <m2m_wifi_connect_sc+0x268>)
    23ea:	4931      	ldr	r1, [pc, #196]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    23ec:	4831      	ldr	r0, [pc, #196]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    23ee:	4c32      	ldr	r4, [pc, #200]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    23f0:	47a0      	blx	r4
    23f2:	ab07      	add	r3, sp, #28
    23f4:	7859      	ldrb	r1, [r3, #1]
    23f6:	483e      	ldr	r0, [pc, #248]	; (24f0 <m2m_wifi_connect_sc+0x26c>)
    23f8:	47a0      	blx	r4
    23fa:	200d      	movs	r0, #13
    23fc:	4b31      	ldr	r3, [pc, #196]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    23fe:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    2400:	200c      	movs	r0, #12
    2402:	4240      	negs	r0, r0
			goto ERR1;
    2404:	e04c      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy((uint8*)pstrWep->au8WepKey,(uint8*)pstrWepParams->au8WepKey, pstrWepParams->u8KeySz);
    2406:	1cb9      	adds	r1, r7, #2
    2408:	2016      	movs	r0, #22
    240a:	ab02      	add	r3, sp, #8
    240c:	469c      	mov	ip, r3
    240e:	4460      	add	r0, ip
    2410:	4b33      	ldr	r3, [pc, #204]	; (24e0 <m2m_wifi_connect_sc+0x25c>)
    2412:	4798      	blx	r3
		pstrWep->au8WepKey[pstrWepParams->u8KeySz] = 0;
    2414:	787b      	ldrb	r3, [r7, #1]
    2416:	aa07      	add	r2, sp, #28
    2418:	4694      	mov	ip, r2
    241a:	4463      	add	r3, ip
    241c:	2200      	movs	r2, #0
    241e:	709a      	strb	r2, [r3, #2]
    2420:	e034      	b.n	248c <m2m_wifi_connect_sc+0x208>

	}


	else if(u8SecType == M2M_WIFI_SEC_WPA_PSK)
    2422:	2d02      	cmp	r5, #2
    2424:	d11a      	bne.n	245c <m2m_wifi_connect_sc+0x1d8>
	{
		uint16	u16KeyLen = m2m_strlen((uint8*)pvAuthInfo);
    2426:	0038      	movs	r0, r7
    2428:	4b27      	ldr	r3, [pc, #156]	; (24c8 <m2m_wifi_connect_sc+0x244>)
    242a:	4798      	blx	r3
		if((u16KeyLen <= 0)||(u16KeyLen >= M2M_MAX_PSK_LEN))
    242c:	1e43      	subs	r3, r0, #1
    242e:	b29b      	uxth	r3, r3
    2430:	2b3f      	cmp	r3, #63	; 0x3f
    2432:	d90d      	bls.n	2450 <m2m_wifi_connect_sc+0x1cc>
		{
			M2M_ERR("Incorrect PSK key length\n");
    2434:	4a2f      	ldr	r2, [pc, #188]	; (24f4 <m2m_wifi_connect_sc+0x270>)
    2436:	491e      	ldr	r1, [pc, #120]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    2438:	481e      	ldr	r0, [pc, #120]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    243a:	4b1f      	ldr	r3, [pc, #124]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    243c:	4798      	blx	r3
    243e:	482e      	ldr	r0, [pc, #184]	; (24f8 <m2m_wifi_connect_sc+0x274>)
    2440:	4b1f      	ldr	r3, [pc, #124]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    2442:	4798      	blx	r3
    2444:	200d      	movs	r0, #13
    2446:	4b1f      	ldr	r3, [pc, #124]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    2448:	4798      	blx	r3
			ret = M2M_ERR_FAIL;
    244a:	200c      	movs	r0, #12
    244c:	4240      	negs	r0, r0
			goto ERR1;
    244e:	e027      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
		}
		m2m_memcpy(pstrAuthInfo->uniAuth.au8PSK, (uint8*)pvAuthInfo, u16KeyLen + 1);
    2450:	1c42      	adds	r2, r0, #1
    2452:	0039      	movs	r1, r7
    2454:	a807      	add	r0, sp, #28
    2456:	4b22      	ldr	r3, [pc, #136]	; (24e0 <m2m_wifi_connect_sc+0x25c>)
    2458:	4798      	blx	r3
    245a:	e017      	b.n	248c <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_802_1X)
    245c:	2d04      	cmp	r5, #4
    245e:	d105      	bne.n	246c <m2m_wifi_connect_sc+0x1e8>
	{
		m2m_memcpy((uint8*)&pstrAuthInfo->uniAuth.strCred1x, (uint8*)pvAuthInfo, sizeof(tstr1xAuthCredentials));
    2460:	223e      	movs	r2, #62	; 0x3e
    2462:	0039      	movs	r1, r7
    2464:	a807      	add	r0, sp, #28
    2466:	4b1e      	ldr	r3, [pc, #120]	; (24e0 <m2m_wifi_connect_sc+0x25c>)
    2468:	4798      	blx	r3
    246a:	e00f      	b.n	248c <m2m_wifi_connect_sc+0x208>
	}
	else if(u8SecType == M2M_WIFI_SEC_OPEN)
    246c:	2d01      	cmp	r5, #1
    246e:	d00d      	beq.n	248c <m2m_wifi_connect_sc+0x208>
	{

	}
	else
	{
		M2M_ERR("undefined sec type\n");
    2470:	4a22      	ldr	r2, [pc, #136]	; (24fc <m2m_wifi_connect_sc+0x278>)
    2472:	490f      	ldr	r1, [pc, #60]	; (24b0 <m2m_wifi_connect_sc+0x22c>)
    2474:	480f      	ldr	r0, [pc, #60]	; (24b4 <m2m_wifi_connect_sc+0x230>)
    2476:	4b10      	ldr	r3, [pc, #64]	; (24b8 <m2m_wifi_connect_sc+0x234>)
    2478:	4798      	blx	r3
    247a:	4821      	ldr	r0, [pc, #132]	; (2500 <m2m_wifi_connect_sc+0x27c>)
    247c:	4b10      	ldr	r3, [pc, #64]	; (24c0 <m2m_wifi_connect_sc+0x23c>)
    247e:	4798      	blx	r3
    2480:	200d      	movs	r0, #13
    2482:	4b10      	ldr	r3, [pc, #64]	; (24c4 <m2m_wifi_connect_sc+0x240>)
    2484:	4798      	blx	r3
		ret = M2M_ERR_FAIL;
    2486:	200c      	movs	r0, #12
    2488:	4240      	negs	r0, r0
		goto ERR1;
    248a:	e009      	b.n	24a0 <m2m_wifi_connect_sc+0x21c>
	}

	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
    248c:	2300      	movs	r3, #0
    248e:	9302      	str	r3, [sp, #8]
    2490:	9301      	str	r3, [sp, #4]
    2492:	9300      	str	r3, [sp, #0]
    2494:	336c      	adds	r3, #108	; 0x6c
    2496:	aa07      	add	r2, sp, #28
    2498:	2128      	movs	r1, #40	; 0x28
    249a:	2001      	movs	r0, #1
    249c:	4c19      	ldr	r4, [pc, #100]	; (2504 <m2m_wifi_connect_sc+0x280>)
    249e:	47a0      	blx	r4

ERR1:
	return ret;
}
    24a0:	b023      	add	sp, #140	; 0x8c
    24a2:	bc0c      	pop	{r2, r3}
    24a4:	4690      	mov	r8, r2
    24a6:	4699      	mov	r9, r3
    24a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    24aa:	46c0      	nop			; (mov r8, r8)
    24ac:	00000215 	.word	0x00000215
    24b0:	0000a1c8 	.word	0x0000a1c8
    24b4:	00009e44 	.word	0x00009e44
    24b8:	00008845 	.word	0x00008845
    24bc:	0000a394 	.word	0x0000a394
    24c0:	00008965 	.word	0x00008965
    24c4:	00008879 	.word	0x00008879
    24c8:	000015f5 	.word	0x000015f5
    24cc:	00000221 	.word	0x00000221
    24d0:	0000a3a8 	.word	0x0000a3a8
    24d4:	0000022b 	.word	0x0000022b
    24d8:	0000a3b4 	.word	0x0000a3b4
    24dc:	0000a3c8 	.word	0x0000a3c8
    24e0:	000015d1 	.word	0x000015d1
    24e4:	0000024b 	.word	0x0000024b
    24e8:	0000a3d4 	.word	0x0000a3d4
    24ec:	00000252 	.word	0x00000252
    24f0:	0000a3f0 	.word	0x0000a3f0
    24f4:	00000261 	.word	0x00000261
    24f8:	0000a40c 	.word	0x0000a40c
    24fc:	00000271 	.word	0x00000271
    2500:	0000a428 	.word	0x0000a428
    2504:	000016f5 	.word	0x000016f5

00002508 <m2m_wifi_connect>:
{
	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
}

sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
{
    2508:	b530      	push	{r4, r5, lr}
    250a:	b083      	sub	sp, #12
    250c:	ac06      	add	r4, sp, #24
    250e:	8824      	ldrh	r4, [r4, #0]
	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
    2510:	2500      	movs	r5, #0
    2512:	9501      	str	r5, [sp, #4]
    2514:	9400      	str	r4, [sp, #0]
    2516:	4c02      	ldr	r4, [pc, #8]	; (2520 <m2m_wifi_connect+0x18>)
    2518:	47a0      	blx	r4
}
    251a:	b003      	add	sp, #12
    251c:	bd30      	pop	{r4, r5, pc}
    251e:	46c0      	nop			; (mov r8, r8)
    2520:	00002285 	.word	0x00002285

00002524 <m2m_wifi_request_dhcp_client>:

sint8 m2m_wifi_request_dhcp_client(void)
{
	/*legacy API should be removed */
	return 0;
}
    2524:	2000      	movs	r0, #0
    2526:	4770      	bx	lr

00002528 <chip_apply_conf>:

#define TIMEOUT						(0xfffffffful)
#define WAKUP_TRAILS_TIMEOUT		(4)

sint8 chip_apply_conf(uint32 u32Conf)
{
    2528:	b5f0      	push	{r4, r5, r6, r7, lr}
    252a:	b083      	sub	sp, #12
#endif
#ifdef __DISABLE_FIRMWARE_LOGS__
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
    252c:	2580      	movs	r5, #128	; 0x80
    252e:	006d      	lsls	r5, r5, #1
    2530:	4305      	orrs	r5, r0
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    2532:	24a5      	movs	r4, #165	; 0xa5
    2534:	0164      	lsls	r4, r4, #5
    2536:	4f08      	ldr	r7, [pc, #32]	; (2558 <chip_apply_conf+0x30>)
		if(val32 != 0) {		
			uint32 reg = 0;
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    2538:	4e08      	ldr	r6, [pc, #32]	; (255c <chip_apply_conf+0x34>)
	val32 |= rHAVE_LOGS_DISABLED_BIT;
#endif

	val32 |= rHAVE_RESERVED1_BIT;
	do  {
		nm_write_reg(rNMI_GP_REG_1, val32);
    253a:	0029      	movs	r1, r5
    253c:	0020      	movs	r0, r4
    253e:	47b8      	blx	r7
		if(val32 != 0) {		
			uint32 reg = 0;
    2540:	2300      	movs	r3, #0
    2542:	9301      	str	r3, [sp, #4]
			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
    2544:	a901      	add	r1, sp, #4
    2546:	0020      	movs	r0, r4
    2548:	47b0      	blx	r6
			if(ret == M2M_SUCCESS) {
    254a:	2800      	cmp	r0, #0
    254c:	d1f5      	bne.n	253a <chip_apply_conf+0x12>
				if(reg == val32)
    254e:	9b01      	ldr	r3, [sp, #4]
    2550:	429d      	cmp	r5, r3
    2552:	d1f2      	bne.n	253a <chip_apply_conf+0x12>
			break;
		}
	} while(1);

	return M2M_SUCCESS;
}
    2554:	b003      	add	sp, #12
    2556:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2558:	00002a0d 	.word	0x00002a0d
    255c:	00002a01 	.word	0x00002a01

00002560 <enable_interrupts>:
		nm_write_reg(WAKE_CLK_REG, reg);
	}
}

sint8 enable_interrupts(void)
{
    2560:	b500      	push	{lr}
    2562:	b083      	sub	sp, #12
	uint32 reg = 0;
    2564:	2300      	movs	r3, #0
    2566:	9301      	str	r3, [sp, #4]
	sint8 ret = M2M_SUCCESS;
	/**
	interrupt pin mux select
	**/
	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
    2568:	a901      	add	r1, sp, #4
    256a:	4810      	ldr	r0, [pc, #64]	; (25ac <enable_interrupts+0x4c>)
    256c:	4b10      	ldr	r3, [pc, #64]	; (25b0 <enable_interrupts+0x50>)
    256e:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    2570:	2800      	cmp	r0, #0
    2572:	d119      	bne.n	25a8 <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 8);
    2574:	2180      	movs	r1, #128	; 0x80
    2576:	0049      	lsls	r1, r1, #1
    2578:	9b01      	ldr	r3, [sp, #4]
    257a:	4319      	orrs	r1, r3
    257c:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
    257e:	480b      	ldr	r0, [pc, #44]	; (25ac <enable_interrupts+0x4c>)
    2580:	4b0c      	ldr	r3, [pc, #48]	; (25b4 <enable_interrupts+0x54>)
    2582:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    2584:	2800      	cmp	r0, #0
    2586:	d10f      	bne.n	25a8 <enable_interrupts+0x48>
	
	/**
	interrupt enable
	**/
	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
    2588:	a901      	add	r1, sp, #4
    258a:	20d0      	movs	r0, #208	; 0xd0
    258c:	0140      	lsls	r0, r0, #5
    258e:	4b08      	ldr	r3, [pc, #32]	; (25b0 <enable_interrupts+0x50>)
    2590:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
    2592:	2800      	cmp	r0, #0
    2594:	d108      	bne.n	25a8 <enable_interrupts+0x48>
	
	reg |= ((uint32) 1 << 16);
    2596:	2180      	movs	r1, #128	; 0x80
    2598:	0249      	lsls	r1, r1, #9
    259a:	9b01      	ldr	r3, [sp, #4]
    259c:	4319      	orrs	r1, r3
    259e:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
    25a0:	20d0      	movs	r0, #208	; 0xd0
    25a2:	0140      	lsls	r0, r0, #5
    25a4:	4b03      	ldr	r3, [pc, #12]	; (25b4 <enable_interrupts+0x54>)
    25a6:	4798      	blx	r3
	if (M2M_SUCCESS != ret) goto ERR1;
ERR1:	
	return ret;
}
    25a8:	b003      	add	sp, #12
    25aa:	bd00      	pop	{pc}
    25ac:	00001408 	.word	0x00001408
    25b0:	00002a01 	.word	0x00002a01
    25b4:	00002a0d 	.word	0x00002a0d

000025b8 <nmi_get_chipid>:
	nm_bsp_sleep(1);
	return ret;
}

uint32 nmi_get_chipid(void)
{
    25b8:	b510      	push	{r4, lr}
    25ba:	b082      	sub	sp, #8
	static uint32 chipid = 0;

	if (chipid == 0) {
    25bc:	4b27      	ldr	r3, [pc, #156]	; (265c <nmi_get_chipid+0xa4>)
    25be:	681c      	ldr	r4, [r3, #0]
    25c0:	2c00      	cmp	r4, #0
    25c2:	d146      	bne.n	2652 <nmi_get_chipid+0x9a>
		uint32 rfrevid;
		
		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
    25c4:	0019      	movs	r1, r3
    25c6:	2080      	movs	r0, #128	; 0x80
    25c8:	0140      	lsls	r0, r0, #5
    25ca:	4b25      	ldr	r3, [pc, #148]	; (2660 <nmi_get_chipid+0xa8>)
    25cc:	4798      	blx	r3
    25ce:	2800      	cmp	r0, #0
    25d0:	d003      	beq.n	25da <nmi_get_chipid+0x22>
			chipid = 0;
    25d2:	2200      	movs	r2, #0
    25d4:	4b21      	ldr	r3, [pc, #132]	; (265c <nmi_get_chipid+0xa4>)
    25d6:	601a      	str	r2, [r3, #0]
			return 0;
    25d8:	e03d      	b.n	2656 <nmi_get_chipid+0x9e>
		}
		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
		//	return 0;
		//}
		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
    25da:	a901      	add	r1, sp, #4
    25dc:	4821      	ldr	r0, [pc, #132]	; (2664 <nmi_get_chipid+0xac>)
    25de:	4b20      	ldr	r3, [pc, #128]	; (2660 <nmi_get_chipid+0xa8>)
    25e0:	4798      	blx	r3
    25e2:	2800      	cmp	r0, #0
    25e4:	d003      	beq.n	25ee <nmi_get_chipid+0x36>
			chipid = 0;
    25e6:	2200      	movs	r2, #0
    25e8:	4b1c      	ldr	r3, [pc, #112]	; (265c <nmi_get_chipid+0xa4>)
    25ea:	601a      	str	r2, [r3, #0]
			return 0;
    25ec:	e033      	b.n	2656 <nmi_get_chipid+0x9e>
		}

		if (chipid == 0x1002a0)  {
    25ee:	4b1b      	ldr	r3, [pc, #108]	; (265c <nmi_get_chipid+0xa4>)
    25f0:	681b      	ldr	r3, [r3, #0]
    25f2:	4a1d      	ldr	r2, [pc, #116]	; (2668 <nmi_get_chipid+0xb0>)
    25f4:	4293      	cmp	r3, r2
    25f6:	d106      	bne.n	2606 <nmi_get_chipid+0x4e>
			if (rfrevid == 0x1) { /* 1002A0 */
    25f8:	9b01      	ldr	r3, [sp, #4]
    25fa:	2b01      	cmp	r3, #1
    25fc:	d021      	beq.n	2642 <nmi_get_chipid+0x8a>
			} else /* if (rfrevid == 0x2) */ { /* 1002A1 */
				chipid = 0x1002a1;
    25fe:	4a1b      	ldr	r2, [pc, #108]	; (266c <nmi_get_chipid+0xb4>)
    2600:	4b16      	ldr	r3, [pc, #88]	; (265c <nmi_get_chipid+0xa4>)
    2602:	601a      	str	r2, [r3, #0]
    2604:	e01d      	b.n	2642 <nmi_get_chipid+0x8a>
			}
		} else if(chipid == 0x1002b0) {
    2606:	4a1a      	ldr	r2, [pc, #104]	; (2670 <nmi_get_chipid+0xb8>)
    2608:	4293      	cmp	r3, r2
    260a:	d10c      	bne.n	2626 <nmi_get_chipid+0x6e>
			if(rfrevid == 3) { /* 1002B0 */
    260c:	9b01      	ldr	r3, [sp, #4]
    260e:	2b03      	cmp	r3, #3
    2610:	d017      	beq.n	2642 <nmi_get_chipid+0x8a>
			} else if(rfrevid == 4) { /* 1002B1 */
    2612:	2b04      	cmp	r3, #4
    2614:	d103      	bne.n	261e <nmi_get_chipid+0x66>
				chipid = 0x1002b1;
    2616:	4a17      	ldr	r2, [pc, #92]	; (2674 <nmi_get_chipid+0xbc>)
    2618:	4b10      	ldr	r3, [pc, #64]	; (265c <nmi_get_chipid+0xa4>)
    261a:	601a      	str	r2, [r3, #0]
    261c:	e011      	b.n	2642 <nmi_get_chipid+0x8a>
			} else /* if(rfrevid == 5) */ { /* 1002B2 */
				chipid = 0x1002b2;
    261e:	4a16      	ldr	r2, [pc, #88]	; (2678 <nmi_get_chipid+0xc0>)
    2620:	4b0e      	ldr	r3, [pc, #56]	; (265c <nmi_get_chipid+0xa4>)
    2622:	601a      	str	r2, [r3, #0]
    2624:	e00d      	b.n	2642 <nmi_get_chipid+0x8a>
			}
		}else if(chipid == 0x1000F0) { 
    2626:	4a15      	ldr	r2, [pc, #84]	; (267c <nmi_get_chipid+0xc4>)
    2628:	4293      	cmp	r3, r2
    262a:	d10a      	bne.n	2642 <nmi_get_chipid+0x8a>
			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
    262c:	490b      	ldr	r1, [pc, #44]	; (265c <nmi_get_chipid+0xa4>)
    262e:	20ec      	movs	r0, #236	; 0xec
    2630:	0380      	lsls	r0, r0, #14
    2632:	4b0b      	ldr	r3, [pc, #44]	; (2660 <nmi_get_chipid+0xa8>)
    2634:	4798      	blx	r3
    2636:	2800      	cmp	r0, #0
    2638:	d003      	beq.n	2642 <nmi_get_chipid+0x8a>
			chipid = 0;
    263a:	2200      	movs	r2, #0
    263c:	4b07      	ldr	r3, [pc, #28]	; (265c <nmi_get_chipid+0xa4>)
    263e:	601a      	str	r2, [r3, #0]
			return 0;
    2640:	e009      	b.n	2656 <nmi_get_chipid+0x9e>
			}
		}
#else
		/*M2M is by default have SPI flash*/
		chipid &= ~(0x0f0000);
		chipid |= 0x050000;
    2642:	4a06      	ldr	r2, [pc, #24]	; (265c <nmi_get_chipid+0xa4>)
    2644:	4b0e      	ldr	r3, [pc, #56]	; (2680 <nmi_get_chipid+0xc8>)
    2646:	6811      	ldr	r1, [r2, #0]
    2648:	400b      	ands	r3, r1
    264a:	21a0      	movs	r1, #160	; 0xa0
    264c:	02c9      	lsls	r1, r1, #11
    264e:	430b      	orrs	r3, r1
    2650:	6013      	str	r3, [r2, #0]
#endif /* PROBE_FLASH */
	}
	return chipid;
    2652:	4b02      	ldr	r3, [pc, #8]	; (265c <nmi_get_chipid+0xa4>)
    2654:	681c      	ldr	r4, [r3, #0]
}
    2656:	0020      	movs	r0, r4
    2658:	b002      	add	sp, #8
    265a:	bd10      	pop	{r4, pc}
    265c:	2000011c 	.word	0x2000011c
    2660:	00002a01 	.word	0x00002a01
    2664:	000013f4 	.word	0x000013f4
    2668:	001002a0 	.word	0x001002a0
    266c:	001002a1 	.word	0x001002a1
    2670:	001002b0 	.word	0x001002b0
    2674:	001002b1 	.word	0x001002b1
    2678:	001002b2 	.word	0x001002b2
    267c:	001000f0 	.word	0x001000f0
    2680:	fff0ffff 	.word	0xfff0ffff

00002684 <chip_sleep>:

	/* Do PLL update */
	nmi_update_pll();
}
sint8 chip_sleep(void)
{
    2684:	b530      	push	{r4, r5, lr}
    2686:	b083      	sub	sp, #12
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    2688:	4c15      	ldr	r4, [pc, #84]	; (26e0 <chip_sleep+0x5c>)
		if(ret != M2M_SUCCESS) goto ERR1;
		if((reg & NBIT0) == 0) break;
    268a:	2501      	movs	r5, #1
	uint32 reg;
	sint8 ret = M2M_SUCCESS;
	
	while(1)
	{
		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
    268c:	a901      	add	r1, sp, #4
    268e:	2010      	movs	r0, #16
    2690:	47a0      	blx	r4
		if(ret != M2M_SUCCESS) goto ERR1;
    2692:	2800      	cmp	r0, #0
    2694:	d122      	bne.n	26dc <chip_sleep+0x58>
		if((reg & NBIT0) == 0) break;
    2696:	9b01      	ldr	r3, [sp, #4]
    2698:	422b      	tst	r3, r5
    269a:	d1f7      	bne.n	268c <chip_sleep+0x8>
	}
	
	/* Clear bit 1 */
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    269c:	a901      	add	r1, sp, #4
    269e:	3001      	adds	r0, #1
    26a0:	4b0f      	ldr	r3, [pc, #60]	; (26e0 <chip_sleep+0x5c>)
    26a2:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    26a4:	2800      	cmp	r0, #0
    26a6:	d119      	bne.n	26dc <chip_sleep+0x58>
	if(reg & NBIT1)
    26a8:	9901      	ldr	r1, [sp, #4]
    26aa:	078b      	lsls	r3, r1, #30
    26ac:	d507      	bpl.n	26be <chip_sleep+0x3a>
	{
		reg &=~NBIT1;
    26ae:	2302      	movs	r3, #2
    26b0:	4399      	bics	r1, r3
    26b2:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(WAKE_CLK_REG, reg);
    26b4:	3001      	adds	r0, #1
    26b6:	4b0b      	ldr	r3, [pc, #44]	; (26e4 <chip_sleep+0x60>)
    26b8:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
    26ba:	2800      	cmp	r0, #0
    26bc:	d10e      	bne.n	26dc <chip_sleep+0x58>
	}
	
	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    26be:	a901      	add	r1, sp, #4
    26c0:	200b      	movs	r0, #11
    26c2:	4b07      	ldr	r3, [pc, #28]	; (26e0 <chip_sleep+0x5c>)
    26c4:	4798      	blx	r3
	if(ret != M2M_SUCCESS)goto ERR1;
    26c6:	2800      	cmp	r0, #0
    26c8:	d108      	bne.n	26dc <chip_sleep+0x58>
	if(reg & NBIT0)
    26ca:	9901      	ldr	r1, [sp, #4]
    26cc:	07cb      	lsls	r3, r1, #31
    26ce:	d505      	bpl.n	26dc <chip_sleep+0x58>
	{
		reg &= ~NBIT0;
    26d0:	2301      	movs	r3, #1
    26d2:	4399      	bics	r1, r3
    26d4:	9101      	str	r1, [sp, #4]
		ret = nm_write_reg(HOST_CORT_COMM, reg);
    26d6:	300b      	adds	r0, #11
    26d8:	4b02      	ldr	r3, [pc, #8]	; (26e4 <chip_sleep+0x60>)
    26da:	4798      	blx	r3
		if(ret != M2M_SUCCESS)goto ERR1;
	}

ERR1:
	return ret;
}
    26dc:	b003      	add	sp, #12
    26de:	bd30      	pop	{r4, r5, pc}
    26e0:	00002a01 	.word	0x00002a01
    26e4:	00002a0d 	.word	0x00002a0d

000026e8 <chip_wake>:
sint8 chip_wake(void)
{
    26e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    26ea:	b083      	sub	sp, #12
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, clk_status_reg = 0,trials = 0;
    26ec:	2300      	movs	r3, #0
    26ee:	9301      	str	r3, [sp, #4]
    26f0:	9300      	str	r3, [sp, #0]

	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
    26f2:	a901      	add	r1, sp, #4
    26f4:	200b      	movs	r0, #11
    26f6:	4b28      	ldr	r3, [pc, #160]	; (2798 <chip_wake+0xb0>)
    26f8:	4798      	blx	r3
    26fa:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    26fc:	d148      	bne.n	2790 <chip_wake+0xa8>
	
	if(!(reg & NBIT0))
    26fe:	9901      	ldr	r1, [sp, #4]
    2700:	07cb      	lsls	r3, r1, #31
    2702:	d406      	bmi.n	2712 <chip_wake+0x2a>
	{
		/*USE bit 0 to indicate host wakeup*/
		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
    2704:	2301      	movs	r3, #1
    2706:	4319      	orrs	r1, r3
    2708:	200b      	movs	r0, #11
    270a:	4b24      	ldr	r3, [pc, #144]	; (279c <chip_wake+0xb4>)
    270c:	4798      	blx	r3
    270e:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    2710:	d13e      	bne.n	2790 <chip_wake+0xa8>
	}
		
	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
    2712:	a901      	add	r1, sp, #4
    2714:	2001      	movs	r0, #1
    2716:	4b20      	ldr	r3, [pc, #128]	; (2798 <chip_wake+0xb0>)
    2718:	4798      	blx	r3
    271a:	1e04      	subs	r4, r0, #0
	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
    271c:	d138      	bne.n	2790 <chip_wake+0xa8>
	/* Set bit 1 */
	if(!(reg & NBIT1))
    271e:	9901      	ldr	r1, [sp, #4]
    2720:	078b      	lsls	r3, r1, #30
    2722:	d406      	bmi.n	2732 <chip_wake+0x4a>
	{
		ret = nm_write_reg(WAKE_CLK_REG, reg | NBIT1);
    2724:	2302      	movs	r3, #2
    2726:	4319      	orrs	r1, r3
    2728:	2001      	movs	r0, #1
    272a:	4b1c      	ldr	r3, [pc, #112]	; (279c <chip_wake+0xb4>)
    272c:	4798      	blx	r3
    272e:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
    2730:	d12e      	bne.n	2790 <chip_wake+0xa8>

ERR1:
	return ret;
}
sint8 chip_wake(void)
{
    2732:	2505      	movs	r5, #5
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    2734:	4f18      	ldr	r7, [pc, #96]	; (2798 <chip_wake+0xb0>)
			goto _WAKE_EXIT;
		}
		if(clk_status_reg & NBIT2) {
			break;
		}
		nm_bsp_sleep(2);
    2736:	4e1a      	ldr	r6, [pc, #104]	; (27a0 <chip_wake+0xb8>)
		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
	}

	do
	{
		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
    2738:	4669      	mov	r1, sp
    273a:	200f      	movs	r0, #15
    273c:	47b8      	blx	r7
    273e:	1e04      	subs	r4, r0, #0
		if(ret != M2M_SUCCESS) {
    2740:	d00d      	beq.n	275e <chip_wake+0x76>
			M2M_ERR("Bus error (5).%d %lx\n",ret,clk_status_reg);
    2742:	22aa      	movs	r2, #170	; 0xaa
    2744:	0052      	lsls	r2, r2, #1
    2746:	4917      	ldr	r1, [pc, #92]	; (27a4 <chip_wake+0xbc>)
    2748:	4817      	ldr	r0, [pc, #92]	; (27a8 <chip_wake+0xc0>)
    274a:	4d18      	ldr	r5, [pc, #96]	; (27ac <chip_wake+0xc4>)
    274c:	47a8      	blx	r5
    274e:	9a00      	ldr	r2, [sp, #0]
    2750:	0021      	movs	r1, r4
    2752:	4817      	ldr	r0, [pc, #92]	; (27b0 <chip_wake+0xc8>)
    2754:	47a8      	blx	r5
    2756:	200d      	movs	r0, #13
    2758:	4b16      	ldr	r3, [pc, #88]	; (27b4 <chip_wake+0xcc>)
    275a:	4798      	blx	r3
			goto _WAKE_EXIT;
    275c:	e018      	b.n	2790 <chip_wake+0xa8>
		}
		if(clk_status_reg & NBIT2) {
    275e:	9b00      	ldr	r3, [sp, #0]
    2760:	075b      	lsls	r3, r3, #29
    2762:	d413      	bmi.n	278c <chip_wake+0xa4>
			break;
		}
		nm_bsp_sleep(2);
    2764:	2002      	movs	r0, #2
    2766:	47b0      	blx	r6
    2768:	3d01      	subs	r5, #1
		trials++;
		if(trials > WAKUP_TRAILS_TIMEOUT)
    276a:	2d00      	cmp	r5, #0
    276c:	d1e4      	bne.n	2738 <chip_wake+0x50>
		{
			M2M_ERR("Failed to wakup the chip\n");
    276e:	22af      	movs	r2, #175	; 0xaf
    2770:	0052      	lsls	r2, r2, #1
    2772:	490c      	ldr	r1, [pc, #48]	; (27a4 <chip_wake+0xbc>)
    2774:	480c      	ldr	r0, [pc, #48]	; (27a8 <chip_wake+0xc0>)
    2776:	4b0d      	ldr	r3, [pc, #52]	; (27ac <chip_wake+0xc4>)
    2778:	4798      	blx	r3
    277a:	480f      	ldr	r0, [pc, #60]	; (27b8 <chip_wake+0xd0>)
    277c:	4b0f      	ldr	r3, [pc, #60]	; (27bc <chip_wake+0xd4>)
    277e:	4798      	blx	r3
    2780:	200d      	movs	r0, #13
    2782:	4b0c      	ldr	r3, [pc, #48]	; (27b4 <chip_wake+0xcc>)
    2784:	4798      	blx	r3
			ret = M2M_ERR_TIME_OUT;
    2786:	2404      	movs	r4, #4
    2788:	4264      	negs	r4, r4
			goto _WAKE_EXIT;
    278a:	e001      	b.n	2790 <chip_wake+0xa8>
		}
	}while(1);
	
	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
	nm_bus_reset();
    278c:	4b0c      	ldr	r3, [pc, #48]	; (27c0 <chip_wake+0xd8>)
    278e:	4798      	blx	r3
	
_WAKE_EXIT:
	return ret;
}
    2790:	0020      	movs	r0, r4
    2792:	b003      	add	sp, #12
    2794:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2796:	46c0      	nop			; (mov r8, r8)
    2798:	00002a01 	.word	0x00002a01
    279c:	00002a0d 	.word	0x00002a0d
    27a0:	000011d5 	.word	0x000011d5
    27a4:	0000a5e0 	.word	0x0000a5e0
    27a8:	00009e44 	.word	0x00009e44
    27ac:	00008845 	.word	0x00008845
    27b0:	0000a570 	.word	0x0000a570
    27b4:	00008879 	.word	0x00008879
    27b8:	0000a588 	.word	0x0000a588
    27bc:	00008965 	.word	0x00008965
    27c0:	000029e9 	.word	0x000029e9

000027c4 <wait_for_bootrom>:
	nm_bsp_sleep(50);
	return ret;
}

sint8 wait_for_bootrom(uint8 arg)
{
    27c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    27c6:	0007      	movs	r7, r0
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    27c8:	4d2d      	ldr	r5, [pc, #180]	; (2880 <wait_for_bootrom+0xbc>)
    27ca:	4c2e      	ldr	r4, [pc, #184]	; (2884 <wait_for_bootrom+0xc0>)
		if (reg & 0x80000000) {
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    27cc:	4e2e      	ldr	r6, [pc, #184]	; (2888 <wait_for_bootrom+0xc4>)
				M2M_RELEASE_VERSION_PATCH_NO);


	reg = 0;
	while(1) {
		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
    27ce:	0028      	movs	r0, r5
    27d0:	47a0      	blx	r4
		if (reg & 0x80000000) {
    27d2:	2800      	cmp	r0, #0
    27d4:	db02      	blt.n	27dc <wait_for_bootrom+0x18>
			break;
		}
		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
    27d6:	2001      	movs	r0, #1
    27d8:	47b0      	blx	r6
	}
    27da:	e7f8      	b.n	27ce <wait_for_bootrom+0xa>
	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
    27dc:	482b      	ldr	r0, [pc, #172]	; (288c <wait_for_bootrom+0xc8>)
    27de:	4b29      	ldr	r3, [pc, #164]	; (2884 <wait_for_bootrom+0xc0>)
    27e0:	4798      	blx	r3
	reg &= 0x1;

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
    27e2:	07c3      	lsls	r3, r0, #31
    27e4:	d409      	bmi.n	27fa <wait_for_bootrom+0x36>
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    27e6:	4e28      	ldr	r6, [pc, #160]	; (2888 <wait_for_bootrom+0xc4>)
			reg = nm_read_reg(BOOTROM_REG);
    27e8:	4c29      	ldr	r4, [pc, #164]	; (2890 <wait_for_bootrom+0xcc>)
    27ea:	4d26      	ldr	r5, [pc, #152]	; (2884 <wait_for_bootrom+0xc0>)
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
		{
			nm_bsp_sleep(1);
    27ec:	2001      	movs	r0, #1
    27ee:	47b0      	blx	r6
			reg = nm_read_reg(BOOTROM_REG);
    27f0:	0020      	movs	r0, r4
    27f2:	47a8      	blx	r5

	/* check if waiting for the host will be skipped or not */
	if(reg == 0)
	{
		reg = 0;
		while(reg != M2M_FINISH_BOOT_ROM)
    27f4:	4b27      	ldr	r3, [pc, #156]	; (2894 <wait_for_bootrom+0xd0>)
    27f6:	4298      	cmp	r0, r3
    27f8:	d1f8      	bne.n	27ec <wait_for_bootrom+0x28>
				goto ERR2;
			}
		}
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
    27fa:	2f02      	cmp	r7, #2
    27fc:	d109      	bne.n	2812 <wait_for_bootrom+0x4e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    27fe:	4926      	ldr	r1, [pc, #152]	; (2898 <wait_for_bootrom+0xd4>)
    2800:	4826      	ldr	r0, [pc, #152]	; (289c <wait_for_bootrom+0xd8>)
    2802:	4c27      	ldr	r4, [pc, #156]	; (28a0 <wait_for_bootrom+0xdc>)
    2804:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, NBIT20);
    2806:	2180      	movs	r1, #128	; 0x80
    2808:	0349      	lsls	r1, r1, #13
    280a:	4826      	ldr	r0, [pc, #152]	; (28a4 <wait_for_bootrom+0xe0>)
    280c:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    280e:	2400      	movs	r4, #0
    2810:	e017      	b.n	2842 <wait_for_bootrom+0x7e>
	}
	
	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
    2812:	2f03      	cmp	r7, #3
    2814:	d108      	bne.n	2828 <wait_for_bootrom+0x64>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
    2816:	4920      	ldr	r1, [pc, #128]	; (2898 <wait_for_bootrom+0xd4>)
    2818:	4820      	ldr	r0, [pc, #128]	; (289c <wait_for_bootrom+0xd8>)
    281a:	4c21      	ldr	r4, [pc, #132]	; (28a0 <wait_for_bootrom+0xdc>)
    281c:	47a0      	blx	r4
		nm_write_reg(NMI_STATE_REG, 0);
    281e:	2100      	movs	r1, #0
    2820:	4820      	ldr	r0, [pc, #128]	; (28a4 <wait_for_bootrom+0xe0>)
    2822:	47a0      	blx	r4

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    2824:	2400      	movs	r4, #0
    2826:	e00c      	b.n	2842 <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
    2828:	2f04      	cmp	r7, #4
    282a:	d105      	bne.n	2838 <wait_for_bootrom+0x74>
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    282c:	491e      	ldr	r1, [pc, #120]	; (28a8 <wait_for_bootrom+0xe4>)
    282e:	481d      	ldr	r0, [pc, #116]	; (28a4 <wait_for_bootrom+0xe0>)
    2830:	4b1b      	ldr	r3, [pc, #108]	; (28a0 <wait_for_bootrom+0xdc>)
    2832:	4798      	blx	r3
		nm_write_reg(NMI_STATE_REG, NBIT20);
	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
		nm_write_reg(NMI_STATE_REG, 0);
	}else if(M2M_WIFI_MODE_ETHERNET == arg){
		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
    2834:	2480      	movs	r4, #128	; 0x80
    2836:	e004      	b.n	2842 <wait_for_bootrom+0x7e>
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
    2838:	491b      	ldr	r1, [pc, #108]	; (28a8 <wait_for_bootrom+0xe4>)
    283a:	481a      	ldr	r0, [pc, #104]	; (28a4 <wait_for_bootrom+0xe0>)
    283c:	4b18      	ldr	r3, [pc, #96]	; (28a0 <wait_for_bootrom+0xdc>)
    283e:	4798      	blx	r3

sint8 wait_for_bootrom(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32GpReg1 = 0;
    2840:	2400      	movs	r4, #0
	} else {
		/*bypass this step*/
		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
	}

	if(REV(nmi_get_chipid()) >= REV_3A0){
    2842:	4b1a      	ldr	r3, [pc, #104]	; (28ac <wait_for_bootrom+0xe8>)
    2844:	4798      	blx	r3
    2846:	0500      	lsls	r0, r0, #20
    2848:	0d00      	lsrs	r0, r0, #20
    284a:	4b19      	ldr	r3, [pc, #100]	; (28b0 <wait_for_bootrom+0xec>)
    284c:	4298      	cmp	r0, r3
    284e:	d904      	bls.n	285a <wait_for_bootrom+0x96>
		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
    2850:	2002      	movs	r0, #2
    2852:	4320      	orrs	r0, r4
    2854:	4b17      	ldr	r3, [pc, #92]	; (28b4 <wait_for_bootrom+0xf0>)
    2856:	4798      	blx	r3
    2858:	e002      	b.n	2860 <wait_for_bootrom+0x9c>
	} else {
		chip_apply_conf(u32GpReg1);
    285a:	0020      	movs	r0, r4
    285c:	4b15      	ldr	r3, [pc, #84]	; (28b4 <wait_for_bootrom+0xf0>)
    285e:	4798      	blx	r3
	}
	M2M_INFO("DriverVerInfo: 0x%08lx\n",u32DriverVerInfo);
    2860:	4815      	ldr	r0, [pc, #84]	; (28b8 <wait_for_bootrom+0xf4>)
    2862:	4c16      	ldr	r4, [pc, #88]	; (28bc <wait_for_bootrom+0xf8>)
    2864:	47a0      	blx	r4
    2866:	4910      	ldr	r1, [pc, #64]	; (28a8 <wait_for_bootrom+0xe4>)
    2868:	4815      	ldr	r0, [pc, #84]	; (28c0 <wait_for_bootrom+0xfc>)
    286a:	47a0      	blx	r4
    286c:	200d      	movs	r0, #13
    286e:	4b15      	ldr	r3, [pc, #84]	; (28c4 <wait_for_bootrom+0x100>)
    2870:	4798      	blx	r3

	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
    2872:	4915      	ldr	r1, [pc, #84]	; (28c8 <wait_for_bootrom+0x104>)
    2874:	4806      	ldr	r0, [pc, #24]	; (2890 <wait_for_bootrom+0xcc>)
    2876:	4b0a      	ldr	r3, [pc, #40]	; (28a0 <wait_for_bootrom+0xdc>)
    2878:	4798      	blx	r3
	rom_test();
#endif /* __ROM_TEST__ */

ERR2:
	return ret;
}
    287a:	2000      	movs	r0, #0
    287c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    287e:	46c0      	nop			; (mov r8, r8)
    2880:	00001014 	.word	0x00001014
    2884:	000029f5 	.word	0x000029f5
    2888:	000011d5 	.word	0x000011d5
    288c:	000207bc 	.word	0x000207bc
    2890:	000c000c 	.word	0x000c000c
    2894:	10add09e 	.word	0x10add09e
    2898:	3c1cd57d 	.word	0x3c1cd57d
    289c:	000207ac 	.word	0x000207ac
    28a0:	00002a0d 	.word	0x00002a0d
    28a4:	0000108c 	.word	0x0000108c
    28a8:	13521352 	.word	0x13521352
    28ac:	000025b9 	.word	0x000025b9
    28b0:	0000039f 	.word	0x0000039f
    28b4:	00002529 	.word	0x00002529
    28b8:	00009ea8 	.word	0x00009ea8
    28bc:	00008845 	.word	0x00008845
    28c0:	0000a5a4 	.word	0x0000a5a4
    28c4:	00008879 	.word	0x00008879
    28c8:	ef522f61 	.word	0xef522f61

000028cc <wait_for_firmware_start>:

sint8 wait_for_firmware_start(uint8 arg)
{
    28cc:	b570      	push	{r4, r5, r6, lr}
    28ce:	b082      	sub	sp, #8
	sint8 ret = M2M_SUCCESS;
	uint32 reg = 0, cnt = 0;
	uint32 u32Timeout = TIMEOUT;
	volatile uint32 regAddress = NMI_STATE_REG;
    28d0:	4b15      	ldr	r3, [pc, #84]	; (2928 <wait_for_firmware_start+0x5c>)
    28d2:	9301      	str	r3, [sp, #4]
	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
    28d4:	4b15      	ldr	r3, [pc, #84]	; (292c <wait_for_firmware_start+0x60>)
    28d6:	9300      	str	r3, [sp, #0]
	
	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
    28d8:	3802      	subs	r0, #2
    28da:	2801      	cmp	r0, #1
    28dc:	d80c      	bhi.n	28f8 <wait_for_firmware_start+0x2c>
		regAddress = NMI_REV_REG;
    28de:	4b14      	ldr	r3, [pc, #80]	; (2930 <wait_for_firmware_start+0x64>)
    28e0:	9301      	str	r3, [sp, #4]
		checkValue = M2M_ATE_FW_IS_UP_VALUE;
    28e2:	4b14      	ldr	r3, [pc, #80]	; (2934 <wait_for_firmware_start+0x68>)
    28e4:	9300      	str	r3, [sp, #0]
    28e6:	e007      	b.n	28f8 <wait_for_firmware_start+0x2c>
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    28e8:	2002      	movs	r0, #2
    28ea:	47b0      	blx	r6
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    28ec:	9801      	ldr	r0, [sp, #4]
    28ee:	47a8      	blx	r5
    28f0:	3c01      	subs	r4, #1
		if(++cnt >= u32Timeout)
    28f2:	2c00      	cmp	r4, #0
    28f4:	d105      	bne.n	2902 <wait_for_firmware_start+0x36>
    28f6:	e012      	b.n	291e <wait_for_firmware_start+0x52>
ERR2:
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
    28f8:	2401      	movs	r4, #1
    28fa:	4264      	negs	r4, r4
    28fc:	2000      	movs	r0, #0
	}
	
	
	while (checkValue != reg)
	{
		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
    28fe:	4e0e      	ldr	r6, [pc, #56]	; (2938 <wait_for_firmware_start+0x6c>)
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
    2900:	4d0e      	ldr	r5, [pc, #56]	; (293c <wait_for_firmware_start+0x70>)
	} else {
		/*bypass this step*/
	}
	
	
	while (checkValue != reg)
    2902:	9b00      	ldr	r3, [sp, #0]
    2904:	4298      	cmp	r0, r3
    2906:	d1ef      	bne.n	28e8 <wait_for_firmware_start+0x1c>
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    2908:	9a00      	ldr	r2, [sp, #0]
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    290a:	2000      	movs	r0, #0
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
			goto ERR;
		}
	}
	if(M2M_FINISH_INIT_STATE == checkValue)
    290c:	4b07      	ldr	r3, [pc, #28]	; (292c <wait_for_firmware_start+0x60>)
    290e:	429a      	cmp	r2, r3
    2910:	d107      	bne.n	2922 <wait_for_firmware_start+0x56>
	{
		nm_write_reg(NMI_STATE_REG, 0);
    2912:	2100      	movs	r1, #0
    2914:	4804      	ldr	r0, [pc, #16]	; (2928 <wait_for_firmware_start+0x5c>)
    2916:	4b0a      	ldr	r3, [pc, #40]	; (2940 <wait_for_firmware_start+0x74>)
    2918:	4798      	blx	r3
	return ret;
}

sint8 wait_for_firmware_start(uint8 arg)
{
	sint8 ret = M2M_SUCCESS;
    291a:	2000      	movs	r0, #0
    291c:	e001      	b.n	2922 <wait_for_firmware_start+0x56>
		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
		reg = nm_read_reg(regAddress);
		if(++cnt >= u32Timeout)
		{
			M2M_DBG("Time out for wait firmware Run\n");
			ret = M2M_ERR_INIT;
    291e:	2005      	movs	r0, #5
    2920:	4240      	negs	r0, r0
	{
		nm_write_reg(NMI_STATE_REG, 0);
	}
ERR:
	return ret;
}
    2922:	b002      	add	sp, #8
    2924:	bd70      	pop	{r4, r5, r6, pc}
    2926:	46c0      	nop			; (mov r8, r8)
    2928:	0000108c 	.word	0x0000108c
    292c:	02532636 	.word	0x02532636
    2930:	000207ac 	.word	0x000207ac
    2934:	d75dc1c3 	.word	0xd75dc1c3
    2938:	000011d5 	.word	0x000011d5
    293c:	000029f5 	.word	0x000029f5
    2940:	00002a0d 	.word	0x00002a0d

00002944 <chip_deinit>:

sint8 chip_deinit(void)
{
    2944:	b510      	push	{r4, lr}
    2946:	b082      	sub	sp, #8
	uint32 reg = 0;
    2948:	2300      	movs	r3, #0
    294a:	9301      	str	r3, [sp, #4]
	sint8 ret;

	/**
	stop the firmware, need a re-download
	**/
	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
    294c:	a901      	add	r1, sp, #4
    294e:	20a0      	movs	r0, #160	; 0xa0
    2950:	0140      	lsls	r0, r0, #5
    2952:	4b14      	ldr	r3, [pc, #80]	; (29a4 <chip_deinit+0x60>)
    2954:	4798      	blx	r3
    2956:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    2958:	d00b      	beq.n	2972 <chip_deinit+0x2e>
		M2M_ERR("failed to de-initialize\n");
    295a:	4a13      	ldr	r2, [pc, #76]	; (29a8 <chip_deinit+0x64>)
    295c:	4913      	ldr	r1, [pc, #76]	; (29ac <chip_deinit+0x68>)
    295e:	4814      	ldr	r0, [pc, #80]	; (29b0 <chip_deinit+0x6c>)
    2960:	4b14      	ldr	r3, [pc, #80]	; (29b4 <chip_deinit+0x70>)
    2962:	4798      	blx	r3
    2964:	4814      	ldr	r0, [pc, #80]	; (29b8 <chip_deinit+0x74>)
    2966:	4b15      	ldr	r3, [pc, #84]	; (29bc <chip_deinit+0x78>)
    2968:	4798      	blx	r3
    296a:	200d      	movs	r0, #13
    296c:	4b14      	ldr	r3, [pc, #80]	; (29c0 <chip_deinit+0x7c>)
    296e:	4798      	blx	r3
		goto ERR1;
    2970:	e014      	b.n	299c <chip_deinit+0x58>
	}
	reg &= ~(1 << 10);
    2972:	4914      	ldr	r1, [pc, #80]	; (29c4 <chip_deinit+0x80>)
    2974:	9b01      	ldr	r3, [sp, #4]
    2976:	4019      	ands	r1, r3
    2978:	9101      	str	r1, [sp, #4]
	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
    297a:	20a0      	movs	r0, #160	; 0xa0
    297c:	0140      	lsls	r0, r0, #5
    297e:	4b12      	ldr	r3, [pc, #72]	; (29c8 <chip_deinit+0x84>)
    2980:	4798      	blx	r3
    2982:	1e04      	subs	r4, r0, #0
	if (ret != M2M_SUCCESS) {
    2984:	d00a      	beq.n	299c <chip_deinit+0x58>
		M2M_ERR("failed to de-initialize\n");
    2986:	4a11      	ldr	r2, [pc, #68]	; (29cc <chip_deinit+0x88>)
    2988:	4908      	ldr	r1, [pc, #32]	; (29ac <chip_deinit+0x68>)
    298a:	4809      	ldr	r0, [pc, #36]	; (29b0 <chip_deinit+0x6c>)
    298c:	4b09      	ldr	r3, [pc, #36]	; (29b4 <chip_deinit+0x70>)
    298e:	4798      	blx	r3
    2990:	4809      	ldr	r0, [pc, #36]	; (29b8 <chip_deinit+0x74>)
    2992:	4b0a      	ldr	r3, [pc, #40]	; (29bc <chip_deinit+0x78>)
    2994:	4798      	blx	r3
    2996:	200d      	movs	r0, #13
    2998:	4b09      	ldr	r3, [pc, #36]	; (29c0 <chip_deinit+0x7c>)
    299a:	4798      	blx	r3
		goto ERR1;
	}

ERR1:
	return ret;
}
    299c:	0020      	movs	r0, r4
    299e:	b002      	add	sp, #8
    29a0:	bd10      	pop	{r4, pc}
    29a2:	46c0      	nop			; (mov r8, r8)
    29a4:	00002a01 	.word	0x00002a01
    29a8:	00000205 	.word	0x00000205
    29ac:	0000a5d4 	.word	0x0000a5d4
    29b0:	00009e44 	.word	0x00009e44
    29b4:	00008845 	.word	0x00008845
    29b8:	0000a5bc 	.word	0x0000a5bc
    29bc:	00008965 	.word	0x00008965
    29c0:	00008879 	.word	0x00008879
    29c4:	fffffbff 	.word	0xfffffbff
    29c8:	00002a0d 	.word	0x00002a0d
    29cc:	0000020b 	.word	0x0000020b

000029d0 <nm_bus_iface_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_bus_iface_init(void *pvInitVal)
{
    29d0:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_init(pvInitVal);
    29d2:	4b01      	ldr	r3, [pc, #4]	; (29d8 <nm_bus_iface_init+0x8>)
    29d4:	4798      	blx	r3
	return ret;
}
    29d6:	bd10      	pop	{r4, pc}
    29d8:	00001315 	.word	0x00001315

000029dc <nm_bus_iface_deinit>:
*	@author	Samer Sarhan
*	@date	07 April 2014
*	@version	1.0
*/
sint8 nm_bus_iface_deinit(void)
{
    29dc:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
	ret = nm_bus_deinit();
    29de:	4b01      	ldr	r3, [pc, #4]	; (29e4 <nm_bus_iface_deinit+0x8>)
    29e0:	4798      	blx	r3

	return ret;
}
    29e2:	bd10      	pop	{r4, pc}
    29e4:	00001565 	.word	0x00001565

000029e8 <nm_bus_reset>:
*	@brief	reset bus interface
*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
*	@version	1.0
*/
sint8 nm_bus_reset(void)
{
    29e8:	b510      	push	{r4, lr}
	sint8 ret = M2M_SUCCESS;
#ifdef CONF_WINC_USE_UART
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_reset();
    29ea:	4b01      	ldr	r3, [pc, #4]	; (29f0 <nm_bus_reset+0x8>)
    29ec:	4798      	blx	r3
#else
#error "Plesae define bus usage"
#endif

	return ret;
}
    29ee:	bd10      	pop	{r4, pc}
    29f0:	0000338d 	.word	0x0000338d

000029f4 <nm_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_read_reg(uint32 u32Addr)
{
    29f4:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg(u32Addr);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg(u32Addr);
    29f6:	4b01      	ldr	r3, [pc, #4]	; (29fc <nm_read_reg+0x8>)
    29f8:	4798      	blx	r3
	return nm_i2c_read_reg(u32Addr);
#else
#error "Plesae define bus usage"
#endif

}
    29fa:	bd10      	pop	{r4, pc}
    29fc:	000033c5 	.word	0x000033c5

00002a00 <nm_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    2a00:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
    2a02:	4b01      	ldr	r3, [pc, #4]	; (2a08 <nm_read_reg_with_ret+0x8>)
    2a04:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
#else
#error "Plesae define bus usage"
#endif
}
    2a06:	bd10      	pop	{r4, pc}
    2a08:	000033d9 	.word	0x000033d9

00002a0c <nm_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
{
    2a0c:	b510      	push	{r4, lr}
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_reg(u32Addr,u32Val);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_reg(u32Addr,u32Val);
    2a0e:	4b01      	ldr	r3, [pc, #4]	; (2a14 <nm_write_reg+0x8>)
    2a10:	4798      	blx	r3
#elif defined (CONF_WINC_USE_I2C)
	return nm_i2c_write_reg(u32Addr,u32Val);
#else
#error "Plesae define bus usage"
#endif
}
    2a12:	bd10      	pop	{r4, pc}
    2a14:	000033f1 	.word	0x000033f1

00002a18 <nm_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    2a18:	b5f0      	push	{r4, r5, r6, r7, lr}
    2a1a:	4657      	mov	r7, sl
    2a1c:	464e      	mov	r6, r9
    2a1e:	4645      	mov	r5, r8
    2a20:	b4e0      	push	{r5, r6, r7}
    2a22:	b082      	sub	sp, #8
    2a24:	4680      	mov	r8, r0
    2a26:	4689      	mov	r9, r1
    2a28:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    2a2a:	4b13      	ldr	r3, [pc, #76]	; (2a78 <nm_read_block+0x60>)
    2a2c:	881f      	ldrh	r7, [r3, #0]
    2a2e:	3f08      	subs	r7, #8
    2a30:	b2bb      	uxth	r3, r7
    2a32:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    2a34:	001e      	movs	r6, r3
    2a36:	0004      	movs	r4, r0
    2a38:	429a      	cmp	r2, r3
    2a3a:	d806      	bhi.n	2a4a <nm_read_block+0x32>
*	@version	1.0
*/ 
sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    2a3c:	2100      	movs	r1, #0
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    2a3e:	b2aa      	uxth	r2, r5
    2a40:	4449      	add	r1, r9
    2a42:	0020      	movs	r0, r4
    2a44:	4b0d      	ldr	r3, [pc, #52]	; (2a7c <nm_read_block+0x64>)
    2a46:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    2a48:	e010      	b.n	2a6c <nm_read_block+0x54>
static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
    2a4a:	4b0c      	ldr	r3, [pc, #48]	; (2a7c <nm_read_block+0x64>)
    2a4c:	469a      	mov	sl, r3
    2a4e:	1a37      	subs	r7, r6, r0
    2a50:	4643      	mov	r3, r8
    2a52:	1ae1      	subs	r1, r4, r3
    2a54:	4449      	add	r1, r9
    2a56:	9a01      	ldr	r2, [sp, #4]
    2a58:	0020      	movs	r0, r4
    2a5a:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    2a5c:	2800      	cmp	r0, #0
    2a5e:	d105      	bne.n	2a6c <nm_read_block+0x54>
			u32Sz -= u16MaxTrxSz;
    2a60:	1bad      	subs	r5, r5, r6
    2a62:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    2a64:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    2a66:	42b5      	cmp	r5, r6
    2a68:	d8f2      	bhi.n	2a50 <nm_read_block+0x38>
    2a6a:	e7e8      	b.n	2a3e <nm_read_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    2a6c:	b002      	add	sp, #8
    2a6e:	bc1c      	pop	{r2, r3, r4}
    2a70:	4690      	mov	r8, r2
    2a72:	4699      	mov	r9, r3
    2a74:	46a2      	mov	sl, r4
    2a76:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2a78:	2000002c 	.word	0x2000002c
    2a7c:	00003535 	.word	0x00003535

00002a80 <nm_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
    2a80:	b5f0      	push	{r4, r5, r6, r7, lr}
    2a82:	4657      	mov	r7, sl
    2a84:	464e      	mov	r6, r9
    2a86:	4645      	mov	r5, r8
    2a88:	b4e0      	push	{r5, r6, r7}
    2a8a:	b082      	sub	sp, #8
    2a8c:	4680      	mov	r8, r0
    2a8e:	4689      	mov	r9, r1
    2a90:	0015      	movs	r5, r2
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
    2a92:	4b13      	ldr	r3, [pc, #76]	; (2ae0 <nm_write_block+0x60>)
    2a94:	881f      	ldrh	r7, [r3, #0]
    2a96:	3f08      	subs	r7, #8
    2a98:	b2bb      	uxth	r3, r7
    2a9a:	9301      	str	r3, [sp, #4]
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    2a9c:	001e      	movs	r6, r3
    2a9e:	0004      	movs	r4, r0
    2aa0:	429a      	cmp	r2, r3
    2aa2:	d806      	bhi.n	2ab2 <nm_write_block+0x32>
*	@version	1.0
*/ 
sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
{
	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
	uint32 off = 0;
    2aa4:	2100      	movs	r1, #0
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    2aa6:	b2aa      	uxth	r2, r5
    2aa8:	4449      	add	r1, r9
    2aaa:	0020      	movs	r0, r4
    2aac:	4b0d      	ldr	r3, [pc, #52]	; (2ae4 <nm_write_block+0x64>)
    2aae:	4798      	blx	r3
	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
			break;
    2ab0:	e010      	b.n	2ad4 <nm_write_block+0x54>
static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
#ifdef CONF_WINC_USE_UART
	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
#elif defined (CONF_WINC_USE_SPI)
	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
    2ab2:	4b0c      	ldr	r3, [pc, #48]	; (2ae4 <nm_write_block+0x64>)
    2ab4:	469a      	mov	sl, r3
    2ab6:	1a37      	subs	r7, r6, r0
    2ab8:	4643      	mov	r3, r8
    2aba:	1ae1      	subs	r1, r4, r3
    2abc:	4449      	add	r1, r9
    2abe:	9a01      	ldr	r2, [sp, #4]
    2ac0:	0020      	movs	r0, r4
    2ac2:	47d0      	blx	sl
			break;
		}
		else
		{
			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
			if(M2M_SUCCESS != s8Ret) break;
    2ac4:	2800      	cmp	r0, #0
    2ac6:	d105      	bne.n	2ad4 <nm_write_block+0x54>
			u32Sz -= u16MaxTrxSz;
    2ac8:	1bad      	subs	r5, r5, r6
    2aca:	1939      	adds	r1, r7, r4
			off += u16MaxTrxSz;
			u32Addr += u16MaxTrxSz;
    2acc:	19a4      	adds	r4, r4, r6
	uint32 off = 0;
	sint8 s8Ret = M2M_SUCCESS;

	for(;;)
	{
		if(u32Sz <= u16MaxTrxSz)
    2ace:	42b5      	cmp	r5, r6
    2ad0:	d8f2      	bhi.n	2ab8 <nm_write_block+0x38>
    2ad2:	e7e8      	b.n	2aa6 <nm_write_block+0x26>
			u32Addr += u16MaxTrxSz;
		}
	}

	return s8Ret;
}
    2ad4:	b002      	add	sp, #8
    2ad6:	bc1c      	pop	{r2, r3, r4}
    2ad8:	4690      	mov	r8, r2
    2ada:	4699      	mov	r9, r3
    2adc:	46a2      	mov	sl, r4
    2ade:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2ae0:	2000002c 	.word	0x2000002c
    2ae4:	00003691 	.word	0x00003691

00002ae8 <nm_get_firmware_full_info>:
*	@param [out]	M2mRev
*			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
*	@version	1.0
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
    2ae8:	b570      	push	{r4, r5, r6, lr}
    2aea:	b084      	sub	sp, #16
    2aec:	0004      	movs	r4, r0
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
    2aee:	2300      	movs	r3, #0
    2af0:	9303      	str	r3, [sp, #12]
	sint8	ret = M2M_SUCCESS;
	tstrGpRegs strgp = {0};
    2af2:	2208      	movs	r2, #8
    2af4:	2100      	movs	r1, #0
    2af6:	a801      	add	r0, sp, #4
    2af8:	4b2d      	ldr	r3, [pc, #180]	; (2bb0 <nm_get_firmware_full_info+0xc8>)
    2afa:	4798      	blx	r3
	if (pstrRev != NULL)
    2afc:	2c00      	cmp	r4, #0
    2afe:	d045      	beq.n	2b8c <nm_get_firmware_full_info+0xa4>
	{
		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
    2b00:	2228      	movs	r2, #40	; 0x28
    2b02:	2100      	movs	r1, #0
    2b04:	0020      	movs	r0, r4
    2b06:	4b2b      	ldr	r3, [pc, #172]	; (2bb4 <nm_get_firmware_full_info+0xcc>)
    2b08:	4798      	blx	r3
		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
    2b0a:	a903      	add	r1, sp, #12
    2b0c:	482a      	ldr	r0, [pc, #168]	; (2bb8 <nm_get_firmware_full_info+0xd0>)
    2b0e:	4b2b      	ldr	r3, [pc, #172]	; (2bbc <nm_get_firmware_full_info+0xd4>)
    2b10:	4798      	blx	r3
		if(ret == M2M_SUCCESS)
    2b12:	2800      	cmp	r0, #0
    2b14:	d14a      	bne.n	2bac <nm_get_firmware_full_info+0xc4>
		{
			if(reg != 0)
    2b16:	9803      	ldr	r0, [sp, #12]
    2b18:	2800      	cmp	r0, #0
    2b1a:	d039      	beq.n	2b90 <nm_get_firmware_full_info+0xa8>
			{
				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
    2b1c:	23c0      	movs	r3, #192	; 0xc0
    2b1e:	029b      	lsls	r3, r3, #10
    2b20:	4318      	orrs	r0, r3
    2b22:	2208      	movs	r2, #8
    2b24:	a901      	add	r1, sp, #4
    2b26:	4b26      	ldr	r3, [pc, #152]	; (2bc0 <nm_get_firmware_full_info+0xd8>)
    2b28:	4798      	blx	r3
				if(ret == M2M_SUCCESS)
    2b2a:	2800      	cmp	r0, #0
    2b2c:	d13e      	bne.n	2bac <nm_get_firmware_full_info+0xc4>
				{
					reg = strgp.u32Firmware_Ota_rev;
					reg &= 0x0000ffff;
    2b2e:	9b02      	ldr	r3, [sp, #8]
    2b30:	0418      	lsls	r0, r3, #16
    2b32:	0c00      	lsrs	r0, r0, #16
    2b34:	9003      	str	r0, [sp, #12]
					if(reg != 0)
    2b36:	d02e      	beq.n	2b96 <nm_get_firmware_full_info+0xae>
					{
						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
    2b38:	23c0      	movs	r3, #192	; 0xc0
    2b3a:	029b      	lsls	r3, r3, #10
    2b3c:	4318      	orrs	r0, r3
    2b3e:	2228      	movs	r2, #40	; 0x28
    2b40:	0021      	movs	r1, r4
    2b42:	4b1f      	ldr	r3, [pc, #124]	; (2bc0 <nm_get_firmware_full_info+0xd8>)
    2b44:	4798      	blx	r3
						if(ret == M2M_SUCCESS)
    2b46:	2800      	cmp	r0, #0
    2b48:	d130      	bne.n	2bac <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
    2b4a:	7923      	ldrb	r3, [r4, #4]
    2b4c:	0219      	lsls	r1, r3, #8
    2b4e:	79a3      	ldrb	r3, [r4, #6]
    2b50:	250f      	movs	r5, #15
    2b52:	402b      	ands	r3, r5
    2b54:	430b      	orrs	r3, r1
    2b56:	7966      	ldrb	r6, [r4, #5]
    2b58:	0136      	lsls	r6, r6, #4
    2b5a:	22ff      	movs	r2, #255	; 0xff
    2b5c:	4016      	ands	r6, r2
    2b5e:	4333      	orrs	r3, r6
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
    2b60:	79e6      	ldrb	r6, [r4, #7]
    2b62:	0236      	lsls	r6, r6, #8
    2b64:	7a61      	ldrb	r1, [r4, #9]
    2b66:	400d      	ands	r5, r1
    2b68:	4335      	orrs	r5, r6
    2b6a:	7a21      	ldrb	r1, [r4, #8]
    2b6c:	0109      	lsls	r1, r1, #4
    2b6e:	4011      	ands	r1, r2
    2b70:	002a      	movs	r2, r5
    2b72:	430a      	orrs	r2, r1
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
    2b74:	2b00      	cmp	r3, #0
    2b76:	d011      	beq.n	2b9c <nm_get_firmware_full_info+0xb4>
    2b78:	2a00      	cmp	r2, #0
    2b7a:	d012      	beq.n	2ba2 <nm_get_firmware_full_info+0xba>
								ret = M2M_ERR_FAIL;
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
    2b7c:	4911      	ldr	r1, [pc, #68]	; (2bc4 <nm_get_firmware_full_info+0xdc>)
    2b7e:	428a      	cmp	r2, r1
    2b80:	d812      	bhi.n	2ba8 <nm_get_firmware_full_info+0xc0>
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
							if(curr_drv_ver >  curr_firm_ver) {
    2b82:	4a11      	ldr	r2, [pc, #68]	; (2bc8 <nm_get_firmware_full_info+0xe0>)
    2b84:	4293      	cmp	r3, r2
    2b86:	d811      	bhi.n	2bac <nm_get_firmware_full_info+0xc4>
								/*The current driver should be equal or less than the firmware version*/
								ret = M2M_ERR_FW_VER_MISMATCH;
    2b88:	380d      	subs	r0, #13
    2b8a:	e00f      	b.n	2bac <nm_get_firmware_full_info+0xc4>
*/
sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
{
	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
	uint32	reg = 0;
	sint8	ret = M2M_SUCCESS;
    2b8c:	2000      	movs	r0, #0
    2b8e:	e00d      	b.n	2bac <nm_get_firmware_full_info+0xc4>
					}else {
						ret = M2M_ERR_FAIL;
					}
				}
			}else{
				ret = M2M_ERR_FAIL;
    2b90:	200c      	movs	r0, #12
    2b92:	4240      	negs	r0, r0
    2b94:	e00a      	b.n	2bac <nm_get_firmware_full_info+0xc4>
								ret = M2M_ERR_FW_VER_MISMATCH;
								goto EXIT;
							}
						}
					}else {
						ret = M2M_ERR_FAIL;
    2b96:	200c      	movs	r0, #12
    2b98:	4240      	negs	r0, r0
    2b9a:	e007      	b.n	2bac <nm_get_firmware_full_info+0xc4>
						{
							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
							curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
							min_req_drv_ver = M2M_MAKE_VERSION(pstrRev->u8DriverMajor, pstrRev->u8DriverMinor,pstrRev->u8DriverPatch);
							if((curr_firm_ver == 0)||(min_req_drv_ver == 0)||(min_req_drv_ver == 0)){
								ret = M2M_ERR_FAIL;
    2b9c:	200c      	movs	r0, #12
    2b9e:	4240      	negs	r0, r0
    2ba0:	e004      	b.n	2bac <nm_get_firmware_full_info+0xc4>
    2ba2:	200c      	movs	r0, #12
    2ba4:	4240      	negs	r0, r0
    2ba6:	e001      	b.n	2bac <nm_get_firmware_full_info+0xc4>
								goto EXIT;
							}
							if(curr_drv_ver <  min_req_drv_ver) {
								/*The current driver version should be larger or equal 
								than the min driver that the current firmware support  */
								ret = M2M_ERR_FW_VER_MISMATCH;
    2ba8:	200d      	movs	r0, #13
    2baa:	4240      	negs	r0, r0
			}
		}
	}
EXIT:
	return ret;
}
    2bac:	b004      	add	sp, #16
    2bae:	bd70      	pop	{r4, r5, r6, pc}
    2bb0:	000086fd 	.word	0x000086fd
    2bb4:	000015e5 	.word	0x000015e5
    2bb8:	000c0008 	.word	0x000c0008
    2bbc:	00002a01 	.word	0x00002a01
    2bc0:	00002a19 	.word	0x00002a19
    2bc4:	00001352 	.word	0x00001352
    2bc8:	00001351 	.word	0x00001351

00002bcc <nm_drv_init>:
*	@author	M. Abdelmawla
*	@date	15 July 2012
*	@version	1.0
*/
sint8 nm_drv_init(void * arg)
{
    2bcc:	b570      	push	{r4, r5, r6, lr}
	sint8 ret = M2M_SUCCESS;
	uint8 u8Mode;
	
	if(NULL != arg) {
    2bce:	2800      	cmp	r0, #0
    2bd0:	d005      	beq.n	2bde <nm_drv_init+0x12>
		u8Mode = *((uint8 *)arg);
    2bd2:	7805      	ldrb	r5, [r0, #0]
		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
    2bd4:	1e6b      	subs	r3, r5, #1
    2bd6:	2b03      	cmp	r3, #3
    2bd8:	d902      	bls.n	2be0 <nm_drv_init+0x14>
			u8Mode = M2M_WIFI_MODE_NORMAL;
    2bda:	2501      	movs	r5, #1
    2bdc:	e000      	b.n	2be0 <nm_drv_init+0x14>
		}
	} else {
		u8Mode = M2M_WIFI_MODE_NORMAL;
    2bde:	2501      	movs	r5, #1
	}
	
	ret = nm_bus_iface_init(NULL);
    2be0:	2000      	movs	r0, #0
    2be2:	4b1f      	ldr	r3, [pc, #124]	; (2c60 <nm_drv_init+0x94>)
    2be4:	4798      	blx	r3
    2be6:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2be8:	d00c      	beq.n	2c04 <nm_drv_init+0x38>
		M2M_ERR("[nmi start]: fail init bus\n");
    2bea:	2228      	movs	r2, #40	; 0x28
    2bec:	32ff      	adds	r2, #255	; 0xff
    2bee:	491d      	ldr	r1, [pc, #116]	; (2c64 <nm_drv_init+0x98>)
    2bf0:	481d      	ldr	r0, [pc, #116]	; (2c68 <nm_drv_init+0x9c>)
    2bf2:	4b1e      	ldr	r3, [pc, #120]	; (2c6c <nm_drv_init+0xa0>)
    2bf4:	4798      	blx	r3
    2bf6:	481e      	ldr	r0, [pc, #120]	; (2c70 <nm_drv_init+0xa4>)
    2bf8:	4b1e      	ldr	r3, [pc, #120]	; (2c74 <nm_drv_init+0xa8>)
    2bfa:	4798      	blx	r3
    2bfc:	200d      	movs	r0, #13
    2bfe:	4b1e      	ldr	r3, [pc, #120]	; (2c78 <nm_drv_init+0xac>)
    2c00:	4798      	blx	r3
		goto ERR1;
    2c02:	e02b      	b.n	2c5c <nm_drv_init+0x90>
	ret = chip_reset();
	if (M2M_SUCCESS != ret) {
		goto ERR2;
	}
#endif
	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
    2c04:	481d      	ldr	r0, [pc, #116]	; (2c7c <nm_drv_init+0xb0>)
    2c06:	4c19      	ldr	r4, [pc, #100]	; (2c6c <nm_drv_init+0xa0>)
    2c08:	47a0      	blx	r4
    2c0a:	4b1d      	ldr	r3, [pc, #116]	; (2c80 <nm_drv_init+0xb4>)
    2c0c:	4798      	blx	r3
    2c0e:	0001      	movs	r1, r0
    2c10:	481c      	ldr	r0, [pc, #112]	; (2c84 <nm_drv_init+0xb8>)
    2c12:	47a0      	blx	r4
    2c14:	200d      	movs	r0, #13
    2c16:	4b18      	ldr	r3, [pc, #96]	; (2c78 <nm_drv_init+0xac>)
    2c18:	4798      	blx	r3
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_init();
    2c1a:	4b1b      	ldr	r3, [pc, #108]	; (2c88 <nm_drv_init+0xbc>)
    2c1c:	4798      	blx	r3
#endif
	ret = wait_for_bootrom(u8Mode);
    2c1e:	0028      	movs	r0, r5
    2c20:	4b1a      	ldr	r3, [pc, #104]	; (2c8c <nm_drv_init+0xc0>)
    2c22:	4798      	blx	r3
    2c24:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2c26:	d117      	bne.n	2c58 <nm_drv_init+0x8c>
		goto ERR2;
	}
		
	ret = wait_for_firmware_start(u8Mode);
    2c28:	0028      	movs	r0, r5
    2c2a:	4b19      	ldr	r3, [pc, #100]	; (2c90 <nm_drv_init+0xc4>)
    2c2c:	4798      	blx	r3
    2c2e:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2c30:	d112      	bne.n	2c58 <nm_drv_init+0x8c>
		goto ERR2;
	}
	
	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
    2c32:	1ea8      	subs	r0, r5, #2
    2c34:	2801      	cmp	r0, #1
    2c36:	d911      	bls.n	2c5c <nm_drv_init+0x90>
		goto ERR1;
	} else {
		/*continue running*/
	}
	
	ret = enable_interrupts();
    2c38:	4b16      	ldr	r3, [pc, #88]	; (2c94 <nm_drv_init+0xc8>)
    2c3a:	4798      	blx	r3
    2c3c:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2c3e:	d00d      	beq.n	2c5c <nm_drv_init+0x90>
		M2M_ERR("failed to enable interrupts..\n");
    2c40:	2256      	movs	r2, #86	; 0x56
    2c42:	32ff      	adds	r2, #255	; 0xff
    2c44:	4907      	ldr	r1, [pc, #28]	; (2c64 <nm_drv_init+0x98>)
    2c46:	4808      	ldr	r0, [pc, #32]	; (2c68 <nm_drv_init+0x9c>)
    2c48:	4b08      	ldr	r3, [pc, #32]	; (2c6c <nm_drv_init+0xa0>)
    2c4a:	4798      	blx	r3
    2c4c:	4812      	ldr	r0, [pc, #72]	; (2c98 <nm_drv_init+0xcc>)
    2c4e:	4b09      	ldr	r3, [pc, #36]	; (2c74 <nm_drv_init+0xa8>)
    2c50:	4798      	blx	r3
    2c52:	200d      	movs	r0, #13
    2c54:	4b08      	ldr	r3, [pc, #32]	; (2c78 <nm_drv_init+0xac>)
    2c56:	4798      	blx	r3
		goto ERR2;
	}
	return ret;
ERR2:
	nm_bus_iface_deinit();
    2c58:	4b10      	ldr	r3, [pc, #64]	; (2c9c <nm_drv_init+0xd0>)
    2c5a:	4798      	blx	r3
ERR1:
	return ret;
}
    2c5c:	0020      	movs	r0, r4
    2c5e:	bd70      	pop	{r4, r5, r6, pc}
    2c60:	000029d1 	.word	0x000029d1
    2c64:	0000a698 	.word	0x0000a698
    2c68:	00009e44 	.word	0x00009e44
    2c6c:	00008845 	.word	0x00008845
    2c70:	0000a5ec 	.word	0x0000a5ec
    2c74:	00008965 	.word	0x00008965
    2c78:	00008879 	.word	0x00008879
    2c7c:	00009ea8 	.word	0x00009ea8
    2c80:	000025b9 	.word	0x000025b9
    2c84:	0000a608 	.word	0x0000a608
    2c88:	00003409 	.word	0x00003409
    2c8c:	000027c5 	.word	0x000027c5
    2c90:	000028cd 	.word	0x000028cd
    2c94:	00002561 	.word	0x00002561
    2c98:	0000a618 	.word	0x0000a618
    2c9c:	000029dd 	.word	0x000029dd

00002ca0 <nm_drv_deinit>:
*	@author	M. Abdelmawla
*	@date	17 July 2012
*	@version	1.0
*/
sint8 nm_drv_deinit(void * arg)
{
    2ca0:	b510      	push	{r4, lr}
	sint8 ret;

	ret = chip_deinit();
    2ca2:	4b1c      	ldr	r3, [pc, #112]	; (2d14 <nm_drv_deinit+0x74>)
    2ca4:	4798      	blx	r3
    2ca6:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2ca8:	d00c      	beq.n	2cc4 <nm_drv_deinit+0x24>
		M2M_ERR("[nmi stop]: chip_deinit fail\n");
    2caa:	22b6      	movs	r2, #182	; 0xb6
    2cac:	0052      	lsls	r2, r2, #1
    2cae:	491a      	ldr	r1, [pc, #104]	; (2d18 <nm_drv_deinit+0x78>)
    2cb0:	481a      	ldr	r0, [pc, #104]	; (2d1c <nm_drv_deinit+0x7c>)
    2cb2:	4b1b      	ldr	r3, [pc, #108]	; (2d20 <nm_drv_deinit+0x80>)
    2cb4:	4798      	blx	r3
    2cb6:	481b      	ldr	r0, [pc, #108]	; (2d24 <nm_drv_deinit+0x84>)
    2cb8:	4b1b      	ldr	r3, [pc, #108]	; (2d28 <nm_drv_deinit+0x88>)
    2cba:	4798      	blx	r3
    2cbc:	200d      	movs	r0, #13
    2cbe:	4b1b      	ldr	r3, [pc, #108]	; (2d2c <nm_drv_deinit+0x8c>)
    2cc0:	4798      	blx	r3
		goto ERR1;
    2cc2:	e024      	b.n	2d0e <nm_drv_deinit+0x6e>
	}
	
	/* Disable SPI flash to save power when the chip is off */
	ret = spi_flash_enable(0);
    2cc4:	2000      	movs	r0, #0
    2cc6:	4b1a      	ldr	r3, [pc, #104]	; (2d30 <nm_drv_deinit+0x90>)
    2cc8:	4798      	blx	r3
    2cca:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2ccc:	d00c      	beq.n	2ce8 <nm_drv_deinit+0x48>
		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
    2cce:	2274      	movs	r2, #116	; 0x74
    2cd0:	32ff      	adds	r2, #255	; 0xff
    2cd2:	4911      	ldr	r1, [pc, #68]	; (2d18 <nm_drv_deinit+0x78>)
    2cd4:	4811      	ldr	r0, [pc, #68]	; (2d1c <nm_drv_deinit+0x7c>)
    2cd6:	4b12      	ldr	r3, [pc, #72]	; (2d20 <nm_drv_deinit+0x80>)
    2cd8:	4798      	blx	r3
    2cda:	4816      	ldr	r0, [pc, #88]	; (2d34 <nm_drv_deinit+0x94>)
    2cdc:	4b12      	ldr	r3, [pc, #72]	; (2d28 <nm_drv_deinit+0x88>)
    2cde:	4798      	blx	r3
    2ce0:	200d      	movs	r0, #13
    2ce2:	4b12      	ldr	r3, [pc, #72]	; (2d2c <nm_drv_deinit+0x8c>)
    2ce4:	4798      	blx	r3
		goto ERR1;
    2ce6:	e012      	b.n	2d0e <nm_drv_deinit+0x6e>
	}

	ret = nm_bus_iface_deinit();
    2ce8:	4b13      	ldr	r3, [pc, #76]	; (2d38 <nm_drv_deinit+0x98>)
    2cea:	4798      	blx	r3
    2cec:	1e04      	subs	r4, r0, #0
	if (M2M_SUCCESS != ret) {
    2cee:	d00c      	beq.n	2d0a <nm_drv_deinit+0x6a>
		M2M_ERR("[nmi stop]: fail init bus\n");
    2cf0:	227a      	movs	r2, #122	; 0x7a
    2cf2:	32ff      	adds	r2, #255	; 0xff
    2cf4:	4908      	ldr	r1, [pc, #32]	; (2d18 <nm_drv_deinit+0x78>)
    2cf6:	4809      	ldr	r0, [pc, #36]	; (2d1c <nm_drv_deinit+0x7c>)
    2cf8:	4b09      	ldr	r3, [pc, #36]	; (2d20 <nm_drv_deinit+0x80>)
    2cfa:	4798      	blx	r3
    2cfc:	480f      	ldr	r0, [pc, #60]	; (2d3c <nm_drv_deinit+0x9c>)
    2cfe:	4b0a      	ldr	r3, [pc, #40]	; (2d28 <nm_drv_deinit+0x88>)
    2d00:	4798      	blx	r3
    2d02:	200d      	movs	r0, #13
    2d04:	4b09      	ldr	r3, [pc, #36]	; (2d2c <nm_drv_deinit+0x8c>)
    2d06:	4798      	blx	r3
		goto ERR1;
    2d08:	e001      	b.n	2d0e <nm_drv_deinit+0x6e>
	}
#ifdef CONF_WINC_USE_SPI
	/* Must do this after global reset to set SPI data packet size. */
	nm_spi_deinit();
    2d0a:	4b0d      	ldr	r3, [pc, #52]	; (2d40 <nm_drv_deinit+0xa0>)
    2d0c:	4798      	blx	r3
#endif

ERR1:
	return ret;
}
    2d0e:	0020      	movs	r0, r4
    2d10:	bd10      	pop	{r4, pc}
    2d12:	46c0      	nop			; (mov r8, r8)
    2d14:	00002945 	.word	0x00002945
    2d18:	0000a6a4 	.word	0x0000a6a4
    2d1c:	00009e44 	.word	0x00009e44
    2d20:	00008845 	.word	0x00008845
    2d24:	0000a638 	.word	0x0000a638
    2d28:	00008965 	.word	0x00008965
    2d2c:	00008879 	.word	0x00008879
    2d30:	0000421d 	.word	0x0000421d
    2d34:	0000a658 	.word	0x0000a658
    2d38:	000029dd 	.word	0x000029dd
    2d3c:	0000a67c 	.word	0x0000a67c
    2d40:	000033b5 	.word	0x000033b5

00002d44 <nmi_spi_write>:
	spi.u16Sz = sz;
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
}

static sint8 nmi_spi_write(uint8* b, uint16 sz)
{
    2d44:	b500      	push	{lr}
    2d46:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = b;
    2d48:	ab01      	add	r3, sp, #4
    2d4a:	9001      	str	r0, [sp, #4]
	spi.pu8OutBuf = NULL;
    2d4c:	2200      	movs	r2, #0
    2d4e:	9202      	str	r2, [sp, #8]
	spi.u16Sz = sz;
    2d50:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    2d52:	0019      	movs	r1, r3
    2d54:	2003      	movs	r0, #3
    2d56:	4b02      	ldr	r3, [pc, #8]	; (2d60 <nmi_spi_write+0x1c>)
    2d58:	4798      	blx	r3
}
    2d5a:	b005      	add	sp, #20
    2d5c:	bd00      	pop	{pc}
    2d5e:	46c0      	nop			; (mov r8, r8)
    2d60:	00001419 	.word	0x00001419

00002d64 <spi_cmd>:
#define DATA_PKT_SZ_4K			(4 * 1024)
#define DATA_PKT_SZ_8K			(8 * 1024)
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
{
    2d64:	b570      	push	{r4, r5, r6, lr}
    2d66:	b084      	sub	sp, #16
    2d68:	ac08      	add	r4, sp, #32
    2d6a:	7825      	ldrb	r5, [r4, #0]
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
    2d6c:	ac01      	add	r4, sp, #4
    2d6e:	7020      	strb	r0, [r4, #0]
	switch (cmd) {
    2d70:	303f      	adds	r0, #63	; 0x3f
    2d72:	b2c4      	uxtb	r4, r0
    2d74:	2c0e      	cmp	r4, #14
    2d76:	d900      	bls.n	2d7a <spi_cmd+0x16>
    2d78:	e092      	b.n	2ea0 <spi_cmd+0x13c>
    2d7a:	00a0      	lsls	r0, r4, #2
    2d7c:	4c50      	ldr	r4, [pc, #320]	; (2ec0 <spi_cmd+0x15c>)
    2d7e:	5820      	ldr	r0, [r4, r0]
    2d80:	4687      	mov	pc, r0
	case CMD_SINGLE_READ:				/* single word (4 bytes) read */
		bc[1] = (uint8)(adr >> 16);
    2d82:	ab01      	add	r3, sp, #4
    2d84:	0c0a      	lsrs	r2, r1, #16
    2d86:	705a      	strb	r2, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    2d88:	0a0a      	lsrs	r2, r1, #8
    2d8a:	709a      	strb	r2, [r3, #2]
		bc[3] = (uint8)adr;
    2d8c:	70d9      	strb	r1, [r3, #3]
		len = 5;
    2d8e:	2105      	movs	r1, #5
		break;
    2d90:	e08e      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    2d92:	0a0b      	lsrs	r3, r1, #8
    2d94:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    2d96:	2d00      	cmp	r5, #0
    2d98:	d102      	bne.n	2da0 <spi_cmd+0x3c>
		bc[2] = (uint8)(adr >> 8);
		bc[3] = (uint8)adr;
		len = 5;
		break;
	case CMD_INTERNAL_READ:			/* internal register read */
		bc[1] = (uint8)(adr >> 8);
    2d9a:	aa01      	add	r2, sp, #4
    2d9c:	7053      	strb	r3, [r2, #1]
    2d9e:	e004      	b.n	2daa <spi_cmd+0x46>
		if(clockless)  bc[1] |= (1 << 7);
    2da0:	2280      	movs	r2, #128	; 0x80
    2da2:	4252      	negs	r2, r2
    2da4:	4313      	orrs	r3, r2
    2da6:	aa01      	add	r2, sp, #4
    2da8:	7053      	strb	r3, [r2, #1]
		bc[2] = (uint8)adr;
    2daa:	ab01      	add	r3, sp, #4
    2dac:	7099      	strb	r1, [r3, #2]
		bc[3] = 0x00;
    2dae:	2200      	movs	r2, #0
    2db0:	70da      	strb	r2, [r3, #3]
		len = 5;
    2db2:	2105      	movs	r1, #5
		break;
    2db4:	e07c      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_TERMINATE:					/* termination */
		bc[1] = 0x00;
    2db6:	ab01      	add	r3, sp, #4
    2db8:	2200      	movs	r2, #0
    2dba:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    2dbc:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    2dbe:	70da      	strb	r2, [r3, #3]
		len = 5;
    2dc0:	2105      	movs	r1, #5
		break;
    2dc2:	e075      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_REPEAT:						/* repeat */
		bc[1] = 0x00;
    2dc4:	ab01      	add	r3, sp, #4
    2dc6:	2200      	movs	r2, #0
    2dc8:	705a      	strb	r2, [r3, #1]
		bc[2] = 0x00;
    2dca:	709a      	strb	r2, [r3, #2]
		bc[3] = 0x00;
    2dcc:	70da      	strb	r2, [r3, #3]
		len = 5;
    2dce:	2105      	movs	r1, #5
		break;
    2dd0:	e06e      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_RESET:							/* reset */
		bc[1] = 0xff;
    2dd2:	ab01      	add	r3, sp, #4
    2dd4:	22ff      	movs	r2, #255	; 0xff
    2dd6:	705a      	strb	r2, [r3, #1]
		bc[2] = 0xff;
    2dd8:	709a      	strb	r2, [r3, #2]
		bc[3] = 0xff;
    2dda:	70da      	strb	r2, [r3, #3]
		len = 5;
    2ddc:	2105      	movs	r1, #5
		break;
    2dde:	e067      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_DMA_WRITE:					/* dma write */
	case CMD_DMA_READ:					/* dma read */
		bc[1] = (uint8)(adr >> 16);
    2de0:	aa01      	add	r2, sp, #4
    2de2:	0c08      	lsrs	r0, r1, #16
    2de4:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    2de6:	0a08      	lsrs	r0, r1, #8
    2de8:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    2dea:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 8);
    2dec:	0a19      	lsrs	r1, r3, #8
    2dee:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz);
    2df0:	7153      	strb	r3, [r2, #5]
		len = 7;
    2df2:	2107      	movs	r1, #7
		break;
    2df4:	e05c      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_DMA_EXT_WRITE:		/* dma extended write */
	case CMD_DMA_EXT_READ:			/* dma extended read */
		bc[1] = (uint8)(adr >> 16);
    2df6:	aa01      	add	r2, sp, #4
    2df8:	0c08      	lsrs	r0, r1, #16
    2dfa:	7050      	strb	r0, [r2, #1]
		bc[2] = (uint8)(adr >> 8);
    2dfc:	0a08      	lsrs	r0, r1, #8
    2dfe:	7090      	strb	r0, [r2, #2]
		bc[3] = (uint8)adr;
    2e00:	70d1      	strb	r1, [r2, #3]
		bc[4] = (uint8)(sz >> 16);
    2e02:	0c19      	lsrs	r1, r3, #16
    2e04:	7111      	strb	r1, [r2, #4]
		bc[5] = (uint8)(sz >> 8);
    2e06:	0a19      	lsrs	r1, r3, #8
    2e08:	7151      	strb	r1, [r2, #5]
		bc[6] = (uint8)(sz);
    2e0a:	7193      	strb	r3, [r2, #6]
		len = 8;
    2e0c:	2108      	movs	r1, #8
		break;
    2e0e:	e04f      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    2e10:	0a0b      	lsrs	r3, r1, #8
    2e12:	b2db      	uxtb	r3, r3
		if(clockless)  bc[1] |= (1 << 7);
    2e14:	2d00      	cmp	r5, #0
    2e16:	d102      	bne.n	2e1e <spi_cmd+0xba>
		bc[5] = (uint8)(sz >> 8);
		bc[6] = (uint8)(sz);
		len = 8;
		break;
	case CMD_INTERNAL_WRITE:		/* internal register write */
		bc[1] = (uint8)(adr >> 8);
    2e18:	a801      	add	r0, sp, #4
    2e1a:	7043      	strb	r3, [r0, #1]
    2e1c:	e004      	b.n	2e28 <spi_cmd+0xc4>
		if(clockless)  bc[1] |= (1 << 7);
    2e1e:	2080      	movs	r0, #128	; 0x80
    2e20:	4240      	negs	r0, r0
    2e22:	4303      	orrs	r3, r0
    2e24:	a801      	add	r0, sp, #4
    2e26:	7043      	strb	r3, [r0, #1]
		bc[2] = (uint8)(adr);
    2e28:	ab01      	add	r3, sp, #4
    2e2a:	7099      	strb	r1, [r3, #2]
		bc[3] = (uint8)(u32data >> 24);
    2e2c:	0e11      	lsrs	r1, r2, #24
    2e2e:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 16);
    2e30:	0c11      	lsrs	r1, r2, #16
    2e32:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 8);
    2e34:	0a11      	lsrs	r1, r2, #8
    2e36:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data);
    2e38:	719a      	strb	r2, [r3, #6]
		len = 8;
    2e3a:	2108      	movs	r1, #8
		break;
    2e3c:	e038      	b.n	2eb0 <spi_cmd+0x14c>
	case CMD_SINGLE_WRITE:			/* single word write */
		bc[1] = (uint8)(adr >> 16);
    2e3e:	ab01      	add	r3, sp, #4
    2e40:	0c08      	lsrs	r0, r1, #16
    2e42:	7058      	strb	r0, [r3, #1]
		bc[2] = (uint8)(adr >> 8);
    2e44:	0a08      	lsrs	r0, r1, #8
    2e46:	7098      	strb	r0, [r3, #2]
		bc[3] = (uint8)(adr);
    2e48:	70d9      	strb	r1, [r3, #3]
		bc[4] = (uint8)(u32data >> 24);
    2e4a:	0e11      	lsrs	r1, r2, #24
    2e4c:	7119      	strb	r1, [r3, #4]
		bc[5] = (uint8)(u32data >> 16);
    2e4e:	0c11      	lsrs	r1, r2, #16
    2e50:	7159      	strb	r1, [r3, #5]
		bc[6] = (uint8)(u32data >> 8);
    2e52:	0a11      	lsrs	r1, r2, #8
    2e54:	7199      	strb	r1, [r3, #6]
		bc[7] = (uint8)(u32data);
    2e56:	71da      	strb	r2, [r3, #7]
		len = 9;
    2e58:	2109      	movs	r1, #9
		break;
    2e5a:	e029      	b.n	2eb0 <spi_cmd+0x14c>
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    2e5c:	005b      	lsls	r3, r3, #1
    2e5e:	7810      	ldrb	r0, [r2, #0]
    2e60:	4043      	eors	r3, r0
    2e62:	5ce3      	ldrb	r3, [r4, r3]
    2e64:	3201      	adds	r2, #1
}

static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
{
	while (len--)
    2e66:	4295      	cmp	r5, r2
    2e68:	d1f8      	bne.n	2e5c <spi_cmd+0xf8>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    2e6a:	005b      	lsls	r3, r3, #1
    2e6c:	aa01      	add	r2, sp, #4
    2e6e:	5593      	strb	r3, [r2, r6]
    2e70:	e001      	b.n	2e76 <spi_cmd+0x112>
		else
			len-=1;
    2e72:	3901      	subs	r1, #1
    2e74:	b2c9      	uxtb	r1, r1

		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
    2e76:	b289      	uxth	r1, r1
    2e78:	a801      	add	r0, sp, #4
    2e7a:	4b12      	ldr	r3, [pc, #72]	; (2ec4 <spi_cmd+0x160>)
    2e7c:	4798      	blx	r3
    2e7e:	2301      	movs	r3, #1
    2e80:	2800      	cmp	r0, #0
    2e82:	d01a      	beq.n	2eba <spi_cmd+0x156>
			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
    2e84:	2228      	movs	r2, #40	; 0x28
    2e86:	32ff      	adds	r2, #255	; 0xff
    2e88:	490f      	ldr	r1, [pc, #60]	; (2ec8 <spi_cmd+0x164>)
    2e8a:	4810      	ldr	r0, [pc, #64]	; (2ecc <spi_cmd+0x168>)
    2e8c:	4b10      	ldr	r3, [pc, #64]	; (2ed0 <spi_cmd+0x16c>)
    2e8e:	4798      	blx	r3
    2e90:	4810      	ldr	r0, [pc, #64]	; (2ed4 <spi_cmd+0x170>)
    2e92:	4b11      	ldr	r3, [pc, #68]	; (2ed8 <spi_cmd+0x174>)
    2e94:	4798      	blx	r3
    2e96:	200d      	movs	r0, #13
    2e98:	4b10      	ldr	r3, [pc, #64]	; (2edc <spi_cmd+0x178>)
    2e9a:	4798      	blx	r3
			result = N_FAIL;
    2e9c:	2300      	movs	r3, #0
    2e9e:	e00c      	b.n	2eba <spi_cmd+0x156>
	uint8 bc[9];
	uint8 len = 5;
	sint8 result = N_OK;

	bc[0] = cmd;
	switch (cmd) {
    2ea0:	2300      	movs	r3, #0
    2ea2:	e00a      	b.n	2eba <spi_cmd+0x156>
		break;
	}

	if (result) {
		if (!gu8Crc_off)
			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
    2ea4:	1e4e      	subs	r6, r1, #1
    2ea6:	aa01      	add	r2, sp, #4
    2ea8:	1995      	adds	r5, r2, r6
    2eaa:	237f      	movs	r3, #127	; 0x7f
};


static uint8 crc7_byte(uint8 crc, uint8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
    2eac:	4c0c      	ldr	r4, [pc, #48]	; (2ee0 <spi_cmd+0x17c>)
    2eae:	e7d5      	b.n	2e5c <spi_cmd+0xf8>
		result = N_FAIL;
		break;
	}

	if (result) {
		if (!gu8Crc_off)
    2eb0:	4b0c      	ldr	r3, [pc, #48]	; (2ee4 <spi_cmd+0x180>)
    2eb2:	781b      	ldrb	r3, [r3, #0]
    2eb4:	2b00      	cmp	r3, #0
    2eb6:	d1dc      	bne.n	2e72 <spi_cmd+0x10e>
    2eb8:	e7f4      	b.n	2ea4 <spi_cmd+0x140>
			result = N_FAIL;
		}
	}

	return result;
}
    2eba:	0018      	movs	r0, r3
    2ebc:	b004      	add	sp, #16
    2ebe:	bd70      	pop	{r4, r5, r6, pc}
    2ec0:	0000a6b4 	.word	0x0000a6b4
    2ec4:	00002d45 	.word	0x00002d45
    2ec8:	0000a704 	.word	0x0000a704
    2ecc:	00009e44 	.word	0x00009e44
    2ed0:	00008845 	.word	0x00008845
    2ed4:	0000a754 	.word	0x0000a754
    2ed8:	00008965 	.word	0x00008965
    2edc:	00008879 	.word	0x00008879
    2ee0:	0000acb8 	.word	0x0000acb8
    2ee4:	20000120 	.word	0x20000120

00002ee8 <nmi_spi_read>:
#define DATA_PKT_SZ				DATA_PKT_SZ_8K

static uint8 	gu8Crc_off	=   0;

static sint8 nmi_spi_read(uint8* b, uint16 sz)
{
    2ee8:	b500      	push	{lr}
    2eea:	b085      	sub	sp, #20
	tstrNmSpiRw spi;
	spi.pu8InBuf = NULL;
    2eec:	ab01      	add	r3, sp, #4
    2eee:	2200      	movs	r2, #0
    2ef0:	9201      	str	r2, [sp, #4]
	spi.pu8OutBuf = b;
    2ef2:	9002      	str	r0, [sp, #8]
	spi.u16Sz = sz;
    2ef4:	8119      	strh	r1, [r3, #8]
	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
    2ef6:	0019      	movs	r1, r3
    2ef8:	2003      	movs	r0, #3
    2efa:	4b02      	ldr	r3, [pc, #8]	; (2f04 <nmi_spi_read+0x1c>)
    2efc:	4798      	blx	r3
}
    2efe:	b005      	add	sp, #20
    2f00:	bd00      	pop	{pc}
    2f02:	46c0      	nop			; (mov r8, r8)
    2f04:	00001419 	.word	0x00001419

00002f08 <spi_cmd_rsp>:

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    2f08:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f0a:	b083      	sub	sp, #12
    2f0c:	1e06      	subs	r6, r0, #0
	sint8 s8RetryCnt;

	/**
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
    2f0e:	2ecf      	cmp	r6, #207	; 0xcf
    2f10:	d004      	beq.n	2f1c <spi_cmd_rsp+0x14>
    2f12:	0003      	movs	r3, r0
    2f14:	333b      	adds	r3, #59	; 0x3b
    2f16:	b2db      	uxtb	r3, r3
    2f18:	2b01      	cmp	r3, #1
    2f1a:	d807      	bhi.n	2f2c <spi_cmd_rsp+0x24>
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2f1c:	2101      	movs	r1, #1
    2f1e:	466b      	mov	r3, sp
    2f20:	1dd8      	adds	r0, r3, #7
    2f22:	4b24      	ldr	r3, [pc, #144]	; (2fb4 <spi_cmd_rsp+0xac>)
    2f24:	4798      	blx	r3
			result = N_FAIL;
    2f26:	2300      	movs	r3, #0
		Command/Control response
	**/
	if ((cmd == CMD_RESET) ||
		 (cmd == CMD_TERMINATE) ||
		 (cmd == CMD_REPEAT)) {
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2f28:	2800      	cmp	r0, #0
    2f2a:	d140      	bne.n	2fae <spi_cmd_rsp+0xa6>

	return result;
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
    2f2c:	240b      	movs	r4, #11

	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2f2e:	466b      	mov	r3, sp
    2f30:	1ddd      	adds	r5, r3, #7
    2f32:	4f20      	ldr	r7, [pc, #128]	; (2fb4 <spi_cmd_rsp+0xac>)
    2f34:	2101      	movs	r1, #1
    2f36:	0028      	movs	r0, r5
    2f38:	47b8      	blx	r7
    2f3a:	2800      	cmp	r0, #0
    2f3c:	d00d      	beq.n	2f5a <spi_cmd_rsp+0x52>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    2f3e:	22b1      	movs	r2, #177	; 0xb1
    2f40:	0052      	lsls	r2, r2, #1
    2f42:	491d      	ldr	r1, [pc, #116]	; (2fb8 <spi_cmd_rsp+0xb0>)
    2f44:	481d      	ldr	r0, [pc, #116]	; (2fbc <spi_cmd_rsp+0xb4>)
    2f46:	4b1e      	ldr	r3, [pc, #120]	; (2fc0 <spi_cmd_rsp+0xb8>)
    2f48:	4798      	blx	r3
    2f4a:	481e      	ldr	r0, [pc, #120]	; (2fc4 <spi_cmd_rsp+0xbc>)
    2f4c:	4b1e      	ldr	r3, [pc, #120]	; (2fc8 <spi_cmd_rsp+0xc0>)
    2f4e:	4798      	blx	r3
    2f50:	200d      	movs	r0, #13
    2f52:	4b1e      	ldr	r3, [pc, #120]	; (2fcc <spi_cmd_rsp+0xc4>)
    2f54:	4798      	blx	r3
			result = N_FAIL;
    2f56:	2300      	movs	r3, #0
			goto _fail_;
    2f58:	e029      	b.n	2fae <spi_cmd_rsp+0xa6>
		}
	} while((rsp != cmd) && (s8RetryCnt-- >0));
    2f5a:	782b      	ldrb	r3, [r5, #0]
    2f5c:	42b3      	cmp	r3, r6
    2f5e:	d005      	beq.n	2f6c <spi_cmd_rsp+0x64>
    2f60:	3c01      	subs	r4, #1
    2f62:	b2e4      	uxtb	r4, r4
    2f64:	2c00      	cmp	r4, #0
    2f66:	d1e5      	bne.n	2f34 <spi_cmd_rsp+0x2c>
    2f68:	340b      	adds	r4, #11
    2f6a:	e000      	b.n	2f6e <spi_cmd_rsp+0x66>
    2f6c:	240b      	movs	r4, #11
	**/
	/* wait for response */
	s8RetryCnt = SPI_RESP_RETRY_COUNT;
	do
	{
		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2f6e:	466b      	mov	r3, sp
    2f70:	1ddd      	adds	r5, r3, #7
    2f72:	4e10      	ldr	r6, [pc, #64]	; (2fb4 <spi_cmd_rsp+0xac>)
    2f74:	2101      	movs	r1, #1
    2f76:	0028      	movs	r0, r5
    2f78:	47b0      	blx	r6
    2f7a:	2800      	cmp	r0, #0
    2f7c:	d00d      	beq.n	2f9a <spi_cmd_rsp+0x92>
			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
    2f7e:	22b8      	movs	r2, #184	; 0xb8
    2f80:	0052      	lsls	r2, r2, #1
    2f82:	490d      	ldr	r1, [pc, #52]	; (2fb8 <spi_cmd_rsp+0xb0>)
    2f84:	480d      	ldr	r0, [pc, #52]	; (2fbc <spi_cmd_rsp+0xb4>)
    2f86:	4b0e      	ldr	r3, [pc, #56]	; (2fc0 <spi_cmd_rsp+0xb8>)
    2f88:	4798      	blx	r3
    2f8a:	480e      	ldr	r0, [pc, #56]	; (2fc4 <spi_cmd_rsp+0xbc>)
    2f8c:	4b0e      	ldr	r3, [pc, #56]	; (2fc8 <spi_cmd_rsp+0xc0>)
    2f8e:	4798      	blx	r3
    2f90:	200d      	movs	r0, #13
    2f92:	4b0e      	ldr	r3, [pc, #56]	; (2fcc <spi_cmd_rsp+0xc4>)
    2f94:	4798      	blx	r3
			result = N_FAIL;
    2f96:	2300      	movs	r3, #0
			goto _fail_;
    2f98:	e009      	b.n	2fae <spi_cmd_rsp+0xa6>
		}
	} while((rsp != 0x00) && (s8RetryCnt-- >0));
    2f9a:	782b      	ldrb	r3, [r5, #0]
    2f9c:	2b00      	cmp	r3, #0
    2f9e:	d005      	beq.n	2fac <spi_cmd_rsp+0xa4>
    2fa0:	3c01      	subs	r4, #1
    2fa2:	b2e4      	uxtb	r4, r4
    2fa4:	2c00      	cmp	r4, #0
    2fa6:	d1e5      	bne.n	2f74 <spi_cmd_rsp+0x6c>
}

static sint8 spi_cmd_rsp(uint8 cmd)
{
	uint8 rsp;
	sint8 result = N_OK;
    2fa8:	2301      	movs	r3, #1
    2faa:	e000      	b.n	2fae <spi_cmd_rsp+0xa6>
    2fac:	2301      	movs	r3, #1
	} while((rsp != 0x00) && (s8RetryCnt-- >0));

_fail_:

	return result;
}
    2fae:	0018      	movs	r0, r3
    2fb0:	b003      	add	sp, #12
    2fb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2fb4:	00002ee9 	.word	0x00002ee9
    2fb8:	0000a748 	.word	0x0000a748
    2fbc:	00009e44 	.word	0x00009e44
    2fc0:	00008845 	.word	0x00008845
    2fc4:	0000a780 	.word	0x0000a780
    2fc8:	00008965 	.word	0x00008965
    2fcc:	00008879 	.word	0x00008879

00002fd0 <spi_data_read>:
_error_:
	return result;
}
#endif
static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
{
    2fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fd2:	465f      	mov	r7, fp
    2fd4:	4656      	mov	r6, sl
    2fd6:	464d      	mov	r5, r9
    2fd8:	4644      	mov	r4, r8
    2fda:	b4f0      	push	{r4, r5, r6, r7}
    2fdc:	b083      	sub	sp, #12
    2fde:	4682      	mov	sl, r0
    2fe0:	4689      	mov	r9, r1
    2fe2:	4693      	mov	fp, r2
	uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    2fe4:	2300      	movs	r3, #0
    2fe6:	4698      	mov	r8, r3
		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2fe8:	4f3c      	ldr	r7, [pc, #240]	; (30dc <spi_data_read+0x10c>)
	/**
		Data
	**/
	ix = 0;
	do {
		if (sz <= DATA_PKT_SZ)
    2fea:	2380      	movs	r3, #128	; 0x80
    2fec:	019b      	lsls	r3, r3, #6
    2fee:	4599      	cmp	r9, r3
    2ff0:	d802      	bhi.n	2ff8 <spi_data_read+0x28>
			nbytes = sz;
    2ff2:	464b      	mov	r3, r9
    2ff4:	b21e      	sxth	r6, r3
    2ff6:	e001      	b.n	2ffc <spi_data_read+0x2c>
		else
			nbytes = DATA_PKT_SZ;
    2ff8:	2680      	movs	r6, #128	; 0x80
    2ffa:	01b6      	lsls	r6, r6, #6

		/**
			Data Respnose header
		**/
		retry = SPI_RESP_RETRY_COUNT;
    2ffc:	240a      	movs	r4, #10
		do {
			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
    2ffe:	466b      	mov	r3, sp
    3000:	1cdd      	adds	r5, r3, #3
    3002:	2101      	movs	r1, #1
    3004:	0028      	movs	r0, r5
    3006:	47b8      	blx	r7
    3008:	2800      	cmp	r0, #0
    300a:	d00c      	beq.n	3026 <spi_data_read+0x56>
				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
    300c:	4a34      	ldr	r2, [pc, #208]	; (30e0 <spi_data_read+0x110>)
    300e:	4935      	ldr	r1, [pc, #212]	; (30e4 <spi_data_read+0x114>)
    3010:	4835      	ldr	r0, [pc, #212]	; (30e8 <spi_data_read+0x118>)
    3012:	4b36      	ldr	r3, [pc, #216]	; (30ec <spi_data_read+0x11c>)
    3014:	4798      	blx	r3
    3016:	4836      	ldr	r0, [pc, #216]	; (30f0 <spi_data_read+0x120>)
    3018:	4b36      	ldr	r3, [pc, #216]	; (30f4 <spi_data_read+0x124>)
    301a:	4798      	blx	r3
    301c:	200d      	movs	r0, #13
    301e:	4b36      	ldr	r3, [pc, #216]	; (30f8 <spi_data_read+0x128>)
    3020:	4798      	blx	r3
    3022:	2000      	movs	r0, #0
    3024:	e053      	b.n	30ce <spi_data_read+0xfe>
				result = N_FAIL;
				break;
			}
			if (((rsp >> 4) & 0xf) == 0xf)
    3026:	782b      	ldrb	r3, [r5, #0]
    3028:	091b      	lsrs	r3, r3, #4
    302a:	2b0f      	cmp	r3, #15
    302c:	d004      	beq.n	3038 <spi_data_read+0x68>
    302e:	3c01      	subs	r4, #1
    3030:	b224      	sxth	r4, r4
				break;
		} while (retry--);
    3032:	1c63      	adds	r3, r4, #1
    3034:	d1e5      	bne.n	3002 <spi_data_read+0x32>
    3036:	e001      	b.n	303c <spi_data_read+0x6c>

		if (result == N_FAIL)
			break;

		if (retry <= 0) {
    3038:	2c00      	cmp	r4, #0
    303a:	dc0d      	bgt.n	3058 <spi_data_read+0x88>
			M2M_ERR("[nmi spi]: Failed data response read...(%02x)\n", rsp);
    303c:	4a2f      	ldr	r2, [pc, #188]	; (30fc <spi_data_read+0x12c>)
    303e:	4929      	ldr	r1, [pc, #164]	; (30e4 <spi_data_read+0x114>)
    3040:	4829      	ldr	r0, [pc, #164]	; (30e8 <spi_data_read+0x118>)
    3042:	4c2a      	ldr	r4, [pc, #168]	; (30ec <spi_data_read+0x11c>)
    3044:	47a0      	blx	r4
    3046:	466b      	mov	r3, sp
    3048:	78d9      	ldrb	r1, [r3, #3]
    304a:	482d      	ldr	r0, [pc, #180]	; (3100 <spi_data_read+0x130>)
    304c:	47a0      	blx	r4
    304e:	200d      	movs	r0, #13
    3050:	4b29      	ldr	r3, [pc, #164]	; (30f8 <spi_data_read+0x128>)
    3052:	4798      	blx	r3
			result = N_FAIL;
    3054:	2000      	movs	r0, #0
			break;
    3056:	e03a      	b.n	30ce <spi_data_read+0xfe>
		}

		/**
			Read bytes
		**/
		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
    3058:	b2b6      	uxth	r6, r6
    305a:	4650      	mov	r0, sl
    305c:	4440      	add	r0, r8
    305e:	0031      	movs	r1, r6
    3060:	4b1e      	ldr	r3, [pc, #120]	; (30dc <spi_data_read+0x10c>)
    3062:	4798      	blx	r3
    3064:	2800      	cmp	r0, #0
    3066:	d00d      	beq.n	3084 <spi_data_read+0xb4>
			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
    3068:	22c5      	movs	r2, #197	; 0xc5
    306a:	0092      	lsls	r2, r2, #2
    306c:	491d      	ldr	r1, [pc, #116]	; (30e4 <spi_data_read+0x114>)
    306e:	481e      	ldr	r0, [pc, #120]	; (30e8 <spi_data_read+0x118>)
    3070:	4b1e      	ldr	r3, [pc, #120]	; (30ec <spi_data_read+0x11c>)
    3072:	4798      	blx	r3
    3074:	4823      	ldr	r0, [pc, #140]	; (3104 <spi_data_read+0x134>)
    3076:	4b1f      	ldr	r3, [pc, #124]	; (30f4 <spi_data_read+0x124>)
    3078:	4798      	blx	r3
    307a:	200d      	movs	r0, #13
    307c:	4b1e      	ldr	r3, [pc, #120]	; (30f8 <spi_data_read+0x128>)
    307e:	4798      	blx	r3
			result = N_FAIL;
    3080:	2000      	movs	r0, #0
			break;
    3082:	e024      	b.n	30ce <spi_data_read+0xfe>
		}
		if(!clockless)
    3084:	465b      	mov	r3, fp
    3086:	2b00      	cmp	r3, #0
    3088:	d116      	bne.n	30b8 <spi_data_read+0xe8>
		{
			/**
			Read Crc
			**/
			if (!gu8Crc_off) {
    308a:	4b1f      	ldr	r3, [pc, #124]	; (3108 <spi_data_read+0x138>)
    308c:	781b      	ldrb	r3, [r3, #0]
    308e:	2b00      	cmp	r3, #0
    3090:	d112      	bne.n	30b8 <spi_data_read+0xe8>
				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
    3092:	2102      	movs	r1, #2
    3094:	a801      	add	r0, sp, #4
    3096:	4b11      	ldr	r3, [pc, #68]	; (30dc <spi_data_read+0x10c>)
    3098:	4798      	blx	r3
    309a:	2800      	cmp	r0, #0
    309c:	d00c      	beq.n	30b8 <spi_data_read+0xe8>
					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
    309e:	4a1b      	ldr	r2, [pc, #108]	; (310c <spi_data_read+0x13c>)
    30a0:	4910      	ldr	r1, [pc, #64]	; (30e4 <spi_data_read+0x114>)
    30a2:	4811      	ldr	r0, [pc, #68]	; (30e8 <spi_data_read+0x118>)
    30a4:	4b11      	ldr	r3, [pc, #68]	; (30ec <spi_data_read+0x11c>)
    30a6:	4798      	blx	r3
    30a8:	4819      	ldr	r0, [pc, #100]	; (3110 <spi_data_read+0x140>)
    30aa:	4b12      	ldr	r3, [pc, #72]	; (30f4 <spi_data_read+0x124>)
    30ac:	4798      	blx	r3
    30ae:	200d      	movs	r0, #13
    30b0:	4b11      	ldr	r3, [pc, #68]	; (30f8 <spi_data_read+0x128>)
    30b2:	4798      	blx	r3
					result = N_FAIL;
    30b4:	2000      	movs	r0, #0
					break;
    30b6:	e00a      	b.n	30ce <spi_data_read+0xfe>
				}
			}
		}
		ix += nbytes;
    30b8:	4643      	mov	r3, r8
    30ba:	18f3      	adds	r3, r6, r3
    30bc:	b21b      	sxth	r3, r3
    30be:	4698      	mov	r8, r3
		sz -= nbytes;
    30c0:	464b      	mov	r3, r9
    30c2:	1b9e      	subs	r6, r3, r6
    30c4:	b2b3      	uxth	r3, r6
    30c6:	4699      	mov	r9, r3

	} while (sz);
    30c8:	2b00      	cmp	r3, #0
    30ca:	d18e      	bne.n	2fea <spi_data_read+0x1a>
    30cc:	2001      	movs	r0, #1

	return result;
}
    30ce:	b003      	add	sp, #12
    30d0:	bc3c      	pop	{r2, r3, r4, r5}
    30d2:	4690      	mov	r8, r2
    30d4:	4699      	mov	r9, r3
    30d6:	46a2      	mov	sl, r4
    30d8:	46ab      	mov	fp, r5
    30da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    30dc:	00002ee9 	.word	0x00002ee9
    30e0:	000002ff 	.word	0x000002ff
    30e4:	0000aca8 	.word	0x0000aca8
    30e8:	00009e44 	.word	0x00009e44
    30ec:	00008845 	.word	0x00008845
    30f0:	0000a7b4 	.word	0x0000a7b4
    30f4:	00008965 	.word	0x00008965
    30f8:	00008879 	.word	0x00008879
    30fc:	0000030b 	.word	0x0000030b
    3100:	0000a7e8 	.word	0x0000a7e8
    3104:	0000a818 	.word	0x0000a818
    3108:	20000120 	.word	0x20000120
    310c:	0000031f 	.word	0x0000031f
    3110:	0000a848 	.word	0x0000a848

00003114 <spi_write_reg>:
	Spi interfaces

********************************************/

static sint8 spi_write_reg(uint32 addr, uint32 u32data)
{
    3114:	b5f0      	push	{r4, r5, r6, r7, lr}
    3116:	4657      	mov	r7, sl
    3118:	464e      	mov	r6, r9
    311a:	4645      	mov	r5, r8
    311c:	b4e0      	push	{r5, r6, r7}
    311e:	b086      	sub	sp, #24
    3120:	9003      	str	r0, [sp, #12]
    3122:	9104      	str	r1, [sp, #16]
    3124:	2830      	cmp	r0, #48	; 0x30
    3126:	d802      	bhi.n	312e <spi_write_reg+0x1a>
    3128:	4b30      	ldr	r3, [pc, #192]	; (31ec <spi_write_reg+0xd8>)
    312a:	781f      	ldrb	r7, [r3, #0]
    312c:	e001      	b.n	3132 <spi_write_reg+0x1e>
    312e:	4b30      	ldr	r3, [pc, #192]	; (31f0 <spi_write_reg+0xdc>)
    3130:	781f      	ldrb	r7, [r3, #0]
    3132:	b2fb      	uxtb	r3, r7
    3134:	9305      	str	r3, [sp, #20]
    3136:	2300      	movs	r3, #0
    3138:	2230      	movs	r2, #48	; 0x30
    313a:	9903      	ldr	r1, [sp, #12]
    313c:	428a      	cmp	r2, r1
    313e:	415b      	adcs	r3, r3
    3140:	b2db      	uxtb	r3, r3
    3142:	469a      	mov	sl, r3
    3144:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    3146:	4b2b      	ldr	r3, [pc, #172]	; (31f4 <spi_write_reg+0xe0>)
    3148:	4698      	mov	r8, r3
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    314a:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_WRITE;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, u32data, 4, clockless);
    314c:	464b      	mov	r3, r9
    314e:	9300      	str	r3, [sp, #0]
    3150:	2304      	movs	r3, #4
    3152:	9a04      	ldr	r2, [sp, #16]
    3154:	9f03      	ldr	r7, [sp, #12]
    3156:	0039      	movs	r1, r7
    3158:	9805      	ldr	r0, [sp, #20]
    315a:	47c0      	blx	r8
    315c:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    315e:	2c01      	cmp	r4, #1
    3160:	d00b      	beq.n	317a <spi_write_reg+0x66>
		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
    3162:	4a25      	ldr	r2, [pc, #148]	; (31f8 <spi_write_reg+0xe4>)
    3164:	4925      	ldr	r1, [pc, #148]	; (31fc <spi_write_reg+0xe8>)
    3166:	4826      	ldr	r0, [pc, #152]	; (3200 <spi_write_reg+0xec>)
    3168:	4e26      	ldr	r6, [pc, #152]	; (3204 <spi_write_reg+0xf0>)
    316a:	47b0      	blx	r6
    316c:	0039      	movs	r1, r7
    316e:	4826      	ldr	r0, [pc, #152]	; (3208 <spi_write_reg+0xf4>)
    3170:	47b0      	blx	r6
    3172:	200d      	movs	r0, #13
    3174:	4b25      	ldr	r3, [pc, #148]	; (320c <spi_write_reg+0xf8>)
    3176:	4798      	blx	r3
		goto _FAIL_;
    3178:	e011      	b.n	319e <spi_write_reg+0x8a>
	}

	result = spi_cmd_rsp(cmd);
    317a:	9805      	ldr	r0, [sp, #20]
    317c:	4b24      	ldr	r3, [pc, #144]	; (3210 <spi_write_reg+0xfc>)
    317e:	4798      	blx	r3
    3180:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    3182:	2c01      	cmp	r4, #1
    3184:	d02a      	beq.n	31dc <spi_write_reg+0xc8>
		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
    3186:	22e7      	movs	r2, #231	; 0xe7
    3188:	0092      	lsls	r2, r2, #2
    318a:	491c      	ldr	r1, [pc, #112]	; (31fc <spi_write_reg+0xe8>)
    318c:	481c      	ldr	r0, [pc, #112]	; (3200 <spi_write_reg+0xec>)
    318e:	4e1d      	ldr	r6, [pc, #116]	; (3204 <spi_write_reg+0xf0>)
    3190:	47b0      	blx	r6
    3192:	9903      	ldr	r1, [sp, #12]
    3194:	481f      	ldr	r0, [pc, #124]	; (3214 <spi_write_reg+0x100>)
    3196:	47b0      	blx	r6
    3198:	200d      	movs	r0, #13
    319a:	4b1c      	ldr	r3, [pc, #112]	; (320c <spi_write_reg+0xf8>)
    319c:	4798      	blx	r3

#endif
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    319e:	2001      	movs	r0, #1
    31a0:	4e1d      	ldr	r6, [pc, #116]	; (3218 <spi_write_reg+0x104>)
    31a2:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    31a4:	2300      	movs	r3, #0
    31a6:	9300      	str	r3, [sp, #0]
    31a8:	2200      	movs	r2, #0
    31aa:	2100      	movs	r1, #0
    31ac:	20cf      	movs	r0, #207	; 0xcf
    31ae:	4f11      	ldr	r7, [pc, #68]	; (31f4 <spi_write_reg+0xe0>)
    31b0:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    31b2:	20cf      	movs	r0, #207	; 0xcf
    31b4:	4b16      	ldr	r3, [pc, #88]	; (3210 <spi_write_reg+0xfc>)
    31b6:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %lx\n",retry,addr,u32data);
    31b8:	4a18      	ldr	r2, [pc, #96]	; (321c <spi_write_reg+0x108>)
    31ba:	4910      	ldr	r1, [pc, #64]	; (31fc <spi_write_reg+0xe8>)
    31bc:	4810      	ldr	r0, [pc, #64]	; (3200 <spi_write_reg+0xec>)
    31be:	4f11      	ldr	r7, [pc, #68]	; (3204 <spi_write_reg+0xf0>)
    31c0:	47b8      	blx	r7
    31c2:	9b04      	ldr	r3, [sp, #16]
    31c4:	9a03      	ldr	r2, [sp, #12]
    31c6:	0029      	movs	r1, r5
    31c8:	4815      	ldr	r0, [pc, #84]	; (3220 <spi_write_reg+0x10c>)
    31ca:	47b8      	blx	r7
    31cc:	200d      	movs	r0, #13
    31ce:	4b0f      	ldr	r3, [pc, #60]	; (320c <spi_write_reg+0xf8>)
    31d0:	4798      	blx	r3
		nm_bsp_sleep(1);
    31d2:	2001      	movs	r0, #1
    31d4:	47b0      	blx	r6
    31d6:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    31d8:	2d00      	cmp	r5, #0
    31da:	d1b7      	bne.n	314c <spi_write_reg+0x38>
	}

	return result;
}
    31dc:	0020      	movs	r0, r4
    31de:	b006      	add	sp, #24
    31e0:	bc1c      	pop	{r2, r3, r4}
    31e2:	4690      	mov	r8, r2
    31e4:	4699      	mov	r9, r3
    31e6:	46a2      	mov	sl, r4
    31e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    31ea:	46c0      	nop			; (mov r8, r8)
    31ec:	0000a6f0 	.word	0x0000a6f0
    31f0:	0000a6f1 	.word	0x0000a6f1
    31f4:	00002d65 	.word	0x00002d65
    31f8:	00000396 	.word	0x00000396
    31fc:	0000a71c 	.word	0x0000a71c
    3200:	00009e44 	.word	0x00009e44
    3204:	00008845 	.word	0x00008845
    3208:	0000a87c 	.word	0x0000a87c
    320c:	00008879 	.word	0x00008879
    3210:	00002f09 	.word	0x00002f09
    3214:	0000a8a8 	.word	0x0000a8a8
    3218:	000011d5 	.word	0x000011d5
    321c:	000003af 	.word	0x000003af
    3220:	0000a8e0 	.word	0x0000a8e0

00003224 <spi_read_reg>:

	return result;
}

static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
{
    3224:	b5f0      	push	{r4, r5, r6, r7, lr}
    3226:	465f      	mov	r7, fp
    3228:	4656      	mov	r6, sl
    322a:	464d      	mov	r5, r9
    322c:	4644      	mov	r4, r8
    322e:	b4f0      	push	{r4, r5, r6, r7}
    3230:	b087      	sub	sp, #28
    3232:	9002      	str	r0, [sp, #8]
    3234:	468b      	mov	fp, r1
    3236:	28ff      	cmp	r0, #255	; 0xff
    3238:	d802      	bhi.n	3240 <spi_read_reg+0x1c>
    323a:	4b41      	ldr	r3, [pc, #260]	; (3340 <spi_read_reg+0x11c>)
    323c:	781f      	ldrb	r7, [r3, #0]
    323e:	e001      	b.n	3244 <spi_read_reg+0x20>
    3240:	4b40      	ldr	r3, [pc, #256]	; (3344 <spi_read_reg+0x120>)
    3242:	781f      	ldrb	r7, [r3, #0]
    3244:	b2fb      	uxtb	r3, r7
    3246:	9303      	str	r3, [sp, #12]
    3248:	2300      	movs	r3, #0
    324a:	22ff      	movs	r2, #255	; 0xff
    324c:	9902      	ldr	r1, [sp, #8]
    324e:	428a      	cmp	r2, r1
    3250:	415b      	adcs	r3, r3
    3252:	b2db      	uxtb	r3, r3
    3254:	469a      	mov	sl, r3
    3256:	250a      	movs	r5, #10
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    3258:	4b3b      	ldr	r3, [pc, #236]	; (3348 <spi_read_reg+0x124>)
    325a:	4698      	mov	r8, r3
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    325c:	46d1      	mov	r9, sl
		cmd = CMD_SINGLE_READ;
		clockless = 0;
	}

#if defined USE_OLD_SPI_SW
	result = spi_cmd(cmd, addr, 0, 4, clockless);
    325e:	464b      	mov	r3, r9
    3260:	9300      	str	r3, [sp, #0]
    3262:	2304      	movs	r3, #4
    3264:	2200      	movs	r2, #0
    3266:	9f02      	ldr	r7, [sp, #8]
    3268:	0039      	movs	r1, r7
    326a:	9803      	ldr	r0, [sp, #12]
    326c:	47c0      	blx	r8
    326e:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    3270:	2c01      	cmp	r4, #1
    3272:	d00b      	beq.n	328c <spi_read_reg+0x68>
		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
    3274:	4a35      	ldr	r2, [pc, #212]	; (334c <spi_read_reg+0x128>)
    3276:	4936      	ldr	r1, [pc, #216]	; (3350 <spi_read_reg+0x12c>)
    3278:	4836      	ldr	r0, [pc, #216]	; (3354 <spi_read_reg+0x130>)
    327a:	4e37      	ldr	r6, [pc, #220]	; (3358 <spi_read_reg+0x134>)
    327c:	47b0      	blx	r6
    327e:	0039      	movs	r1, r7
    3280:	4836      	ldr	r0, [pc, #216]	; (335c <spi_read_reg+0x138>)
    3282:	47b0      	blx	r6
    3284:	200d      	movs	r0, #13
    3286:	4b36      	ldr	r3, [pc, #216]	; (3360 <spi_read_reg+0x13c>)
    3288:	4798      	blx	r3
		goto _FAIL_;
    328a:	e033      	b.n	32f4 <spi_read_reg+0xd0>
	}

	result = spi_cmd_rsp(cmd);
    328c:	9803      	ldr	r0, [sp, #12]
    328e:	4b35      	ldr	r3, [pc, #212]	; (3364 <spi_read_reg+0x140>)
    3290:	4798      	blx	r3
    3292:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    3294:	2c01      	cmp	r4, #1
    3296:	d00b      	beq.n	32b0 <spi_read_reg+0x8c>
		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
    3298:	4a33      	ldr	r2, [pc, #204]	; (3368 <spi_read_reg+0x144>)
    329a:	492d      	ldr	r1, [pc, #180]	; (3350 <spi_read_reg+0x12c>)
    329c:	482d      	ldr	r0, [pc, #180]	; (3354 <spi_read_reg+0x130>)
    329e:	4e2e      	ldr	r6, [pc, #184]	; (3358 <spi_read_reg+0x134>)
    32a0:	47b0      	blx	r6
    32a2:	9902      	ldr	r1, [sp, #8]
    32a4:	4831      	ldr	r0, [pc, #196]	; (336c <spi_read_reg+0x148>)
    32a6:	47b0      	blx	r6
    32a8:	200d      	movs	r0, #13
    32aa:	4b2d      	ldr	r3, [pc, #180]	; (3360 <spi_read_reg+0x13c>)
    32ac:	4798      	blx	r3
		goto _FAIL_;
    32ae:	e021      	b.n	32f4 <spi_read_reg+0xd0>
	}

	/* to avoid endianess issues */
	result = spi_data_read(&tmp[0], 4, clockless);
    32b0:	464a      	mov	r2, r9
    32b2:	2104      	movs	r1, #4
    32b4:	a805      	add	r0, sp, #20
    32b6:	4b2e      	ldr	r3, [pc, #184]	; (3370 <spi_read_reg+0x14c>)
    32b8:	4798      	blx	r3
    32ba:	1e04      	subs	r4, r0, #0
	if (result != N_OK) {
    32bc:	2c01      	cmp	r4, #1
    32be:	d00b      	beq.n	32d8 <spi_read_reg+0xb4>
		M2M_ERR("[nmi spi]: Failed data read...\n");
    32c0:	4a2c      	ldr	r2, [pc, #176]	; (3374 <spi_read_reg+0x150>)
    32c2:	4923      	ldr	r1, [pc, #140]	; (3350 <spi_read_reg+0x12c>)
    32c4:	4823      	ldr	r0, [pc, #140]	; (3354 <spi_read_reg+0x130>)
    32c6:	4b24      	ldr	r3, [pc, #144]	; (3358 <spi_read_reg+0x134>)
    32c8:	4798      	blx	r3
    32ca:	482b      	ldr	r0, [pc, #172]	; (3378 <spi_read_reg+0x154>)
    32cc:	4b2b      	ldr	r3, [pc, #172]	; (337c <spi_read_reg+0x158>)
    32ce:	4798      	blx	r3
    32d0:	200d      	movs	r0, #13
    32d2:	4b23      	ldr	r3, [pc, #140]	; (3360 <spi_read_reg+0x13c>)
    32d4:	4798      	blx	r3
		goto _FAIL_;
    32d6:	e00d      	b.n	32f4 <spi_read_reg+0xd0>
	}

#endif

	*u32data = tmp[0] |
		((uint32)tmp[1] << 8) |
    32d8:	aa05      	add	r2, sp, #20
		goto _FAIL_;
	}

#endif

	*u32data = tmp[0] |
    32da:	7853      	ldrb	r3, [r2, #1]
    32dc:	0219      	lsls	r1, r3, #8
    32de:	7893      	ldrb	r3, [r2, #2]
    32e0:	041b      	lsls	r3, r3, #16
    32e2:	430b      	orrs	r3, r1
    32e4:	7811      	ldrb	r1, [r2, #0]
    32e6:	430b      	orrs	r3, r1
    32e8:	78d2      	ldrb	r2, [r2, #3]
    32ea:	0612      	lsls	r2, r2, #24
    32ec:	4313      	orrs	r3, r2
    32ee:	465a      	mov	r2, fp
    32f0:	6013      	str	r3, [r2, #0]
    32f2:	e01d      	b.n	3330 <spi_read_reg+0x10c>
		
_FAIL_:
	if(result != N_OK)
	{
		
		nm_bsp_sleep(1);
    32f4:	2001      	movs	r0, #1
    32f6:	4e22      	ldr	r6, [pc, #136]	; (3380 <spi_read_reg+0x15c>)
    32f8:	47b0      	blx	r6
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    32fa:	2300      	movs	r3, #0
    32fc:	9300      	str	r3, [sp, #0]
    32fe:	2200      	movs	r2, #0
    3300:	2100      	movs	r1, #0
    3302:	20cf      	movs	r0, #207	; 0xcf
    3304:	4f10      	ldr	r7, [pc, #64]	; (3348 <spi_read_reg+0x124>)
    3306:	47b8      	blx	r7
		spi_cmd_rsp(CMD_RESET);
    3308:	20cf      	movs	r0, #207	; 0xcf
    330a:	4b16      	ldr	r3, [pc, #88]	; (3364 <spi_read_reg+0x140>)
    330c:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx\n",retry,addr);
    330e:	4a1d      	ldr	r2, [pc, #116]	; (3384 <spi_read_reg+0x160>)
    3310:	490f      	ldr	r1, [pc, #60]	; (3350 <spi_read_reg+0x12c>)
    3312:	4810      	ldr	r0, [pc, #64]	; (3354 <spi_read_reg+0x130>)
    3314:	4f10      	ldr	r7, [pc, #64]	; (3358 <spi_read_reg+0x134>)
    3316:	47b8      	blx	r7
    3318:	9a02      	ldr	r2, [sp, #8]
    331a:	0029      	movs	r1, r5
    331c:	481a      	ldr	r0, [pc, #104]	; (3388 <spi_read_reg+0x164>)
    331e:	47b8      	blx	r7
    3320:	200d      	movs	r0, #13
    3322:	4b0f      	ldr	r3, [pc, #60]	; (3360 <spi_read_reg+0x13c>)
    3324:	4798      	blx	r3
		nm_bsp_sleep(1);
    3326:	2001      	movs	r0, #1
    3328:	47b0      	blx	r6
    332a:	3d01      	subs	r5, #1
		retry--;
		if(retry) goto _RETRY_;
    332c:	2d00      	cmp	r5, #0
    332e:	d196      	bne.n	325e <spi_read_reg+0x3a>
	}
		
	return result;
}
    3330:	0020      	movs	r0, r4
    3332:	b007      	add	sp, #28
    3334:	bc3c      	pop	{r2, r3, r4, r5}
    3336:	4690      	mov	r8, r2
    3338:	4699      	mov	r9, r3
    333a:	46a2      	mov	sl, r4
    333c:	46ab      	mov	fp, r5
    333e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3340:	0000a6f2 	.word	0x0000a6f2
    3344:	0000a6f3 	.word	0x0000a6f3
    3348:	00002d65 	.word	0x00002d65
    334c:	00000417 	.word	0x00000417
    3350:	0000ac98 	.word	0x0000ac98
    3354:	00009e44 	.word	0x00009e44
    3358:	00008845 	.word	0x00008845
    335c:	0000a8fc 	.word	0x0000a8fc
    3360:	00008879 	.word	0x00008879
    3364:	00002f09 	.word	0x00002f09
    3368:	0000041d 	.word	0x0000041d
    336c:	0000a928 	.word	0x0000a928
    3370:	00002fd1 	.word	0x00002fd1
    3374:	00000424 	.word	0x00000424
    3378:	0000a95c 	.word	0x0000a95c
    337c:	00008965 	.word	0x00008965
    3380:	000011d5 	.word	0x000011d5
    3384:	0000043c 	.word	0x0000043c
    3388:	0000a97c 	.word	0x0000a97c

0000338c <nm_spi_reset>:
	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
}

sint8 nm_spi_reset(void)
{
    338c:	b510      	push	{r4, lr}
    338e:	b082      	sub	sp, #8
	spi_cmd(CMD_RESET, 0, 0, 0, 0);
    3390:	2300      	movs	r3, #0
    3392:	9300      	str	r3, [sp, #0]
    3394:	2200      	movs	r2, #0
    3396:	2100      	movs	r1, #0
    3398:	20cf      	movs	r0, #207	; 0xcf
    339a:	4c04      	ldr	r4, [pc, #16]	; (33ac <nm_spi_reset+0x20>)
    339c:	47a0      	blx	r4
	spi_cmd_rsp(CMD_RESET);
    339e:	20cf      	movs	r0, #207	; 0xcf
    33a0:	4b03      	ldr	r3, [pc, #12]	; (33b0 <nm_spi_reset+0x24>)
    33a2:	4798      	blx	r3
	return M2M_SUCCESS;
}
    33a4:	2000      	movs	r0, #0
    33a6:	b002      	add	sp, #8
    33a8:	bd10      	pop	{r4, pc}
    33aa:	46c0      	nop			; (mov r8, r8)
    33ac:	00002d65 	.word	0x00002d65
    33b0:	00002f09 	.word	0x00002f09

000033b4 <nm_spi_deinit>:
*	@date	27 Feb 2015
*	@version	1.0
*/ 
sint8 nm_spi_deinit(void)
{
	gu8Crc_off = 0;
    33b4:	2200      	movs	r2, #0
    33b6:	4b02      	ldr	r3, [pc, #8]	; (33c0 <nm_spi_deinit+0xc>)
    33b8:	701a      	strb	r2, [r3, #0]
	return M2M_SUCCESS;
}
    33ba:	2000      	movs	r0, #0
    33bc:	4770      	bx	lr
    33be:	46c0      	nop			; (mov r8, r8)
    33c0:	20000120 	.word	0x20000120

000033c4 <nm_spi_read_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
uint32 nm_spi_read_reg(uint32 u32Addr)
{
    33c4:	b500      	push	{lr}
    33c6:	b083      	sub	sp, #12
	uint32 u32Val;

	spi_read_reg(u32Addr, &u32Val);
    33c8:	a901      	add	r1, sp, #4
    33ca:	4b02      	ldr	r3, [pc, #8]	; (33d4 <nm_spi_read_reg+0x10>)
    33cc:	4798      	blx	r3

	return u32Val;
}
    33ce:	9801      	ldr	r0, [sp, #4]
    33d0:	b003      	add	sp, #12
    33d2:	bd00      	pop	{pc}
    33d4:	00003225 	.word	0x00003225

000033d8 <nm_spi_read_reg_with_ret>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
{
    33d8:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
    33da:	4b04      	ldr	r3, [pc, #16]	; (33ec <nm_spi_read_reg_with_ret+0x14>)
    33dc:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    33de:	2300      	movs	r3, #0
    33e0:	2801      	cmp	r0, #1
    33e2:	d000      	beq.n	33e6 <nm_spi_read_reg_with_ret+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    33e4:	3b06      	subs	r3, #6

	return s8Ret;
}
    33e6:	0018      	movs	r0, r3
    33e8:	bd10      	pop	{r4, pc}
    33ea:	46c0      	nop			; (mov r8, r8)
    33ec:	00003225 	.word	0x00003225

000033f0 <nm_spi_write_reg>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
{
    33f0:	b510      	push	{r4, lr}
	sint8 s8Ret;

	s8Ret = spi_write_reg(u32Addr, u32Val);
    33f2:	4b04      	ldr	r3, [pc, #16]	; (3404 <nm_spi_write_reg+0x14>)
    33f4:	4798      	blx	r3

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    33f6:	2300      	movs	r3, #0
    33f8:	2801      	cmp	r0, #1
    33fa:	d000      	beq.n	33fe <nm_spi_write_reg+0xe>
	else s8Ret = M2M_ERR_BUS_FAIL;
    33fc:	3b06      	subs	r3, #6

	return s8Ret;
}
    33fe:	0018      	movs	r0, r3
    3400:	bd10      	pop	{r4, pc}
    3402:	46c0      	nop			; (mov r8, r8)
    3404:	00003115 	.word	0x00003115

00003408 <nm_spi_init>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_init(void)
{
    3408:	b510      	push	{r4, lr}
    340a:	b082      	sub	sp, #8
	uint32 chipid;
	uint32 reg = 0;
    340c:	2300      	movs	r3, #0
    340e:	9300      	str	r3, [sp, #0]
	

	/**
		configure protocol
	**/
	gu8Crc_off = 0;
    3410:	4a35      	ldr	r2, [pc, #212]	; (34e8 <nm_spi_init+0xe0>)
    3412:	7013      	strb	r3, [r2, #0]

	// TODO: We can remove the CRC trials if there is a definite way to reset
	// the SPI to it's initial value.
	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
    3414:	4669      	mov	r1, sp
    3416:	4835      	ldr	r0, [pc, #212]	; (34ec <nm_spi_init+0xe4>)
    3418:	4b35      	ldr	r3, [pc, #212]	; (34f0 <nm_spi_init+0xe8>)
    341a:	4798      	blx	r3
    341c:	2800      	cmp	r0, #0
    341e:	d11f      	bne.n	3460 <nm_spi_init+0x58>
		/* Read failed. Try with CRC off. This might happen when module
		is removed but chip isn't reset*/
		gu8Crc_off = 1;
    3420:	2201      	movs	r2, #1
    3422:	4b31      	ldr	r3, [pc, #196]	; (34e8 <nm_spi_init+0xe0>)
    3424:	701a      	strb	r2, [r3, #0]
		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
    3426:	4a33      	ldr	r2, [pc, #204]	; (34f4 <nm_spi_init+0xec>)
    3428:	4933      	ldr	r1, [pc, #204]	; (34f8 <nm_spi_init+0xf0>)
    342a:	4834      	ldr	r0, [pc, #208]	; (34fc <nm_spi_init+0xf4>)
    342c:	4b34      	ldr	r3, [pc, #208]	; (3500 <nm_spi_init+0xf8>)
    342e:	4798      	blx	r3
    3430:	4834      	ldr	r0, [pc, #208]	; (3504 <nm_spi_init+0xfc>)
    3432:	4b35      	ldr	r3, [pc, #212]	; (3508 <nm_spi_init+0x100>)
    3434:	4798      	blx	r3
    3436:	200d      	movs	r0, #13
    3438:	4b34      	ldr	r3, [pc, #208]	; (350c <nm_spi_init+0x104>)
    343a:	4798      	blx	r3
		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
    343c:	4669      	mov	r1, sp
    343e:	482b      	ldr	r0, [pc, #172]	; (34ec <nm_spi_init+0xe4>)
    3440:	4b2b      	ldr	r3, [pc, #172]	; (34f0 <nm_spi_init+0xe8>)
    3442:	4798      	blx	r3
    3444:	1e04      	subs	r4, r0, #0
    3446:	d10b      	bne.n	3460 <nm_spi_init+0x58>
			// Reaad failed with both CRC on and off, something went bad
			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
    3448:	4a31      	ldr	r2, [pc, #196]	; (3510 <nm_spi_init+0x108>)
    344a:	492b      	ldr	r1, [pc, #172]	; (34f8 <nm_spi_init+0xf0>)
    344c:	482b      	ldr	r0, [pc, #172]	; (34fc <nm_spi_init+0xf4>)
    344e:	4b2c      	ldr	r3, [pc, #176]	; (3500 <nm_spi_init+0xf8>)
    3450:	4798      	blx	r3
    3452:	4830      	ldr	r0, [pc, #192]	; (3514 <nm_spi_init+0x10c>)
    3454:	4b2c      	ldr	r3, [pc, #176]	; (3508 <nm_spi_init+0x100>)
    3456:	4798      	blx	r3
    3458:	200d      	movs	r0, #13
    345a:	4b2c      	ldr	r3, [pc, #176]	; (350c <nm_spi_init+0x104>)
    345c:	4798      	blx	r3
			return 0;
    345e:	e03f      	b.n	34e0 <nm_spi_init+0xd8>
		}
	}
	if(gu8Crc_off == 0)
    3460:	4b21      	ldr	r3, [pc, #132]	; (34e8 <nm_spi_init+0xe0>)
    3462:	781b      	ldrb	r3, [r3, #0]
    3464:	2b00      	cmp	r3, #0
    3466:	d119      	bne.n	349c <nm_spi_init+0x94>
	{
		reg &= ~0xc;	/* disable crc checking */
		reg &= ~0x70;
		reg |= (0x5 << 4);
    3468:	337c      	adds	r3, #124	; 0x7c
    346a:	9900      	ldr	r1, [sp, #0]
    346c:	4399      	bics	r1, r3
    346e:	3b2c      	subs	r3, #44	; 0x2c
    3470:	4319      	orrs	r1, r3
    3472:	9100      	str	r1, [sp, #0]
		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
    3474:	481d      	ldr	r0, [pc, #116]	; (34ec <nm_spi_init+0xe4>)
    3476:	4b28      	ldr	r3, [pc, #160]	; (3518 <nm_spi_init+0x110>)
    3478:	4798      	blx	r3
    347a:	1e04      	subs	r4, r0, #0
    347c:	d10b      	bne.n	3496 <nm_spi_init+0x8e>
			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
    347e:	4a27      	ldr	r2, [pc, #156]	; (351c <nm_spi_init+0x114>)
    3480:	491d      	ldr	r1, [pc, #116]	; (34f8 <nm_spi_init+0xf0>)
    3482:	481e      	ldr	r0, [pc, #120]	; (34fc <nm_spi_init+0xf4>)
    3484:	4b1e      	ldr	r3, [pc, #120]	; (3500 <nm_spi_init+0xf8>)
    3486:	4798      	blx	r3
    3488:	4825      	ldr	r0, [pc, #148]	; (3520 <nm_spi_init+0x118>)
    348a:	4b1f      	ldr	r3, [pc, #124]	; (3508 <nm_spi_init+0x100>)
    348c:	4798      	blx	r3
    348e:	200d      	movs	r0, #13
    3490:	4b1e      	ldr	r3, [pc, #120]	; (350c <nm_spi_init+0x104>)
    3492:	4798      	blx	r3
			return 0;
    3494:	e024      	b.n	34e0 <nm_spi_init+0xd8>
		}
		gu8Crc_off = 1;
    3496:	2201      	movs	r2, #1
    3498:	4b13      	ldr	r3, [pc, #76]	; (34e8 <nm_spi_init+0xe0>)
    349a:	701a      	strb	r2, [r3, #0]
	}

	/**
		make sure can read back chip id correctly
	**/
	if (!spi_read_reg(0x1000, &chipid)) {
    349c:	a901      	add	r1, sp, #4
    349e:	2080      	movs	r0, #128	; 0x80
    34a0:	0140      	lsls	r0, r0, #5
    34a2:	4b13      	ldr	r3, [pc, #76]	; (34f0 <nm_spi_init+0xe8>)
    34a4:	4798      	blx	r3
    34a6:	2800      	cmp	r0, #0
    34a8:	d10d      	bne.n	34c6 <nm_spi_init+0xbe>
		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
    34aa:	4a1e      	ldr	r2, [pc, #120]	; (3524 <nm_spi_init+0x11c>)
    34ac:	4912      	ldr	r1, [pc, #72]	; (34f8 <nm_spi_init+0xf0>)
    34ae:	4813      	ldr	r0, [pc, #76]	; (34fc <nm_spi_init+0xf4>)
    34b0:	4b13      	ldr	r3, [pc, #76]	; (3500 <nm_spi_init+0xf8>)
    34b2:	4798      	blx	r3
    34b4:	481c      	ldr	r0, [pc, #112]	; (3528 <nm_spi_init+0x120>)
    34b6:	4b14      	ldr	r3, [pc, #80]	; (3508 <nm_spi_init+0x100>)
    34b8:	4798      	blx	r3
    34ba:	200d      	movs	r0, #13
    34bc:	4b13      	ldr	r3, [pc, #76]	; (350c <nm_spi_init+0x104>)
    34be:	4798      	blx	r3
		return M2M_ERR_BUS_FAIL;
    34c0:	2406      	movs	r4, #6
    34c2:	4264      	negs	r4, r4
    34c4:	e00c      	b.n	34e0 <nm_spi_init+0xd8>
static void spi_init_pkt_sz(void)
{
	uint32 val32;

	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
	val32 = nm_spi_read_reg(SPI_BASE+0x24);
    34c6:	4c09      	ldr	r4, [pc, #36]	; (34ec <nm_spi_init+0xe4>)
    34c8:	0020      	movs	r0, r4
    34ca:	4b18      	ldr	r3, [pc, #96]	; (352c <nm_spi_init+0x124>)
    34cc:	4798      	blx	r3
	val32 &= ~(0x7 << 4);
    34ce:	2370      	movs	r3, #112	; 0x70
    34d0:	0001      	movs	r1, r0
    34d2:	4399      	bics	r1, r3
	case 2048: val32 |= (3 << 4); break;
	case 4096: val32 |= (4 << 4); break;
	case 8192: val32 |= (5 << 4); break;

	}
	nm_spi_write_reg(SPI_BASE+0x24, val32);
    34d4:	3b20      	subs	r3, #32
    34d6:	4319      	orrs	r1, r3
    34d8:	0020      	movs	r0, r4
    34da:	4b15      	ldr	r3, [pc, #84]	; (3530 <nm_spi_init+0x128>)
    34dc:	4798      	blx	r3

	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
	spi_init_pkt_sz();


	return M2M_SUCCESS;
    34de:	2400      	movs	r4, #0
}
    34e0:	0020      	movs	r0, r4
    34e2:	b002      	add	sp, #8
    34e4:	bd10      	pop	{r4, pc}
    34e6:	46c0      	nop			; (mov r8, r8)
    34e8:	20000120 	.word	0x20000120
    34ec:	0000e824 	.word	0x0000e824
    34f0:	00003225 	.word	0x00003225
    34f4:	000004c7 	.word	0x000004c7
    34f8:	0000a72c 	.word	0x0000a72c
    34fc:	00009e44 	.word	0x00009e44
    3500:	00008845 	.word	0x00008845
    3504:	0000a994 	.word	0x0000a994
    3508:	00008965 	.word	0x00008965
    350c:	00008879 	.word	0x00008879
    3510:	000004ca 	.word	0x000004ca
    3514:	0000a9e4 	.word	0x0000a9e4
    3518:	00003115 	.word	0x00003115
    351c:	000004d4 	.word	0x000004d4
    3520:	0000aa10 	.word	0x0000aa10
    3524:	000004de 	.word	0x000004de
    3528:	0000aa44 	.word	0x0000aa44
    352c:	000033c5 	.word	0x000033c5
    3530:	000033f1 	.word	0x000033f1

00003534 <nm_spi_read_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    3534:	b5f0      	push	{r4, r5, r6, r7, lr}
    3536:	465f      	mov	r7, fp
    3538:	4656      	mov	r6, sl
    353a:	464d      	mov	r5, r9
    353c:	4644      	mov	r4, r8
    353e:	b4f0      	push	{r4, r5, r6, r7}
    3540:	b087      	sub	sp, #28
    3542:	9002      	str	r0, [sp, #8]
    3544:	9103      	str	r1, [sp, #12]
    3546:	0016      	movs	r6, r2
    3548:	250a      	movs	r5, #10
	uint8 cmd = CMD_DMA_EXT_READ;
	sint8 result;
	uint8 retry = SPI_RETRY_COUNT;
#if defined USE_OLD_SPI_SW
	uint8 tmp[2];
	uint8 single_byte_workaround = 0;
    354a:	2300      	movs	r3, #0
    354c:	469b      	mov	fp, r3
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    354e:	2400      	movs	r4, #0
    3550:	4b3e      	ldr	r3, [pc, #248]	; (364c <nm_spi_read_block+0x118>)
    3552:	4698      	mov	r8, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    3554:	46a9      	mov	r9, r5

	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
    3556:	2e01      	cmp	r6, #1
    3558:	d102      	bne.n	3560 <nm_spi_read_block+0x2c>
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
		single_byte_workaround = 1;
    355a:	2301      	movs	r3, #1
    355c:	469b      	mov	fp, r3
	**/
#if defined USE_OLD_SPI_SW
	if (size == 1)
	{
		//Workaround hardware problem with single byte transfers over SPI bus
		size = 2;
    355e:	3601      	adds	r6, #1
		single_byte_workaround = 1;
	}
	result = spi_cmd(cmd, addr, 0, size,0);
    3560:	9400      	str	r4, [sp, #0]
    3562:	0033      	movs	r3, r6
    3564:	0022      	movs	r2, r4
    3566:	9d02      	ldr	r5, [sp, #8]
    3568:	0029      	movs	r1, r5
    356a:	20c8      	movs	r0, #200	; 0xc8
    356c:	47c0      	blx	r8
	if (result != N_OK) {
    356e:	2801      	cmp	r0, #1
    3570:	d00b      	beq.n	358a <nm_spi_read_block+0x56>
		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
    3572:	4a37      	ldr	r2, [pc, #220]	; (3650 <nm_spi_read_block+0x11c>)
    3574:	4937      	ldr	r1, [pc, #220]	; (3654 <nm_spi_read_block+0x120>)
    3576:	4838      	ldr	r0, [pc, #224]	; (3658 <nm_spi_read_block+0x124>)
    3578:	4f38      	ldr	r7, [pc, #224]	; (365c <nm_spi_read_block+0x128>)
    357a:	47b8      	blx	r7
    357c:	0029      	movs	r1, r5
    357e:	4838      	ldr	r0, [pc, #224]	; (3660 <nm_spi_read_block+0x12c>)
    3580:	47b8      	blx	r7
    3582:	200d      	movs	r0, #13
    3584:	4b37      	ldr	r3, [pc, #220]	; (3664 <nm_spi_read_block+0x130>)
    3586:	4798      	blx	r3
    3588:	e032      	b.n	35f0 <nm_spi_read_block+0xbc>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    358a:	20c8      	movs	r0, #200	; 0xc8
    358c:	4b36      	ldr	r3, [pc, #216]	; (3668 <nm_spi_read_block+0x134>)
    358e:	4798      	blx	r3
	if (result != N_OK) {
    3590:	2801      	cmp	r0, #1
    3592:	d00b      	beq.n	35ac <nm_spi_read_block+0x78>
		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
    3594:	4a35      	ldr	r2, [pc, #212]	; (366c <nm_spi_read_block+0x138>)
    3596:	492f      	ldr	r1, [pc, #188]	; (3654 <nm_spi_read_block+0x120>)
    3598:	482f      	ldr	r0, [pc, #188]	; (3658 <nm_spi_read_block+0x124>)
    359a:	4f30      	ldr	r7, [pc, #192]	; (365c <nm_spi_read_block+0x128>)
    359c:	47b8      	blx	r7
    359e:	9902      	ldr	r1, [sp, #8]
    35a0:	4833      	ldr	r0, [pc, #204]	; (3670 <nm_spi_read_block+0x13c>)
    35a2:	47b8      	blx	r7
    35a4:	200d      	movs	r0, #13
    35a6:	4b2f      	ldr	r3, [pc, #188]	; (3664 <nm_spi_read_block+0x130>)
    35a8:	4798      	blx	r3
    35aa:	e021      	b.n	35f0 <nm_spi_read_block+0xbc>
	}

	/**
		Data
	**/
	if (single_byte_workaround)
    35ac:	465b      	mov	r3, fp
    35ae:	2b00      	cmp	r3, #0
    35b0:	d009      	beq.n	35c6 <nm_spi_read_block+0x92>
	{
		result = spi_data_read(tmp, size,0);
    35b2:	af05      	add	r7, sp, #20
    35b4:	0022      	movs	r2, r4
    35b6:	0031      	movs	r1, r6
    35b8:	0038      	movs	r0, r7
    35ba:	4b2e      	ldr	r3, [pc, #184]	; (3674 <nm_spi_read_block+0x140>)
    35bc:	4798      	blx	r3
		buf[0] = tmp[0];
    35be:	783b      	ldrb	r3, [r7, #0]
    35c0:	9a03      	ldr	r2, [sp, #12]
    35c2:	7013      	strb	r3, [r2, #0]
    35c4:	e004      	b.n	35d0 <nm_spi_read_block+0x9c>
	}
	else
		result = spi_data_read(buf, size,0);
    35c6:	0022      	movs	r2, r4
    35c8:	0031      	movs	r1, r6
    35ca:	9803      	ldr	r0, [sp, #12]
    35cc:	4b29      	ldr	r3, [pc, #164]	; (3674 <nm_spi_read_block+0x140>)
    35ce:	4798      	blx	r3

	if (result != N_OK) {
    35d0:	2801      	cmp	r0, #1
    35d2:	d00b      	beq.n	35ec <nm_spi_read_block+0xb8>
		M2M_ERR("[nmi spi]: Failed block data read...\n");
    35d4:	4a28      	ldr	r2, [pc, #160]	; (3678 <nm_spi_read_block+0x144>)
    35d6:	491f      	ldr	r1, [pc, #124]	; (3654 <nm_spi_read_block+0x120>)
    35d8:	481f      	ldr	r0, [pc, #124]	; (3658 <nm_spi_read_block+0x124>)
    35da:	4b20      	ldr	r3, [pc, #128]	; (365c <nm_spi_read_block+0x128>)
    35dc:	4798      	blx	r3
    35de:	4827      	ldr	r0, [pc, #156]	; (367c <nm_spi_read_block+0x148>)
    35e0:	4b27      	ldr	r3, [pc, #156]	; (3680 <nm_spi_read_block+0x14c>)
    35e2:	4798      	blx	r3
    35e4:	200d      	movs	r0, #13
    35e6:	4b1f      	ldr	r3, [pc, #124]	; (3664 <nm_spi_read_block+0x130>)
    35e8:	4798      	blx	r3
    35ea:	e001      	b.n	35f0 <nm_spi_read_block+0xbc>
{
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    35ec:	2000      	movs	r0, #0
    35ee:	e025      	b.n	363c <nm_spi_read_block+0x108>
#endif

_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    35f0:	2001      	movs	r0, #1
    35f2:	4f24      	ldr	r7, [pc, #144]	; (3684 <nm_spi_read_block+0x150>)
    35f4:	47b8      	blx	r7
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    35f6:	9400      	str	r4, [sp, #0]
    35f8:	0023      	movs	r3, r4
    35fa:	0022      	movs	r2, r4
    35fc:	0021      	movs	r1, r4
    35fe:	20cf      	movs	r0, #207	; 0xcf
    3600:	4d12      	ldr	r5, [pc, #72]	; (364c <nm_spi_read_block+0x118>)
    3602:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    3604:	20cf      	movs	r0, #207	; 0xcf
    3606:	4b18      	ldr	r3, [pc, #96]	; (3668 <nm_spi_read_block+0x134>)
    3608:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    360a:	4a1f      	ldr	r2, [pc, #124]	; (3688 <nm_spi_read_block+0x154>)
    360c:	4911      	ldr	r1, [pc, #68]	; (3654 <nm_spi_read_block+0x120>)
    360e:	4812      	ldr	r0, [pc, #72]	; (3658 <nm_spi_read_block+0x124>)
    3610:	4b12      	ldr	r3, [pc, #72]	; (365c <nm_spi_read_block+0x128>)
    3612:	469a      	mov	sl, r3
    3614:	4798      	blx	r3
    3616:	0033      	movs	r3, r6
    3618:	9a02      	ldr	r2, [sp, #8]
    361a:	4649      	mov	r1, r9
    361c:	481b      	ldr	r0, [pc, #108]	; (368c <nm_spi_read_block+0x158>)
    361e:	47d0      	blx	sl
    3620:	200d      	movs	r0, #13
    3622:	4b10      	ldr	r3, [pc, #64]	; (3664 <nm_spi_read_block+0x130>)
    3624:	4798      	blx	r3
		nm_bsp_sleep(1);
    3626:	2001      	movs	r0, #1
    3628:	47b8      	blx	r7
    362a:	2301      	movs	r3, #1
    362c:	425b      	negs	r3, r3
    362e:	469c      	mov	ip, r3
    3630:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    3632:	464b      	mov	r3, r9
    3634:	2b00      	cmp	r3, #0
    3636:	d18e      	bne.n	3556 <nm_spi_read_block+0x22>
	sint8 s8Ret;

	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    3638:	2006      	movs	r0, #6
    363a:	4240      	negs	r0, r0

	return s8Ret;
}
    363c:	b007      	add	sp, #28
    363e:	bc3c      	pop	{r2, r3, r4, r5}
    3640:	4690      	mov	r8, r2
    3642:	4699      	mov	r9, r3
    3644:	46a2      	mov	sl, r4
    3646:	46ab      	mov	fp, r5
    3648:	bdf0      	pop	{r4, r5, r6, r7, pc}
    364a:	46c0      	nop			; (mov r8, r8)
    364c:	00002d65 	.word	0x00002d65
    3650:	0000045d 	.word	0x0000045d
    3654:	0000adb8 	.word	0x0000adb8
    3658:	00009e44 	.word	0x00009e44
    365c:	00008845 	.word	0x00008845
    3660:	0000aa68 	.word	0x0000aa68
    3664:	00008879 	.word	0x00008879
    3668:	00002f09 	.word	0x00002f09
    366c:	00000463 	.word	0x00000463
    3670:	0000aa98 	.word	0x0000aa98
    3674:	00002fd1 	.word	0x00002fd1
    3678:	00000473 	.word	0x00000473
    367c:	0000aad0 	.word	0x0000aad0
    3680:	00008965 	.word	0x00008965
    3684:	000011d5 	.word	0x000011d5
    3688:	00000484 	.word	0x00000484
    368c:	0000aaf8 	.word	0x0000aaf8

00003690 <nm_spi_write_block>:
*	@author	M. Abdelmawla
*	@date	11 July 2012
*	@version	1.0
*/
sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
{
    3690:	b5f0      	push	{r4, r5, r6, r7, lr}
    3692:	465f      	mov	r7, fp
    3694:	4656      	mov	r6, sl
    3696:	464d      	mov	r5, r9
    3698:	4644      	mov	r4, r8
    369a:	b4f0      	push	{r4, r5, r6, r7}
    369c:	b089      	sub	sp, #36	; 0x24
    369e:	9004      	str	r0, [sp, #16]
    36a0:	4688      	mov	r8, r1
    36a2:	9203      	str	r2, [sp, #12]
    36a4:	270a      	movs	r7, #10
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
		size = 2;

	result = spi_cmd(cmd, addr, 0, size,0);
    36a6:	2600      	movs	r6, #0
    36a8:	4b89      	ldr	r3, [pc, #548]	; (38d0 <nm_spi_write_block+0x240>)
    36aa:	469a      	mov	sl, r3
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    36ac:	46b9      	mov	r9, r7
	/**
		Command
	**/
#if defined USE_OLD_SPI_SW
	//Workaround hardware problem with single byte transfers over SPI bus
	if (size == 1)
    36ae:	9b03      	ldr	r3, [sp, #12]
    36b0:	2b01      	cmp	r3, #1
    36b2:	d101      	bne.n	36b8 <nm_spi_write_block+0x28>
		size = 2;
    36b4:	3301      	adds	r3, #1
    36b6:	9303      	str	r3, [sp, #12]

	result = spi_cmd(cmd, addr, 0, size,0);
    36b8:	9600      	str	r6, [sp, #0]
    36ba:	9b03      	ldr	r3, [sp, #12]
    36bc:	0032      	movs	r2, r6
    36be:	9d04      	ldr	r5, [sp, #16]
    36c0:	0029      	movs	r1, r5
    36c2:	20c7      	movs	r0, #199	; 0xc7
    36c4:	47d0      	blx	sl
	if (result != N_OK) {
    36c6:	2801      	cmp	r0, #1
    36c8:	d00b      	beq.n	36e2 <nm_spi_write_block+0x52>
		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
    36ca:	4a82      	ldr	r2, [pc, #520]	; (38d4 <nm_spi_write_block+0x244>)
    36cc:	4982      	ldr	r1, [pc, #520]	; (38d8 <nm_spi_write_block+0x248>)
    36ce:	4883      	ldr	r0, [pc, #524]	; (38dc <nm_spi_write_block+0x24c>)
    36d0:	4c83      	ldr	r4, [pc, #524]	; (38e0 <nm_spi_write_block+0x250>)
    36d2:	47a0      	blx	r4
    36d4:	0029      	movs	r1, r5
    36d6:	4883      	ldr	r0, [pc, #524]	; (38e4 <nm_spi_write_block+0x254>)
    36d8:	47a0      	blx	r4
    36da:	200d      	movs	r0, #13
    36dc:	4b82      	ldr	r3, [pc, #520]	; (38e8 <nm_spi_write_block+0x258>)
    36de:	4798      	blx	r3
    36e0:	e0c9      	b.n	3876 <nm_spi_write_block+0x1e6>
		goto _FAIL_;
	}

	result = spi_cmd_rsp(cmd);
    36e2:	20c7      	movs	r0, #199	; 0xc7
    36e4:	4b81      	ldr	r3, [pc, #516]	; (38ec <nm_spi_write_block+0x25c>)
    36e6:	4798      	blx	r3
	if (result != N_OK) {
    36e8:	2801      	cmp	r0, #1
    36ea:	d00c      	beq.n	3706 <nm_spi_write_block+0x76>
		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
    36ec:	22f4      	movs	r2, #244	; 0xf4
    36ee:	0092      	lsls	r2, r2, #2
    36f0:	4979      	ldr	r1, [pc, #484]	; (38d8 <nm_spi_write_block+0x248>)
    36f2:	487a      	ldr	r0, [pc, #488]	; (38dc <nm_spi_write_block+0x24c>)
    36f4:	4c7a      	ldr	r4, [pc, #488]	; (38e0 <nm_spi_write_block+0x250>)
    36f6:	47a0      	blx	r4
    36f8:	9904      	ldr	r1, [sp, #16]
    36fa:	487d      	ldr	r0, [pc, #500]	; (38f0 <nm_spi_write_block+0x260>)
    36fc:	47a0      	blx	r4
    36fe:	200d      	movs	r0, #13
    3700:	4b79      	ldr	r3, [pc, #484]	; (38e8 <nm_spi_write_block+0x258>)
    3702:	4798      	blx	r3
    3704:	e0b7      	b.n	3876 <nm_spi_write_block+0x1e6>
static sint8 spi_data_write(uint8 *b, uint16 sz)
{
	sint16 ix;
	uint16 nbytes;
	sint8 result = 1;
	uint8 cmd, order, crc[2] = {0};
    3706:	ab07      	add	r3, sp, #28
    3708:	801e      	strh	r6, [r3, #0]
    370a:	9c03      	ldr	r4, [sp, #12]
	//uint8 rsp;

	/**
		Data
	**/
	ix = 0;
    370c:	0037      	movs	r7, r6
    370e:	2380      	movs	r3, #128	; 0x80
    3710:	019b      	lsls	r3, r3, #6
    3712:	469b      	mov	fp, r3
    3714:	466a      	mov	r2, sp
    3716:	82d3      	strh	r3, [r2, #22]
    3718:	1c25      	adds	r5, r4, #0
    371a:	455c      	cmp	r4, fp
    371c:	d901      	bls.n	3722 <nm_spi_write_block+0x92>
    371e:	466b      	mov	r3, sp
    3720:	8add      	ldrh	r5, [r3, #22]
    3722:	b2ad      	uxth	r5, r5

		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
    3724:	2f00      	cmp	r7, #0
    3726:	d104      	bne.n	3732 <nm_spi_write_block+0xa2>
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
    3728:	2303      	movs	r3, #3
		/**
			Write command
		**/
		cmd = 0xf0;
		if (ix == 0)  {
			if (sz <= DATA_PKT_SZ)
    372a:	455c      	cmp	r4, fp
    372c:	d906      	bls.n	373c <nm_spi_write_block+0xac>
				order = 0x3;
			else
				order = 0x1;
    372e:	3b02      	subs	r3, #2
    3730:	e004      	b.n	373c <nm_spi_write_block+0xac>
		} else {
			if (sz <= DATA_PKT_SZ)
				order = 0x3;
			else
				order = 0x2;
    3732:	0033      	movs	r3, r6
    3734:	465a      	mov	r2, fp
    3736:	42a2      	cmp	r2, r4
    3738:	4173      	adcs	r3, r6
    373a:	3302      	adds	r3, #2
		}
		cmd |= order;
    373c:	200b      	movs	r0, #11
    373e:	aa04      	add	r2, sp, #16
    3740:	4694      	mov	ip, r2
    3742:	4460      	add	r0, ip
    3744:	2210      	movs	r2, #16
    3746:	4252      	negs	r2, r2
    3748:	4313      	orrs	r3, r2
    374a:	7003      	strb	r3, [r0, #0]
		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
    374c:	2101      	movs	r1, #1
    374e:	4b69      	ldr	r3, [pc, #420]	; (38f4 <nm_spi_write_block+0x264>)
    3750:	4798      	blx	r3
    3752:	2800      	cmp	r0, #0
    3754:	d00c      	beq.n	3770 <nm_spi_write_block+0xe0>
			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
    3756:	22d4      	movs	r2, #212	; 0xd4
    3758:	0092      	lsls	r2, r2, #2
    375a:	4967      	ldr	r1, [pc, #412]	; (38f8 <nm_spi_write_block+0x268>)
    375c:	485f      	ldr	r0, [pc, #380]	; (38dc <nm_spi_write_block+0x24c>)
    375e:	4b60      	ldr	r3, [pc, #384]	; (38e0 <nm_spi_write_block+0x250>)
    3760:	4798      	blx	r3
    3762:	4866      	ldr	r0, [pc, #408]	; (38fc <nm_spi_write_block+0x26c>)
    3764:	4b66      	ldr	r3, [pc, #408]	; (3900 <nm_spi_write_block+0x270>)
    3766:	4798      	blx	r3
    3768:	200d      	movs	r0, #13
    376a:	4b5f      	ldr	r3, [pc, #380]	; (38e8 <nm_spi_write_block+0x258>)
    376c:	4798      	blx	r3
    376e:	e059      	b.n	3824 <nm_spi_write_block+0x194>
		}

		/**
			Write data
		**/
		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
    3770:	4643      	mov	r3, r8
    3772:	19d8      	adds	r0, r3, r7
    3774:	0029      	movs	r1, r5
    3776:	4b5f      	ldr	r3, [pc, #380]	; (38f4 <nm_spi_write_block+0x264>)
    3778:	4798      	blx	r3
    377a:	2800      	cmp	r0, #0
    377c:	d00b      	beq.n	3796 <nm_spi_write_block+0x106>
			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
    377e:	4a61      	ldr	r2, [pc, #388]	; (3904 <nm_spi_write_block+0x274>)
    3780:	495d      	ldr	r1, [pc, #372]	; (38f8 <nm_spi_write_block+0x268>)
    3782:	4856      	ldr	r0, [pc, #344]	; (38dc <nm_spi_write_block+0x24c>)
    3784:	4b56      	ldr	r3, [pc, #344]	; (38e0 <nm_spi_write_block+0x250>)
    3786:	4798      	blx	r3
    3788:	485f      	ldr	r0, [pc, #380]	; (3908 <nm_spi_write_block+0x278>)
    378a:	4b5d      	ldr	r3, [pc, #372]	; (3900 <nm_spi_write_block+0x270>)
    378c:	4798      	blx	r3
    378e:	200d      	movs	r0, #13
    3790:	4b55      	ldr	r3, [pc, #340]	; (38e8 <nm_spi_write_block+0x258>)
    3792:	4798      	blx	r3
    3794:	e046      	b.n	3824 <nm_spi_write_block+0x194>
		}

		/**
			Write Crc
		**/
		if (!gu8Crc_off) {
    3796:	4b5d      	ldr	r3, [pc, #372]	; (390c <nm_spi_write_block+0x27c>)
    3798:	781b      	ldrb	r3, [r3, #0]
    379a:	2b00      	cmp	r3, #0
    379c:	d111      	bne.n	37c2 <nm_spi_write_block+0x132>
			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
    379e:	2102      	movs	r1, #2
    37a0:	a807      	add	r0, sp, #28
    37a2:	4b54      	ldr	r3, [pc, #336]	; (38f4 <nm_spi_write_block+0x264>)
    37a4:	4798      	blx	r3
    37a6:	2800      	cmp	r0, #0
    37a8:	d00b      	beq.n	37c2 <nm_spi_write_block+0x132>
				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
    37aa:	4a59      	ldr	r2, [pc, #356]	; (3910 <nm_spi_write_block+0x280>)
    37ac:	4952      	ldr	r1, [pc, #328]	; (38f8 <nm_spi_write_block+0x268>)
    37ae:	484b      	ldr	r0, [pc, #300]	; (38dc <nm_spi_write_block+0x24c>)
    37b0:	4b4b      	ldr	r3, [pc, #300]	; (38e0 <nm_spi_write_block+0x250>)
    37b2:	4798      	blx	r3
    37b4:	4857      	ldr	r0, [pc, #348]	; (3914 <nm_spi_write_block+0x284>)
    37b6:	4b52      	ldr	r3, [pc, #328]	; (3900 <nm_spi_write_block+0x270>)
    37b8:	4798      	blx	r3
    37ba:	200d      	movs	r0, #13
    37bc:	4b4a      	ldr	r3, [pc, #296]	; (38e8 <nm_spi_write_block+0x258>)
    37be:	4798      	blx	r3
    37c0:	e030      	b.n	3824 <nm_spi_write_block+0x194>
				result = N_FAIL;
				break;
			}
		}

		ix += nbytes;
    37c2:	19ef      	adds	r7, r5, r7
    37c4:	b23f      	sxth	r7, r7
		sz -= nbytes;
    37c6:	1b64      	subs	r4, r4, r5
    37c8:	b2a4      	uxth	r4, r4
	} while (sz);
    37ca:	2c00      	cmp	r4, #0
    37cc:	d1a4      	bne.n	3718 <nm_spi_write_block+0x88>
    37ce:	e036      	b.n	383e <nm_spi_write_block+0x1ae>
		len = 2;
	else
		len = 3;

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
		M2M_ERR("[nmi spi]: Failed bus error...\n");
    37d0:	223c      	movs	r2, #60	; 0x3c
    37d2:	32ff      	adds	r2, #255	; 0xff
    37d4:	4950      	ldr	r1, [pc, #320]	; (3918 <nm_spi_write_block+0x288>)
    37d6:	4841      	ldr	r0, [pc, #260]	; (38dc <nm_spi_write_block+0x24c>)
    37d8:	4b41      	ldr	r3, [pc, #260]	; (38e0 <nm_spi_write_block+0x250>)
    37da:	4798      	blx	r3
    37dc:	484f      	ldr	r0, [pc, #316]	; (391c <nm_spi_write_block+0x28c>)
    37de:	4b48      	ldr	r3, [pc, #288]	; (3900 <nm_spi_write_block+0x270>)
    37e0:	4798      	blx	r3
    37e2:	200d      	movs	r0, #13
    37e4:	4b40      	ldr	r3, [pc, #256]	; (38e8 <nm_spi_write_block+0x258>)
    37e6:	4798      	blx	r3
    37e8:	e036      	b.n	3858 <nm_spi_write_block+0x1c8>
		result = N_FAIL;
		goto _fail_;
	}
		
	if((rsp[len-1] != 0)||(rsp[len-2] != 0xC3))
    37ea:	ab08      	add	r3, sp, #32
    37ec:	191b      	adds	r3, r3, r4
    37ee:	3b05      	subs	r3, #5
    37f0:	781b      	ldrb	r3, [r3, #0]
    37f2:	2b00      	cmp	r3, #0
    37f4:	d106      	bne.n	3804 <nm_spi_write_block+0x174>
    37f6:	ab08      	add	r3, sp, #32
    37f8:	469c      	mov	ip, r3
    37fa:	4464      	add	r4, ip
    37fc:	3c06      	subs	r4, #6
    37fe:	7823      	ldrb	r3, [r4, #0]
    3800:	2bc3      	cmp	r3, #195	; 0xc3
    3802:	d036      	beq.n	3872 <nm_spi_write_block+0x1e2>
	{
		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
    3804:	22a1      	movs	r2, #161	; 0xa1
    3806:	0052      	lsls	r2, r2, #1
    3808:	4943      	ldr	r1, [pc, #268]	; (3918 <nm_spi_write_block+0x288>)
    380a:	4834      	ldr	r0, [pc, #208]	; (38dc <nm_spi_write_block+0x24c>)
    380c:	4c34      	ldr	r4, [pc, #208]	; (38e0 <nm_spi_write_block+0x250>)
    380e:	47a0      	blx	r4
    3810:	a907      	add	r1, sp, #28
    3812:	788b      	ldrb	r3, [r1, #2]
    3814:	784a      	ldrb	r2, [r1, #1]
    3816:	7809      	ldrb	r1, [r1, #0]
    3818:	4841      	ldr	r0, [pc, #260]	; (3920 <nm_spi_write_block+0x290>)
    381a:	47a0      	blx	r4
    381c:	200d      	movs	r0, #13
    381e:	4b32      	ldr	r3, [pc, #200]	; (38e8 <nm_spi_write_block+0x258>)
    3820:	4798      	blx	r3
    3822:	e019      	b.n	3858 <nm_spi_write_block+0x1c8>
	/**
		Data
	**/
	result = spi_data_write(buf, size);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    3824:	22f8      	movs	r2, #248	; 0xf8
    3826:	0092      	lsls	r2, r2, #2
    3828:	492b      	ldr	r1, [pc, #172]	; (38d8 <nm_spi_write_block+0x248>)
    382a:	482c      	ldr	r0, [pc, #176]	; (38dc <nm_spi_write_block+0x24c>)
    382c:	4b2c      	ldr	r3, [pc, #176]	; (38e0 <nm_spi_write_block+0x250>)
    382e:	4798      	blx	r3
    3830:	483c      	ldr	r0, [pc, #240]	; (3924 <nm_spi_write_block+0x294>)
    3832:	4b33      	ldr	r3, [pc, #204]	; (3900 <nm_spi_write_block+0x270>)
    3834:	4798      	blx	r3
    3836:	200d      	movs	r0, #13
    3838:	4b2b      	ldr	r3, [pc, #172]	; (38e8 <nm_spi_write_block+0x258>)
    383a:	4798      	blx	r3
    383c:	e01b      	b.n	3876 <nm_spi_write_block+0x1e6>
{
	uint8 len;
	uint8 rsp[3];
	sint8 result = N_OK;

    if (!gu8Crc_off)
    383e:	4b33      	ldr	r3, [pc, #204]	; (390c <nm_spi_write_block+0x27c>)
    3840:	781c      	ldrb	r4, [r3, #0]
		len = 2;
	else
		len = 3;
    3842:	4263      	negs	r3, r4
    3844:	4163      	adcs	r3, r4
    3846:	2403      	movs	r4, #3
    3848:	1ae4      	subs	r4, r4, r3

	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
    384a:	b2a1      	uxth	r1, r4
    384c:	a807      	add	r0, sp, #28
    384e:	4b36      	ldr	r3, [pc, #216]	; (3928 <nm_spi_write_block+0x298>)
    3850:	4798      	blx	r3
    3852:	2800      	cmp	r0, #0
    3854:	d0c9      	beq.n	37ea <nm_spi_write_block+0x15a>
    3856:	e7bb      	b.n	37d0 <nm_spi_write_block+0x140>
	/**
		Data RESP
	**/
	result = spi_data_rsp(cmd);
	if (result != N_OK) {
		M2M_ERR("[nmi spi]: Failed block data write...\n");
    3858:	22fa      	movs	r2, #250	; 0xfa
    385a:	0092      	lsls	r2, r2, #2
    385c:	491e      	ldr	r1, [pc, #120]	; (38d8 <nm_spi_write_block+0x248>)
    385e:	481f      	ldr	r0, [pc, #124]	; (38dc <nm_spi_write_block+0x24c>)
    3860:	4b1f      	ldr	r3, [pc, #124]	; (38e0 <nm_spi_write_block+0x250>)
    3862:	4798      	blx	r3
    3864:	482f      	ldr	r0, [pc, #188]	; (3924 <nm_spi_write_block+0x294>)
    3866:	4b26      	ldr	r3, [pc, #152]	; (3900 <nm_spi_write_block+0x270>)
    3868:	4798      	blx	r3
    386a:	200d      	movs	r0, #13
    386c:	4b1e      	ldr	r3, [pc, #120]	; (38e8 <nm_spi_write_block+0x258>)
    386e:	4798      	blx	r3
    3870:	e001      	b.n	3876 <nm_spi_write_block+0x1e6>
{
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
    3872:	2000      	movs	r0, #0
    3874:	e025      	b.n	38c2 <nm_spi_write_block+0x232>
	}
	
_FAIL_:
	if(result != N_OK)
	{
		nm_bsp_sleep(1);
    3876:	2001      	movs	r0, #1
    3878:	4c2c      	ldr	r4, [pc, #176]	; (392c <nm_spi_write_block+0x29c>)
    387a:	47a0      	blx	r4
		spi_cmd(CMD_RESET, 0, 0, 0, 0);
    387c:	9600      	str	r6, [sp, #0]
    387e:	0033      	movs	r3, r6
    3880:	0032      	movs	r2, r6
    3882:	0031      	movs	r1, r6
    3884:	20cf      	movs	r0, #207	; 0xcf
    3886:	4d12      	ldr	r5, [pc, #72]	; (38d0 <nm_spi_write_block+0x240>)
    3888:	47a8      	blx	r5
		spi_cmd_rsp(CMD_RESET);
    388a:	20cf      	movs	r0, #207	; 0xcf
    388c:	4b17      	ldr	r3, [pc, #92]	; (38ec <nm_spi_write_block+0x25c>)
    388e:	4798      	blx	r3
		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
    3890:	4a27      	ldr	r2, [pc, #156]	; (3930 <nm_spi_write_block+0x2a0>)
    3892:	4911      	ldr	r1, [pc, #68]	; (38d8 <nm_spi_write_block+0x248>)
    3894:	4811      	ldr	r0, [pc, #68]	; (38dc <nm_spi_write_block+0x24c>)
    3896:	4d12      	ldr	r5, [pc, #72]	; (38e0 <nm_spi_write_block+0x250>)
    3898:	47a8      	blx	r5
    389a:	9b03      	ldr	r3, [sp, #12]
    389c:	9a04      	ldr	r2, [sp, #16]
    389e:	4649      	mov	r1, r9
    38a0:	4824      	ldr	r0, [pc, #144]	; (3934 <nm_spi_write_block+0x2a4>)
    38a2:	47a8      	blx	r5
    38a4:	200d      	movs	r0, #13
    38a6:	4b10      	ldr	r3, [pc, #64]	; (38e8 <nm_spi_write_block+0x258>)
    38a8:	4798      	blx	r3
		nm_bsp_sleep(1);
    38aa:	2001      	movs	r0, #1
    38ac:	47a0      	blx	r4
    38ae:	2301      	movs	r3, #1
    38b0:	425b      	negs	r3, r3
    38b2:	469c      	mov	ip, r3
    38b4:	44e1      	add	r9, ip
		retry--;
		if(retry) goto _RETRY_;
    38b6:	464b      	mov	r3, r9
    38b8:	2b00      	cmp	r3, #0
    38ba:	d000      	beq.n	38be <nm_spi_write_block+0x22e>
    38bc:	e6f7      	b.n	36ae <nm_spi_write_block+0x1e>
	sint8 s8Ret;

	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);

	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
	else s8Ret = M2M_ERR_BUS_FAIL;
    38be:	2006      	movs	r0, #6
    38c0:	4240      	negs	r0, r0

	return s8Ret;
}
    38c2:	b009      	add	sp, #36	; 0x24
    38c4:	bc3c      	pop	{r2, r3, r4, r5}
    38c6:	4690      	mov	r8, r2
    38c8:	4699      	mov	r9, r3
    38ca:	46a2      	mov	sl, r4
    38cc:	46ab      	mov	fp, r5
    38ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    38d0:	00002d65 	.word	0x00002d65
    38d4:	000003ca 	.word	0x000003ca
    38d8:	0000a738 	.word	0x0000a738
    38dc:	00009e44 	.word	0x00009e44
    38e0:	00008845 	.word	0x00008845
    38e4:	0000ab14 	.word	0x0000ab14
    38e8:	00008879 	.word	0x00008879
    38ec:	00002f09 	.word	0x00002f09
    38f0:	0000ab44 	.word	0x0000ab44
    38f4:	00002d45 	.word	0x00002d45
    38f8:	0000a6f4 	.word	0x0000a6f4
    38fc:	0000ab7c 	.word	0x0000ab7c
    3900:	00008965 	.word	0x00008965
    3904:	00000359 	.word	0x00000359
    3908:	0000abb4 	.word	0x0000abb4
    390c:	20000120 	.word	0x20000120
    3910:	00000363 	.word	0x00000363
    3914:	0000abe8 	.word	0x0000abe8
    3918:	0000a70c 	.word	0x0000a70c
    391c:	0000ac20 	.word	0x0000ac20
    3920:	0000ac40 	.word	0x0000ac40
    3924:	0000ac70 	.word	0x0000ac70
    3928:	00002ee9 	.word	0x00002ee9
    392c:	000011d5 	.word	0x000011d5
    3930:	000003f2 	.word	0x000003f2
    3934:	0000aaf8 	.word	0x0000aaf8

00003938 <Socket_ReadSocketData>:
Date
		17 July 2012
*********************************************************************/
NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
								  uint32 u32StartAddress,uint16 u16ReadCount)
{
    3938:	b5f0      	push	{r4, r5, r6, r7, lr}
    393a:	465f      	mov	r7, fp
    393c:	4656      	mov	r6, sl
    393e:	464d      	mov	r5, r9
    3940:	4644      	mov	r4, r8
    3942:	b4f0      	push	{r4, r5, r6, r7}
    3944:	b085      	sub	sp, #20
    3946:	9001      	str	r0, [sp, #4]
    3948:	000e      	movs	r6, r1
    394a:	9202      	str	r2, [sp, #8]
    394c:	001d      	movs	r5, r3
    394e:	ab0e      	add	r3, sp, #56	; 0x38
    3950:	881c      	ldrh	r4, [r3, #0]
	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
    3952:	2c00      	cmp	r4, #0
    3954:	d062      	beq.n	3a1c <Socket_ReadSocketData+0xe4>
    3956:	0103      	lsls	r3, r0, #4
    3958:	4934      	ldr	r1, [pc, #208]	; (3a2c <Socket_ReadSocketData+0xf4>)
    395a:	585b      	ldr	r3, [r3, r1]
    395c:	2b00      	cmp	r3, #0
    395e:	d05d      	beq.n	3a1c <Socket_ReadSocketData+0xe4>
    3960:	0103      	lsls	r3, r0, #4
    3962:	18cb      	adds	r3, r1, r3
    3964:	889b      	ldrh	r3, [r3, #4]
    3966:	b29b      	uxth	r3, r3
    3968:	2b00      	cmp	r3, #0
    396a:	d057      	beq.n	3a1c <Socket_ReadSocketData+0xe4>
    396c:	0103      	lsls	r3, r0, #4
    396e:	18cb      	adds	r3, r1, r3
    3970:	7a9b      	ldrb	r3, [r3, #10]
    3972:	2b01      	cmp	r3, #1
    3974:	d152      	bne.n	3a1c <Socket_ReadSocketData+0xe4>
		uint32	u32Address = u32StartAddress;
		uint16	u16Read;
		sint16	s16Diff;
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
    3976:	80f4      	strh	r4, [r6, #6]
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    3978:	0107      	lsls	r7, r0, #4
    397a:	468b      	mov	fp, r1
    397c:	44bb      	add	fp, r7
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);

				u16ReadCount -= u16Read;
				u32Address += u16Read;

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    397e:	465b      	mov	r3, fp
    3980:	220a      	movs	r2, #10
    3982:	4690      	mov	r8, r2
    3984:	44d8      	add	r8, fp
    3986:	46ba      	mov	sl, r7
    3988:	9500      	str	r5, [sp, #0]
    398a:	9303      	str	r3, [sp, #12]
		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
    398c:	465b      	mov	r3, fp
    398e:	889b      	ldrh	r3, [r3, #4]
			if(s16Diff > 0)
    3990:	1ae3      	subs	r3, r4, r3
    3992:	b21b      	sxth	r3, r3
    3994:	2b00      	cmp	r3, #0
    3996:	dd04      	ble.n	39a2 <Socket_ReadSocketData+0x6a>
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
    3998:	9b03      	ldr	r3, [sp, #12]
    399a:	889d      	ldrh	r5, [r3, #4]
    399c:	b2ad      	uxth	r5, r5
			u8SetRxDone = 1;
			u16Read = u16ReadCount;
			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
			if(s16Diff > 0)
			{
				u8SetRxDone = 0;
    399e:	2300      	movs	r3, #0
    39a0:	e001      	b.n	39a6 <Socket_ReadSocketData+0x6e>
    39a2:	0025      	movs	r5, r4
		uint8	u8SetRxDone;

		pstrRecv->u16RemainingSize = u16ReadCount;
		do
		{
			u8SetRxDone = 1;
    39a4:	2301      	movs	r3, #1
			{
				u8SetRxDone = 0;
				u16Read		= gastrSockets[sock].u16UserBufferSize;
			}
			
			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
    39a6:	4a21      	ldr	r2, [pc, #132]	; (3a2c <Socket_ReadSocketData+0xf4>)
    39a8:	4651      	mov	r1, sl
    39aa:	5889      	ldr	r1, [r1, r2]
    39ac:	002a      	movs	r2, r5
    39ae:	9800      	ldr	r0, [sp, #0]
    39b0:	4f1f      	ldr	r7, [pc, #124]	; (3a30 <Socket_ReadSocketData+0xf8>)
    39b2:	47b8      	blx	r7
    39b4:	2800      	cmp	r0, #0
    39b6:	d125      	bne.n	3a04 <Socket_ReadSocketData+0xcc>
			{
				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
    39b8:	4b1c      	ldr	r3, [pc, #112]	; (3a2c <Socket_ReadSocketData+0xf4>)
    39ba:	4652      	mov	r2, sl
    39bc:	58d3      	ldr	r3, [r2, r3]
    39be:	6033      	str	r3, [r6, #0]
				pstrRecv->s16BufferSize		= u16Read;
    39c0:	80b5      	strh	r5, [r6, #4]
				pstrRecv->u16RemainingSize	-= u16Read;
    39c2:	88f3      	ldrh	r3, [r6, #6]
    39c4:	1b5b      	subs	r3, r3, r5
    39c6:	80f3      	strh	r3, [r6, #6]

				if (gpfAppSocketCb)
    39c8:	4b1a      	ldr	r3, [pc, #104]	; (3a34 <Socket_ReadSocketData+0xfc>)
    39ca:	681b      	ldr	r3, [r3, #0]
    39cc:	2b00      	cmp	r3, #0
    39ce:	d005      	beq.n	39dc <Socket_ReadSocketData+0xa4>
					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
    39d0:	4b18      	ldr	r3, [pc, #96]	; (3a34 <Socket_ReadSocketData+0xfc>)
    39d2:	681b      	ldr	r3, [r3, #0]
    39d4:	0032      	movs	r2, r6
    39d6:	9902      	ldr	r1, [sp, #8]
    39d8:	9801      	ldr	r0, [sp, #4]
    39da:	4798      	blx	r3

				u16ReadCount -= u16Read;
    39dc:	1b64      	subs	r4, r4, r5
    39de:	b2a4      	uxth	r4, r4
				u32Address += u16Read;
    39e0:	9b00      	ldr	r3, [sp, #0]
    39e2:	469c      	mov	ip, r3
    39e4:	44ac      	add	ip, r5
    39e6:	4663      	mov	r3, ip
    39e8:	9300      	str	r3, [sp, #0]

				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
    39ea:	4643      	mov	r3, r8
    39ec:	781b      	ldrb	r3, [r3, #0]
    39ee:	2b00      	cmp	r3, #0
    39f0:	d112      	bne.n	3a18 <Socket_ReadSocketData+0xe0>
    39f2:	2c00      	cmp	r4, #0
    39f4:	d012      	beq.n	3a1c <Socket_ReadSocketData+0xe4>
				{
					M2M_DBG("Application Closed Socket While Rx Is not Complete\n");
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    39f6:	3301      	adds	r3, #1
    39f8:	2200      	movs	r2, #0
    39fa:	2100      	movs	r1, #0
    39fc:	2000      	movs	r0, #0
    39fe:	4c0c      	ldr	r4, [pc, #48]	; (3a30 <Socket_ReadSocketData+0xf8>)
    3a00:	47a0      	blx	r4
    3a02:	e00b      	b.n	3a1c <Socket_ReadSocketData+0xe4>
					break;
				}
			}
			else
			{
				M2M_INFO("(ERRR)Current <%d>\n", u16ReadCount);
    3a04:	480c      	ldr	r0, [pc, #48]	; (3a38 <Socket_ReadSocketData+0x100>)
    3a06:	4d0d      	ldr	r5, [pc, #52]	; (3a3c <Socket_ReadSocketData+0x104>)
    3a08:	47a8      	blx	r5
    3a0a:	0021      	movs	r1, r4
    3a0c:	480c      	ldr	r0, [pc, #48]	; (3a40 <Socket_ReadSocketData+0x108>)
    3a0e:	47a8      	blx	r5
    3a10:	200d      	movs	r0, #13
    3a12:	4b0c      	ldr	r3, [pc, #48]	; (3a44 <Socket_ReadSocketData+0x10c>)
    3a14:	4798      	blx	r3
				break;
    3a16:	e001      	b.n	3a1c <Socket_ReadSocketData+0xe4>
			}
		}while(u16ReadCount != 0);
    3a18:	2c00      	cmp	r4, #0
    3a1a:	d1b7      	bne.n	398c <Socket_ReadSocketData+0x54>
	}
}
    3a1c:	b005      	add	sp, #20
    3a1e:	bc3c      	pop	{r2, r3, r4, r5}
    3a20:	4690      	mov	r8, r2
    3a22:	4699      	mov	r9, r3
    3a24:	46a2      	mov	sl, r4
    3a26:	46ab      	mov	fp, r5
    3a28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3a2a:	46c0      	nop			; (mov r8, r8)
    3a2c:	20000260 	.word	0x20000260
    3a30:	00001d09 	.word	0x00001d09
    3a34:	20000310 	.word	0x20000310
    3a38:	00009ea8 	.word	0x00009ea8
    3a3c:	00008845 	.word	0x00008845
    3a40:	0000adc4 	.word	0x0000adc4
    3a44:	00008879 	.word	0x00008879

00003a48 <m2m_ip_cb>:

Date
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
    3a48:	b5f0      	push	{r4, r5, r6, r7, lr}
    3a4a:	464f      	mov	r7, r9
    3a4c:	4646      	mov	r6, r8
    3a4e:	b4c0      	push	{r6, r7}
    3a50:	b09b      	sub	sp, #108	; 0x6c
    3a52:	000d      	movs	r5, r1
    3a54:	0014      	movs	r4, r2
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
    3a56:	2841      	cmp	r0, #65	; 0x41
    3a58:	d001      	beq.n	3a5e <m2m_ip_cb+0x16>
    3a5a:	2854      	cmp	r0, #84	; 0x54
    3a5c:	d11a      	bne.n	3a94 <m2m_ip_cb+0x4c>
	{
		tstrBindReply		strBindReply;
		tstrSocketBindMsg	strBind;

		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
    3a5e:	2300      	movs	r3, #0
    3a60:	2204      	movs	r2, #4
    3a62:	a909      	add	r1, sp, #36	; 0x24
    3a64:	0020      	movs	r0, r4
    3a66:	4caf      	ldr	r4, [pc, #700]	; (3d24 <m2m_ip_cb+0x2dc>)
    3a68:	47a0      	blx	r4
    3a6a:	2800      	cmp	r0, #0
    3a6c:	d000      	beq.n	3a70 <m2m_ip_cb+0x28>
    3a6e:	e153      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			strBind.status = strBindReply.s8Status;
    3a70:	ab09      	add	r3, sp, #36	; 0x24
    3a72:	785a      	ldrb	r2, [r3, #1]
    3a74:	ab05      	add	r3, sp, #20
    3a76:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    3a78:	4bab      	ldr	r3, [pc, #684]	; (3d28 <m2m_ip_cb+0x2e0>)
    3a7a:	681b      	ldr	r3, [r3, #0]
    3a7c:	2b00      	cmp	r3, #0
    3a7e:	d100      	bne.n	3a82 <m2m_ip_cb+0x3a>
    3a80:	e14a      	b.n	3d18 <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
    3a82:	4ba9      	ldr	r3, [pc, #676]	; (3d28 <m2m_ip_cb+0x2e0>)
    3a84:	681b      	ldr	r3, [r3, #0]
    3a86:	aa09      	add	r2, sp, #36	; 0x24
    3a88:	2000      	movs	r0, #0
    3a8a:	5610      	ldrsb	r0, [r2, r0]
    3a8c:	aa05      	add	r2, sp, #20
    3a8e:	2101      	movs	r1, #1
    3a90:	4798      	blx	r3
		17 July 2012
*********************************************************************/
static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
{	
	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
	{
    3a92:	e141      	b.n	3d18 <m2m_ip_cb+0x2d0>
			strBind.status = strBindReply.s8Status;
			if(gpfAppSocketCb)
				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
		}
	}
	else if(u8OpCode == SOCKET_CMD_LISTEN)
    3a94:	2842      	cmp	r0, #66	; 0x42
    3a96:	d11a      	bne.n	3ace <m2m_ip_cb+0x86>
	{
		tstrListenReply			strListenReply;
		tstrSocketListenMsg		strListen;
		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
    3a98:	2300      	movs	r3, #0
    3a9a:	2204      	movs	r2, #4
    3a9c:	a909      	add	r1, sp, #36	; 0x24
    3a9e:	0020      	movs	r0, r4
    3aa0:	4ca0      	ldr	r4, [pc, #640]	; (3d24 <m2m_ip_cb+0x2dc>)
    3aa2:	47a0      	blx	r4
    3aa4:	2800      	cmp	r0, #0
    3aa6:	d000      	beq.n	3aaa <m2m_ip_cb+0x62>
    3aa8:	e136      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			strListen.status = strListenReply.s8Status;
    3aaa:	ab09      	add	r3, sp, #36	; 0x24
    3aac:	785a      	ldrb	r2, [r3, #1]
    3aae:	ab05      	add	r3, sp, #20
    3ab0:	701a      	strb	r2, [r3, #0]
			if(gpfAppSocketCb)
    3ab2:	4b9d      	ldr	r3, [pc, #628]	; (3d28 <m2m_ip_cb+0x2e0>)
    3ab4:	681b      	ldr	r3, [r3, #0]
    3ab6:	2b00      	cmp	r3, #0
    3ab8:	d100      	bne.n	3abc <m2m_ip_cb+0x74>
    3aba:	e12d      	b.n	3d18 <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
    3abc:	4b9a      	ldr	r3, [pc, #616]	; (3d28 <m2m_ip_cb+0x2e0>)
    3abe:	681b      	ldr	r3, [r3, #0]
    3ac0:	aa09      	add	r2, sp, #36	; 0x24
    3ac2:	2000      	movs	r0, #0
    3ac4:	5610      	ldrsb	r0, [r2, r0]
    3ac6:	aa05      	add	r2, sp, #20
    3ac8:	2102      	movs	r1, #2
    3aca:	4798      	blx	r3
    3acc:	e124      	b.n	3d18 <m2m_ip_cb+0x2d0>
		}
	}
	else if(u8OpCode == SOCKET_CMD_ACCEPT)
    3ace:	2843      	cmp	r0, #67	; 0x43
    3ad0:	d149      	bne.n	3b66 <m2m_ip_cb+0x11e>
	{
		tstrAcceptReply			strAcceptReply;
		tstrSocketAcceptMsg		strAccept;
		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
    3ad2:	2300      	movs	r3, #0
    3ad4:	220c      	movs	r2, #12
    3ad6:	a905      	add	r1, sp, #20
    3ad8:	0020      	movs	r0, r4
    3ada:	4c92      	ldr	r4, [pc, #584]	; (3d24 <m2m_ip_cb+0x2dc>)
    3adc:	47a0      	blx	r4
    3ade:	2800      	cmp	r0, #0
    3ae0:	d000      	beq.n	3ae4 <m2m_ip_cb+0x9c>
    3ae2:	e119      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			if(strAcceptReply.sConnectedSock >= 0)
    3ae4:	ab05      	add	r3, sp, #20
    3ae6:	2209      	movs	r2, #9
    3ae8:	569a      	ldrsb	r2, [r3, r2]
    3aea:	2a00      	cmp	r2, #0
    3aec:	db24      	blt.n	3b38 <m2m_ip_cb+0xf0>
			{
				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
    3aee:	0018      	movs	r0, r3
    3af0:	2108      	movs	r1, #8
    3af2:	5659      	ldrsb	r1, [r3, r1]
    3af4:	4c8d      	ldr	r4, [pc, #564]	; (3d2c <m2m_ip_cb+0x2e4>)
    3af6:	0109      	lsls	r1, r1, #4
    3af8:	1861      	adds	r1, r4, r1
    3afa:	7ac9      	ldrb	r1, [r1, #11]
    3afc:	b2c9      	uxtb	r1, r1
    3afe:	0113      	lsls	r3, r2, #4
    3b00:	18e3      	adds	r3, r4, r3
    3b02:	72d9      	strb	r1, [r3, #11]
				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
    3b04:	2101      	movs	r1, #1
    3b06:	7299      	strb	r1, [r3, #10]
				gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    3b08:	8941      	ldrh	r1, [r0, #10]
    3b0a:	3908      	subs	r1, #8
    3b0c:	b289      	uxth	r1, r1
    3b0e:	8119      	strh	r1, [r3, #8]

				/* The session ID is used to distinguish different socket connections
					by comparing the assigned session ID to the one reported by the firmware*/
				++gu16SessionID;
    3b10:	4987      	ldr	r1, [pc, #540]	; (3d30 <m2m_ip_cb+0x2e8>)
    3b12:	880b      	ldrh	r3, [r1, #0]
    3b14:	3301      	adds	r3, #1
    3b16:	b29b      	uxth	r3, r3
    3b18:	800b      	strh	r3, [r1, #0]
				if(gu16SessionID == 0)
    3b1a:	880b      	ldrh	r3, [r1, #0]
    3b1c:	b29b      	uxth	r3, r3
    3b1e:	2b00      	cmp	r3, #0
    3b20:	d103      	bne.n	3b2a <m2m_ip_cb+0xe2>
					++gu16SessionID;
    3b22:	880b      	ldrh	r3, [r1, #0]
    3b24:	3301      	adds	r3, #1
    3b26:	b29b      	uxth	r3, r3
    3b28:	800b      	strh	r3, [r1, #0]

				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
    3b2a:	4b81      	ldr	r3, [pc, #516]	; (3d30 <m2m_ip_cb+0x2e8>)
    3b2c:	8819      	ldrh	r1, [r3, #0]
    3b2e:	b289      	uxth	r1, r1
    3b30:	0113      	lsls	r3, r2, #4
    3b32:	487e      	ldr	r0, [pc, #504]	; (3d2c <m2m_ip_cb+0x2e4>)
    3b34:	18c3      	adds	r3, r0, r3
    3b36:	80d9      	strh	r1, [r3, #6]
				M2M_DBG("Socket %d session ID = %d\r\n",strAcceptReply.sConnectedSock , gu16SessionID );		
			}
			strAccept.sock = strAcceptReply.sConnectedSock;
    3b38:	ab09      	add	r3, sp, #36	; 0x24
    3b3a:	701a      	strb	r2, [r3, #0]
			strAccept.strAddr.sin_family		= AF_INET;
    3b3c:	2202      	movs	r2, #2
    3b3e:	809a      	strh	r2, [r3, #4]
			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
    3b40:	aa05      	add	r2, sp, #20
    3b42:	8851      	ldrh	r1, [r2, #2]
    3b44:	80d9      	strh	r1, [r3, #6]
			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
    3b46:	9a06      	ldr	r2, [sp, #24]
    3b48:	920b      	str	r2, [sp, #44]	; 0x2c
			if(gpfAppSocketCb)
    3b4a:	4b77      	ldr	r3, [pc, #476]	; (3d28 <m2m_ip_cb+0x2e0>)
    3b4c:	681b      	ldr	r3, [r3, #0]
    3b4e:	2b00      	cmp	r3, #0
    3b50:	d100      	bne.n	3b54 <m2m_ip_cb+0x10c>
    3b52:	e0e1      	b.n	3d18 <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
    3b54:	4b74      	ldr	r3, [pc, #464]	; (3d28 <m2m_ip_cb+0x2e0>)
    3b56:	681b      	ldr	r3, [r3, #0]
    3b58:	aa05      	add	r2, sp, #20
    3b5a:	2008      	movs	r0, #8
    3b5c:	5610      	ldrsb	r0, [r2, r0]
    3b5e:	aa09      	add	r2, sp, #36	; 0x24
    3b60:	2104      	movs	r1, #4
    3b62:	4798      	blx	r3
    3b64:	e0d8      	b.n	3d18 <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
    3b66:	2844      	cmp	r0, #68	; 0x44
    3b68:	d001      	beq.n	3b6e <m2m_ip_cb+0x126>
    3b6a:	284b      	cmp	r0, #75	; 0x4b
    3b6c:	d125      	bne.n	3bba <m2m_ip_cb+0x172>
	{
		tstrConnectReply		strConnectReply;
		tstrSocketConnectMsg	strConnMsg;
		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
    3b6e:	2300      	movs	r3, #0
    3b70:	2204      	movs	r2, #4
    3b72:	a909      	add	r1, sp, #36	; 0x24
    3b74:	0020      	movs	r0, r4
    3b76:	4c6b      	ldr	r4, [pc, #428]	; (3d24 <m2m_ip_cb+0x2dc>)
    3b78:	47a0      	blx	r4
    3b7a:	2800      	cmp	r0, #0
    3b7c:	d000      	beq.n	3b80 <m2m_ip_cb+0x138>
    3b7e:	e0cb      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			strConnMsg.sock		= strConnectReply.sock;
    3b80:	ab09      	add	r3, sp, #36	; 0x24
    3b82:	2000      	movs	r0, #0
    3b84:	5618      	ldrsb	r0, [r3, r0]
    3b86:	aa05      	add	r2, sp, #20
    3b88:	7010      	strb	r0, [r2, #0]
			strConnMsg.s8Error	= strConnectReply.s8Error;
    3b8a:	785b      	ldrb	r3, [r3, #1]
    3b8c:	b25b      	sxtb	r3, r3
    3b8e:	7053      	strb	r3, [r2, #1]
			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
    3b90:	2b00      	cmp	r3, #0
    3b92:	d107      	bne.n	3ba4 <m2m_ip_cb+0x15c>
			{
				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
    3b94:	ab09      	add	r3, sp, #36	; 0x24
    3b96:	885a      	ldrh	r2, [r3, #2]
    3b98:	3a08      	subs	r2, #8
    3b9a:	b292      	uxth	r2, r2
    3b9c:	0103      	lsls	r3, r0, #4
    3b9e:	4963      	ldr	r1, [pc, #396]	; (3d2c <m2m_ip_cb+0x2e4>)
    3ba0:	18cb      	adds	r3, r1, r3
    3ba2:	811a      	strh	r2, [r3, #8]
			}
			if(gpfAppSocketCb)
    3ba4:	4b60      	ldr	r3, [pc, #384]	; (3d28 <m2m_ip_cb+0x2e0>)
    3ba6:	681b      	ldr	r3, [r3, #0]
    3ba8:	2b00      	cmp	r3, #0
    3baa:	d100      	bne.n	3bae <m2m_ip_cb+0x166>
    3bac:	e0b4      	b.n	3d18 <m2m_ip_cb+0x2d0>
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
    3bae:	4b5e      	ldr	r3, [pc, #376]	; (3d28 <m2m_ip_cb+0x2e0>)
    3bb0:	681b      	ldr	r3, [r3, #0]
    3bb2:	aa05      	add	r2, sp, #20
    3bb4:	2105      	movs	r1, #5
    3bb6:	4798      	blx	r3
			if(gpfAppSocketCb)
				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
		}
	}
	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
	{
    3bb8:	e0ae      	b.n	3d18 <m2m_ip_cb+0x2d0>
			}
			if(gpfAppSocketCb)
				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
		}
	}
	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
    3bba:	284a      	cmp	r0, #74	; 0x4a
    3bbc:	d115      	bne.n	3bea <m2m_ip_cb+0x1a2>
	{
		tstrDnsReply	strDnsReply;
		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
    3bbe:	2300      	movs	r3, #0
    3bc0:	2244      	movs	r2, #68	; 0x44
    3bc2:	a909      	add	r1, sp, #36	; 0x24
    3bc4:	0020      	movs	r0, r4
    3bc6:	4c57      	ldr	r4, [pc, #348]	; (3d24 <m2m_ip_cb+0x2dc>)
    3bc8:	47a0      	blx	r4
    3bca:	2800      	cmp	r0, #0
    3bcc:	d000      	beq.n	3bd0 <m2m_ip_cb+0x188>
    3bce:	e0a3      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			if(gpfAppResolveCb)
    3bd0:	4b58      	ldr	r3, [pc, #352]	; (3d34 <m2m_ip_cb+0x2ec>)
    3bd2:	681b      	ldr	r3, [r3, #0]
    3bd4:	2b00      	cmp	r3, #0
    3bd6:	d100      	bne.n	3bda <m2m_ip_cb+0x192>
    3bd8:	e09e      	b.n	3d18 <m2m_ip_cb+0x2d0>
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
    3bda:	4b56      	ldr	r3, [pc, #344]	; (3d34 <m2m_ip_cb+0x2ec>)
    3bdc:	681b      	ldr	r3, [r3, #0]
    3bde:	9a19      	ldr	r2, [sp, #100]	; 0x64
    3be0:	9203      	str	r2, [sp, #12]
    3be2:	0011      	movs	r1, r2
    3be4:	a809      	add	r0, sp, #36	; 0x24
    3be6:	4798      	blx	r3
    3be8:	e096      	b.n	3d18 <m2m_ip_cb+0x2d0>
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    3bea:	2846      	cmp	r0, #70	; 0x46
    3bec:	d005      	beq.n	3bfa <m2m_ip_cb+0x1b2>
    3bee:	2848      	cmp	r0, #72	; 0x48
    3bf0:	d005      	beq.n	3bfe <m2m_ip_cb+0x1b6>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    3bf2:	2606      	movs	r6, #6
		{
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
    3bf4:	284d      	cmp	r0, #77	; 0x4d
    3bf6:	d003      	beq.n	3c00 <m2m_ip_cb+0x1b8>
    3bf8:	e04c      	b.n	3c94 <m2m_ip_cb+0x24c>
		SOCKET				sock;
		sint16				s16RecvStatus;
		tstrRecvReply		strRecvReply;
		uint16				u16ReadSize;
		tstrSocketRecvMsg	strRecvMsg;
		uint8				u8CallbackMsgID = SOCKET_MSG_RECV;
    3bfa:	2606      	movs	r6, #6
    3bfc:	e000      	b.n	3c00 <m2m_ip_cb+0x1b8>
		uint16				u16DataOffset;

		if(u8OpCode == SOCKET_CMD_RECVFROM)
			u8CallbackMsgID = SOCKET_MSG_RECVFROM;
    3bfe:	2609      	movs	r6, #9

		/* Read RECV REPLY data structure.
		*/
		u16ReadSize = sizeof(tstrRecvReply);
		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
    3c00:	2300      	movs	r3, #0
    3c02:	2210      	movs	r2, #16
    3c04:	a905      	add	r1, sp, #20
    3c06:	0020      	movs	r0, r4
    3c08:	4f46      	ldr	r7, [pc, #280]	; (3d24 <m2m_ip_cb+0x2dc>)
    3c0a:	47b8      	blx	r7
    3c0c:	2800      	cmp	r0, #0
    3c0e:	d000      	beq.n	3c12 <m2m_ip_cb+0x1ca>
    3c10:	e082      	b.n	3d18 <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;

			sock			= strRecvReply.sock;
    3c12:	aa05      	add	r2, sp, #20
    3c14:	200c      	movs	r0, #12
    3c16:	5610      	ldrsb	r0, [r2, r0]
			u16SessionID = strRecvReply.u16SessionID;
    3c18:	89d3      	ldrh	r3, [r2, #14]
    3c1a:	469c      	mov	ip, r3
			M2M_DBG("recv callback session ID = %d\r\n",u16SessionID);
			
			/* Reset the Socket RX Pending Flag.
			*/
			gastrSockets[sock].bIsRecvPending = 0;
    3c1c:	0103      	lsls	r3, r0, #4
    3c1e:	4943      	ldr	r1, [pc, #268]	; (3d2c <m2m_ip_cb+0x2e4>)
    3c20:	18c9      	adds	r1, r1, r3
    3c22:	2300      	movs	r3, #0
    3c24:	730b      	strb	r3, [r1, #12]

			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
    3c26:	2708      	movs	r7, #8
    3c28:	5fd3      	ldrsh	r3, [r2, r7]
    3c2a:	4698      	mov	r8, r3
			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
    3c2c:	8953      	ldrh	r3, [r2, #10]
    3c2e:	4699      	mov	r9, r3
			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
    3c30:	af09      	add	r7, sp, #36	; 0x24
    3c32:	8853      	ldrh	r3, [r2, #2]
    3c34:	817b      	strh	r3, [r7, #10]
			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
    3c36:	9b06      	ldr	r3, [sp, #24]
    3c38:	930c      	str	r3, [sp, #48]	; 0x30

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    3c3a:	88ca      	ldrh	r2, [r1, #6]
    3c3c:	b292      	uxth	r2, r2
    3c3e:	4594      	cmp	ip, r2
    3c40:	d11f      	bne.n	3c82 <m2m_ip_cb+0x23a>
			{
				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
    3c42:	4643      	mov	r3, r8
    3c44:	2b00      	cmp	r3, #0
    3c46:	dd0d      	ble.n	3c64 <m2m_ip_cb+0x21c>
    3c48:	45a8      	cmp	r8, r5
    3c4a:	da0b      	bge.n	3c64 <m2m_ip_cb+0x21c>
					/* Read the Application data and deliver it to the application callback in
					the given application buffer. If the buffer is smaller than the received data,
					the data is passed to the application in chunks according to its buffer size.
					*/
					u16ReadSize = (uint16)s16RecvStatus;
					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
    3c4c:	0023      	movs	r3, r4
    3c4e:	444b      	add	r3, r9
    3c50:	4642      	mov	r2, r8
    3c52:	4669      	mov	r1, sp
    3c54:	818a      	strh	r2, [r1, #12]
    3c56:	898a      	ldrh	r2, [r1, #12]
    3c58:	9200      	str	r2, [sp, #0]
    3c5a:	0032      	movs	r2, r6
    3c5c:	0039      	movs	r1, r7
    3c5e:	4c36      	ldr	r4, [pc, #216]	; (3d38 <m2m_ip_cb+0x2f0>)
    3c60:	47a0      	blx	r4
    3c62:	e059      	b.n	3d18 <m2m_ip_cb+0x2d0>
				}
				else
				{
					strRecvMsg.s16BufferSize	= s16RecvStatus;
    3c64:	ab09      	add	r3, sp, #36	; 0x24
    3c66:	4642      	mov	r2, r8
    3c68:	809a      	strh	r2, [r3, #4]
					strRecvMsg.pu8Buffer		= NULL;
    3c6a:	2300      	movs	r3, #0
    3c6c:	9309      	str	r3, [sp, #36]	; 0x24
					if(gpfAppSocketCb)
    3c6e:	4b2e      	ldr	r3, [pc, #184]	; (3d28 <m2m_ip_cb+0x2e0>)
    3c70:	681b      	ldr	r3, [r3, #0]
    3c72:	2b00      	cmp	r3, #0
    3c74:	d050      	beq.n	3d18 <m2m_ip_cb+0x2d0>
						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
    3c76:	4b2c      	ldr	r3, [pc, #176]	; (3d28 <m2m_ip_cb+0x2e0>)
    3c78:	681b      	ldr	r3, [r3, #0]
    3c7a:	aa09      	add	r2, sp, #36	; 0x24
    3c7c:	0031      	movs	r1, r6
    3c7e:	4798      	blx	r3
    3c80:	e04a      	b.n	3d18 <m2m_ip_cb+0x2d0>
				}
			}
			else
			{
				M2M_DBG("Discard recv callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
				if(u16ReadSize < u16BufferSize)
    3c82:	2d10      	cmp	r5, #16
    3c84:	d948      	bls.n	3d18 <m2m_ip_cb+0x2d0>
				{
					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
    3c86:	2301      	movs	r3, #1
    3c88:	2200      	movs	r2, #0
    3c8a:	2100      	movs	r1, #0
    3c8c:	2000      	movs	r0, #0
    3c8e:	4c25      	ldr	r4, [pc, #148]	; (3d24 <m2m_ip_cb+0x2dc>)
    3c90:	47a0      	blx	r4
			if(gpfAppResolveCb)
				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
		}
	}
	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
	{
    3c92:	e041      	b.n	3d18 <m2m_ip_cb+0x2d0>
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    3c94:	2845      	cmp	r0, #69	; 0x45
    3c96:	d005      	beq.n	3ca4 <m2m_ip_cb+0x25c>
    3c98:	2847      	cmp	r0, #71	; 0x47
    3c9a:	d005      	beq.n	3ca8 <m2m_ip_cb+0x260>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    3c9c:	2507      	movs	r5, #7
						M2M_DBG("hif_receive Fail\n");
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
    3c9e:	284c      	cmp	r0, #76	; 0x4c
    3ca0:	d003      	beq.n	3caa <m2m_ip_cb+0x262>
    3ca2:	e022      	b.n	3cea <m2m_ip_cb+0x2a2>
	{
		SOCKET			sock;
		sint16			s16Rcvd;
		tstrSendReply	strReply;
		uint8			u8CallbackMsgID = SOCKET_MSG_SEND;
    3ca4:	2507      	movs	r5, #7
    3ca6:	e000      	b.n	3caa <m2m_ip_cb+0x262>

		if(u8OpCode == SOCKET_CMD_SENDTO)
			u8CallbackMsgID = SOCKET_MSG_SENDTO;
    3ca8:	2508      	movs	r5, #8

		if(hif_receive(u32Address, (uint8*)&strReply, sizeof(tstrSendReply), 0) == M2M_SUCCESS)
    3caa:	2300      	movs	r3, #0
    3cac:	2208      	movs	r2, #8
    3cae:	a909      	add	r1, sp, #36	; 0x24
    3cb0:	0020      	movs	r0, r4
    3cb2:	4c1c      	ldr	r4, [pc, #112]	; (3d24 <m2m_ip_cb+0x2dc>)
    3cb4:	47a0      	blx	r4
    3cb6:	2800      	cmp	r0, #0
    3cb8:	d12e      	bne.n	3d18 <m2m_ip_cb+0x2d0>
		{
			uint16 u16SessionID = 0;
			
			sock = strReply.sock;
    3cba:	ab09      	add	r3, sp, #36	; 0x24
    3cbc:	2000      	movs	r0, #0
    3cbe:	5618      	ldrsb	r0, [r3, r0]
			u16SessionID = strReply.u16SessionID;
    3cc0:	889a      	ldrh	r2, [r3, #4]
			M2M_DBG("send callback session ID = %d\r\n",u16SessionID);
			
			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
    3cc2:	8859      	ldrh	r1, [r3, #2]
    3cc4:	ab05      	add	r3, sp, #20
    3cc6:	8019      	strh	r1, [r3, #0]

			if(u16SessionID == gastrSockets[sock].u16SessionID)
    3cc8:	0103      	lsls	r3, r0, #4
    3cca:	4918      	ldr	r1, [pc, #96]	; (3d2c <m2m_ip_cb+0x2e4>)
    3ccc:	18cb      	adds	r3, r1, r3
    3cce:	88db      	ldrh	r3, [r3, #6]
    3cd0:	b29b      	uxth	r3, r3
    3cd2:	429a      	cmp	r2, r3
    3cd4:	d120      	bne.n	3d18 <m2m_ip_cb+0x2d0>
			{
				if(gpfAppSocketCb)
    3cd6:	4b14      	ldr	r3, [pc, #80]	; (3d28 <m2m_ip_cb+0x2e0>)
    3cd8:	681b      	ldr	r3, [r3, #0]
    3cda:	2b00      	cmp	r3, #0
    3cdc:	d01c      	beq.n	3d18 <m2m_ip_cb+0x2d0>
					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
    3cde:	4b12      	ldr	r3, [pc, #72]	; (3d28 <m2m_ip_cb+0x2e0>)
    3ce0:	681b      	ldr	r3, [r3, #0]
    3ce2:	aa05      	add	r2, sp, #20
    3ce4:	0029      	movs	r1, r5
    3ce6:	4798      	blx	r3
				}
			}
		}
	}
	else if((u8OpCode == SOCKET_CMD_SEND) || (u8OpCode == SOCKET_CMD_SENDTO) || (u8OpCode == SOCKET_CMD_SSL_SEND))
	{
    3ce8:	e016      	b.n	3d18 <m2m_ip_cb+0x2d0>
			{
				M2M_DBG("Discard send callback %d %d \r\n",u16SessionID , gastrSockets[sock].u16SessionID);
			}
		}
	}
	else if(u8OpCode == SOCKET_CMD_PING)
    3cea:	2852      	cmp	r0, #82	; 0x52
    3cec:	d114      	bne.n	3d18 <m2m_ip_cb+0x2d0>
	{
		tstrPingReply	strPingReply;
		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
    3cee:	2301      	movs	r3, #1
    3cf0:	2214      	movs	r2, #20
    3cf2:	a909      	add	r1, sp, #36	; 0x24
    3cf4:	0020      	movs	r0, r4
    3cf6:	4c0b      	ldr	r4, [pc, #44]	; (3d24 <m2m_ip_cb+0x2dc>)
    3cf8:	47a0      	blx	r4
    3cfa:	2800      	cmp	r0, #0
    3cfc:	d10c      	bne.n	3d18 <m2m_ip_cb+0x2d0>
		{
			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
    3cfe:	4b0f      	ldr	r3, [pc, #60]	; (3d3c <m2m_ip_cb+0x2f4>)
    3d00:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3d02:	601a      	str	r2, [r3, #0]
			if(gfpPingCb != NULL)
    3d04:	681b      	ldr	r3, [r3, #0]
    3d06:	2b00      	cmp	r3, #0
    3d08:	d006      	beq.n	3d18 <m2m_ip_cb+0x2d0>
			{
				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
    3d0a:	4b0c      	ldr	r3, [pc, #48]	; (3d3c <m2m_ip_cb+0x2f4>)
    3d0c:	681c      	ldr	r4, [r3, #0]
    3d0e:	ab09      	add	r3, sp, #36	; 0x24
    3d10:	7c1a      	ldrb	r2, [r3, #16]
    3d12:	990b      	ldr	r1, [sp, #44]	; 0x2c
    3d14:	9809      	ldr	r0, [sp, #36]	; 0x24
    3d16:	47a0      	blx	r4
			}
		}
	}
}
    3d18:	b01b      	add	sp, #108	; 0x6c
    3d1a:	bc0c      	pop	{r2, r3}
    3d1c:	4690      	mov	r8, r2
    3d1e:	4699      	mov	r9, r3
    3d20:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d22:	46c0      	nop			; (mov r8, r8)
    3d24:	00001d09 	.word	0x00001d09
    3d28:	20000310 	.word	0x20000310
    3d2c:	20000260 	.word	0x20000260
    3d30:	20000124 	.word	0x20000124
    3d34:	20000318 	.word	0x20000318
    3d38:	00003939 	.word	0x00003939
    3d3c:	20000314 	.word	0x20000314

00003d40 <socketInit>:

Date
		4 June 2012
*********************************************************************/
void socketInit(void)
{
    3d40:	b510      	push	{r4, lr}
	if(gbSocketInit == 0)
    3d42:	4b0a      	ldr	r3, [pc, #40]	; (3d6c <socketInit+0x2c>)
    3d44:	781b      	ldrb	r3, [r3, #0]
    3d46:	2b00      	cmp	r3, #0
    3d48:	d10e      	bne.n	3d68 <socketInit+0x28>
	{
		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
    3d4a:	22b0      	movs	r2, #176	; 0xb0
    3d4c:	2100      	movs	r1, #0
    3d4e:	4808      	ldr	r0, [pc, #32]	; (3d70 <socketInit+0x30>)
    3d50:	4b08      	ldr	r3, [pc, #32]	; (3d74 <socketInit+0x34>)
    3d52:	4798      	blx	r3
		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
    3d54:	4908      	ldr	r1, [pc, #32]	; (3d78 <socketInit+0x38>)
    3d56:	2002      	movs	r0, #2
    3d58:	4b08      	ldr	r3, [pc, #32]	; (3d7c <socketInit+0x3c>)
    3d5a:	4798      	blx	r3
		gbSocketInit	= 1;
    3d5c:	2201      	movs	r2, #1
    3d5e:	4b03      	ldr	r3, [pc, #12]	; (3d6c <socketInit+0x2c>)
    3d60:	701a      	strb	r2, [r3, #0]
		gu16SessionID	= 0;
    3d62:	2200      	movs	r2, #0
    3d64:	4b06      	ldr	r3, [pc, #24]	; (3d80 <socketInit+0x40>)
    3d66:	801a      	strh	r2, [r3, #0]
	}
}
    3d68:	bd10      	pop	{r4, pc}
    3d6a:	46c0      	nop			; (mov r8, r8)
    3d6c:	20000122 	.word	0x20000122
    3d70:	20000260 	.word	0x20000260
    3d74:	000015e5 	.word	0x000015e5
    3d78:	00003a49 	.word	0x00003a49
    3d7c:	00001df5 	.word	0x00001df5
    3d80:	20000124 	.word	0x20000124

00003d84 <registerSocketCallback>:
Date
		4 June 2012
*********************************************************************/
void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
{
	gpfAppSocketCb = pfAppSocketCb;
    3d84:	4b02      	ldr	r3, [pc, #8]	; (3d90 <registerSocketCallback+0xc>)
    3d86:	6018      	str	r0, [r3, #0]
	gpfAppResolveCb = pfAppResolveCb;
    3d88:	4b02      	ldr	r3, [pc, #8]	; (3d94 <registerSocketCallback+0x10>)
    3d8a:	6019      	str	r1, [r3, #0]
}
    3d8c:	4770      	bx	lr
    3d8e:	46c0      	nop			; (mov r8, r8)
    3d90:	20000310 	.word	0x20000310
    3d94:	20000318 	.word	0x20000318

00003d98 <socket>:

Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
    3d98:	b5f0      	push	{r4, r5, r6, r7, lr}
    3d9a:	4657      	mov	r7, sl
    3d9c:	464e      	mov	r6, r9
    3d9e:	b4c0      	push	{r6, r7}
    3da0:	b089      	sub	sp, #36	; 0x24
    3da2:	9205      	str	r2, [sp, #20]
	volatile tstrSocket		*pstrSock;
	static volatile uint8	u8NextTcpSock	= 0;
	static volatile uint8	u8NextUdpSock	= 0;

	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
    3da4:	2802      	cmp	r0, #2
    3da6:	d000      	beq.n	3daa <socket+0x12>
    3da8:	e094      	b.n	3ed4 <socket+0x13c>
	{
		if(u8Type == SOCK_STREAM)
    3daa:	2901      	cmp	r1, #1
    3dac:	d133      	bne.n	3e16 <socket+0x7e>
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    3dae:	4c4f      	ldr	r4, [pc, #316]	; (3eec <socket+0x154>)
    3db0:	7825      	ldrb	r5, [r4, #0]
    3db2:	b2ef      	uxtb	r7, r5
				pstrSock	= &gastrSockets[u8NextTcpSock];
    3db4:	7823      	ldrb	r3, [r4, #0]
    3db6:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    3db8:	7820      	ldrb	r0, [r4, #0]
    3dba:	3001      	adds	r0, #1
    3dbc:	3106      	adds	r1, #6
    3dbe:	4b4c      	ldr	r3, [pc, #304]	; (3ef0 <socket+0x158>)
    3dc0:	4798      	blx	r3
    3dc2:	b2c9      	uxtb	r1, r1
    3dc4:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    3dc6:	0133      	lsls	r3, r6, #4
    3dc8:	4a4a      	ldr	r2, [pc, #296]	; (3ef4 <socket+0x15c>)
    3dca:	18d3      	adds	r3, r2, r3
    3dcc:	7a9b      	ldrb	r3, [r3, #10]
    3dce:	2506      	movs	r5, #6
    3dd0:	2b00      	cmp	r3, #0
    3dd2:	d102      	bne.n	3dda <socket+0x42>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    3dd4:	0134      	lsls	r4, r6, #4
    3dd6:	18a4      	adds	r4, r4, r2
    3dd8:	e016      	b.n	3e08 <socket+0x70>
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    3dda:	4c44      	ldr	r4, [pc, #272]	; (3eec <socket+0x154>)
				pstrSock	= &gastrSockets[u8NextTcpSock];
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    3ddc:	4b44      	ldr	r3, [pc, #272]	; (3ef0 <socket+0x158>)
    3dde:	469a      	mov	sl, r3
				if(!pstrSock->bIsUsed)
    3de0:	4b44      	ldr	r3, [pc, #272]	; (3ef4 <socket+0x15c>)
    3de2:	4699      	mov	r9, r3
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
    3de4:	7827      	ldrb	r7, [r4, #0]
    3de6:	b2ff      	uxtb	r7, r7
				pstrSock	= &gastrSockets[u8NextTcpSock];
    3de8:	7823      	ldrb	r3, [r4, #0]
    3dea:	b2de      	uxtb	r6, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
    3dec:	7820      	ldrb	r0, [r4, #0]
    3dee:	3001      	adds	r0, #1
    3df0:	2107      	movs	r1, #7
    3df2:	47d0      	blx	sl
    3df4:	b2c9      	uxtb	r1, r1
    3df6:	7021      	strb	r1, [r4, #0]
				if(!pstrSock->bIsUsed)
    3df8:	0133      	lsls	r3, r6, #4
    3dfa:	444b      	add	r3, r9
    3dfc:	7a9b      	ldrb	r3, [r3, #10]
    3dfe:	2b00      	cmp	r3, #0
    3e00:	d104      	bne.n	3e0c <socket+0x74>
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
			{
				u8SockID	= u8NextTcpSock;
				pstrSock	= &gastrSockets[u8NextTcpSock];
    3e02:	0134      	lsls	r4, r6, #4
    3e04:	4b3b      	ldr	r3, [pc, #236]	; (3ef4 <socket+0x15c>)
    3e06:	18e4      	adds	r4, r4, r3
				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
				if(!pstrSock->bIsUsed)
				{
					sock = (SOCKET)u8SockID;
    3e08:	b27d      	sxtb	r5, r7
					break;
    3e0a:	e02d      	b.n	3e68 <socket+0xd0>
    3e0c:	3d01      	subs	r5, #1
    3e0e:	b2ed      	uxtb	r5, r5
	/* The only supported family is the AF_INET for UDP and TCP transport layer protocols. */
	if(u16Domain == AF_INET)
	{
		if(u8Type == SOCK_STREAM)
		{
			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
    3e10:	2d00      	cmp	r5, #0
    3e12:	d1e7      	bne.n	3de4 <socket+0x4c>
    3e14:	e061      	b.n	3eda <socket+0x142>
					sock = (SOCKET)u8SockID;
					break;
				}
			}
		}
		else if(u8Type == SOCK_DGRAM)
    3e16:	2902      	cmp	r1, #2
    3e18:	d15f      	bne.n	3eda <socket+0x142>
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    3e1a:	4a37      	ldr	r2, [pc, #220]	; (3ef8 <socket+0x160>)
    3e1c:	7815      	ldrb	r5, [r2, #0]
    3e1e:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    3e20:	7814      	ldrb	r4, [r2, #0]
    3e22:	0124      	lsls	r4, r4, #4
    3e24:	4b35      	ldr	r3, [pc, #212]	; (3efc <socket+0x164>)
    3e26:	18e4      	adds	r4, r4, r3
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    3e28:	7813      	ldrb	r3, [r2, #0]
    3e2a:	3301      	adds	r3, #1
    3e2c:	3101      	adds	r1, #1
    3e2e:	400b      	ands	r3, r1
    3e30:	7013      	strb	r3, [r2, #0]
				if(!pstrSock->bIsUsed)
    3e32:	7aa3      	ldrb	r3, [r4, #10]
    3e34:	2b00      	cmp	r3, #0
    3e36:	d00f      	beq.n	3e58 <socket+0xc0>
    3e38:	2203      	movs	r2, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    3e3a:	492f      	ldr	r1, [pc, #188]	; (3ef8 <socket+0x160>)
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    3e3c:	4f2f      	ldr	r7, [pc, #188]	; (3efc <socket+0x164>)
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    3e3e:	2003      	movs	r0, #3
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
			{
				u8SockID		= u8NextUdpSock;
    3e40:	780d      	ldrb	r5, [r1, #0]
    3e42:	b2ed      	uxtb	r5, r5
				pstrSock		= &pastrUDPSockets[u8NextUdpSock];
    3e44:	780c      	ldrb	r4, [r1, #0]
    3e46:	0124      	lsls	r4, r4, #4
    3e48:	19e4      	adds	r4, r4, r7
				u8NextUdpSock	= (u8NextUdpSock + 1) % UDP_SOCK_MAX;
    3e4a:	780b      	ldrb	r3, [r1, #0]
    3e4c:	3301      	adds	r3, #1
    3e4e:	4003      	ands	r3, r0
    3e50:	700b      	strb	r3, [r1, #0]
				if(!pstrSock->bIsUsed)
    3e52:	7aa3      	ldrb	r3, [r4, #10]
    3e54:	2b00      	cmp	r3, #0
    3e56:	d102      	bne.n	3e5e <socket+0xc6>
				{
					sock = (SOCKET)(u8SockID + TCP_SOCK_MAX);
    3e58:	3507      	adds	r5, #7
    3e5a:	b26d      	sxtb	r5, r5
					break;
    3e5c:	e004      	b.n	3e68 <socket+0xd0>
    3e5e:	3a01      	subs	r2, #1
    3e60:	b2d2      	uxtb	r2, r2
			}
		}
		else if(u8Type == SOCK_DGRAM)
		{
			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
    3e62:	2a00      	cmp	r2, #0
    3e64:	d1ec      	bne.n	3e40 <socket+0xa8>
    3e66:	e038      	b.n	3eda <socket+0x142>
					break;
				}
			}
		}

		if(sock >= 0)
    3e68:	2d00      	cmp	r5, #0
    3e6a:	db38      	blt.n	3ede <socket+0x146>
		{
			m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
    3e6c:	2210      	movs	r2, #16
    3e6e:	2100      	movs	r1, #0
    3e70:	0020      	movs	r0, r4
    3e72:	4b23      	ldr	r3, [pc, #140]	; (3f00 <socket+0x168>)
    3e74:	4798      	blx	r3
			pstrSock->bIsUsed = 1;
    3e76:	2301      	movs	r3, #1
    3e78:	72a3      	strb	r3, [r4, #10]

			/* The session ID is used to distinguish different socket connections
				by comparing the assigned session ID to the one reported by the firmware*/
			++gu16SessionID;
    3e7a:	4a22      	ldr	r2, [pc, #136]	; (3f04 <socket+0x16c>)
    3e7c:	8813      	ldrh	r3, [r2, #0]
    3e7e:	3301      	adds	r3, #1
    3e80:	b29b      	uxth	r3, r3
    3e82:	8013      	strh	r3, [r2, #0]
			if(gu16SessionID == 0)
    3e84:	8813      	ldrh	r3, [r2, #0]
    3e86:	b29b      	uxth	r3, r3
    3e88:	2b00      	cmp	r3, #0
    3e8a:	d103      	bne.n	3e94 <socket+0xfc>
				++gu16SessionID;
    3e8c:	8813      	ldrh	r3, [r2, #0]
    3e8e:	3301      	adds	r3, #1
    3e90:	b29b      	uxth	r3, r3
    3e92:	8013      	strh	r3, [r2, #0]
				
			pstrSock->u16SessionID = gu16SessionID;
    3e94:	4e1b      	ldr	r6, [pc, #108]	; (3f04 <socket+0x16c>)
    3e96:	8833      	ldrh	r3, [r6, #0]
    3e98:	b29b      	uxth	r3, r3
    3e9a:	80e3      	strh	r3, [r4, #6]
            M2M_INFO("Socket %d session ID = %d\r\n",sock, gu16SessionID );
    3e9c:	481a      	ldr	r0, [pc, #104]	; (3f08 <socket+0x170>)
    3e9e:	4f1b      	ldr	r7, [pc, #108]	; (3f0c <socket+0x174>)
    3ea0:	47b8      	blx	r7
    3ea2:	8832      	ldrh	r2, [r6, #0]
    3ea4:	b292      	uxth	r2, r2
    3ea6:	0029      	movs	r1, r5
    3ea8:	4819      	ldr	r0, [pc, #100]	; (3f10 <socket+0x178>)
    3eaa:	47b8      	blx	r7
    3eac:	200d      	movs	r0, #13
    3eae:	4b19      	ldr	r3, [pc, #100]	; (3f14 <socket+0x17c>)
    3eb0:	4798      	blx	r3

			if(u8Flags & SOCKET_FLAGS_SSL)
    3eb2:	9b05      	ldr	r3, [sp, #20]
    3eb4:	07db      	lsls	r3, r3, #31
    3eb6:	d512      	bpl.n	3ede <socket+0x146>
			{
				tstrSSLSocketCreateCmd	strSSLCreate;
				strSSLCreate.sslSock = sock;
    3eb8:	aa07      	add	r2, sp, #28
    3eba:	7015      	strb	r5, [r2, #0]
				pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
    3ebc:	2321      	movs	r3, #33	; 0x21
    3ebe:	72e3      	strb	r3, [r4, #11]
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
    3ec0:	2300      	movs	r3, #0
    3ec2:	9302      	str	r3, [sp, #8]
    3ec4:	9301      	str	r3, [sp, #4]
    3ec6:	9300      	str	r3, [sp, #0]
    3ec8:	3304      	adds	r3, #4
    3eca:	2150      	movs	r1, #80	; 0x50
    3ecc:	2002      	movs	r0, #2
    3ece:	4c12      	ldr	r4, [pc, #72]	; (3f18 <socket+0x180>)
    3ed0:	47a0      	blx	r4
    3ed2:	e004      	b.n	3ede <socket+0x146>
Date
		4 June 2012
*********************************************************************/
SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
{
	SOCKET					sock = -1;
    3ed4:	2501      	movs	r5, #1
    3ed6:	426d      	negs	r5, r5
    3ed8:	e001      	b.n	3ede <socket+0x146>
    3eda:	2501      	movs	r5, #1
    3edc:	426d      	negs	r5, r5
				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
			}
		}
	}
	return sock;
}
    3ede:	0028      	movs	r0, r5
    3ee0:	b009      	add	sp, #36	; 0x24
    3ee2:	bc0c      	pop	{r2, r3}
    3ee4:	4691      	mov	r9, r2
    3ee6:	469a      	mov	sl, r3
    3ee8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3eea:	46c0      	nop			; (mov r8, r8)
    3eec:	20000123 	.word	0x20000123
    3ef0:	000085dd 	.word	0x000085dd
    3ef4:	20000260 	.word	0x20000260
    3ef8:	20000121 	.word	0x20000121
    3efc:	200002d0 	.word	0x200002d0
    3f00:	000015e5 	.word	0x000015e5
    3f04:	20000124 	.word	0x20000124
    3f08:	00009ea8 	.word	0x00009ea8
    3f0c:	00008845 	.word	0x00008845
    3f10:	0000add8 	.word	0x0000add8
    3f14:	00008879 	.word	0x00008879
    3f18:	000016f5 	.word	0x000016f5

00003f1c <connect>:

Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
    3f1c:	b570      	push	{r4, r5, r6, lr}
    3f1e:	b088      	sub	sp, #32
    3f20:	1e04      	subs	r4, r0, #0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
    3f22:	db2f      	blt.n	3f84 <connect+0x68>
    3f24:	2900      	cmp	r1, #0
    3f26:	d030      	beq.n	3f8a <connect+0x6e>
    3f28:	0103      	lsls	r3, r0, #4
    3f2a:	481d      	ldr	r0, [pc, #116]	; (3fa0 <connect+0x84>)
    3f2c:	18c3      	adds	r3, r0, r3
    3f2e:	7a9b      	ldrb	r3, [r3, #10]
    3f30:	2b01      	cmp	r3, #1
    3f32:	d12d      	bne.n	3f90 <connect+0x74>
    3f34:	2a00      	cmp	r2, #0
    3f36:	d02e      	beq.n	3f96 <connect+0x7a>
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    3f38:	0123      	lsls	r3, r4, #4
    3f3a:	18c3      	adds	r3, r0, r3
    3f3c:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
    3f3e:	2644      	movs	r6, #68	; 0x44
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
    3f40:	07db      	lsls	r3, r3, #31
    3f42:	d505      	bpl.n	3f50 <connect+0x34>
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
    3f44:	0123      	lsls	r3, r4, #4
    3f46:	18c3      	adds	r3, r0, r3
    3f48:	7ada      	ldrb	r2, [r3, #11]
    3f4a:	ab05      	add	r3, sp, #20
    3f4c:	725a      	strb	r2, [r3, #9]
	{
		tstrConnectCmd	strConnect;
		uint8			u8Cmd = SOCKET_CMD_CONNECT;
		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
		{
			u8Cmd = SOCKET_CMD_SSL_CONNECT;
    3f4e:	3607      	adds	r6, #7
			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
		}
		strConnect.sock = sock;
    3f50:	ad05      	add	r5, sp, #20
    3f52:	722c      	strb	r4, [r5, #8]
		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
    3f54:	2208      	movs	r2, #8
    3f56:	0028      	movs	r0, r5
    3f58:	4b12      	ldr	r3, [pc, #72]	; (3fa4 <connect+0x88>)
    3f5a:	4798      	blx	r3

		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
    3f5c:	0124      	lsls	r4, r4, #4
    3f5e:	4b10      	ldr	r3, [pc, #64]	; (3fa0 <connect+0x84>)
    3f60:	191c      	adds	r4, r3, r4
    3f62:	88e3      	ldrh	r3, [r4, #6]
    3f64:	816b      	strh	r3, [r5, #10]
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
    3f66:	2300      	movs	r3, #0
    3f68:	9302      	str	r3, [sp, #8]
    3f6a:	9301      	str	r3, [sp, #4]
    3f6c:	9300      	str	r3, [sp, #0]
    3f6e:	330c      	adds	r3, #12
    3f70:	002a      	movs	r2, r5
    3f72:	0031      	movs	r1, r6
    3f74:	2002      	movs	r0, #2
    3f76:	4c0c      	ldr	r4, [pc, #48]	; (3fa8 <connect+0x8c>)
    3f78:	47a0      	blx	r4
		if(s8Ret != SOCK_ERR_NO_ERROR)
    3f7a:	2800      	cmp	r0, #0
    3f7c:	d00d      	beq.n	3f9a <connect+0x7e>
		{
			s8Ret = SOCK_ERR_INVALID;
    3f7e:	2009      	movs	r0, #9
    3f80:	4240      	negs	r0, r0
    3f82:	e00a      	b.n	3f9a <connect+0x7e>
Date
		5 June 2012
*********************************************************************/
sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    3f84:	2006      	movs	r0, #6
    3f86:	4240      	negs	r0, r0
    3f88:	e007      	b.n	3f9a <connect+0x7e>
    3f8a:	2006      	movs	r0, #6
    3f8c:	4240      	negs	r0, r0
    3f8e:	e004      	b.n	3f9a <connect+0x7e>
    3f90:	2006      	movs	r0, #6
    3f92:	4240      	negs	r0, r0
    3f94:	e001      	b.n	3f9a <connect+0x7e>
    3f96:	2006      	movs	r0, #6
    3f98:	4240      	negs	r0, r0
		{
			s8Ret = SOCK_ERR_INVALID;
		}
	}
	return s8Ret;
}
    3f9a:	b008      	add	sp, #32
    3f9c:	bd70      	pop	{r4, r5, r6, pc}
    3f9e:	46c0      	nop			; (mov r8, r8)
    3fa0:	20000260 	.word	0x20000260
    3fa4:	000015d1 	.word	0x000015d1
    3fa8:	000016f5 	.word	0x000016f5

00003fac <send>:

Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
    3fac:	b530      	push	{r4, r5, lr}
    3fae:	b089      	sub	sp, #36	; 0x24
    3fb0:	000c      	movs	r4, r1
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
    3fb2:	2800      	cmp	r0, #0
    3fb4:	db33      	blt.n	401e <send+0x72>
    3fb6:	2900      	cmp	r1, #0
    3fb8:	d034      	beq.n	4024 <send+0x78>
    3fba:	23af      	movs	r3, #175	; 0xaf
    3fbc:	00db      	lsls	r3, r3, #3
    3fbe:	429a      	cmp	r2, r3
    3fc0:	d833      	bhi.n	402a <send+0x7e>
    3fc2:	0103      	lsls	r3, r0, #4
    3fc4:	491d      	ldr	r1, [pc, #116]	; (403c <send+0x90>)
    3fc6:	18cb      	adds	r3, r1, r3
    3fc8:	7a9b      	ldrb	r3, [r3, #10]
    3fca:	2b01      	cmp	r3, #1
    3fcc:	d130      	bne.n	4030 <send+0x84>
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;

		strSend.sock			= sock;
    3fce:	a904      	add	r1, sp, #16
    3fd0:	7008      	strb	r0, [r1, #0]
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
    3fd2:	804a      	strh	r2, [r1, #2]
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
    3fd4:	0103      	lsls	r3, r0, #4
    3fd6:	4d19      	ldr	r5, [pc, #100]	; (403c <send+0x90>)
    3fd8:	18eb      	adds	r3, r5, r3
    3fda:	88db      	ldrh	r3, [r3, #6]
    3fdc:	818b      	strh	r3, [r1, #12]
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
		u16DataOffset	= TCP_TX_PACKET_OFFSET;
    3fde:	2550      	movs	r5, #80	; 0x50

		strSend.sock			= sock;
		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;

		if(sock >= TCP_SOCK_MAX)
    3fe0:	2806      	cmp	r0, #6
    3fe2:	dd00      	ble.n	3fe6 <send+0x3a>
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
    3fe4:	3d0c      	subs	r5, #12
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3fe6:	0103      	lsls	r3, r0, #4
    3fe8:	4914      	ldr	r1, [pc, #80]	; (403c <send+0x90>)
    3fea:	18cb      	adds	r3, r1, r3
    3fec:	7adb      	ldrb	r3, [r3, #11]
	{
		uint16			u16DataOffset;
		tstrSendCmd		strSend;
		uint8			u8Cmd;

		u8Cmd			= SOCKET_CMD_SEND;
    3fee:	2145      	movs	r1, #69	; 0x45

		if(sock >= TCP_SOCK_MAX)
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    3ff0:	07db      	lsls	r3, r3, #31
    3ff2:	d505      	bpl.n	4000 <send+0x54>
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
    3ff4:	0100      	lsls	r0, r0, #4
    3ff6:	4b11      	ldr	r3, [pc, #68]	; (403c <send+0x90>)
    3ff8:	1818      	adds	r0, r3, r0
    3ffa:	8905      	ldrh	r5, [r0, #8]
    3ffc:	b2ad      	uxth	r5, r5
		{
			u16DataOffset = UDP_TX_PACKET_OFFSET;
		}
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
		{
			u8Cmd			= SOCKET_CMD_SSL_SEND;
    3ffe:	3107      	adds	r1, #7
			u16DataOffset	= gastrSockets[sock].u16DataOffset;
		}

		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
    4000:	2380      	movs	r3, #128	; 0x80
    4002:	4319      	orrs	r1, r3
    4004:	9502      	str	r5, [sp, #8]
    4006:	9201      	str	r2, [sp, #4]
    4008:	9400      	str	r4, [sp, #0]
    400a:	3b70      	subs	r3, #112	; 0x70
    400c:	aa04      	add	r2, sp, #16
    400e:	2002      	movs	r0, #2
    4010:	4c0b      	ldr	r4, [pc, #44]	; (4040 <send+0x94>)
    4012:	47a0      	blx	r4
    4014:	2300      	movs	r3, #0
		if(s16Ret != SOCK_ERR_NO_ERROR)
    4016:	2800      	cmp	r0, #0
    4018:	d00c      	beq.n	4034 <send+0x88>
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
    401a:	3b0e      	subs	r3, #14
    401c:	e00a      	b.n	4034 <send+0x88>
Date
		5 June 2012
*********************************************************************/
sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    401e:	2306      	movs	r3, #6
    4020:	425b      	negs	r3, r3
    4022:	e007      	b.n	4034 <send+0x88>
    4024:	2306      	movs	r3, #6
    4026:	425b      	negs	r3, r3
    4028:	e004      	b.n	4034 <send+0x88>
    402a:	2306      	movs	r3, #6
    402c:	425b      	negs	r3, r3
    402e:	e001      	b.n	4034 <send+0x88>
    4030:	2306      	movs	r3, #6
    4032:	425b      	negs	r3, r3
		{
			s16Ret = SOCK_ERR_BUFFER_FULL;
		}
	}
	return s16Ret;
}
    4034:	0018      	movs	r0, r3
    4036:	b009      	add	sp, #36	; 0x24
    4038:	bd30      	pop	{r4, r5, pc}
    403a:	46c0      	nop			; (mov r8, r8)
    403c:	20000260 	.word	0x20000260
    4040:	000016f5 	.word	0x000016f5

00004044 <recv>:

Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
    4044:	b530      	push	{r4, r5, lr}
    4046:	b087      	sub	sp, #28
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
    4048:	2800      	cmp	r0, #0
    404a:	db33      	blt.n	40b4 <recv+0x70>
    404c:	2900      	cmp	r1, #0
    404e:	d034      	beq.n	40ba <recv+0x76>
    4050:	2a00      	cmp	r2, #0
    4052:	d035      	beq.n	40c0 <recv+0x7c>
    4054:	0104      	lsls	r4, r0, #4
    4056:	4d1e      	ldr	r5, [pc, #120]	; (40d0 <recv+0x8c>)
    4058:	192c      	adds	r4, r5, r4
    405a:	7aa4      	ldrb	r4, [r4, #10]
    405c:	2c01      	cmp	r4, #1
    405e:	d132      	bne.n	40c6 <recv+0x82>
	{
		s16Ret = SOCK_ERR_NO_ERROR;
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
    4060:	0104      	lsls	r4, r0, #4
    4062:	5161      	str	r1, [r4, r5]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
    4064:	1929      	adds	r1, r5, r4
    4066:	808a      	strh	r2, [r1, #4]

		if(!gastrSockets[sock].bIsRecvPending)
    4068:	7b09      	ldrb	r1, [r1, #12]
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
	
	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
	{
		s16Ret = SOCK_ERR_NO_ERROR;
    406a:	2200      	movs	r2, #0
		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
    406c:	2900      	cmp	r1, #0
    406e:	d12c      	bne.n	40ca <recv+0x86>
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;

			gastrSockets[sock].bIsRecvPending = 1;
    4070:	192a      	adds	r2, r5, r4
    4072:	2101      	movs	r1, #1
    4074:	7311      	strb	r1, [r2, #12]
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    4076:	7ad2      	ldrb	r2, [r2, #11]
		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;

		if(!gastrSockets[sock].bIsRecvPending)
		{
			tstrRecvCmd	strRecv;
			uint8		u8Cmd = SOCKET_CMD_RECV;
    4078:	3145      	adds	r1, #69	; 0x45

			gastrSockets[sock].bIsRecvPending = 1;
			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    407a:	07d2      	lsls	r2, r2, #31
    407c:	d500      	bpl.n	4080 <recv+0x3c>
			{
				u8Cmd = SOCKET_CMD_SSL_RECV;
    407e:	3107      	adds	r1, #7
			}

			/* Check the timeout value. */
			if(u32Timeoutmsec == 0)
    4080:	2b00      	cmp	r3, #0
    4082:	d102      	bne.n	408a <recv+0x46>
				strRecv.u32Timeoutmsec = 0xFFFFFFFF;
    4084:	3b01      	subs	r3, #1
    4086:	9304      	str	r3, [sp, #16]
    4088:	e000      	b.n	408c <recv+0x48>
			else
				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
    408a:	9304      	str	r3, [sp, #16]
			strRecv.sock = sock;
    408c:	aa04      	add	r2, sp, #16
    408e:	7110      	strb	r0, [r2, #4]
			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
    4090:	0100      	lsls	r0, r0, #4
    4092:	4b0f      	ldr	r3, [pc, #60]	; (40d0 <recv+0x8c>)
    4094:	1818      	adds	r0, r3, r0
    4096:	88c3      	ldrh	r3, [r0, #6]
    4098:	80d3      	strh	r3, [r2, #6]
		
			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
    409a:	2300      	movs	r3, #0
    409c:	9302      	str	r3, [sp, #8]
    409e:	9301      	str	r3, [sp, #4]
    40a0:	9300      	str	r3, [sp, #0]
    40a2:	3308      	adds	r3, #8
    40a4:	2002      	movs	r0, #2
    40a6:	4c0b      	ldr	r4, [pc, #44]	; (40d4 <recv+0x90>)
    40a8:	47a0      	blx	r4
    40aa:	2200      	movs	r2, #0
			if(s16Ret != SOCK_ERR_NO_ERROR)
    40ac:	2800      	cmp	r0, #0
    40ae:	d00c      	beq.n	40ca <recv+0x86>
			{
				s16Ret = SOCK_ERR_BUFFER_FULL;
    40b0:	3a0e      	subs	r2, #14
    40b2:	e00a      	b.n	40ca <recv+0x86>
Date
		5 June 2012
*********************************************************************/
sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
{
	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
    40b4:	2206      	movs	r2, #6
    40b6:	4252      	negs	r2, r2
    40b8:	e007      	b.n	40ca <recv+0x86>
    40ba:	2206      	movs	r2, #6
    40bc:	4252      	negs	r2, r2
    40be:	e004      	b.n	40ca <recv+0x86>
    40c0:	2206      	movs	r2, #6
    40c2:	4252      	negs	r2, r2
    40c4:	e001      	b.n	40ca <recv+0x86>
    40c6:	2206      	movs	r2, #6
    40c8:	4252      	negs	r2, r2
				s16Ret = SOCK_ERR_BUFFER_FULL;
			}
		}
	}
	return s16Ret;
}
    40ca:	0010      	movs	r0, r2
    40cc:	b007      	add	sp, #28
    40ce:	bd30      	pop	{r4, r5, pc}
    40d0:	20000260 	.word	0x20000260
    40d4:	000016f5 	.word	0x000016f5

000040d8 <close>:

Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
    40d8:	b530      	push	{r4, r5, lr}
    40da:	b087      	sub	sp, #28
    40dc:	0004      	movs	r4, r0
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
    40de:	481e      	ldr	r0, [pc, #120]	; (4158 <close+0x80>)
    40e0:	4d1e      	ldr	r5, [pc, #120]	; (415c <close+0x84>)
    40e2:	47a8      	blx	r5
    40e4:	0021      	movs	r1, r4
    40e6:	481e      	ldr	r0, [pc, #120]	; (4160 <close+0x88>)
    40e8:	47a8      	blx	r5
    40ea:	200d      	movs	r0, #13
    40ec:	4b1d      	ldr	r3, [pc, #116]	; (4164 <close+0x8c>)
    40ee:	4798      	blx	r3
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
    40f0:	2c00      	cmp	r4, #0
    40f2:	db29      	blt.n	4148 <close+0x70>
    40f4:	0123      	lsls	r3, r4, #4
    40f6:	4a1c      	ldr	r2, [pc, #112]	; (4168 <close+0x90>)
    40f8:	18d3      	adds	r3, r2, r3
    40fa:	7a9b      	ldrb	r3, [r3, #10]
    40fc:	2b01      	cmp	r3, #1
    40fe:	d126      	bne.n	414e <close+0x76>
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
		tstrCloseCmd strclose;
		strclose.sock = sock; 
    4100:	a905      	add	r1, sp, #20
    4102:	700c      	strb	r4, [r1, #0]
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
    4104:	0122      	lsls	r2, r4, #4
    4106:	4b18      	ldr	r3, [pc, #96]	; (4168 <close+0x90>)
    4108:	189b      	adds	r3, r3, r2
    410a:	88da      	ldrh	r2, [r3, #6]
    410c:	804a      	strh	r2, [r1, #2]
		
		gastrSockets[sock].bIsUsed = 0;
    410e:	2200      	movs	r2, #0
    4110:	729a      	strb	r2, [r3, #10]
		gastrSockets[sock].u16SessionID =0;
    4112:	80da      	strh	r2, [r3, #6]
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    4114:	7adb      	ldrb	r3, [r3, #11]
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    M2M_INFO("Sock to delete <%d>\n", sock);
	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
	{
		uint8	u8Cmd = SOCKET_CMD_CLOSE;
    4116:	2149      	movs	r1, #73	; 0x49
		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
		
		gastrSockets[sock].bIsUsed = 0;
		gastrSockets[sock].u16SessionID =0;
		
		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
    4118:	07db      	lsls	r3, r3, #31
    411a:	d500      	bpl.n	411e <close+0x46>
		{
			u8Cmd = SOCKET_CMD_SSL_CLOSE;
    411c:	3105      	adds	r1, #5
		}
		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
    411e:	2300      	movs	r3, #0
    4120:	9302      	str	r3, [sp, #8]
    4122:	9301      	str	r3, [sp, #4]
    4124:	9300      	str	r3, [sp, #0]
    4126:	3304      	adds	r3, #4
    4128:	aa05      	add	r2, sp, #20
    412a:	2002      	movs	r0, #2
    412c:	4d0f      	ldr	r5, [pc, #60]	; (416c <close+0x94>)
    412e:	47a8      	blx	r5
    4130:	1e05      	subs	r5, r0, #0
		if(s8Ret != SOCK_ERR_NO_ERROR)
    4132:	d001      	beq.n	4138 <close+0x60>
		{
			s8Ret = SOCK_ERR_INVALID;
    4134:	2509      	movs	r5, #9
    4136:	426d      	negs	r5, r5
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
    4138:	0124      	lsls	r4, r4, #4
    413a:	480b      	ldr	r0, [pc, #44]	; (4168 <close+0x90>)
    413c:	1820      	adds	r0, r4, r0
    413e:	2210      	movs	r2, #16
    4140:	2100      	movs	r1, #0
    4142:	4b0b      	ldr	r3, [pc, #44]	; (4170 <close+0x98>)
    4144:	4798      	blx	r3
    4146:	e004      	b.n	4152 <close+0x7a>
Date
		4 June 2012
*********************************************************************/
sint8 close(SOCKET sock)
{
	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
    4148:	2506      	movs	r5, #6
    414a:	426d      	negs	r5, r5
    414c:	e001      	b.n	4152 <close+0x7a>
    414e:	2506      	movs	r5, #6
    4150:	426d      	negs	r5, r5
			s8Ret = SOCK_ERR_INVALID;
		}
		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
	}
	return s8Ret;
}
    4152:	0028      	movs	r0, r5
    4154:	b007      	add	sp, #28
    4156:	bd30      	pop	{r4, r5, pc}
    4158:	00009ea8 	.word	0x00009ea8
    415c:	00008845 	.word	0x00008845
    4160:	0000adf4 	.word	0x0000adf4
    4164:	00008879 	.word	0x00008879
    4168:	20000260 	.word	0x20000260
    416c:	000016f5 	.word	0x000016f5
    4170:	000015e5 	.word	0x000015e5

00004174 <nmi_inet_addr>:

Date
		4 June 2012
*********************************************************************/
uint32 nmi_inet_addr(char *pcIpAddr)
{
    4174:	b5f0      	push	{r4, r5, r6, r7, lr}
    4176:	b083      	sub	sp, #12
	uint8	tmp;
	uint32	u32IP = 0;
    4178:	2300      	movs	r3, #0
    417a:	9301      	str	r3, [sp, #4]
    417c:	2600      	movs	r6, #0
    417e:	1c45      	adds	r5, r0, #1
    4180:	1d47      	adds	r7, r0, #5
    4182:	2200      	movs	r2, #0
		j = 0;
		do
		{
			c = *pcIpAddr;
			++j;
			if(j > 4)
    4184:	42bd      	cmp	r5, r7
    4186:	d01d      	beq.n	41c4 <nmi_inet_addr+0x50>
    4188:	0028      	movs	r0, r5
	for(i = 0; i < 4; ++i)
	{
		j = 0;
		do
		{
			c = *pcIpAddr;
    418a:	1e6b      	subs	r3, r5, #1
    418c:	781c      	ldrb	r4, [r3, #0]
			++j;
			if(j > 4)
			{
				return 0;
			}
			if(c == '.' || c == 0)
    418e:	2c2e      	cmp	r4, #46	; 0x2e
    4190:	d01c      	beq.n	41cc <nmi_inet_addr+0x58>
    4192:	2c00      	cmp	r4, #0
    4194:	d01d      	beq.n	41d2 <nmi_inet_addr+0x5e>
			{
				au8IP[i] = tmp;
				tmp = 0;
			}
			else if(c >= '0' && c <= '9')
    4196:	0023      	movs	r3, r4
    4198:	3b30      	subs	r3, #48	; 0x30
    419a:	2b09      	cmp	r3, #9
    419c:	d814      	bhi.n	41c8 <nmi_inet_addr+0x54>
    419e:	0091      	lsls	r1, r2, #2
    41a0:	1852      	adds	r2, r2, r1
    41a2:	0052      	lsls	r2, r2, #1
    41a4:	0013      	movs	r3, r2
    41a6:	3b30      	subs	r3, #48	; 0x30
			{
				tmp = (tmp * 10) + (c - '0');
    41a8:	191b      	adds	r3, r3, r4
    41aa:	b2da      	uxtb	r2, r3
    41ac:	3501      	adds	r5, #1
    41ae:	e7e9      	b.n	4184 <nmi_inet_addr+0x10>
    41b0:	3601      	adds	r6, #1
	uint8 	c;
	uint8	i, j;

	tmp = 0;

	for(i = 0; i < 4; ++i)
    41b2:	2e04      	cmp	r6, #4
    41b4:	d1e3      	bne.n	417e <nmi_inet_addr+0xa>
				return 0;
			}
			++pcIpAddr;
		} while(c != '.' && c != 0);
	}
	m2m_memcpy((uint8*)&u32IP, au8IP, 4);
    41b6:	2204      	movs	r2, #4
    41b8:	4669      	mov	r1, sp
    41ba:	a801      	add	r0, sp, #4
    41bc:	4b07      	ldr	r3, [pc, #28]	; (41dc <nmi_inet_addr+0x68>)
    41be:	4798      	blx	r3
	return u32IP;
    41c0:	9801      	ldr	r0, [sp, #4]
    41c2:	e009      	b.n	41d8 <nmi_inet_addr+0x64>
		{
			c = *pcIpAddr;
			++j;
			if(j > 4)
			{
				return 0;
    41c4:	2000      	movs	r0, #0
    41c6:	e007      	b.n	41d8 <nmi_inet_addr+0x64>
			{
				tmp = (tmp * 10) + (c - '0');
			}
			else
			{
				return 0;
    41c8:	2000      	movs	r0, #0
    41ca:	e005      	b.n	41d8 <nmi_inet_addr+0x64>
			{
				return 0;
			}
			if(c == '.' || c == 0)
			{
				au8IP[i] = tmp;
    41cc:	466b      	mov	r3, sp
    41ce:	54f2      	strb	r2, [r6, r3]
    41d0:	e7ee      	b.n	41b0 <nmi_inet_addr+0x3c>
    41d2:	466b      	mov	r3, sp
    41d4:	54f2      	strb	r2, [r6, r3]
    41d6:	e7eb      	b.n	41b0 <nmi_inet_addr+0x3c>
			++pcIpAddr;
		} while(c != '.' && c != 0);
	}
	m2m_memcpy((uint8*)&u32IP, au8IP, 4);
	return u32IP;
}
    41d8:	b003      	add	sp, #12
    41da:	bdf0      	pop	{r4, r5, r6, r7, pc}
    41dc:	000015d1 	.word	0x000015d1

000041e0 <gethostbyname>:

Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
    41e0:	b510      	push	{r4, lr}
    41e2:	b084      	sub	sp, #16
    41e4:	0004      	movs	r4, r0
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
    41e6:	4b0b      	ldr	r3, [pc, #44]	; (4214 <gethostbyname+0x34>)
    41e8:	4798      	blx	r3
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
    41ea:	b2c3      	uxtb	r3, r0
    41ec:	2b40      	cmp	r3, #64	; 0x40
    41ee:	d80c      	bhi.n	420a <gethostbyname+0x2a>
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
    41f0:	23ff      	movs	r3, #255	; 0xff
    41f2:	4018      	ands	r0, r3
    41f4:	1c43      	adds	r3, r0, #1
    41f6:	2200      	movs	r2, #0
    41f8:	9202      	str	r2, [sp, #8]
    41fa:	9201      	str	r2, [sp, #4]
    41fc:	9200      	str	r2, [sp, #0]
    41fe:	0022      	movs	r2, r4
    4200:	214a      	movs	r1, #74	; 0x4a
    4202:	2002      	movs	r0, #2
    4204:	4c04      	ldr	r4, [pc, #16]	; (4218 <gethostbyname+0x38>)
    4206:	47a0      	blx	r4
    4208:	e001      	b.n	420e <gethostbyname+0x2e>
Date
		4 June 2012
*********************************************************************/
sint8 gethostbyname(uint8 * pcHostName)
{
	sint8	s8Err = SOCK_ERR_INVALID_ARG;
    420a:	2006      	movs	r0, #6
    420c:	4240      	negs	r0, r0
	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
	{
		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
	}
	return s8Err;
}
    420e:	b004      	add	sp, #16
    4210:	bd10      	pop	{r4, pc}
    4212:	46c0      	nop			; (mov r8, r8)
    4214:	000015f5 	.word	0x000015f5
    4218:	000016f5 	.word	0x000016f5

0000421c <spi_flash_enable>:
 *	@brief	Enable spi flash operations
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
    421c:	b570      	push	{r4, r5, r6, lr}
    421e:	b082      	sub	sp, #8
    4220:	0004      	movs	r4, r0
	sint8 s8Ret = M2M_SUCCESS;
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    4222:	4b29      	ldr	r3, [pc, #164]	; (42c8 <spi_flash_enable+0xac>)
    4224:	4798      	blx	r3
    4226:	0500      	lsls	r0, r0, #20
    4228:	0d00      	lsrs	r0, r0, #20
 *	@author	M. Abdelmawla
 *	@version	1.0
 */
sint8 spi_flash_enable(uint8 enable)
{
	sint8 s8Ret = M2M_SUCCESS;
    422a:	2500      	movs	r5, #0
	if(REV(nmi_get_chipid()) >= REV_3A0) {		
    422c:	4b27      	ldr	r3, [pc, #156]	; (42cc <spi_flash_enable+0xb0>)
    422e:	4298      	cmp	r0, r3
    4230:	d947      	bls.n	42c2 <spi_flash_enable+0xa6>
		uint32 u32Val;
		
		/* Enable pinmux to SPI flash. */
		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
    4232:	a901      	add	r1, sp, #4
    4234:	4826      	ldr	r0, [pc, #152]	; (42d0 <spi_flash_enable+0xb4>)
    4236:	4b27      	ldr	r3, [pc, #156]	; (42d4 <spi_flash_enable+0xb8>)
    4238:	4798      	blx	r3
    423a:	1e05      	subs	r5, r0, #0
		if(s8Ret != M2M_SUCCESS) {
    423c:	d141      	bne.n	42c2 <spi_flash_enable+0xa6>
			goto ERR1;
		}
		/* GPIO15/16/17/18 */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x1111ul) << 12);
    423e:	4926      	ldr	r1, [pc, #152]	; (42d8 <spi_flash_enable+0xbc>)
    4240:	9b01      	ldr	r3, [sp, #4]
    4242:	4019      	ands	r1, r3
    4244:	4b25      	ldr	r3, [pc, #148]	; (42dc <spi_flash_enable+0xc0>)
    4246:	4319      	orrs	r1, r3
    4248:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    424a:	4821      	ldr	r0, [pc, #132]	; (42d0 <spi_flash_enable+0xb4>)
    424c:	4b24      	ldr	r3, [pc, #144]	; (42e0 <spi_flash_enable+0xc4>)
    424e:	4798      	blx	r3
		if(enable) {
    4250:	2c00      	cmp	r4, #0
    4252:	d016      	beq.n	4282 <spi_flash_enable+0x66>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xab;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    4254:	2100      	movs	r1, #0
    4256:	4823      	ldr	r0, [pc, #140]	; (42e4 <spi_flash_enable+0xc8>)
    4258:	4c21      	ldr	r4, [pc, #132]	; (42e0 <spi_flash_enable+0xc4>)
    425a:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    425c:	21ab      	movs	r1, #171	; 0xab
    425e:	4822      	ldr	r0, [pc, #136]	; (42e8 <spi_flash_enable+0xcc>)
    4260:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    4262:	2101      	movs	r1, #1
    4264:	4821      	ldr	r0, [pc, #132]	; (42ec <spi_flash_enable+0xd0>)
    4266:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    4268:	2100      	movs	r1, #0
    426a:	4821      	ldr	r0, [pc, #132]	; (42f0 <spi_flash_enable+0xd4>)
    426c:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
    426e:	2181      	movs	r1, #129	; 0x81
    4270:	4820      	ldr	r0, [pc, #128]	; (42f4 <spi_flash_enable+0xd8>)
    4272:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    4274:	4e20      	ldr	r6, [pc, #128]	; (42f8 <spi_flash_enable+0xdc>)
    4276:	4c21      	ldr	r4, [pc, #132]	; (42fc <spi_flash_enable+0xe0>)
    4278:	0030      	movs	r0, r6
    427a:	47a0      	blx	r4
    427c:	2801      	cmp	r0, #1
    427e:	d1fb      	bne.n	4278 <spi_flash_enable+0x5c>
    4280:	e015      	b.n	42ae <spi_flash_enable+0x92>
	volatile unsigned long tmp;
	unsigned char* cmd = (unsigned char*) &tmp;

	cmd[0] = 0xb9;

	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
    4282:	2100      	movs	r1, #0
    4284:	4817      	ldr	r0, [pc, #92]	; (42e4 <spi_flash_enable+0xc8>)
    4286:	4c16      	ldr	r4, [pc, #88]	; (42e0 <spi_flash_enable+0xc4>)
    4288:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
    428a:	21b9      	movs	r1, #185	; 0xb9
    428c:	4816      	ldr	r0, [pc, #88]	; (42e8 <spi_flash_enable+0xcc>)
    428e:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
    4290:	2101      	movs	r1, #1
    4292:	4816      	ldr	r0, [pc, #88]	; (42ec <spi_flash_enable+0xd0>)
    4294:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
    4296:	2100      	movs	r1, #0
    4298:	4815      	ldr	r0, [pc, #84]	; (42f0 <spi_flash_enable+0xd4>)
    429a:	47a0      	blx	r4
	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
    429c:	2181      	movs	r1, #129	; 0x81
    429e:	4815      	ldr	r0, [pc, #84]	; (42f4 <spi_flash_enable+0xd8>)
    42a0:	47a0      	blx	r4
	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
    42a2:	4e15      	ldr	r6, [pc, #84]	; (42f8 <spi_flash_enable+0xdc>)
    42a4:	4c15      	ldr	r4, [pc, #84]	; (42fc <spi_flash_enable+0xe0>)
    42a6:	0030      	movs	r0, r6
    42a8:	47a0      	blx	r4
    42aa:	2801      	cmp	r0, #1
    42ac:	d1fb      	bne.n	42a6 <spi_flash_enable+0x8a>
		} else {
			spi_flash_enter_low_power_mode();
		}
		/* Disable pinmux to SPI flash to minimize leakage. */
		u32Val &= ~((0x7777ul) << 12);
		u32Val |= ((0x0010ul) << 12);
    42ae:	490a      	ldr	r1, [pc, #40]	; (42d8 <spi_flash_enable+0xbc>)
    42b0:	9b01      	ldr	r3, [sp, #4]
    42b2:	4019      	ands	r1, r3
    42b4:	2380      	movs	r3, #128	; 0x80
    42b6:	025b      	lsls	r3, r3, #9
    42b8:	4319      	orrs	r1, r3
    42ba:	9101      	str	r1, [sp, #4]
		nm_write_reg(0x1410, u32Val);
    42bc:	4804      	ldr	r0, [pc, #16]	; (42d0 <spi_flash_enable+0xb4>)
    42be:	4b08      	ldr	r3, [pc, #32]	; (42e0 <spi_flash_enable+0xc4>)
    42c0:	4798      	blx	r3
	}
ERR1:
	return s8Ret;
}
    42c2:	0028      	movs	r0, r5
    42c4:	b002      	add	sp, #8
    42c6:	bd70      	pop	{r4, r5, r6, pc}
    42c8:	000025b9 	.word	0x000025b9
    42cc:	0000039f 	.word	0x0000039f
    42d0:	00001410 	.word	0x00001410
    42d4:	00002a01 	.word	0x00002a01
    42d8:	f8888fff 	.word	0xf8888fff
    42dc:	01111000 	.word	0x01111000
    42e0:	00002a0d 	.word	0x00002a0d
    42e4:	00010208 	.word	0x00010208
    42e8:	0001020c 	.word	0x0001020c
    42ec:	00010214 	.word	0x00010214
    42f0:	0001021c 	.word	0x0001021c
    42f4:	00010204 	.word	0x00010204
    42f8:	00010218 	.word	0x00010218
    42fc:	000029f5 	.word	0x000029f5

00004300 <mem_test_unit_ready>:
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
    4300:	b510      	push	{r4, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
    4302:	2301      	movs	r3, #1
    4304:	2800      	cmp	r0, #0
    4306:	d102      	bne.n	430e <mem_test_unit_ready+0xe>
    4308:	4b02      	ldr	r3, [pc, #8]	; (4314 <mem_test_unit_ready+0x14>)
    430a:	4798      	blx	r3
    430c:	0003      	movs	r3, r0
#endif

  Ctrl_access_unlock();

  return status;
}
    430e:	0018      	movs	r0, r3
    4310:	bd10      	pop	{r4, pc}
    4312:	46c0      	nop			; (mov r8, r8)
    4314:	00000a59 	.word	0x00000a59

00004318 <mem_read_capacity>:


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
    4318:	b510      	push	{r4, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
    431a:	2301      	movs	r3, #1
    431c:	2800      	cmp	r0, #0
    431e:	d103      	bne.n	4328 <mem_read_capacity+0x10>
    4320:	0008      	movs	r0, r1
    4322:	4b02      	ldr	r3, [pc, #8]	; (432c <mem_read_capacity+0x14>)
    4324:	4798      	blx	r3
    4326:	0003      	movs	r3, r0
#endif

  Ctrl_access_unlock();

  return status;
}
    4328:	0018      	movs	r0, r3
    432a:	bd10      	pop	{r4, pc}
    432c:	00000a89 	.word	0x00000a89

00004330 <mem_sector_size>:


U8 mem_sector_size(U8 lun)
{
    4330:	4243      	negs	r3, r0
    4332:	4158      	adcs	r0, r3
    4334:	b2c0      	uxtb	r0, r0
#endif

  Ctrl_access_unlock();

  return sector_size;
}
    4336:	4770      	bx	lr

00004338 <memory_2_ram>:
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
    4338:	b510      	push	{r4, lr}
    433a:	000c      	movs	r4, r1
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
    433c:	2301      	movs	r3, #1
    433e:	2800      	cmp	r0, #0
    4340:	d104      	bne.n	434c <memory_2_ram+0x14>
    4342:	0011      	movs	r1, r2
    4344:	0020      	movs	r0, r4
    4346:	4b02      	ldr	r3, [pc, #8]	; (4350 <memory_2_ram+0x18>)
    4348:	4798      	blx	r3
    434a:	0003      	movs	r3, r0
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
    434c:	0018      	movs	r0, r3
    434e:	bd10      	pop	{r4, pc}
    4350:	00000add 	.word	0x00000add

00004354 <ram_2_memory>:


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
    4354:	b510      	push	{r4, lr}
    4356:	000c      	movs	r4, r1
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
    4358:	2301      	movs	r3, #1
    435a:	2800      	cmp	r0, #0
    435c:	d104      	bne.n	4368 <ram_2_memory+0x14>
    435e:	0011      	movs	r1, r2
    4360:	0020      	movs	r0, r4
    4362:	4b02      	ldr	r3, [pc, #8]	; (436c <ram_2_memory+0x18>)
    4364:	4798      	blx	r3
    4366:	0003      	movs	r3, r0
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
    4368:	0018      	movs	r0, r3
    436a:	bd10      	pop	{r4, pc}
    436c:	00000b35 	.word	0x00000b35

00004370 <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    4370:	4b0c      	ldr	r3, [pc, #48]	; (43a4 <cpu_irq_enter_critical+0x34>)
    4372:	681b      	ldr	r3, [r3, #0]
    4374:	2b00      	cmp	r3, #0
    4376:	d110      	bne.n	439a <cpu_irq_enter_critical+0x2a>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    4378:	f3ef 8310 	mrs	r3, PRIMASK
		if (cpu_irq_is_enabled()) {
    437c:	2b00      	cmp	r3, #0
    437e:	d109      	bne.n	4394 <cpu_irq_enter_critical+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    4380:	b672      	cpsid	i
    4382:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    4386:	2200      	movs	r2, #0
    4388:	4b07      	ldr	r3, [pc, #28]	; (43a8 <cpu_irq_enter_critical+0x38>)
    438a:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    438c:	3201      	adds	r2, #1
    438e:	4b07      	ldr	r3, [pc, #28]	; (43ac <cpu_irq_enter_critical+0x3c>)
    4390:	701a      	strb	r2, [r3, #0]
    4392:	e002      	b.n	439a <cpu_irq_enter_critical+0x2a>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    4394:	2200      	movs	r2, #0
    4396:	4b05      	ldr	r3, [pc, #20]	; (43ac <cpu_irq_enter_critical+0x3c>)
    4398:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    439a:	4a02      	ldr	r2, [pc, #8]	; (43a4 <cpu_irq_enter_critical+0x34>)
    439c:	6813      	ldr	r3, [r2, #0]
    439e:	3301      	adds	r3, #1
    43a0:	6013      	str	r3, [r2, #0]
}
    43a2:	4770      	bx	lr
    43a4:	20000128 	.word	0x20000128
    43a8:	2000002e 	.word	0x2000002e
    43ac:	2000012c 	.word	0x2000012c

000043b0 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    43b0:	4b08      	ldr	r3, [pc, #32]	; (43d4 <cpu_irq_leave_critical+0x24>)
    43b2:	681a      	ldr	r2, [r3, #0]
    43b4:	3a01      	subs	r2, #1
    43b6:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    43b8:	681b      	ldr	r3, [r3, #0]
    43ba:	2b00      	cmp	r3, #0
    43bc:	d109      	bne.n	43d2 <cpu_irq_leave_critical+0x22>
    43be:	4b06      	ldr	r3, [pc, #24]	; (43d8 <cpu_irq_leave_critical+0x28>)
    43c0:	781b      	ldrb	r3, [r3, #0]
    43c2:	2b00      	cmp	r3, #0
    43c4:	d005      	beq.n	43d2 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    43c6:	2201      	movs	r2, #1
    43c8:	4b04      	ldr	r3, [pc, #16]	; (43dc <cpu_irq_leave_critical+0x2c>)
    43ca:	701a      	strb	r2, [r3, #0]
    43cc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    43d0:	b662      	cpsie	i
	}
}
    43d2:	4770      	bx	lr
    43d4:	20000128 	.word	0x20000128
    43d8:	2000012c 	.word	0x2000012c
    43dc:	2000002e 	.word	0x2000002e

000043e0 <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    43e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    43e2:	b083      	sub	sp, #12
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
	config->input_pull = PORT_PIN_PULL_UP;
    43e4:	ac01      	add	r4, sp, #4
    43e6:	2501      	movs	r5, #1
    43e8:	7065      	strb	r5, [r4, #1]
	config->powersave  = false;
    43ea:	2700      	movs	r7, #0
    43ec:	70a7      	strb	r7, [r4, #2]
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    43ee:	7025      	strb	r5, [r4, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    43f0:	0021      	movs	r1, r4
    43f2:	2017      	movs	r0, #23
    43f4:	4e06      	ldr	r6, [pc, #24]	; (4410 <system_board_init+0x30>)
    43f6:	47b0      	blx	r6
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    43f8:	2280      	movs	r2, #128	; 0x80
    43fa:	0412      	lsls	r2, r2, #16
    43fc:	4b05      	ldr	r3, [pc, #20]	; (4414 <system_board_init+0x34>)
    43fe:	619a      	str	r2, [r3, #24]
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    4400:	7027      	strb	r7, [r4, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    4402:	7065      	strb	r5, [r4, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    4404:	0021      	movs	r1, r4
    4406:	2037      	movs	r0, #55	; 0x37
    4408:	47b0      	blx	r6
}
    440a:	b003      	add	sp, #12
    440c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    440e:	46c0      	nop			; (mov r8, r8)
    4410:	000045f9 	.word	0x000045f9
    4414:	41004400 	.word	0x41004400

00004418 <extint_register_callback>:
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4418:	2317      	movs	r3, #23
	const enum extint_callback_type type)
{
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    441a:	2a00      	cmp	r2, #0
    441c:	d10d      	bne.n	443a <extint_register_callback+0x22>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    441e:	008b      	lsls	r3, r1, #2
    4420:	4a07      	ldr	r2, [pc, #28]	; (4440 <extint_register_callback+0x28>)
    4422:	589b      	ldr	r3, [r3, r2]
    4424:	2b00      	cmp	r3, #0
    4426:	d103      	bne.n	4430 <extint_register_callback+0x18>
		_extint_dev.callbacks[channel] = callback;
    4428:	0089      	lsls	r1, r1, #2
    442a:	5088      	str	r0, [r1, r2]
		return STATUS_OK;
    442c:	2300      	movs	r3, #0
    442e:	e004      	b.n	443a <extint_register_callback+0x22>
	} else if (_extint_dev.callbacks[channel] == callback) {
    4430:	4283      	cmp	r3, r0
    4432:	d001      	beq.n	4438 <extint_register_callback+0x20>
		return STATUS_OK;
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    4434:	231d      	movs	r3, #29
    4436:	e000      	b.n	443a <extint_register_callback+0x22>

	if (_extint_dev.callbacks[channel] == NULL) {
		_extint_dev.callbacks[channel] = callback;
		return STATUS_OK;
	} else if (_extint_dev.callbacks[channel] == callback) {
		return STATUS_OK;
    4438:	2300      	movs	r3, #0
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
}
    443a:	0018      	movs	r0, r3
    443c:	4770      	bx	lr
    443e:	46c0      	nop			; (mov r8, r8)
    4440:	20000320 	.word	0x20000320

00004444 <extint_chan_enable_callback>:

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4444:	2317      	movs	r3, #23
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    4446:	2900      	cmp	r1, #0
    4448:	d107      	bne.n	445a <extint_chan_enable_callback+0x16>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    444a:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    444c:	281f      	cmp	r0, #31
    444e:	d800      	bhi.n	4452 <extint_chan_enable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    4450:	4a03      	ldr	r2, [pc, #12]	; (4460 <extint_chan_enable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENSET.reg = (1UL << channel);
    4452:	2301      	movs	r3, #1
    4454:	4083      	lsls	r3, r0
    4456:	60d3      	str	r3, [r2, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    4458:	2300      	movs	r3, #0
}
    445a:	0018      	movs	r0, r3
    445c:	4770      	bx	lr
    445e:	46c0      	nop			; (mov r8, r8)
    4460:	40001800 	.word	0x40001800

00004464 <extint_chan_disable_callback>:

		eic->INTENCLR.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4464:	2317      	movs	r3, #23
 */
enum status_code extint_chan_disable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    4466:	2900      	cmp	r1, #0
    4468:	d107      	bne.n	447a <extint_chan_disable_callback+0x16>
	} else {
		Assert(false);
		return NULL;
    446a:	2200      	movs	r2, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    446c:	281f      	cmp	r0, #31
    446e:	d800      	bhi.n	4472 <extint_chan_disable_callback+0xe>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    4470:	4a03      	ldr	r2, [pc, #12]	; (4480 <extint_chan_disable_callback+0x1c>)
		Eic *const eic = _extint_get_eic_from_channel(channel);

		eic->INTENCLR.reg = (1UL << channel);
    4472:	2301      	movs	r3, #1
    4474:	4083      	lsls	r3, r0
    4476:	6093      	str	r3, [r2, #8]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    4478:	2300      	movs	r3, #0
}
    447a:	0018      	movs	r0, r3
    447c:	4770      	bx	lr
    447e:	46c0      	nop			; (mov r8, r8)
    4480:	40001800 	.word	0x40001800

00004484 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    4484:	b570      	push	{r4, r5, r6, lr}
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    4486:	2200      	movs	r2, #0
    4488:	4b15      	ldr	r3, [pc, #84]	; (44e0 <EIC_Handler+0x5c>)
    448a:	701a      	strb	r2, [r3, #0]
    448c:	2300      	movs	r3, #0
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    448e:	251f      	movs	r5, #31
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    4490:	4e14      	ldr	r6, [pc, #80]	; (44e4 <EIC_Handler+0x60>)

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    4492:	4c13      	ldr	r4, [pc, #76]	; (44e0 <EIC_Handler+0x5c>)
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    4494:	2b1f      	cmp	r3, #31
    4496:	d919      	bls.n	44cc <EIC_Handler+0x48>
    4498:	e00f      	b.n	44ba <EIC_Handler+0x36>
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    449a:	2100      	movs	r1, #0
    449c:	e000      	b.n	44a0 <EIC_Handler+0x1c>

	if (eic_index < EIC_INST_NUM) {
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    449e:	4912      	ldr	r1, [pc, #72]	; (44e8 <EIC_Handler+0x64>)
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));

	eic_module->INTFLAG.reg = eic_mask;
    44a0:	610a      	str	r2, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    44a2:	009b      	lsls	r3, r3, #2
    44a4:	599b      	ldr	r3, [r3, r6]
    44a6:	2b00      	cmp	r3, #0
    44a8:	d000      	beq.n	44ac <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    44aa:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    44ac:	7823      	ldrb	r3, [r4, #0]
    44ae:	3301      	adds	r3, #1
    44b0:	b2db      	uxtb	r3, r3
    44b2:	7023      	strb	r3, [r4, #0]
    44b4:	2b0f      	cmp	r3, #15
    44b6:	d9ed      	bls.n	4494 <EIC_Handler+0x10>
    44b8:	e011      	b.n	44de <EIC_Handler+0x5a>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    44ba:	0029      	movs	r1, r5
    44bc:	4019      	ands	r1, r3
    44be:	2201      	movs	r2, #1
    44c0:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    44c2:	2100      	movs	r1, #0
    44c4:	6909      	ldr	r1, [r1, #16]
		if (extint_chan_is_detected(_current_channel)) {
    44c6:	4211      	tst	r1, r2
    44c8:	d1e7      	bne.n	449a <EIC_Handler+0x16>
    44ca:	e7ef      	b.n	44ac <EIC_Handler+0x28>
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
	uint32_t eic_mask   = (1UL << (channel % 32));
    44cc:	0029      	movs	r1, r5
    44ce:	4019      	ands	r1, r3
    44d0:	2201      	movs	r2, #1
    44d2:	408a      	lsls	r2, r1

	return (eic_module->INTFLAG.reg & eic_mask);
    44d4:	4904      	ldr	r1, [pc, #16]	; (44e8 <EIC_Handler+0x64>)
    44d6:	6909      	ldr	r1, [r1, #16]
    44d8:	4211      	tst	r1, r2
    44da:	d1e0      	bne.n	449e <EIC_Handler+0x1a>
    44dc:	e7e6      	b.n	44ac <EIC_Handler+0x28>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    44de:	bd70      	pop	{r4, r5, r6, pc}
    44e0:	2000031c 	.word	0x2000031c
    44e4:	20000320 	.word	0x20000320
    44e8:	40001800 	.word	0x40001800

000044ec <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    44ec:	4a04      	ldr	r2, [pc, #16]	; (4500 <_extint_enable+0x14>)
    44ee:	7811      	ldrb	r1, [r2, #0]
    44f0:	2302      	movs	r3, #2
    44f2:	430b      	orrs	r3, r1
    44f4:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    44f6:	7853      	ldrb	r3, [r2, #1]
    44f8:	b25b      	sxtb	r3, r3
    44fa:	2b00      	cmp	r3, #0
    44fc:	dbfb      	blt.n	44f6 <_extint_enable+0xa>
	}

	while (extint_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    44fe:	4770      	bx	lr
    4500:	40001800 	.word	0x40001800

00004504 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    4504:	b500      	push	{lr}
    4506:	b083      	sub	sp, #12
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    4508:	4a12      	ldr	r2, [pc, #72]	; (4554 <_system_extint_init+0x50>)
    450a:	6991      	ldr	r1, [r2, #24]
    450c:	2340      	movs	r3, #64	; 0x40
    450e:	430b      	orrs	r3, r1
    4510:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    4512:	a901      	add	r1, sp, #4
    4514:	2300      	movs	r3, #0
    4516:	700b      	strb	r3, [r1, #0]

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    4518:	2005      	movs	r0, #5
    451a:	4b0f      	ldr	r3, [pc, #60]	; (4558 <_system_extint_init+0x54>)
    451c:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    451e:	2005      	movs	r0, #5
    4520:	4b0e      	ldr	r3, [pc, #56]	; (455c <_system_extint_init+0x58>)
    4522:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    4524:	4a0e      	ldr	r2, [pc, #56]	; (4560 <_system_extint_init+0x5c>)
    4526:	7811      	ldrb	r1, [r2, #0]
    4528:	2301      	movs	r3, #1
    452a:	430b      	orrs	r3, r1
    452c:	7013      	strb	r3, [r2, #0]
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    452e:	7853      	ldrb	r3, [r2, #1]
    4530:	b25b      	sxtb	r3, r3
    4532:	2b00      	cmp	r3, #0
    4534:	dbfb      	blt.n	452e <_system_extint_init+0x2a>
    4536:	4b0b      	ldr	r3, [pc, #44]	; (4564 <_system_extint_init+0x60>)
    4538:	0019      	movs	r1, r3
    453a:	3140      	adds	r1, #64	; 0x40

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
		_extint_dev.callbacks[j] = NULL;
    453c:	2200      	movs	r2, #0
    453e:	c304      	stmia	r3!, {r2}
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    4540:	4299      	cmp	r1, r3
    4542:	d1fc      	bne.n	453e <_system_extint_init+0x3a>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4544:	2210      	movs	r2, #16
    4546:	4b08      	ldr	r3, [pc, #32]	; (4568 <_system_extint_init+0x64>)
    4548:	601a      	str	r2, [r3, #0]
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
#endif

	/* Enables the driver for further use */
	_extint_enable();
    454a:	4b08      	ldr	r3, [pc, #32]	; (456c <_system_extint_init+0x68>)
    454c:	4798      	blx	r3
}
    454e:	b003      	add	sp, #12
    4550:	bd00      	pop	{pc}
    4552:	46c0      	nop			; (mov r8, r8)
    4554:	40000400 	.word	0x40000400
    4558:	00005d9d 	.word	0x00005d9d
    455c:	00005d11 	.word	0x00005d11
    4560:	40001800 	.word	0x40001800
    4564:	20000320 	.word	0x20000320
    4568:	e000e100 	.word	0xe000e100
    456c:	000044ed 	.word	0x000044ed

00004570 <extint_chan_get_config_defaults>:
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    4570:	2300      	movs	r3, #0
    4572:	6003      	str	r3, [r0, #0]
	config->gpio_pin_mux        = 0;
    4574:	6043      	str	r3, [r0, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    4576:	2201      	movs	r2, #1
    4578:	7202      	strb	r2, [r0, #8]
	config->wake_if_sleeping    = true;
    457a:	7242      	strb	r2, [r0, #9]
	config->filter_input_signal = false;
    457c:	7283      	strb	r3, [r0, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    457e:	3302      	adds	r3, #2
    4580:	72c3      	strb	r3, [r0, #11]
}
    4582:	4770      	bx	lr

00004584 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    4584:	b5f0      	push	{r4, r5, r6, r7, lr}
    4586:	b083      	sub	sp, #12
    4588:	0005      	movs	r5, r0
    458a:	000c      	movs	r4, r1
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    458c:	a901      	add	r1, sp, #4
    458e:	2300      	movs	r3, #0
    4590:	704b      	strb	r3, [r1, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    4592:	70cb      	strb	r3, [r1, #3]
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = config->gpio_pin_mux;
    4594:	7923      	ldrb	r3, [r4, #4]
    4596:	700b      	strb	r3, [r1, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    4598:	7a23      	ldrb	r3, [r4, #8]
    459a:	708b      	strb	r3, [r1, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    459c:	7820      	ldrb	r0, [r4, #0]
    459e:	4b14      	ldr	r3, [pc, #80]	; (45f0 <extint_chan_set_config+0x6c>)
    45a0:	4798      	blx	r3
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
	} else {
		Assert(false);
		return NULL;
    45a2:	2000      	movs	r0, #0
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
	uint8_t eic_index = (channel / 32);

	if (eic_index < EIC_INST_NUM) {
    45a4:	2d1f      	cmp	r5, #31
    45a6:	d800      	bhi.n	45aa <extint_chan_set_config+0x26>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

		return eics[eic_index];
    45a8:	4812      	ldr	r0, [pc, #72]	; (45f4 <extint_chan_set_config+0x70>)

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);

	uint32_t config_pos = (4 * (channel % 8));
    45aa:	2107      	movs	r1, #7
    45ac:	4029      	ands	r1, r5
    45ae:	0089      	lsls	r1, r1, #2
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    45b0:	7ae2      	ldrb	r2, [r4, #11]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    45b2:	7aa3      	ldrb	r3, [r4, #10]
    45b4:	2b00      	cmp	r3, #0
    45b6:	d001      	beq.n	45bc <extint_chan_set_config+0x38>
		new_config |= EIC_CONFIG_FILTEN0;
    45b8:	2308      	movs	r3, #8
    45ba:	431a      	orrs	r2, r3
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
    45bc:	08eb      	lsrs	r3, r5, #3
    45be:	009b      	lsls	r3, r3, #2
    45c0:	18c3      	adds	r3, r0, r3
		= (EIC_module->CONFIG[channel / 8].reg &
    45c2:	699e      	ldr	r6, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    45c4:	270f      	movs	r7, #15
    45c6:	408f      	lsls	r7, r1
    45c8:	43be      	bics	r6, r7
    45ca:	408a      	lsls	r2, r1
    45cc:	4332      	orrs	r2, r6
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    45ce:	619a      	str	r2, [r3, #24]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
    45d0:	7a63      	ldrb	r3, [r4, #9]
    45d2:	2b00      	cmp	r3, #0
    45d4:	d005      	beq.n	45e2 <extint_chan_set_config+0x5e>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
    45d6:	6942      	ldr	r2, [r0, #20]
    45d8:	2301      	movs	r3, #1
    45da:	40ab      	lsls	r3, r5
    45dc:	4313      	orrs	r3, r2
    45de:	6143      	str	r3, [r0, #20]
    45e0:	e004      	b.n	45ec <extint_chan_set_config+0x68>
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
    45e2:	6943      	ldr	r3, [r0, #20]
    45e4:	2201      	movs	r2, #1
    45e6:	40aa      	lsls	r2, r5
    45e8:	4393      	bics	r3, r2
    45ea:	6143      	str	r3, [r0, #20]
	}
}
    45ec:	b003      	add	sp, #12
    45ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    45f0:	00005e95 	.word	0x00005e95
    45f4:	40001800 	.word	0x40001800

000045f8 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    45f8:	b500      	push	{lr}
    45fa:	b083      	sub	sp, #12
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    45fc:	ab01      	add	r3, sp, #4
    45fe:	2280      	movs	r2, #128	; 0x80
    4600:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    4602:	780a      	ldrb	r2, [r1, #0]
    4604:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    4606:	784a      	ldrb	r2, [r1, #1]
    4608:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    460a:	788a      	ldrb	r2, [r1, #2]
    460c:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    460e:	0019      	movs	r1, r3
    4610:	4b01      	ldr	r3, [pc, #4]	; (4618 <port_pin_set_config+0x20>)
    4612:	4798      	blx	r3
}
    4614:	b003      	add	sp, #12
    4616:	bd00      	pop	{pc}
    4618:	00005e95 	.word	0x00005e95

0000461c <rtc_calendar_register_value_to_time>:
 */
void rtc_calendar_register_value_to_time(
		struct rtc_module *const module,
		const uint32_t register_value,
		struct rtc_calendar_time *const time)
{
    461c:	b510      	push	{r4, lr}
	/* Set year plus value of initial year. */
	time->year = ((register_value & RTC_MODE2_CLOCK_YEAR_Msk) >>
    461e:	0e8c      	lsrs	r4, r1, #26
    4620:	88c3      	ldrh	r3, [r0, #6]
    4622:	18e3      	adds	r3, r4, r3
    4624:	80d3      	strh	r3, [r2, #6]
			RTC_MODE2_CLOCK_YEAR_Pos) + module->year_init_value;

	/* Set month value into time struct. */
	time->month = ((register_value & RTC_MODE2_CLOCK_MONTH_Msk) >>
    4626:	018b      	lsls	r3, r1, #6
    4628:	0f1b      	lsrs	r3, r3, #28
    462a:	7153      	strb	r3, [r2, #5]
			RTC_MODE2_CLOCK_MONTH_Pos);

	/* Set day value into time struct. */
	time->day = ((register_value & RTC_MODE2_CLOCK_DAY_Msk) >>
    462c:	028b      	lsls	r3, r1, #10
    462e:	0edb      	lsrs	r3, r3, #27
    4630:	7113      	strb	r3, [r2, #4]
			RTC_MODE2_CLOCK_DAY_Pos);

	if (module->clock_24h) {
    4632:	7903      	ldrb	r3, [r0, #4]
    4634:	2b00      	cmp	r3, #0
    4636:	d003      	beq.n	4640 <rtc_calendar_register_value_to_time+0x24>
		/* Set hour in 24h mode. */
		time->hour = ((register_value & RTC_MODE2_CLOCK_HOUR_Msk) >>
    4638:	03cb      	lsls	r3, r1, #15
    463a:	0edb      	lsrs	r3, r3, #27
    463c:	7093      	strb	r3, [r2, #2]
    463e:	e005      	b.n	464c <rtc_calendar_register_value_to_time+0x30>
				RTC_MODE2_CLOCK_HOUR_Pos);
	} else {
		/* Set hour in 12h mode. */
		time->hour = ((register_value &
    4640:	040b      	lsls	r3, r1, #16
    4642:	0f1b      	lsrs	r3, r3, #28
    4644:	7093      	strb	r3, [r2, #2]
				(RTC_MODE2_CLOCK_HOUR_Msk & ~RTC_MODE2_CLOCK_HOUR_PM)) >>
				RTC_MODE2_CLOCK_HOUR_Pos);

		/* Set pm flag */
		time->pm = ((register_value & RTC_MODE2_CLOCK_HOUR_PM) != 0);
    4646:	03cb      	lsls	r3, r1, #15
    4648:	0fdb      	lsrs	r3, r3, #31
    464a:	70d3      	strb	r3, [r2, #3]
	}

	/* Set minute value into time struct. */
	time->minute = ((register_value & RTC_MODE2_CLOCK_MINUTE_Msk) >>
    464c:	098b      	lsrs	r3, r1, #6
    464e:	203f      	movs	r0, #63	; 0x3f
    4650:	4003      	ands	r3, r0
    4652:	7053      	strb	r3, [r2, #1]
			RTC_MODE2_CLOCK_MINUTE_Pos);

	/* Set second value into time struct. */
	time->second = ((register_value & RTC_MODE2_CLOCK_SECOND_Msk) >>
    4654:	4001      	ands	r1, r0
    4656:	7011      	strb	r1, [r2, #0]
			RTC_MODE2_CLOCK_SECOND_Pos);
}
    4658:	bd10      	pop	{r4, pc}
    465a:	46c0      	nop			; (mov r8, r8)

0000465c <rtc_calendar_get_time>:
 * \param[out] time  Pointer to value that will be filled with current time
 */
void rtc_calendar_get_time(
		struct rtc_module *const module,
		struct rtc_calendar_time *const time)
{
    465c:	b510      	push	{r4, lr}
    465e:	000a      	movs	r2, r1
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    4660:	6803      	ldr	r3, [r0, #0]

	/* Change of read method based on value of continuously_update value in
	 * the configuration structure. */
	if (!(module->continuously_update)) {
    4662:	7941      	ldrb	r1, [r0, #5]
    4664:	2900      	cmp	r1, #0
    4666:	d107      	bne.n	4678 <rtc_calendar_get_time+0x1c>
		/* Request read on CLOCK register. */
		rtc_module->MODE2.READREQ.reg = RTC_READREQ_RREQ;
    4668:	490c      	ldr	r1, [pc, #48]	; (469c <rtc_calendar_get_time+0x40>)
    466a:	8059      	strh	r1, [r3, #2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    466c:	6804      	ldr	r4, [r0, #0]

        if (rtc_module->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) {
    466e:	7aa1      	ldrb	r1, [r4, #10]
	 * the configuration structure. */
	if (!(module->continuously_update)) {
		/* Request read on CLOCK register. */
		rtc_module->MODE2.READREQ.reg = RTC_READREQ_RREQ;

		while (rtc_calendar_is_syncing(module)) {
    4670:	b249      	sxtb	r1, r1
    4672:	2900      	cmp	r1, #0
    4674:	dbfb      	blt.n	466e <rtc_calendar_get_time+0x12>
    4676:	e00c      	b.n	4692 <rtc_calendar_get_time+0x36>
			/* Wait for synchronization */
		}
	} else if (!(rtc_module->MODE2.READREQ.reg & RTC_READREQ_RCONT)){
    4678:	8859      	ldrh	r1, [r3, #2]
    467a:	0449      	lsls	r1, r1, #17
    467c:	d409      	bmi.n	4692 <rtc_calendar_get_time+0x36>
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT | RTC_READREQ_RREQ;
    467e:	885c      	ldrh	r4, [r3, #2]
    4680:	21c0      	movs	r1, #192	; 0xc0
    4682:	0209      	lsls	r1, r1, #8
    4684:	4321      	orrs	r1, r4
    4686:	8059      	strh	r1, [r3, #2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	Rtc *const rtc_module = module->hw;
    4688:	6804      	ldr	r4, [r0, #0]

        if (rtc_module->MODE2.STATUS.reg & RTC_STATUS_SYNCBUSY) {
    468a:	7aa1      	ldrb	r1, [r4, #10]
			/* Wait for synchronization */
		}
	} else if (!(rtc_module->MODE2.READREQ.reg & RTC_READREQ_RCONT)){
		rtc_module->MODE2.READREQ.reg |= RTC_READREQ_RCONT | RTC_READREQ_RREQ;
		 /* wait that the first Read request finishes */
		while (rtc_calendar_is_syncing(module)) {
    468c:	b249      	sxtb	r1, r1
    468e:	2900      	cmp	r1, #0
    4690:	dbfb      	blt.n	468a <rtc_calendar_get_time+0x2e>
			/* Wait for synchronization */
		}
	}

	/* Read value. */
	uint32_t register_value = rtc_module->MODE2.CLOCK.reg;
    4692:	6919      	ldr	r1, [r3, #16]

	/* Convert value to time structure. */
	rtc_calendar_register_value_to_time(module, register_value, time);
    4694:	4b02      	ldr	r3, [pc, #8]	; (46a0 <rtc_calendar_get_time+0x44>)
    4696:	4798      	blx	r3
}
    4698:	bd10      	pop	{r4, pc}
    469a:	46c0      	nop			; (mov r8, r8)
    469c:	ffff8000 	.word	0xffff8000
    46a0:	0000461d 	.word	0x0000461d

000046a4 <RTC_Handler>:
/**
 * \internal ISR handler for RTC
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
    46a4:	b510      	push	{r4, lr}
 *
 * \param [in] instance_index  Default value 0
 */
static void _rtc_interrupt_handler(const uint32_t instance_index)
{
	struct rtc_module *module = _rtc_instance[instance_index];
    46a6:	4b0d      	ldr	r3, [pc, #52]	; (46dc <RTC_Handler+0x38>)
    46a8:	681a      	ldr	r2, [r3, #0]

	Rtc *const rtc_module = module->hw;
    46aa:	6814      	ldr	r4, [r2, #0]

	/* Combine callback registered and enabled masks */
	uint16_t callback_mask = module->enabled_callback;
    46ac:	8a53      	ldrh	r3, [r2, #18]
	callback_mask &= module->registered_callback;
    46ae:	8a11      	ldrh	r1, [r2, #16]
    46b0:	4019      	ands	r1, r3

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = rtc_module->MODE2.INTFLAG.reg;
    46b2:	7a23      	ldrb	r3, [r4, #8]
	interrupt_status &= rtc_module->MODE2.INTENSET.reg;
    46b4:	79e0      	ldrb	r0, [r4, #7]
    46b6:	4003      	ands	r3, r0

	if (interrupt_status & RTC_MODE2_INTFLAG_OVF) {
    46b8:	09d8      	lsrs	r0, r3, #7
    46ba:	d006      	beq.n	46ca <RTC_Handler+0x26>
		/* Overflow interrupt */
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_OVERFLOW)) {
    46bc:	078b      	lsls	r3, r1, #30
    46be:	d501      	bpl.n	46c4 <RTC_Handler+0x20>
			module->callbacks[RTC_CALENDAR_CALLBACK_OVERFLOW]();
    46c0:	68d3      	ldr	r3, [r2, #12]
    46c2:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_OVF;
    46c4:	2380      	movs	r3, #128	; 0x80
    46c6:	7223      	strb	r3, [r4, #8]
    46c8:	e007      	b.n	46da <RTC_Handler+0x36>

	} else if (interrupt_status & RTC_MODE2_INTFLAG_ALARM(1 << 0)) {
    46ca:	07db      	lsls	r3, r3, #31
    46cc:	d505      	bpl.n	46da <RTC_Handler+0x36>
		/* Alarm 0 interrupt */
		if (callback_mask & (1 << RTC_CALENDAR_CALLBACK_ALARM_0)) {
    46ce:	07cb      	lsls	r3, r1, #31
    46d0:	d501      	bpl.n	46d6 <RTC_Handler+0x32>
			module->callbacks[RTC_CALENDAR_CALLBACK_ALARM_0]();
    46d2:	6893      	ldr	r3, [r2, #8]
    46d4:	4798      	blx	r3
		}
		/* Clear interrupt flag */
		rtc_module->MODE2.INTFLAG.reg = RTC_MODE2_INTFLAG_ALARM(1 << 0);
    46d6:	2301      	movs	r3, #1
    46d8:	7223      	strb	r3, [r4, #8]
 */
#if (RTC_INST_NUM == 1)
void RTC_Handler(void)
{
	_rtc_interrupt_handler(0);
}
    46da:	bd10      	pop	{r4, pc}
    46dc:	20000360 	.word	0x20000360

000046e0 <long_division>:
/**
 * \internal Calculate 64 bit division, ref can be found in
 * http://en.wikipedia.org/wiki/Division_algorithm#Long_division
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
    46e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    46e2:	465f      	mov	r7, fp
    46e4:	4656      	mov	r6, sl
    46e6:	464d      	mov	r5, r9
    46e8:	4644      	mov	r4, r8
    46ea:	b4f0      	push	{r4, r5, r6, r7}
    46ec:	b087      	sub	sp, #28
    46ee:	4680      	mov	r8, r0
    46f0:	9104      	str	r1, [sp, #16]
    46f2:	0016      	movs	r6, r2
    46f4:	001f      	movs	r7, r3
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
    46f6:	2200      	movs	r2, #0
    46f8:	2300      	movs	r3, #0
    46fa:	2100      	movs	r1, #0
    46fc:	468b      	mov	fp, r1
	for (i = 63; i >= 0; i--) {
    46fe:	243f      	movs	r4, #63	; 0x3f
		bit_shift = (uint64_t)1 << i;
    4700:	2001      	movs	r0, #1
    4702:	0021      	movs	r1, r4
    4704:	9600      	str	r6, [sp, #0]
    4706:	9701      	str	r7, [sp, #4]
    4708:	465c      	mov	r4, fp
    470a:	9403      	str	r4, [sp, #12]
    470c:	4644      	mov	r4, r8
    470e:	9405      	str	r4, [sp, #20]
    4710:	2420      	movs	r4, #32
    4712:	4264      	negs	r4, r4
    4714:	190c      	adds	r4, r1, r4
    4716:	d403      	bmi.n	4720 <long_division+0x40>
    4718:	0005      	movs	r5, r0
    471a:	40a5      	lsls	r5, r4
    471c:	46a8      	mov	r8, r5
    471e:	e004      	b.n	472a <long_division+0x4a>
    4720:	2420      	movs	r4, #32
    4722:	1a64      	subs	r4, r4, r1
    4724:	0005      	movs	r5, r0
    4726:	40e5      	lsrs	r5, r4
    4728:	46a8      	mov	r8, r5
    472a:	0004      	movs	r4, r0
    472c:	408c      	lsls	r4, r1
    472e:	46a1      	mov	r9, r4

		r = r << 1;
    4730:	0014      	movs	r4, r2
    4732:	001d      	movs	r5, r3
    4734:	18a4      	adds	r4, r4, r2
    4736:	415d      	adcs	r5, r3
    4738:	0022      	movs	r2, r4
    473a:	002b      	movs	r3, r5

		if (n & bit_shift) {
    473c:	9e05      	ldr	r6, [sp, #20]
    473e:	464f      	mov	r7, r9
    4740:	403e      	ands	r6, r7
    4742:	46b2      	mov	sl, r6
    4744:	9e04      	ldr	r6, [sp, #16]
    4746:	4647      	mov	r7, r8
    4748:	403e      	ands	r6, r7
    474a:	46b4      	mov	ip, r6
    474c:	4656      	mov	r6, sl
    474e:	4667      	mov	r7, ip
    4750:	433e      	orrs	r6, r7
    4752:	d003      	beq.n	475c <long_division+0x7c>
			r |= 0x01;
    4754:	0006      	movs	r6, r0
    4756:	4326      	orrs	r6, r4
    4758:	0032      	movs	r2, r6
    475a:	002b      	movs	r3, r5
		}

		if (r >= d) {
    475c:	9c00      	ldr	r4, [sp, #0]
    475e:	9d01      	ldr	r5, [sp, #4]
    4760:	429d      	cmp	r5, r3
    4762:	d80e      	bhi.n	4782 <long_division+0xa2>
    4764:	d101      	bne.n	476a <long_division+0x8a>
    4766:	4294      	cmp	r4, r2
    4768:	d80b      	bhi.n	4782 <long_division+0xa2>
			r = r - d;
    476a:	9c00      	ldr	r4, [sp, #0]
    476c:	9d01      	ldr	r5, [sp, #4]
    476e:	1b12      	subs	r2, r2, r4
    4770:	41ab      	sbcs	r3, r5
			q |= bit_shift;
    4772:	465c      	mov	r4, fp
    4774:	464d      	mov	r5, r9
    4776:	432c      	orrs	r4, r5
    4778:	46a3      	mov	fp, r4
    477a:	9c03      	ldr	r4, [sp, #12]
    477c:	4645      	mov	r5, r8
    477e:	432c      	orrs	r4, r5
    4780:	9403      	str	r4, [sp, #12]
 */
static uint64_t long_division(uint64_t n, uint64_t d)
{
	int32_t i;
	uint64_t q = 0, r = 0, bit_shift;
	for (i = 63; i >= 0; i--) {
    4782:	3901      	subs	r1, #1
    4784:	d2c4      	bcs.n	4710 <long_division+0x30>
    4786:	9b03      	ldr	r3, [sp, #12]
			q |= bit_shift;
		}
	}

	return q;
}
    4788:	4658      	mov	r0, fp
    478a:	0019      	movs	r1, r3
    478c:	b007      	add	sp, #28
    478e:	bc3c      	pop	{r2, r3, r4, r5}
    4790:	4690      	mov	r8, r2
    4792:	4699      	mov	r9, r3
    4794:	46a2      	mov	sl, r4
    4796:	46ab      	mov	fp, r5
    4798:	bdf0      	pop	{r4, r5, r6, r7, pc}
    479a:	46c0      	nop			; (mov r8, r8)

0000479c <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    479c:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    479e:	0849      	lsrs	r1, r1, #1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    47a0:	2340      	movs	r3, #64	; 0x40
    47a2:	2400      	movs	r4, #0
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    47a4:	4281      	cmp	r1, r0
    47a6:	d201      	bcs.n	47ac <_sercom_get_sync_baud_val+0x10>
    47a8:	e00a      	b.n	47c0 <_sercom_get_sync_baud_val+0x24>

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
		baud_calculated++;
    47aa:	001c      	movs	r4, r3
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
		clock_value = clock_value - baudrate;
    47ac:	1a09      	subs	r1, r1, r0
		baud_calculated++;
    47ae:	1c63      	adds	r3, r4, #1
    47b0:	b29b      	uxth	r3, r3
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    47b2:	4288      	cmp	r0, r1
    47b4:	d9f9      	bls.n	47aa <_sercom_get_sync_baud_val+0xe>

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    47b6:	2340      	movs	r3, #64	; 0x40
	}
	baud_calculated = baud_calculated - 1;

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    47b8:	2cff      	cmp	r4, #255	; 0xff
    47ba:	d801      	bhi.n	47c0 <_sercom_get_sync_baud_val+0x24>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
    47bc:	8014      	strh	r4, [r2, #0]
		return STATUS_OK;
    47be:	2300      	movs	r3, #0
	}
}
    47c0:	0018      	movs	r0, r3
    47c2:	bd10      	pop	{r4, pc}

000047c4 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    47c4:	b5f0      	push	{r4, r5, r6, r7, lr}
    47c6:	b083      	sub	sp, #12
    47c8:	000f      	movs	r7, r1
    47ca:	0016      	movs	r6, r2
    47cc:	aa08      	add	r2, sp, #32
    47ce:	7811      	ldrb	r1, [r2, #0]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    47d0:	0004      	movs	r4, r0
    47d2:	434c      	muls	r4, r1
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    47d4:	2240      	movs	r2, #64	; 0x40
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    47d6:	42bc      	cmp	r4, r7
    47d8:	d836      	bhi.n	4848 <_sercom_get_async_baud_val+0x84>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    47da:	2b00      	cmp	r3, #0
    47dc:	d112      	bne.n	4804 <_sercom_get_async_baud_val+0x40>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
    47de:	0002      	movs	r2, r0
    47e0:	0008      	movs	r0, r1
    47e2:	2100      	movs	r1, #0
    47e4:	4c1a      	ldr	r4, [pc, #104]	; (4850 <_sercom_get_async_baud_val+0x8c>)
    47e6:	47a0      	blx	r4
    47e8:	0001      	movs	r1, r0
    47ea:	003a      	movs	r2, r7
    47ec:	2300      	movs	r3, #0
    47ee:	2000      	movs	r0, #0
    47f0:	4c18      	ldr	r4, [pc, #96]	; (4854 <_sercom_get_async_baud_val+0x90>)
    47f2:	47a0      	blx	r4
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
    47f4:	2200      	movs	r2, #0
    47f6:	2301      	movs	r3, #1
    47f8:	1a12      	subs	r2, r2, r0
    47fa:	418b      	sbcs	r3, r1
    47fc:	0c12      	lsrs	r2, r2, #16
    47fe:	041b      	lsls	r3, r3, #16
    4800:	431a      	orrs	r2, r3
    4802:	e01f      	b.n	4844 <_sercom_get_async_baud_val+0x80>
		enum sercom_asynchronous_sample_num sample_num)
{
	/* Temporary variables  */
	uint64_t ratio = 0;
	uint64_t scale = 0;
	uint64_t baud_calculated = 0;
    4804:	2200      	movs	r2, #0
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    4806:	2b01      	cmp	r3, #1
    4808:	d11c      	bne.n	4844 <_sercom_get_async_baud_val+0x80>
		temp1 = ((uint64_t)baudrate * sample_num);
    480a:	000a      	movs	r2, r1
    480c:	2300      	movs	r3, #0
    480e:	2100      	movs	r1, #0
    4810:	4c0f      	ldr	r4, [pc, #60]	; (4850 <_sercom_get_async_baud_val+0x8c>)
    4812:	47a0      	blx	r4
    4814:	0002      	movs	r2, r0
    4816:	000b      	movs	r3, r1
    4818:	9200      	str	r2, [sp, #0]
    481a:	9301      	str	r3, [sp, #4]
		baud_int = long_division( peripheral_clock, temp1);
    481c:	0038      	movs	r0, r7
    481e:	2100      	movs	r1, #0
    4820:	4c0c      	ldr	r4, [pc, #48]	; (4854 <_sercom_get_async_baud_val+0x90>)
    4822:	47a0      	blx	r4
    4824:	0005      	movs	r5, r0
		if(baud_int > BAUD_INT_MAX) {
				return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    4826:	2240      	movs	r2, #64	; 0x40
		scale = ((uint64_t)1 << SHIFT) - ratio;
		baud_calculated = (65536 * scale) >> SHIFT;
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
		temp1 = ((uint64_t)baudrate * sample_num);
		baud_int = long_division( peripheral_clock, temp1);
		if(baud_int > BAUD_INT_MAX) {
    4828:	2380      	movs	r3, #128	; 0x80
    482a:	019b      	lsls	r3, r3, #6
    482c:	4298      	cmp	r0, r3
    482e:	d80b      	bhi.n	4848 <_sercom_get_async_baud_val+0x84>
				return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		temp1 = long_division( 8 * (uint64_t)peripheral_clock, temp1);
    4830:	0f79      	lsrs	r1, r7, #29
    4832:	00f8      	lsls	r0, r7, #3
    4834:	9a00      	ldr	r2, [sp, #0]
    4836:	9b01      	ldr	r3, [sp, #4]
    4838:	47a0      	blx	r4
		baud_fp = temp1 - 8 * baud_int;
		baud_calculated = baud_int | (baud_fp << 13);
    483a:	00ea      	lsls	r2, r5, #3
    483c:	1a82      	subs	r2, r0, r2
    483e:	b2d2      	uxtb	r2, r2
    4840:	0352      	lsls	r2, r2, #13
    4842:	432a      	orrs	r2, r5
	}

	*baudval = baud_calculated;
    4844:	8032      	strh	r2, [r6, #0]
	return STATUS_OK;
    4846:	2200      	movs	r2, #0
}
    4848:	0010      	movs	r0, r2
    484a:	b003      	add	sp, #12
    484c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    484e:	46c0      	nop			; (mov r8, r8)
    4850:	000085e9 	.word	0x000085e9
    4854:	000046e1 	.word	0x000046e1

00004858 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    4858:	b510      	push	{r4, lr}
    485a:	b082      	sub	sp, #8
    485c:	0004      	movs	r4, r0
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    485e:	4b0e      	ldr	r3, [pc, #56]	; (4898 <sercom_set_gclk_generator+0x40>)
    4860:	781b      	ldrb	r3, [r3, #0]
    4862:	2b00      	cmp	r3, #0
    4864:	d001      	beq.n	486a <sercom_set_gclk_generator+0x12>
    4866:	2900      	cmp	r1, #0
    4868:	d00d      	beq.n	4886 <sercom_set_gclk_generator+0x2e>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    486a:	a901      	add	r1, sp, #4
    486c:	700c      	strb	r4, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    486e:	2013      	movs	r0, #19
    4870:	4b0a      	ldr	r3, [pc, #40]	; (489c <sercom_set_gclk_generator+0x44>)
    4872:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    4874:	2013      	movs	r0, #19
    4876:	4b0a      	ldr	r3, [pc, #40]	; (48a0 <sercom_set_gclk_generator+0x48>)
    4878:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    487a:	4b07      	ldr	r3, [pc, #28]	; (4898 <sercom_set_gclk_generator+0x40>)
    487c:	705c      	strb	r4, [r3, #1]
		_sercom_config.generator_is_set = true;
    487e:	2201      	movs	r2, #1
    4880:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    4882:	2000      	movs	r0, #0
    4884:	e006      	b.n	4894 <sercom_set_gclk_generator+0x3c>
	} else if (generator_source == _sercom_config.generator_source) {
    4886:	4b04      	ldr	r3, [pc, #16]	; (4898 <sercom_set_gclk_generator+0x40>)
    4888:	785b      	ldrb	r3, [r3, #1]
    488a:	4283      	cmp	r3, r0
    488c:	d001      	beq.n	4892 <sercom_set_gclk_generator+0x3a>
		/* Return status OK if same config */
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    488e:	201d      	movs	r0, #29
    4890:	e000      	b.n	4894 <sercom_set_gclk_generator+0x3c>
		_sercom_config.generator_is_set = true;

		return STATUS_OK;
	} else if (generator_source == _sercom_config.generator_source) {
		/* Return status OK if same config */
		return STATUS_OK;
    4892:	2000      	movs	r0, #0
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    4894:	b002      	add	sp, #8
    4896:	bd10      	pop	{r4, pc}
    4898:	20000130 	.word	0x20000130
    489c:	00005d9d 	.word	0x00005d9d
    48a0:	00005d11 	.word	0x00005d11

000048a4 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    48a4:	4b44      	ldr	r3, [pc, #272]	; (49b8 <_sercom_get_default_pad+0x114>)
    48a6:	4298      	cmp	r0, r3
    48a8:	d033      	beq.n	4912 <_sercom_get_default_pad+0x6e>
    48aa:	d806      	bhi.n	48ba <_sercom_get_default_pad+0x16>
    48ac:	4b43      	ldr	r3, [pc, #268]	; (49bc <_sercom_get_default_pad+0x118>)
    48ae:	4298      	cmp	r0, r3
    48b0:	d00d      	beq.n	48ce <_sercom_get_default_pad+0x2a>
    48b2:	4b43      	ldr	r3, [pc, #268]	; (49c0 <_sercom_get_default_pad+0x11c>)
    48b4:	4298      	cmp	r0, r3
    48b6:	d01b      	beq.n	48f0 <_sercom_get_default_pad+0x4c>
    48b8:	e06f      	b.n	499a <_sercom_get_default_pad+0xf6>
    48ba:	4b42      	ldr	r3, [pc, #264]	; (49c4 <_sercom_get_default_pad+0x120>)
    48bc:	4298      	cmp	r0, r3
    48be:	d04a      	beq.n	4956 <_sercom_get_default_pad+0xb2>
    48c0:	4b41      	ldr	r3, [pc, #260]	; (49c8 <_sercom_get_default_pad+0x124>)
    48c2:	4298      	cmp	r0, r3
    48c4:	d058      	beq.n	4978 <_sercom_get_default_pad+0xd4>
    48c6:	4b41      	ldr	r3, [pc, #260]	; (49cc <_sercom_get_default_pad+0x128>)
    48c8:	4298      	cmp	r0, r3
    48ca:	d166      	bne.n	499a <_sercom_get_default_pad+0xf6>
    48cc:	e032      	b.n	4934 <_sercom_get_default_pad+0x90>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    48ce:	2901      	cmp	r1, #1
    48d0:	d006      	beq.n	48e0 <_sercom_get_default_pad+0x3c>
    48d2:	2900      	cmp	r1, #0
    48d4:	d063      	beq.n	499e <_sercom_get_default_pad+0xfa>
    48d6:	2902      	cmp	r1, #2
    48d8:	d006      	beq.n	48e8 <_sercom_get_default_pad+0x44>
    48da:	2903      	cmp	r1, #3
    48dc:	d006      	beq.n	48ec <_sercom_get_default_pad+0x48>
    48de:	e001      	b.n	48e4 <_sercom_get_default_pad+0x40>
    48e0:	483b      	ldr	r0, [pc, #236]	; (49d0 <_sercom_get_default_pad+0x12c>)
    48e2:	e067      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    48e4:	2000      	movs	r0, #0
    48e6:	e065      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    48e8:	483a      	ldr	r0, [pc, #232]	; (49d4 <_sercom_get_default_pad+0x130>)
    48ea:	e063      	b.n	49b4 <_sercom_get_default_pad+0x110>
    48ec:	483a      	ldr	r0, [pc, #232]	; (49d8 <_sercom_get_default_pad+0x134>)
    48ee:	e061      	b.n	49b4 <_sercom_get_default_pad+0x110>
    48f0:	2901      	cmp	r1, #1
    48f2:	d006      	beq.n	4902 <_sercom_get_default_pad+0x5e>
    48f4:	2900      	cmp	r1, #0
    48f6:	d054      	beq.n	49a2 <_sercom_get_default_pad+0xfe>
    48f8:	2902      	cmp	r1, #2
    48fa:	d006      	beq.n	490a <_sercom_get_default_pad+0x66>
    48fc:	2903      	cmp	r1, #3
    48fe:	d006      	beq.n	490e <_sercom_get_default_pad+0x6a>
    4900:	e001      	b.n	4906 <_sercom_get_default_pad+0x62>
    4902:	4836      	ldr	r0, [pc, #216]	; (49dc <_sercom_get_default_pad+0x138>)
    4904:	e056      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4906:	2000      	movs	r0, #0
    4908:	e054      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    490a:	4835      	ldr	r0, [pc, #212]	; (49e0 <_sercom_get_default_pad+0x13c>)
    490c:	e052      	b.n	49b4 <_sercom_get_default_pad+0x110>
    490e:	4835      	ldr	r0, [pc, #212]	; (49e4 <_sercom_get_default_pad+0x140>)
    4910:	e050      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4912:	2901      	cmp	r1, #1
    4914:	d006      	beq.n	4924 <_sercom_get_default_pad+0x80>
    4916:	2900      	cmp	r1, #0
    4918:	d045      	beq.n	49a6 <_sercom_get_default_pad+0x102>
    491a:	2902      	cmp	r1, #2
    491c:	d006      	beq.n	492c <_sercom_get_default_pad+0x88>
    491e:	2903      	cmp	r1, #3
    4920:	d006      	beq.n	4930 <_sercom_get_default_pad+0x8c>
    4922:	e001      	b.n	4928 <_sercom_get_default_pad+0x84>
    4924:	4830      	ldr	r0, [pc, #192]	; (49e8 <_sercom_get_default_pad+0x144>)
    4926:	e045      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    4928:	2000      	movs	r0, #0
    492a:	e043      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    492c:	482f      	ldr	r0, [pc, #188]	; (49ec <_sercom_get_default_pad+0x148>)
    492e:	e041      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4930:	482f      	ldr	r0, [pc, #188]	; (49f0 <_sercom_get_default_pad+0x14c>)
    4932:	e03f      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4934:	2901      	cmp	r1, #1
    4936:	d006      	beq.n	4946 <_sercom_get_default_pad+0xa2>
    4938:	2900      	cmp	r1, #0
    493a:	d036      	beq.n	49aa <_sercom_get_default_pad+0x106>
    493c:	2902      	cmp	r1, #2
    493e:	d006      	beq.n	494e <_sercom_get_default_pad+0xaa>
    4940:	2903      	cmp	r1, #3
    4942:	d006      	beq.n	4952 <_sercom_get_default_pad+0xae>
    4944:	e001      	b.n	494a <_sercom_get_default_pad+0xa6>
    4946:	482b      	ldr	r0, [pc, #172]	; (49f4 <_sercom_get_default_pad+0x150>)
    4948:	e034      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    494a:	2000      	movs	r0, #0
    494c:	e032      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    494e:	482a      	ldr	r0, [pc, #168]	; (49f8 <_sercom_get_default_pad+0x154>)
    4950:	e030      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4952:	482a      	ldr	r0, [pc, #168]	; (49fc <_sercom_get_default_pad+0x158>)
    4954:	e02e      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4956:	2901      	cmp	r1, #1
    4958:	d006      	beq.n	4968 <_sercom_get_default_pad+0xc4>
    495a:	2900      	cmp	r1, #0
    495c:	d027      	beq.n	49ae <_sercom_get_default_pad+0x10a>
    495e:	2902      	cmp	r1, #2
    4960:	d006      	beq.n	4970 <_sercom_get_default_pad+0xcc>
    4962:	2903      	cmp	r1, #3
    4964:	d006      	beq.n	4974 <_sercom_get_default_pad+0xd0>
    4966:	e001      	b.n	496c <_sercom_get_default_pad+0xc8>
    4968:	4825      	ldr	r0, [pc, #148]	; (4a00 <_sercom_get_default_pad+0x15c>)
    496a:	e023      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    496c:	2000      	movs	r0, #0
    496e:	e021      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4970:	4824      	ldr	r0, [pc, #144]	; (4a04 <_sercom_get_default_pad+0x160>)
    4972:	e01f      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4974:	4824      	ldr	r0, [pc, #144]	; (4a08 <_sercom_get_default_pad+0x164>)
    4976:	e01d      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4978:	2901      	cmp	r1, #1
    497a:	d006      	beq.n	498a <_sercom_get_default_pad+0xe6>
    497c:	2900      	cmp	r1, #0
    497e:	d018      	beq.n	49b2 <_sercom_get_default_pad+0x10e>
    4980:	2902      	cmp	r1, #2
    4982:	d006      	beq.n	4992 <_sercom_get_default_pad+0xee>
    4984:	2903      	cmp	r1, #3
    4986:	d006      	beq.n	4996 <_sercom_get_default_pad+0xf2>
    4988:	e001      	b.n	498e <_sercom_get_default_pad+0xea>
    498a:	4820      	ldr	r0, [pc, #128]	; (4a0c <_sercom_get_default_pad+0x168>)
    498c:	e012      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    498e:	2000      	movs	r0, #0
    4990:	e010      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    4992:	481f      	ldr	r0, [pc, #124]	; (4a10 <_sercom_get_default_pad+0x16c>)
    4994:	e00e      	b.n	49b4 <_sercom_get_default_pad+0x110>
    4996:	481f      	ldr	r0, [pc, #124]	; (4a14 <_sercom_get_default_pad+0x170>)
    4998:	e00c      	b.n	49b4 <_sercom_get_default_pad+0x110>
	}

	Assert(false);
	return 0;
    499a:	2000      	movs	r0, #0
    499c:	e00a      	b.n	49b4 <_sercom_get_default_pad+0x110>
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    499e:	481e      	ldr	r0, [pc, #120]	; (4a18 <_sercom_get_default_pad+0x174>)
    49a0:	e008      	b.n	49b4 <_sercom_get_default_pad+0x110>
    49a2:	2003      	movs	r0, #3
    49a4:	e006      	b.n	49b4 <_sercom_get_default_pad+0x110>
    49a6:	481d      	ldr	r0, [pc, #116]	; (4a1c <_sercom_get_default_pad+0x178>)
    49a8:	e004      	b.n	49b4 <_sercom_get_default_pad+0x110>
    49aa:	481d      	ldr	r0, [pc, #116]	; (4a20 <_sercom_get_default_pad+0x17c>)
    49ac:	e002      	b.n	49b4 <_sercom_get_default_pad+0x110>
    49ae:	481d      	ldr	r0, [pc, #116]	; (4a24 <_sercom_get_default_pad+0x180>)
    49b0:	e000      	b.n	49b4 <_sercom_get_default_pad+0x110>
    49b2:	481d      	ldr	r0, [pc, #116]	; (4a28 <_sercom_get_default_pad+0x184>)
	}

	Assert(false);
	return 0;
}
    49b4:	4770      	bx	lr
    49b6:	46c0      	nop			; (mov r8, r8)
    49b8:	42001000 	.word	0x42001000
    49bc:	42000800 	.word	0x42000800
    49c0:	42000c00 	.word	0x42000c00
    49c4:	42001800 	.word	0x42001800
    49c8:	42001c00 	.word	0x42001c00
    49cc:	42001400 	.word	0x42001400
    49d0:	00050003 	.word	0x00050003
    49d4:	00060003 	.word	0x00060003
    49d8:	00070003 	.word	0x00070003
    49dc:	00010003 	.word	0x00010003
    49e0:	001e0003 	.word	0x001e0003
    49e4:	001f0003 	.word	0x001f0003
    49e8:	00090003 	.word	0x00090003
    49ec:	000a0003 	.word	0x000a0003
    49f0:	000b0003 	.word	0x000b0003
    49f4:	00110003 	.word	0x00110003
    49f8:	00120003 	.word	0x00120003
    49fc:	00130003 	.word	0x00130003
    4a00:	000d0003 	.word	0x000d0003
    4a04:	000e0003 	.word	0x000e0003
    4a08:	000f0003 	.word	0x000f0003
    4a0c:	00170003 	.word	0x00170003
    4a10:	00180003 	.word	0x00180003
    4a14:	00190003 	.word	0x00190003
    4a18:	00040003 	.word	0x00040003
    4a1c:	00080003 	.word	0x00080003
    4a20:	00100003 	.word	0x00100003
    4a24:	000c0003 	.word	0x000c0003
    4a28:	00160003 	.word	0x00160003

00004a2c <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    4a2c:	b530      	push	{r4, r5, lr}
    4a2e:	b087      	sub	sp, #28
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    4a30:	4b0c      	ldr	r3, [pc, #48]	; (4a64 <_sercom_get_sercom_inst_index+0x38>)
    4a32:	466a      	mov	r2, sp
    4a34:	cb32      	ldmia	r3!, {r1, r4, r5}
    4a36:	c232      	stmia	r2!, {r1, r4, r5}
    4a38:	cb32      	ldmia	r3!, {r1, r4, r5}
    4a3a:	c232      	stmia	r2!, {r1, r4, r5}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    4a3c:	9b00      	ldr	r3, [sp, #0]
    4a3e:	4283      	cmp	r3, r0
    4a40:	d006      	beq.n	4a50 <_sercom_get_sercom_inst_index+0x24>
    4a42:	2301      	movs	r3, #1
    4a44:	009a      	lsls	r2, r3, #2
    4a46:	4669      	mov	r1, sp
    4a48:	5852      	ldr	r2, [r2, r1]
    4a4a:	4282      	cmp	r2, r0
    4a4c:	d103      	bne.n	4a56 <_sercom_get_sercom_inst_index+0x2a>
    4a4e:	e000      	b.n	4a52 <_sercom_get_sercom_inst_index+0x26>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    4a50:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
			return i;
    4a52:	b2d8      	uxtb	r0, r3
    4a54:	e003      	b.n	4a5e <_sercom_get_sercom_inst_index+0x32>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    4a56:	3301      	adds	r3, #1
    4a58:	2b06      	cmp	r3, #6
    4a5a:	d1f3      	bne.n	4a44 <_sercom_get_sercom_inst_index+0x18>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    4a5c:	2000      	movs	r0, #0
}
    4a5e:	b007      	add	sp, #28
    4a60:	bd30      	pop	{r4, r5, pc}
    4a62:	46c0      	nop			; (mov r8, r8)
    4a64:	0000ae54 	.word	0x0000ae54

00004a68 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    4a68:	4770      	bx	lr
    4a6a:	46c0      	nop			; (mov r8, r8)

00004a6c <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    4a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    4a6e:	4b0a      	ldr	r3, [pc, #40]	; (4a98 <_sercom_set_handler+0x2c>)
    4a70:	781b      	ldrb	r3, [r3, #0]
    4a72:	2b00      	cmp	r3, #0
    4a74:	d10c      	bne.n	4a90 <_sercom_set_handler+0x24>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    4a76:	4f09      	ldr	r7, [pc, #36]	; (4a9c <_sercom_set_handler+0x30>)
    4a78:	4e09      	ldr	r6, [pc, #36]	; (4aa0 <_sercom_set_handler+0x34>)
			_sercom_instances[i] = NULL;
    4a7a:	4d0a      	ldr	r5, [pc, #40]	; (4aa4 <_sercom_set_handler+0x38>)
    4a7c:	2400      	movs	r4, #0
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    4a7e:	51de      	str	r6, [r3, r7]
			_sercom_instances[i] = NULL;
    4a80:	195a      	adds	r2, r3, r5
    4a82:	6014      	str	r4, [r2, #0]
    4a84:	3304      	adds	r3, #4
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    4a86:	2b18      	cmp	r3, #24
    4a88:	d1f9      	bne.n	4a7e <_sercom_set_handler+0x12>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    4a8a:	2201      	movs	r2, #1
    4a8c:	4b02      	ldr	r3, [pc, #8]	; (4a98 <_sercom_set_handler+0x2c>)
    4a8e:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    4a90:	0080      	lsls	r0, r0, #2
    4a92:	4b02      	ldr	r3, [pc, #8]	; (4a9c <_sercom_set_handler+0x30>)
    4a94:	50c1      	str	r1, [r0, r3]
}
    4a96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4a98:	20000132 	.word	0x20000132
    4a9c:	20000134 	.word	0x20000134
    4aa0:	00004a69 	.word	0x00004a69
    4aa4:	20000364 	.word	0x20000364

00004aa8 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    4aa8:	b510      	push	{r4, lr}
    4aaa:	b082      	sub	sp, #8
    4aac:	0004      	movs	r4, r0
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    4aae:	2206      	movs	r2, #6
    4ab0:	4905      	ldr	r1, [pc, #20]	; (4ac8 <_sercom_get_interrupt_vector+0x20>)
    4ab2:	4668      	mov	r0, sp
    4ab4:	4b05      	ldr	r3, [pc, #20]	; (4acc <_sercom_get_interrupt_vector+0x24>)
    4ab6:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    4ab8:	0020      	movs	r0, r4
    4aba:	4b05      	ldr	r3, [pc, #20]	; (4ad0 <_sercom_get_interrupt_vector+0x28>)
    4abc:	4798      	blx	r3

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    4abe:	466b      	mov	r3, sp
    4ac0:	5618      	ldrsb	r0, [r3, r0]
}
    4ac2:	b002      	add	sp, #8
    4ac4:	bd10      	pop	{r4, pc}
    4ac6:	46c0      	nop			; (mov r8, r8)
    4ac8:	0000ae6c 	.word	0x0000ae6c
    4acc:	000086c1 	.word	0x000086c1
    4ad0:	00004a2d 	.word	0x00004a2d

00004ad4 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    4ad4:	b510      	push	{r4, lr}
    4ad6:	4b02      	ldr	r3, [pc, #8]	; (4ae0 <SERCOM0_Handler+0xc>)
    4ad8:	681b      	ldr	r3, [r3, #0]
    4ada:	2000      	movs	r0, #0
    4adc:	4798      	blx	r3
    4ade:	bd10      	pop	{r4, pc}
    4ae0:	20000134 	.word	0x20000134

00004ae4 <SERCOM1_Handler>:
    4ae4:	b510      	push	{r4, lr}
    4ae6:	4b02      	ldr	r3, [pc, #8]	; (4af0 <SERCOM1_Handler+0xc>)
    4ae8:	685b      	ldr	r3, [r3, #4]
    4aea:	2001      	movs	r0, #1
    4aec:	4798      	blx	r3
    4aee:	bd10      	pop	{r4, pc}
    4af0:	20000134 	.word	0x20000134

00004af4 <SERCOM2_Handler>:
    4af4:	b510      	push	{r4, lr}
    4af6:	4b02      	ldr	r3, [pc, #8]	; (4b00 <SERCOM2_Handler+0xc>)
    4af8:	689b      	ldr	r3, [r3, #8]
    4afa:	2002      	movs	r0, #2
    4afc:	4798      	blx	r3
    4afe:	bd10      	pop	{r4, pc}
    4b00:	20000134 	.word	0x20000134

00004b04 <SERCOM3_Handler>:
    4b04:	b510      	push	{r4, lr}
    4b06:	4b02      	ldr	r3, [pc, #8]	; (4b10 <SERCOM3_Handler+0xc>)
    4b08:	68db      	ldr	r3, [r3, #12]
    4b0a:	2003      	movs	r0, #3
    4b0c:	4798      	blx	r3
    4b0e:	bd10      	pop	{r4, pc}
    4b10:	20000134 	.word	0x20000134

00004b14 <SERCOM4_Handler>:
    4b14:	b510      	push	{r4, lr}
    4b16:	4b02      	ldr	r3, [pc, #8]	; (4b20 <SERCOM4_Handler+0xc>)
    4b18:	691b      	ldr	r3, [r3, #16]
    4b1a:	2004      	movs	r0, #4
    4b1c:	4798      	blx	r3
    4b1e:	bd10      	pop	{r4, pc}
    4b20:	20000134 	.word	0x20000134

00004b24 <SERCOM5_Handler>:
    4b24:	b510      	push	{r4, lr}
    4b26:	4b02      	ldr	r3, [pc, #8]	; (4b30 <SERCOM5_Handler+0xc>)
    4b28:	695b      	ldr	r3, [r3, #20]
    4b2a:	2005      	movs	r0, #5
    4b2c:	4798      	blx	r3
    4b2e:	bd10      	pop	{r4, pc}
    4b30:	20000134 	.word	0x20000134

00004b34 <spi_set_baudrate>:
 * \retval STATUS_OK               If the configuration was written
 */
enum status_code spi_set_baudrate(
		struct spi_module *const module,
		uint32_t baudrate)
{
    4b34:	b570      	push	{r4, r5, r6, lr}
    4b36:	b082      	sub	sp, #8
    4b38:	0005      	movs	r5, r0
    4b3a:	000c      	movs	r4, r1
	Assert(module);
	Assert(baudrate);
	Assert(module->hw);

	/* Value to write to BAUD register */
	uint16_t baud = 0;
    4b3c:	2200      	movs	r2, #0
    4b3e:	466b      	mov	r3, sp
    4b40:	80da      	strh	r2, [r3, #6]

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b42:	6806      	ldr	r6, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    4b44:	0030      	movs	r0, r6
    4b46:	4b23      	ldr	r3, [pc, #140]	; (4bd4 <spi_set_baudrate+0xa0>)
    4b48:	4798      	blx	r3
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4b4a:	231f      	movs	r3, #31
    4b4c:	4018      	ands	r0, r3
    4b4e:	3b1e      	subs	r3, #30
    4b50:	4083      	lsls	r3, r0
    4b52:	2280      	movs	r2, #128	; 0x80
    4b54:	4920      	ldr	r1, [pc, #128]	; (4bd8 <spi_set_baudrate+0xa4>)
    4b56:	508b      	str	r3, [r1, r2]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b58:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4b5a:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    4b5c:	2b00      	cmp	r3, #0
    4b5e:	d1fc      	bne.n	4b5a <spi_set_baudrate+0x26>
		/* Wait until the synchronization is complete */
	}

	/* Disbale interrupt */
	spi_module->INTENCLR.reg = SERCOM_SPI_INTENCLR_MASK;
    4b60:	338f      	adds	r3, #143	; 0x8f
    4b62:	7533      	strb	r3, [r6, #20]
	/* Clear interrupt flag */
	spi_module->INTFLAG.reg = SERCOM_SPI_INTFLAG_MASK;
    4b64:	7633      	strb	r3, [r6, #24]

	/* Disable SPI */
	spi_module->CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
    4b66:	6833      	ldr	r3, [r6, #0]
    4b68:	2202      	movs	r2, #2
    4b6a:	4393      	bics	r3, r2
    4b6c:	6033      	str	r3, [r6, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b6e:	6828      	ldr	r0, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4b70:	69c3      	ldr	r3, [r0, #28]

	/* Disable the module */
	spi_disable(module);

	while (spi_is_syncing(module)) {
    4b72:	2b00      	cmp	r3, #0
    4b74:	d1fc      	bne.n	4b70 <spi_set_baudrate+0x3c>
		/* Wait until the synchronization is complete */
	}

	/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4b76:	4b19      	ldr	r3, [pc, #100]	; (4bdc <spi_set_baudrate+0xa8>)
    4b78:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
	uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    4b7a:	3014      	adds	r0, #20
    4b7c:	b2c0      	uxtb	r0, r0
    4b7e:	4b18      	ldr	r3, [pc, #96]	; (4be0 <spi_set_baudrate+0xac>)
    4b80:	4798      	blx	r3
    4b82:	0001      	movs	r1, r0

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
    4b84:	466b      	mov	r3, sp
    4b86:	1d9a      	adds	r2, r3, #6
    4b88:	0020      	movs	r0, r4
    4b8a:	4b16      	ldr	r3, [pc, #88]	; (4be4 <spi_set_baudrate+0xb0>)
    4b8c:	4798      	blx	r3
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
    4b8e:	2317      	movs	r3, #23

	/* Get baud value, based on baudrate and the internal clock frequency */
	enum status_code error_code = _sercom_get_sync_baud_val(
			baudrate, internal_clock, &baud);

	if (error_code != STATUS_OK) {
    4b90:	2800      	cmp	r0, #0
    4b92:	d11c      	bne.n	4bce <spi_set_baudrate+0x9a>
		/* Baud rate calculation error, return status code */
		return STATUS_ERR_INVALID_ARG;
	}

	spi_module->BAUD.reg = (uint8_t)baud;
    4b94:	466b      	mov	r3, sp
    4b96:	3306      	adds	r3, #6
    4b98:	781b      	ldrb	r3, [r3, #0]
    4b9a:	7333      	strb	r3, [r6, #12]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4b9c:	682c      	ldr	r4, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4b9e:	69e3      	ldr	r3, [r4, #28]

	while (spi_is_syncing(module)) {
    4ba0:	2b00      	cmp	r3, #0
    4ba2:	d1fc      	bne.n	4b9e <spi_set_baudrate+0x6a>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    4ba4:	0020      	movs	r0, r4
    4ba6:	4b0b      	ldr	r3, [pc, #44]	; (4bd4 <spi_set_baudrate+0xa0>)
    4ba8:	4798      	blx	r3
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    4baa:	231f      	movs	r3, #31
    4bac:	4018      	ands	r0, r3
    4bae:	3b1e      	subs	r3, #30
    4bb0:	4083      	lsls	r3, r0
    4bb2:	4a09      	ldr	r2, [pc, #36]	; (4bd8 <spi_set_baudrate+0xa4>)
    4bb4:	6013      	str	r3, [r2, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4bb6:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4bb8:	69d3      	ldr	r3, [r2, #28]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#  endif

	while (spi_is_syncing(module)) {
    4bba:	2b00      	cmp	r3, #0
    4bbc:	d1fc      	bne.n	4bb8 <spi_set_baudrate+0x84>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    4bbe:	6822      	ldr	r2, [r4, #0]
    4bc0:	3302      	adds	r3, #2
    4bc2:	4313      	orrs	r3, r2
    4bc4:	6023      	str	r3, [r4, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4bc6:	682a      	ldr	r2, [r5, #0]

#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
    4bc8:	69d3      	ldr	r3, [r2, #28]
	}

	/* Enable the module */
	spi_enable(module);

	while (spi_is_syncing(module)) {
    4bca:	2b00      	cmp	r3, #0
    4bcc:	d1fc      	bne.n	4bc8 <spi_set_baudrate+0x94>
		/* Wait until the synchronization is complete */
	}

	return STATUS_OK;
}
    4bce:	0018      	movs	r0, r3
    4bd0:	b002      	add	sp, #8
    4bd2:	bd70      	pop	{r4, r5, r6, pc}
    4bd4:	00004aa9 	.word	0x00004aa9
    4bd8:	e000e100 	.word	0xe000e100
    4bdc:	00004a2d 	.word	0x00004a2d
    4be0:	00005db9 	.word	0x00005db9
    4be4:	0000479d 	.word	0x0000479d

00004be8 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    4be8:	b5f0      	push	{r4, r5, r6, r7, lr}
    4bea:	b08b      	sub	sp, #44	; 0x2c
    4bec:	0005      	movs	r5, r0
    4bee:	000c      	movs	r4, r1
    4bf0:	0016      	movs	r6, r2
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    4bf2:	6029      	str	r1, [r5, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    4bf4:	680b      	ldr	r3, [r1, #0]
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    4bf6:	201c      	movs	r0, #28
	module->hw = hw;

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    4bf8:	079b      	lsls	r3, r3, #30
    4bfa:	d500      	bpl.n	4bfe <spi_init+0x16>
    4bfc:	e0be      	b.n	4d7c <spi_init+0x194>
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    4bfe:	680b      	ldr	r3, [r1, #0]
		return STATUS_BUSY;
    4c00:	3817      	subs	r0, #23
		return STATUS_ERR_DENIED;
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    4c02:	07db      	lsls	r3, r3, #31
    4c04:	d500      	bpl.n	4c08 <spi_init+0x20>
    4c06:	e0b9      	b.n	4d7c <spi_init+0x194>
		return STATUS_BUSY;
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4c08:	0008      	movs	r0, r1
    4c0a:	4b5d      	ldr	r3, [pc, #372]	; (4d80 <spi_init+0x198>)
    4c0c:	4798      	blx	r3
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    4c0e:	495d      	ldr	r1, [pc, #372]	; (4d84 <spi_init+0x19c>)
    4c10:	6a0a      	ldr	r2, [r1, #32]
    4c12:	1c87      	adds	r7, r0, #2
    4c14:	2301      	movs	r3, #1
    4c16:	40bb      	lsls	r3, r7
    4c18:	4313      	orrs	r3, r2
    4c1a:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    4c1c:	a909      	add	r1, sp, #36	; 0x24
    4c1e:	2724      	movs	r7, #36	; 0x24
    4c20:	5df3      	ldrb	r3, [r6, r7]
    4c22:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    4c24:	3014      	adds	r0, #20
    4c26:	b2c3      	uxtb	r3, r0
    4c28:	9301      	str	r3, [sp, #4]
    4c2a:	0018      	movs	r0, r3
    4c2c:	4b56      	ldr	r3, [pc, #344]	; (4d88 <spi_init+0x1a0>)
    4c2e:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    4c30:	9801      	ldr	r0, [sp, #4]
    4c32:	4b56      	ldr	r3, [pc, #344]	; (4d8c <spi_init+0x1a4>)
    4c34:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    4c36:	5df0      	ldrb	r0, [r6, r7]
    4c38:	2100      	movs	r1, #0
    4c3a:	4b55      	ldr	r3, [pc, #340]	; (4d90 <spi_init+0x1a8>)
    4c3c:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    4c3e:	7833      	ldrb	r3, [r6, #0]
    4c40:	2b01      	cmp	r3, #1
    4c42:	d103      	bne.n	4c4c <spi_init+0x64>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    4c44:	6822      	ldr	r2, [r4, #0]
    4c46:	330b      	adds	r3, #11
    4c48:	4313      	orrs	r3, r2
    4c4a:	6023      	str	r3, [r4, #0]
    4c4c:	002b      	movs	r3, r5
    4c4e:	330c      	adds	r3, #12
    4c50:	0029      	movs	r1, r5
    4c52:	3128      	adds	r1, #40	; 0x28
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
		module->callback[i]        = NULL;
    4c54:	2200      	movs	r2, #0
    4c56:	c304      	stmia	r3!, {r2}
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    4c58:	4299      	cmp	r1, r3
    4c5a:	d1fc      	bne.n	4c56 <spi_init+0x6e>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    4c5c:	2300      	movs	r3, #0
    4c5e:	62eb      	str	r3, [r5, #44]	; 0x2c
	module->rx_buffer_ptr              = NULL;
    4c60:	62ab      	str	r3, [r5, #40]	; 0x28
	module->remaining_tx_buffer_length = 0x0000;
    4c62:	2400      	movs	r4, #0
    4c64:	86ab      	strh	r3, [r5, #52]	; 0x34
	module->remaining_rx_buffer_length = 0x0000;
    4c66:	862b      	strh	r3, [r5, #48]	; 0x30
	module->registered_callback        = 0x00;
    4c68:	3336      	adds	r3, #54	; 0x36
    4c6a:	54ec      	strb	r4, [r5, r3]
	module->enabled_callback           = 0x00;
    4c6c:	3301      	adds	r3, #1
    4c6e:	54ec      	strb	r4, [r5, r3]
	module->status                     = STATUS_OK;
    4c70:	3301      	adds	r3, #1
    4c72:	54ec      	strb	r4, [r5, r3]
	module->dir                        = SPI_DIRECTION_IDLE;
    4c74:	3b35      	subs	r3, #53	; 0x35
    4c76:	726b      	strb	r3, [r5, #9]
	module->locked                     = false;
    4c78:	712c      	strb	r4, [r5, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    4c7a:	6828      	ldr	r0, [r5, #0]
    4c7c:	4b40      	ldr	r3, [pc, #256]	; (4d80 <spi_init+0x198>)
    4c7e:	4798      	blx	r3
    4c80:	0007      	movs	r7, r0
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    4c82:	4944      	ldr	r1, [pc, #272]	; (4d94 <spi_init+0x1ac>)
    4c84:	4b44      	ldr	r3, [pc, #272]	; (4d98 <spi_init+0x1b0>)
    4c86:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    4c88:	00b8      	lsls	r0, r7, #2
    4c8a:	4b44      	ldr	r3, [pc, #272]	; (4d9c <spi_init+0x1b4>)
    4c8c:	50c5      	str	r5, [r0, r3]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4c8e:	682f      	ldr	r7, [r5, #0]
    4c90:	ab04      	add	r3, sp, #16
    4c92:	2280      	movs	r2, #128	; 0x80
    4c94:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    4c96:	705c      	strb	r4, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    4c98:	3a7f      	subs	r2, #127	; 0x7f
    4c9a:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    4c9c:	70dc      	strb	r4, [r3, #3]
	Sercom *const hw = module->hw;

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
    4c9e:	7833      	ldrb	r3, [r6, #0]
    4ca0:	2b00      	cmp	r3, #0
    4ca2:	d102      	bne.n	4caa <spi_init+0xc2>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    4ca4:	2200      	movs	r2, #0
    4ca6:	ab04      	add	r3, sp, #16
    4ca8:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
    4caa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
    4cac:	9305      	str	r3, [sp, #20]
    4cae:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    4cb0:	9306      	str	r3, [sp, #24]
    4cb2:	6b33      	ldr	r3, [r6, #48]	; 0x30
    4cb4:	9307      	str	r3, [sp, #28]
    4cb6:	6b73      	ldr	r3, [r6, #52]	; 0x34
    4cb8:	9308      	str	r3, [sp, #32]
    4cba:	2400      	movs	r4, #0
    4cbc:	b2e1      	uxtb	r1, r4
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    4cbe:	00a3      	lsls	r3, r4, #2
    4cc0:	aa05      	add	r2, sp, #20
    4cc2:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    4cc4:	2800      	cmp	r0, #0
    4cc6:	d102      	bne.n	4cce <spi_init+0xe6>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    4cc8:	0038      	movs	r0, r7
    4cca:	4b35      	ldr	r3, [pc, #212]	; (4da0 <spi_init+0x1b8>)
    4ccc:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    4cce:	1c43      	adds	r3, r0, #1
    4cd0:	d006      	beq.n	4ce0 <spi_init+0xf8>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    4cd2:	ab02      	add	r3, sp, #8
    4cd4:	7218      	strb	r0, [r3, #8]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    4cd6:	0c00      	lsrs	r0, r0, #16
    4cd8:	b2c0      	uxtb	r0, r0
    4cda:	a904      	add	r1, sp, #16
    4cdc:	4b31      	ldr	r3, [pc, #196]	; (4da4 <spi_init+0x1bc>)
    4cde:	4798      	blx	r3
    4ce0:	3401      	adds	r4, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    4ce2:	2c04      	cmp	r4, #4
    4ce4:	d1ea      	bne.n	4cbc <spi_init+0xd4>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    4ce6:	7833      	ldrb	r3, [r6, #0]
    4ce8:	716b      	strb	r3, [r5, #5]
	module->character_size   = config->character_size;
    4cea:	7c33      	ldrb	r3, [r6, #16]
    4cec:	71ab      	strb	r3, [r5, #6]
	module->receiver_enabled = config->receiver_enable;
    4cee:	7cb3      	ldrb	r3, [r6, #18]
    4cf0:	71eb      	strb	r3, [r5, #7]
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	module->master_slave_select_enable = config->master_slave_select_enable;
    4cf2:	7d33      	ldrb	r3, [r6, #20]
    4cf4:	722b      	strb	r3, [r5, #8]
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    4cf6:	2200      	movs	r2, #0
    4cf8:	ab02      	add	r3, sp, #8
    4cfa:	80da      	strh	r2, [r3, #6]
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    4cfc:	7833      	ldrb	r3, [r6, #0]
    4cfe:	2b01      	cmp	r3, #1
    4d00:	d114      	bne.n	4d2c <spi_init+0x144>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    4d02:	6828      	ldr	r0, [r5, #0]
    4d04:	4b1e      	ldr	r3, [pc, #120]	; (4d80 <spi_init+0x198>)
    4d06:	4798      	blx	r3
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    4d08:	3014      	adds	r0, #20
    4d0a:	b2c0      	uxtb	r0, r0
    4d0c:	4b26      	ldr	r3, [pc, #152]	; (4da8 <spi_init+0x1c0>)
    4d0e:	4798      	blx	r3
    4d10:	0001      	movs	r1, r0

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    4d12:	ab02      	add	r3, sp, #8
    4d14:	1d9a      	adds	r2, r3, #6
    4d16:	69b0      	ldr	r0, [r6, #24]
    4d18:	4b24      	ldr	r3, [pc, #144]	; (4dac <spi_init+0x1c4>)
    4d1a:	4798      	blx	r3
    4d1c:	0003      	movs	r3, r0
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    4d1e:	2017      	movs	r0, #23
		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    4d20:	2b00      	cmp	r3, #0
    4d22:	d12b      	bne.n	4d7c <spi_init+0x194>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    4d24:	ab02      	add	r3, sp, #8
    4d26:	3306      	adds	r3, #6
    4d28:	781b      	ldrb	r3, [r3, #0]
    4d2a:	733b      	strb	r3, [r7, #12]
# endif
	/* Set data order */
	ctrla |= config->data_order;

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;
    4d2c:	6873      	ldr	r3, [r6, #4]
    4d2e:	68b2      	ldr	r2, [r6, #8]
    4d30:	4313      	orrs	r3, r2

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    4d32:	68f2      	ldr	r2, [r6, #12]
    4d34:	4313      	orrs	r3, r2

	/* Set SPI character size */
	ctrlb |= config->character_size;
    4d36:	7c32      	ldrb	r2, [r6, #16]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    4d38:	7c71      	ldrb	r1, [r6, #17]
    4d3a:	2900      	cmp	r1, #0
    4d3c:	d103      	bne.n	4d46 <spi_init+0x15e>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    4d3e:	491c      	ldr	r1, [pc, #112]	; (4db0 <spi_init+0x1c8>)
    4d40:	7889      	ldrb	r1, [r1, #2]
    4d42:	0789      	lsls	r1, r1, #30
    4d44:	d501      	bpl.n	4d4a <spi_init+0x162>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    4d46:	2180      	movs	r1, #128	; 0x80
    4d48:	430b      	orrs	r3, r1
	}

	if (config->receiver_enable) {
    4d4a:	7cb1      	ldrb	r1, [r6, #18]
    4d4c:	2900      	cmp	r1, #0
    4d4e:	d002      	beq.n	4d56 <spi_init+0x16e>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    4d50:	2180      	movs	r1, #128	; 0x80
    4d52:	0289      	lsls	r1, r1, #10
    4d54:	430a      	orrs	r2, r1
	}
#  ifdef FEATURE_SPI_SLAVE_SELECT_LOW_DETECT
	if (config->select_slave_low_detect_enable) {
    4d56:	7cf1      	ldrb	r1, [r6, #19]
    4d58:	2900      	cmp	r1, #0
    4d5a:	d002      	beq.n	4d62 <spi_init+0x17a>
		/* Enable Slave Select Low Detect */
		ctrlb |= SERCOM_SPI_CTRLB_SSDE;
    4d5c:	2180      	movs	r1, #128	; 0x80
    4d5e:	0089      	lsls	r1, r1, #2
    4d60:	430a      	orrs	r2, r1
	}
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if (config->master_slave_select_enable) {
    4d62:	7d31      	ldrb	r1, [r6, #20]
    4d64:	2900      	cmp	r1, #0
    4d66:	d002      	beq.n	4d6e <spi_init+0x186>
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
    4d68:	2180      	movs	r1, #128	; 0x80
    4d6a:	0189      	lsls	r1, r1, #6
    4d6c:	430a      	orrs	r2, r1
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    4d6e:	6839      	ldr	r1, [r7, #0]
    4d70:	430b      	orrs	r3, r1
    4d72:	603b      	str	r3, [r7, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    4d74:	687b      	ldr	r3, [r7, #4]
    4d76:	4313      	orrs	r3, r2
    4d78:	607b      	str	r3, [r7, #4]

	return STATUS_OK;
    4d7a:	2000      	movs	r0, #0
	_sercom_instances[instance_index] = module;
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
}
    4d7c:	b00b      	add	sp, #44	; 0x2c
    4d7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4d80:	00004a2d 	.word	0x00004a2d
    4d84:	40000400 	.word	0x40000400
    4d88:	00005d9d 	.word	0x00005d9d
    4d8c:	00005d11 	.word	0x00005d11
    4d90:	00004859 	.word	0x00004859
    4d94:	00005021 	.word	0x00005021
    4d98:	00004a6d 	.word	0x00004a6d
    4d9c:	20000364 	.word	0x20000364
    4da0:	000048a5 	.word	0x000048a5
    4da4:	00005e95 	.word	0x00005e95
    4da8:	00005db9 	.word	0x00005db9
    4dac:	0000479d 	.word	0x0000479d
    4db0:	41002000 	.word	0x41002000

00004db4 <spi_read_buffer_wait>:
enum status_code spi_read_buffer_wait(
		struct spi_module *const module,
		uint8_t *rx_data,
		uint16_t length,
		uint16_t dummy)
{
    4db4:	b5f0      	push	{r4, r5, r6, r7, lr}
    4db6:	4657      	mov	r7, sl
    4db8:	4646      	mov	r6, r8
    4dba:	b4c0      	push	{r6, r7}
    4dbc:	0007      	movs	r7, r0
    4dbe:	4688      	mov	r8, r1
    4dc0:	001d      	movs	r5, r3
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    4dc2:	2038      	movs	r0, #56	; 0x38
    4dc4:	5c3c      	ldrb	r4, [r7, r0]
    4dc6:	b2e0      	uxtb	r0, r4
    4dc8:	2805      	cmp	r0, #5
    4dca:	d047      	beq.n	4e5c <spi_read_buffer_wait+0xa8>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    4dcc:	2017      	movs	r0, #23
		return STATUS_BUSY;
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
    4dce:	2a00      	cmp	r2, #0
    4dd0:	d044      	beq.n	4e5c <spi_read_buffer_wait+0xa8>
		return STATUS_ERR_INVALID_ARG;
	}

	if (!(module->receiver_enabled)) {
    4dd2:	79fc      	ldrb	r4, [r7, #7]
		return STATUS_ERR_DENIED;
    4dd4:	3005      	adds	r0, #5
	/* Sanity check arguments */
	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
	}

	if (!(module->receiver_enabled)) {
    4dd6:	2c00      	cmp	r4, #0
    4dd8:	d040      	beq.n	4e5c <spi_read_buffer_wait+0xa8>
    4dda:	2300      	movs	r3, #0

	while (length--) {
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
    4ddc:	381b      	subs	r0, #27
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4dde:	05ec      	lsls	r4, r5, #23
    4de0:	0de1      	lsrs	r1, r4, #23
    4de2:	468c      	mov	ip, r1
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    4de4:	2604      	movs	r6, #4
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
    4de6:	797c      	ldrb	r4, [r7, #5]
    4de8:	2c01      	cmp	r4, #1
    4dea:	d108      	bne.n	4dfe <spi_read_buffer_wait+0x4a>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4dec:	683d      	ldr	r5, [r7, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4dee:	7e2c      	ldrb	r4, [r5, #24]
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
    4df0:	4204      	tst	r4, r0
    4df2:	d0fc      	beq.n	4dee <spi_read_buffer_wait+0x3a>
    4df4:	7e2c      	ldrb	r4, [r5, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    4df6:	4204      	tst	r4, r0
    4df8:	d001      	beq.n	4dfe <spi_read_buffer_wait+0x4a>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4dfa:	4661      	mov	r1, ip
    4dfc:	62a9      	str	r1, [r5, #40]	; 0x28
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4dfe:	683d      	ldr	r5, [r7, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    4e00:	7e2c      	ldrb	r4, [r5, #24]
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    4e02:	4234      	tst	r4, r6
    4e04:	d0fc      	beq.n	4e00 <spi_read_buffer_wait+0x4c>
    4e06:	7e2c      	ldrb	r4, [r5, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    4e08:	4234      	tst	r4, r6
    4e0a:	d024      	beq.n	4e56 <spi_read_buffer_wait+0xa2>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4e0c:	8b69      	ldrh	r1, [r5, #26]
		/* No data has been received, return */
		return STATUS_ERR_IO;
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    4e0e:	2400      	movs	r4, #0

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4e10:	4231      	tst	r1, r6
    4e12:	d001      	beq.n	4e18 <spi_read_buffer_wait+0x64>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    4e14:	836e      	strh	r6, [r5, #26]
	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
		retval = STATUS_ERR_OVERFLOW;
    4e16:	341e      	adds	r4, #30
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4e18:	79b9      	ldrb	r1, [r7, #6]
    4e1a:	2901      	cmp	r1, #1
    4e1c:	d103      	bne.n	4e26 <spi_read_buffer_wait+0x72>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    4e1e:	6aad      	ldr	r5, [r5, #40]	; 0x28
    4e20:	05ed      	lsls	r5, r5, #23
    4e22:	0ded      	lsrs	r5, r5, #23
    4e24:	e001      	b.n	4e2a <spi_read_buffer_wait+0x76>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    4e26:	6aad      	ldr	r5, [r5, #40]	; 0x28
    4e28:	b2ed      	uxtb	r5, r5
		}

		uint16_t received_data = 0;
		enum status_code retval = spi_read(module, &received_data);

		if (retval != STATUS_OK) {
    4e2a:	2c00      	cmp	r4, #0
    4e2c:	d115      	bne.n	4e5a <spi_read_buffer_wait+0xa6>
			/* Overflow, abort */
			return retval;
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    4e2e:	1c5c      	adds	r4, r3, #1
    4e30:	b2a4      	uxth	r4, r4
    4e32:	4641      	mov	r1, r8
    4e34:	54cd      	strb	r5, [r1, r3]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4e36:	79b9      	ldrb	r1, [r7, #6]
    4e38:	2901      	cmp	r1, #1
    4e3a:	d105      	bne.n	4e48 <spi_read_buffer_wait+0x94>
			rx_data[rx_pos++] = (received_data >> 8);
    4e3c:	3302      	adds	r3, #2
    4e3e:	b29b      	uxth	r3, r3
    4e40:	0a2d      	lsrs	r5, r5, #8
    4e42:	4641      	mov	r1, r8
    4e44:	550d      	strb	r5, [r1, r4]
    4e46:	e000      	b.n	4e4a <spi_read_buffer_wait+0x96>
			/* Overflow, abort */
			return retval;
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    4e48:	0023      	movs	r3, r4
    4e4a:	3a01      	subs	r2, #1
    4e4c:	b292      	uxth	r2, r2
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
    4e4e:	2a00      	cmp	r2, #0
    4e50:	d1c9      	bne.n	4de6 <spi_read_buffer_wait+0x32>
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

	return STATUS_OK;
    4e52:	2000      	movs	r0, #0
    4e54:	e002      	b.n	4e5c <spi_read_buffer_wait+0xa8>
	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
		/* No data has been received, return */
		return STATUS_ERR_IO;
    4e56:	2010      	movs	r0, #16
    4e58:	e000      	b.n	4e5c <spi_read_buffer_wait+0xa8>
    4e5a:	0020      	movs	r0, r4
}
    4e5c:	bc0c      	pop	{r2, r3}
    4e5e:	4690      	mov	r8, r2
    4e60:	469a      	mov	sl, r3
    4e62:	bdf0      	pop	{r4, r5, r6, r7, pc}

00004e64 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    4e64:	b510      	push	{r4, lr}
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    4e66:	7944      	ldrb	r4, [r0, #5]
		return STATUS_ERR_UNSUPPORTED_DEV;
    4e68:	2315      	movs	r3, #21
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    4e6a:	2c01      	cmp	r4, #1
    4e6c:	d16e      	bne.n	4f4c <spi_select_slave+0xe8>
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    4e6e:	7a04      	ldrb	r4, [r0, #8]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4e70:	2300      	movs	r3, #0
	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
		return STATUS_ERR_UNSUPPORTED_DEV;
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
    4e72:	2c00      	cmp	r4, #0
    4e74:	d16a      	bne.n	4f4c <spi_select_slave+0xe8>
#  endif
	{
		if (select) {
    4e76:	2a00      	cmp	r2, #0
    4e78:	d058      	beq.n	4f2c <spi_select_slave+0xc8>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    4e7a:	784b      	ldrb	r3, [r1, #1]
    4e7c:	2b00      	cmp	r3, #0
    4e7e:	d044      	beq.n	4f0a <spi_select_slave+0xa6>
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4e80:	6803      	ldr	r3, [r0, #0]
    4e82:	7e1b      	ldrb	r3, [r3, #24]
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    4e84:	07db      	lsls	r3, r3, #31
    4e86:	d410      	bmi.n	4eaa <spi_select_slave+0x46>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    4e88:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4e8a:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4e8c:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4e8e:	2900      	cmp	r1, #0
    4e90:	d104      	bne.n	4e9c <spi_select_slave+0x38>
		return &(ports[port_index]->Group[group_index]);
    4e92:	095a      	lsrs	r2, r3, #5
    4e94:	01d2      	lsls	r2, r2, #7
    4e96:	492e      	ldr	r1, [pc, #184]	; (4f50 <spi_select_slave+0xec>)
    4e98:	468c      	mov	ip, r1
    4e9a:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4e9c:	211f      	movs	r1, #31
    4e9e:	400b      	ands	r3, r1
    4ea0:	391e      	subs	r1, #30
    4ea2:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4ea4:	6191      	str	r1, [r2, #24]
					return STATUS_BUSY;
    4ea6:	2305      	movs	r3, #5
    4ea8:	e050      	b.n	4f4c <spi_select_slave+0xe8>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    4eaa:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4eac:	09dc      	lsrs	r4, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4eae:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4eb0:	2c00      	cmp	r4, #0
    4eb2:	d104      	bne.n	4ebe <spi_select_slave+0x5a>
		return &(ports[port_index]->Group[group_index]);
    4eb4:	095a      	lsrs	r2, r3, #5
    4eb6:	01d2      	lsls	r2, r2, #7
    4eb8:	4c25      	ldr	r4, [pc, #148]	; (4f50 <spi_select_slave+0xec>)
    4eba:	46a4      	mov	ip, r4
    4ebc:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4ebe:	241f      	movs	r4, #31
    4ec0:	4023      	ands	r3, r4
    4ec2:	3c1e      	subs	r4, #30
    4ec4:	409c      	lsls	r4, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4ec6:	6154      	str	r4, [r2, #20]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4ec8:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4eca:	7e1a      	ldrb	r2, [r3, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    4ecc:	07d2      	lsls	r2, r2, #31
    4ece:	d501      	bpl.n	4ed4 <spi_select_slave+0x70>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4ed0:	788a      	ldrb	r2, [r1, #2]
    4ed2:	629a      	str	r2, [r3, #40]	; 0x28

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    4ed4:	79c2      	ldrb	r2, [r0, #7]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4ed6:	2300      	movs	r3, #0
				port_pin_set_output_level(slave->ss_pin, false);

				/* Write address to slave */
				spi_write(module, slave->address);

				if (!(module->receiver_enabled)) {
    4ed8:	2a00      	cmp	r2, #0
    4eda:	d137      	bne.n	4f4c <spi_select_slave+0xe8>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4edc:	6802      	ldr	r2, [r0, #0]
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    4ede:	2104      	movs	r1, #4

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    4ee0:	7e13      	ldrb	r3, [r2, #24]
    4ee2:	420b      	tst	r3, r1
    4ee4:	d0fc      	beq.n	4ee0 <spi_select_slave+0x7c>
    4ee6:	7e11      	ldrb	r1, [r2, #24]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4ee8:	2300      	movs	r3, #0
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    4eea:	0749      	lsls	r1, r1, #29
    4eec:	d52e      	bpl.n	4f4c <spi_select_slave+0xe8>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4eee:	8b53      	ldrh	r3, [r2, #26]
    4ef0:	075b      	lsls	r3, r3, #29
    4ef2:	d501      	bpl.n	4ef8 <spi_select_slave+0x94>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    4ef4:	2304      	movs	r3, #4
    4ef6:	8353      	strh	r3, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4ef8:	7983      	ldrb	r3, [r0, #6]
    4efa:	2b01      	cmp	r3, #1
    4efc:	d102      	bne.n	4f04 <spi_select_slave+0xa0>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    4efe:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4f00:	2300      	movs	r3, #0
    4f02:	e023      	b.n	4f4c <spi_select_slave+0xe8>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    4f04:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4f06:	2300      	movs	r3, #0
    4f08:	e020      	b.n	4f4c <spi_select_slave+0xe8>
					uint16_t flush = 0;
					spi_read(module, &flush);
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    4f0a:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4f0c:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4f0e:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4f10:	2900      	cmp	r1, #0
    4f12:	d104      	bne.n	4f1e <spi_select_slave+0xba>
		return &(ports[port_index]->Group[group_index]);
    4f14:	095a      	lsrs	r2, r3, #5
    4f16:	01d2      	lsls	r2, r2, #7
    4f18:	490d      	ldr	r1, [pc, #52]	; (4f50 <spi_select_slave+0xec>)
    4f1a:	468c      	mov	ip, r1
    4f1c:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4f1e:	211f      	movs	r1, #31
    4f20:	400b      	ands	r3, r1
    4f22:	391e      	subs	r1, #30
    4f24:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    4f26:	6151      	str	r1, [r2, #20]
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
		}
	}
	return STATUS_OK;
    4f28:	2300      	movs	r3, #0
    4f2a:	e00f      	b.n	4f4c <spi_select_slave+0xe8>
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    4f2c:	780b      	ldrb	r3, [r1, #0]
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4f2e:	09d9      	lsrs	r1, r3, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    4f30:	2200      	movs	r2, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    4f32:	2900      	cmp	r1, #0
    4f34:	d104      	bne.n	4f40 <spi_select_slave+0xdc>
		return &(ports[port_index]->Group[group_index]);
    4f36:	095a      	lsrs	r2, r3, #5
    4f38:	01d2      	lsls	r2, r2, #7
    4f3a:	4905      	ldr	r1, [pc, #20]	; (4f50 <spi_select_slave+0xec>)
    4f3c:	468c      	mov	ip, r1
    4f3e:	4462      	add	r2, ip
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    4f40:	211f      	movs	r1, #31
    4f42:	400b      	ands	r3, r1
    4f44:	391e      	subs	r1, #30
    4f46:	4099      	lsls	r1, r3

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    4f48:	6191      	str	r1, [r2, #24]
		}
	}
	return STATUS_OK;
    4f4a:	2300      	movs	r3, #0
}
    4f4c:	0018      	movs	r0, r3
    4f4e:	bd10      	pop	{r4, pc}
    4f50:	41004400 	.word	0x41004400

00004f54 <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
    4f54:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f56:	465f      	mov	r7, fp
    4f58:	4656      	mov	r6, sl
    4f5a:	464d      	mov	r5, r9
    4f5c:	4644      	mov	r4, r8
    4f5e:	b4f0      	push	{r4, r5, r6, r7}
    4f60:	b083      	sub	sp, #12
    4f62:	0007      	movs	r7, r0
    4f64:	468a      	mov	sl, r1
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    4f66:	2338      	movs	r3, #56	; 0x38
    4f68:	5cc0      	ldrb	r0, [r0, r3]
    4f6a:	b2c0      	uxtb	r0, r0
    4f6c:	2805      	cmp	r0, #5
    4f6e:	d04e      	beq.n	500e <spi_write_buffer_wait+0xba>
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    4f70:	2017      	movs	r0, #23
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
	}
#  endif

	if (length == 0) {
    4f72:	2a00      	cmp	r2, #0
    4f74:	d04b      	beq.n	500e <spi_write_buffer_wait+0xba>
    4f76:	e042      	b.n	4ffe <spi_write_buffer_wait+0xaa>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4f78:	683a      	ldr	r2, [r7, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    4f7a:	7e13      	ldrb	r3, [r2, #24]
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    4f7c:	4223      	tst	r3, r4
    4f7e:	d0fc      	beq.n	4f7a <spi_write_buffer_wait+0x26>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    4f80:	1c43      	adds	r3, r0, #1
    4f82:	b29b      	uxth	r3, r3
    4f84:	4698      	mov	r8, r3
    4f86:	4653      	mov	r3, sl
    4f88:	5c1b      	ldrb	r3, [r3, r0]
    4f8a:	469b      	mov	fp, r3

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4f8c:	79b9      	ldrb	r1, [r7, #6]
    4f8e:	2901      	cmp	r1, #1
    4f90:	d004      	beq.n	4f9c <spi_write_buffer_wait+0x48>
		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    4f92:	4669      	mov	r1, sp
    4f94:	80cb      	strh	r3, [r1, #6]
    4f96:	88cb      	ldrh	r3, [r1, #6]
    4f98:	4640      	mov	r0, r8
    4f9a:	e007      	b.n	4fac <spi_write_buffer_wait+0x58>

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			data_to_send |= (tx_data[tx_pos++] << 8);
    4f9c:	3002      	adds	r0, #2
    4f9e:	b280      	uxth	r0, r0
    4fa0:	4641      	mov	r1, r8
    4fa2:	4653      	mov	r3, sl
    4fa4:	5c59      	ldrb	r1, [r3, r1]
    4fa6:	0209      	lsls	r1, r1, #8
    4fa8:	465b      	mov	r3, fp
    4faa:	430b      	orrs	r3, r1
    4fac:	7e11      	ldrb	r1, [r2, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    4fae:	4221      	tst	r1, r4
    4fb0:	d002      	beq.n	4fb8 <spi_write_buffer_wait+0x64>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    4fb2:	05db      	lsls	r3, r3, #23
    4fb4:	0ddb      	lsrs	r3, r3, #23
    4fb6:	6293      	str	r3, [r2, #40]	; 0x28
		}

		/* Write the data to send */
		spi_write(module, data_to_send);

		if (module->receiver_enabled) {
    4fb8:	79fb      	ldrb	r3, [r7, #7]
    4fba:	2b00      	cmp	r3, #0
    4fbc:	d010      	beq.n	4fe0 <spi_write_buffer_wait+0x8c>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4fbe:	683a      	ldr	r2, [r7, #0]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    4fc0:	7e13      	ldrb	r3, [r2, #24]
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    4fc2:	422b      	tst	r3, r5
    4fc4:	d0fc      	beq.n	4fc0 <spi_write_buffer_wait+0x6c>
    4fc6:	7e13      	ldrb	r3, [r2, #24]
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    4fc8:	422b      	tst	r3, r5
    4fca:	d009      	beq.n	4fe0 <spi_write_buffer_wait+0x8c>

	/* Return value */
	enum status_code retval = STATUS_OK;

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    4fcc:	8b53      	ldrh	r3, [r2, #26]
    4fce:	422b      	tst	r3, r5
    4fd0:	d000      	beq.n	4fd4 <spi_write_buffer_wait+0x80>
		retval = STATUS_ERR_OVERFLOW;
		/* Clear overflow flag */
		spi_module->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    4fd2:	8355      	strh	r5, [r2, #26]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    4fd4:	79bb      	ldrb	r3, [r7, #6]
    4fd6:	2b01      	cmp	r3, #1
    4fd8:	d101      	bne.n	4fde <spi_write_buffer_wait+0x8a>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    4fda:	6a93      	ldr	r3, [r2, #40]	; 0x28
    4fdc:	e000      	b.n	4fe0 <spi_write_buffer_wait+0x8c>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    4fde:	6a93      	ldr	r3, [r2, #40]	; 0x28

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    4fe0:	3e01      	subs	r6, #1
    4fe2:	b2b6      	uxth	r6, r6
    4fe4:	4566      	cmp	r6, ip
    4fe6:	d1c7      	bne.n	4f78 <spi_write_buffer_wait+0x24>
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    4fe8:	797b      	ldrb	r3, [r7, #5]
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    4fea:	2000      	movs	r0, #0
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    4fec:	2b01      	cmp	r3, #1
    4fee:	d10e      	bne.n	500e <spi_write_buffer_wait+0xba>
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    4ff0:	6839      	ldr	r1, [r7, #0]
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    4ff2:	2202      	movs	r2, #2

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    4ff4:	7e0b      	ldrb	r3, [r1, #24]
    4ff6:	4213      	tst	r3, r2
    4ff8:	d0fc      	beq.n	4ff4 <spi_write_buffer_wait+0xa0>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    4ffa:	2000      	movs	r0, #0
    4ffc:	e007      	b.n	500e <spi_write_buffer_wait+0xba>

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    4ffe:	3a01      	subs	r2, #1
    5000:	b296      	uxth	r6, r2
    5002:	2000      	movs	r0, #0
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    5004:	2401      	movs	r4, #1
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    5006:	2504      	movs	r5, #4

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    5008:	4b04      	ldr	r3, [pc, #16]	; (501c <spi_write_buffer_wait+0xc8>)
    500a:	469c      	mov	ip, r3
    500c:	e7b4      	b.n	4f78 <spi_write_buffer_wait+0x24>
			}
		}
	}
#  endif
	return STATUS_OK;
}
    500e:	b003      	add	sp, #12
    5010:	bc3c      	pop	{r2, r3, r4, r5}
    5012:	4690      	mov	r8, r2
    5014:	4699      	mov	r9, r3
    5016:	46a2      	mov	sl, r4
    5018:	46ab      	mov	fp, r5
    501a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    501c:	0000ffff 	.word	0x0000ffff

00005020 <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    5020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Get device instance from the look-up table */
	struct spi_module *module
    5022:	0080      	lsls	r0, r0, #2
    5024:	4b67      	ldr	r3, [pc, #412]	; (51c4 <_spi_interrupt_handler+0x1a4>)
    5026:	58c4      	ldr	r4, [r0, r3]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    5028:	6826      	ldr	r6, [r4, #0]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    502a:	2337      	movs	r3, #55	; 0x37

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
    502c:	5ce3      	ldrb	r3, [r4, r3]
    502e:	2236      	movs	r2, #54	; 0x36
    5030:	5ca7      	ldrb	r7, [r4, r2]
    5032:	401f      	ands	r7, r3
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    5034:	7e33      	ldrb	r3, [r6, #24]
	interrupt_status &= spi_hw->INTENSET.reg;
    5036:	7db5      	ldrb	r5, [r6, #22]
    5038:	401d      	ands	r5, r3

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    503a:	07eb      	lsls	r3, r5, #31
    503c:	d53d      	bpl.n	50ba <_spi_interrupt_handler+0x9a>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    503e:	7963      	ldrb	r3, [r4, #5]
    5040:	2b01      	cmp	r3, #1
    5042:	d13a      	bne.n	50ba <_spi_interrupt_handler+0x9a>
			(module->dir == SPI_DIRECTION_READ)) {
    5044:	7a63      	ldrb	r3, [r4, #9]
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    5046:	2b00      	cmp	r3, #0
    5048:	d10f      	bne.n	506a <_spi_interrupt_handler+0x4a>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
    504a:	4b5f      	ldr	r3, [pc, #380]	; (51c8 <_spi_interrupt_handler+0x1a8>)
    504c:	881b      	ldrh	r3, [r3, #0]
    504e:	62b3      	str	r3, [r6, #40]	; 0x28

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    5050:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    5052:	3b01      	subs	r3, #1
    5054:	b29b      	uxth	r3, r3
    5056:	8663      	strh	r3, [r4, #50]	; 0x32
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
			if (module->remaining_dummy_buffer_length == 0) {
    5058:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    505a:	b29b      	uxth	r3, r3
    505c:	2b00      	cmp	r3, #0
    505e:	d101      	bne.n	5064 <_spi_interrupt_handler+0x44>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    5060:	3301      	adds	r3, #1
    5062:	7533      	strb	r3, [r6, #20]
			}
		}
#  endif

		if (0
    5064:	7963      	ldrb	r3, [r4, #5]
    5066:	2b01      	cmp	r3, #1
    5068:	d127      	bne.n	50ba <_spi_interrupt_handler+0x9a>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
    506a:	7a63      	ldrb	r3, [r4, #9]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    506c:	2b00      	cmp	r3, #0
    506e:	d024      	beq.n	50ba <_spi_interrupt_handler+0x9a>
 */
static void _spi_write(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    5070:	6820      	ldr	r0, [r4, #0]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    5072:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    5074:	780b      	ldrb	r3, [r1, #0]
    5076:	b2da      	uxtb	r2, r3
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
    5078:	1c4b      	adds	r3, r1, #1
    507a:	62e3      	str	r3, [r4, #44]	; 0x2c

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    507c:	79a3      	ldrb	r3, [r4, #6]
    507e:	2b01      	cmp	r3, #1
    5080:	d001      	beq.n	5086 <_spi_interrupt_handler+0x66>
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    5082:	b293      	uxth	r3, r2
    5084:	e004      	b.n	5090 <_spi_interrupt_handler+0x70>
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    5086:	784b      	ldrb	r3, [r1, #1]
    5088:	021b      	lsls	r3, r3, #8
    508a:	4313      	orrs	r3, r2
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
    508c:	3102      	adds	r1, #2
    508e:	62e1      	str	r1, [r4, #44]	; 0x2c
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    5090:	05db      	lsls	r3, r3, #23
    5092:	0ddb      	lsrs	r3, r3, #23
    5094:	6283      	str	r3, [r0, #40]	; 0x28

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
    5096:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    5098:	3b01      	subs	r3, #1
    509a:	b29b      	uxth	r3, r3
    509c:	86a3      	strh	r3, [r4, #52]	; 0x34
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
			if (module->remaining_tx_buffer_length == 0) {
    509e:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
    50a0:	b29b      	uxth	r3, r3
    50a2:	2b00      	cmp	r3, #0
    50a4:	d109      	bne.n	50ba <_spi_interrupt_handler+0x9a>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    50a6:	3301      	adds	r3, #1
    50a8:	7533      	strb	r3, [r6, #20]

				if (module->dir == SPI_DIRECTION_WRITE &&
    50aa:	7a63      	ldrb	r3, [r4, #9]
    50ac:	2b01      	cmp	r3, #1
    50ae:	d104      	bne.n	50ba <_spi_interrupt_handler+0x9a>
    50b0:	79e3      	ldrb	r3, [r4, #7]
    50b2:	2b00      	cmp	r3, #0
    50b4:	d101      	bne.n	50ba <_spi_interrupt_handler+0x9a>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    50b6:	3302      	adds	r3, #2
    50b8:	75b3      	strb	r3, [r6, #22]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    50ba:	076b      	lsls	r3, r5, #29
    50bc:	d55f      	bpl.n	517e <_spi_interrupt_handler+0x15e>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    50be:	8b73      	ldrh	r3, [r6, #26]
    50c0:	075b      	lsls	r3, r3, #29
    50c2:	d512      	bpl.n	50ea <_spi_interrupt_handler+0xca>
			if (module->dir != SPI_DIRECTION_WRITE) {
    50c4:	7a63      	ldrb	r3, [r4, #9]
    50c6:	2b01      	cmp	r3, #1
    50c8:	d00b      	beq.n	50e2 <_spi_interrupt_handler+0xc2>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    50ca:	221e      	movs	r2, #30
    50cc:	2338      	movs	r3, #56	; 0x38
    50ce:	54e2      	strb	r2, [r4, r3]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    50d0:	3b35      	subs	r3, #53	; 0x35
    50d2:	7263      	strb	r3, [r4, #9]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    50d4:	3302      	adds	r3, #2
    50d6:	7533      	strb	r3, [r6, #20]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    50d8:	073b      	lsls	r3, r7, #28
    50da:	d502      	bpl.n	50e2 <_spi_interrupt_handler+0xc2>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    50dc:	0020      	movs	r0, r4
    50de:	69a3      	ldr	r3, [r4, #24]
    50e0:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    50e2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
    50e4:	2304      	movs	r3, #4
    50e6:	8373      	strh	r3, [r6, #26]
    50e8:	e049      	b.n	517e <_spi_interrupt_handler+0x15e>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
    50ea:	7a63      	ldrb	r3, [r4, #9]
    50ec:	2b01      	cmp	r3, #1
    50ee:	d116      	bne.n	511e <_spi_interrupt_handler+0xfe>
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    50f0:	6823      	ldr	r3, [r4, #0]
	uint16_t flush = 0;

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
    50f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    50f4:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    50f6:	3b01      	subs	r3, #1
    50f8:	b29b      	uxth	r3, r3
    50fa:	8663      	strh	r3, [r4, #50]	; 0x32
			spi_hw->STATUS.reg = SERCOM_SPI_STATUS_BUFOVF;
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
				if (module->remaining_dummy_buffer_length == 0) {
    50fc:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    50fe:	b29b      	uxth	r3, r3
    5100:	2b00      	cmp	r3, #0
    5102:	d13c      	bne.n	517e <_spi_interrupt_handler+0x15e>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    5104:	3304      	adds	r3, #4
    5106:	7533      	strb	r3, [r6, #20]
					module->status = STATUS_OK;
    5108:	2200      	movs	r2, #0
    510a:	3334      	adds	r3, #52	; 0x34
    510c:	54e2      	strb	r2, [r4, r3]
					module->dir = SPI_DIRECTION_IDLE;
    510e:	3b35      	subs	r3, #53	; 0x35
    5110:	7263      	strb	r3, [r4, #9]
					/* Run callback if registered and enabled */
					if (callback_mask &
    5112:	07fb      	lsls	r3, r7, #31
    5114:	d533      	bpl.n	517e <_spi_interrupt_handler+0x15e>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    5116:	0020      	movs	r0, r4
    5118:	68e3      	ldr	r3, [r4, #12]
    511a:	4798      	blx	r3
    511c:	e02f      	b.n	517e <_spi_interrupt_handler+0x15e>
 */
static void _spi_read(
		struct spi_module *const module)
{
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    511e:	6823      	ldr	r3, [r4, #0]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    5120:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5122:	05db      	lsls	r3, r3, #23
    5124:	0ddb      	lsrs	r3, r3, #23

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
    5126:	b2da      	uxtb	r2, r3
    5128:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    512a:	700a      	strb	r2, [r1, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
    512c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    512e:	1c51      	adds	r1, r2, #1
    5130:	62a1      	str	r1, [r4, #40]	; 0x28

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    5132:	79a1      	ldrb	r1, [r4, #6]
    5134:	2901      	cmp	r1, #1
    5136:	d104      	bne.n	5142 <_spi_interrupt_handler+0x122>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
    5138:	0a1b      	lsrs	r3, r3, #8
    513a:	7053      	strb	r3, [r2, #1]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
    513c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    513e:	3301      	adds	r3, #1
    5140:	62a3      	str	r3, [r4, #40]	; 0x28
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
    5142:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    5144:	3b01      	subs	r3, #1
    5146:	b29b      	uxth	r3, r3
    5148:	8623      	strh	r3, [r4, #48]	; 0x30
			} else {
				/* Read data register */
				_spi_read(module);

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
    514a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    514c:	b29b      	uxth	r3, r3
    514e:	2b00      	cmp	r3, #0
    5150:	d115      	bne.n	517e <_spi_interrupt_handler+0x15e>
					module->status = STATUS_OK;
    5152:	2200      	movs	r2, #0
    5154:	3338      	adds	r3, #56	; 0x38
    5156:	54e2      	strb	r2, [r4, r3]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    5158:	3b34      	subs	r3, #52	; 0x34
    515a:	7533      	strb	r3, [r6, #20]
					if(module->dir == SPI_DIRECTION_BOTH) {
    515c:	7a63      	ldrb	r3, [r4, #9]
    515e:	2b02      	cmp	r3, #2
    5160:	d105      	bne.n	516e <_spi_interrupt_handler+0x14e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    5162:	077b      	lsls	r3, r7, #29
    5164:	d50b      	bpl.n	517e <_spi_interrupt_handler+0x15e>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    5166:	0020      	movs	r0, r4
    5168:	6963      	ldr	r3, [r4, #20]
    516a:	4798      	blx	r3
    516c:	e007      	b.n	517e <_spi_interrupt_handler+0x15e>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
    516e:	7a63      	ldrb	r3, [r4, #9]
    5170:	2b00      	cmp	r3, #0
    5172:	d104      	bne.n	517e <_spi_interrupt_handler+0x15e>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    5174:	07bb      	lsls	r3, r7, #30
    5176:	d502      	bpl.n	517e <_spi_interrupt_handler+0x15e>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    5178:	0020      	movs	r0, r4
    517a:	6923      	ldr	r3, [r4, #16]
    517c:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    517e:	07ab      	lsls	r3, r5, #30
    5180:	d514      	bpl.n	51ac <_spi_interrupt_handler+0x18c>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    5182:	7963      	ldrb	r3, [r4, #5]
    5184:	2b01      	cmp	r3, #1
    5186:	d111      	bne.n	51ac <_spi_interrupt_handler+0x18c>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    5188:	7a63      	ldrb	r3, [r4, #9]
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    518a:	2b01      	cmp	r3, #1
    518c:	d10e      	bne.n	51ac <_spi_interrupt_handler+0x18c>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    518e:	79e3      	ldrb	r3, [r4, #7]
    5190:	2b00      	cmp	r3, #0
    5192:	d10b      	bne.n	51ac <_spi_interrupt_handler+0x18c>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    5194:	3302      	adds	r3, #2
    5196:	7533      	strb	r3, [r6, #20]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
    5198:	3301      	adds	r3, #1
    519a:	7263      	strb	r3, [r4, #9]
			module->status = STATUS_OK;
    519c:	2200      	movs	r2, #0
    519e:	3335      	adds	r3, #53	; 0x35
    51a0:	54e2      	strb	r2, [r4, r3]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    51a2:	07fb      	lsls	r3, r7, #31
    51a4:	d502      	bpl.n	51ac <_spi_interrupt_handler+0x18c>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    51a6:	0020      	movs	r0, r4
    51a8:	68e3      	ldr	r3, [r4, #12]
    51aa:	4798      	blx	r3
#  endif
#  endif

#  ifdef FEATURE_SPI_ERROR_INTERRUPT
	/* When combined error happen */
	if (interrupt_status & SPI_INTERRUPT_FLAG_COMBINED_ERROR) {
    51ac:	09ed      	lsrs	r5, r5, #7
    51ae:	d007      	beq.n	51c0 <_spi_interrupt_handler+0x1a0>
		/* Disable interrupts */
		spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    51b0:	2380      	movs	r3, #128	; 0x80
    51b2:	7533      	strb	r3, [r6, #20]
		/* Clear interrupt flag */
		spi_hw->INTFLAG.reg = SPI_INTERRUPT_FLAG_COMBINED_ERROR;
    51b4:	7633      	strb	r3, [r6, #24]

		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
    51b6:	067b      	lsls	r3, r7, #25
    51b8:	d502      	bpl.n	51c0 <_spi_interrupt_handler+0x1a0>
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
    51ba:	6a63      	ldr	r3, [r4, #36]	; 0x24
    51bc:	0020      	movs	r0, r4
    51be:	4798      	blx	r3
		}
	}
#  endif
}
    51c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    51c2:	46c0      	nop			; (mov r8, r8)
    51c4:	20000364 	.word	0x20000364
    51c8:	2000037c 	.word	0x2000037c

000051cc <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    51cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    51ce:	465f      	mov	r7, fp
    51d0:	4656      	mov	r6, sl
    51d2:	464d      	mov	r5, r9
    51d4:	4644      	mov	r4, r8
    51d6:	b4f0      	push	{r4, r5, r6, r7}
    51d8:	b091      	sub	sp, #68	; 0x44
    51da:	0005      	movs	r5, r0
    51dc:	000c      	movs	r4, r1
    51de:	0016      	movs	r6, r2
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    51e0:	6029      	str	r1, [r5, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    51e2:	0008      	movs	r0, r1
    51e4:	4bbb      	ldr	r3, [pc, #748]	; (54d4 <usart_init+0x308>)
    51e6:	4798      	blx	r3
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    51e8:	6822      	ldr	r2, [r4, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    51ea:	2305      	movs	r3, #5
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    51ec:	07d2      	lsls	r2, r2, #31
    51ee:	d500      	bpl.n	51f2 <usart_init+0x26>
    51f0:	e167      	b.n	54c2 <usart_init+0x2f6>
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    51f2:	6822      	ldr	r2, [r4, #0]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    51f4:	3317      	adds	r3, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
		/* The module is busy resetting itself */
		return STATUS_BUSY;
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    51f6:	0792      	lsls	r2, r2, #30
    51f8:	d500      	bpl.n	51fc <usart_init+0x30>
    51fa:	e162      	b.n	54c2 <usart_init+0x2f6>
    51fc:	49b6      	ldr	r1, [pc, #728]	; (54d8 <usart_init+0x30c>)
    51fe:	6a0a      	ldr	r2, [r1, #32]
    5200:	1c87      	adds	r7, r0, #2
    5202:	3b1b      	subs	r3, #27
    5204:	40bb      	lsls	r3, r7
    5206:	4313      	orrs	r3, r2
    5208:	620b      	str	r3, [r1, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    520a:	a90f      	add	r1, sp, #60	; 0x3c
    520c:	272d      	movs	r7, #45	; 0x2d
    520e:	5df3      	ldrb	r3, [r6, r7]
    5210:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    5212:	3014      	adds	r0, #20
    5214:	b2c3      	uxtb	r3, r0
    5216:	9302      	str	r3, [sp, #8]
    5218:	0018      	movs	r0, r3
    521a:	4bb0      	ldr	r3, [pc, #704]	; (54dc <usart_init+0x310>)
    521c:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    521e:	9802      	ldr	r0, [sp, #8]
    5220:	4baf      	ldr	r3, [pc, #700]	; (54e0 <usart_init+0x314>)
    5222:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    5224:	5df0      	ldrb	r0, [r6, r7]
    5226:	2100      	movs	r1, #0
    5228:	4bae      	ldr	r3, [pc, #696]	; (54e4 <usart_init+0x318>)
    522a:	4798      	blx	r3

	/* Set character size */
	module->character_size = config->character_size;
    522c:	7af3      	ldrb	r3, [r6, #11]
    522e:	716b      	strb	r3, [r5, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    5230:	2324      	movs	r3, #36	; 0x24
    5232:	5cf3      	ldrb	r3, [r6, r3]
    5234:	71ab      	strb	r3, [r5, #6]
	module->transmitter_enabled = config->transmitter_enable;
    5236:	2325      	movs	r3, #37	; 0x25
    5238:	5cf3      	ldrb	r3, [r6, r3]
    523a:	71eb      	strb	r3, [r5, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    523c:	7ef3      	ldrb	r3, [r6, #27]
    523e:	722b      	strb	r3, [r5, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    5240:	7f33      	ldrb	r3, [r6, #28]
    5242:	726b      	strb	r3, [r5, #9]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    5244:	682b      	ldr	r3, [r5, #0]
    5246:	4699      	mov	r9, r3

	/* Index for generic clock */
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    5248:	0018      	movs	r0, r3
    524a:	4ba2      	ldr	r3, [pc, #648]	; (54d4 <usart_init+0x308>)
    524c:	4798      	blx	r3
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    524e:	3014      	adds	r0, #20
	uint32_t ctrla = 0;
	uint32_t ctrlb = 0;
#ifdef FEATURE_USART_ISO7816
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
    5250:	2200      	movs	r2, #0
    5252:	230e      	movs	r3, #14
    5254:	a906      	add	r1, sp, #24
    5256:	468c      	mov	ip, r1
    5258:	4463      	add	r3, ip
    525a:	801a      	strh	r2, [r3, #0]

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;

#ifdef FEATURE_USART_OVER_SAMPLE
	switch (config->sample_rate) {
    525c:	8a32      	ldrh	r2, [r6, #16]
    525e:	9202      	str	r2, [sp, #8]
    5260:	2380      	movs	r3, #128	; 0x80
    5262:	01db      	lsls	r3, r3, #7
    5264:	429a      	cmp	r2, r3
    5266:	d01a      	beq.n	529e <usart_init+0xd2>
    5268:	d804      	bhi.n	5274 <usart_init+0xa8>
    526a:	2380      	movs	r3, #128	; 0x80
    526c:	019b      	lsls	r3, r3, #6
    526e:	429a      	cmp	r2, r3
    5270:	d00b      	beq.n	528a <usart_init+0xbe>
    5272:	e107      	b.n	5484 <usart_init+0x2b8>
    5274:	23c0      	movs	r3, #192	; 0xc0
    5276:	01db      	lsls	r3, r3, #7
    5278:	9a02      	ldr	r2, [sp, #8]
    527a:	429a      	cmp	r2, r3
    527c:	d00a      	beq.n	5294 <usart_init+0xc8>
    527e:	2380      	movs	r3, #128	; 0x80
    5280:	021b      	lsls	r3, r3, #8
    5282:	429a      	cmp	r2, r3
    5284:	d100      	bne.n	5288 <usart_init+0xbc>
    5286:	e102      	b.n	548e <usart_init+0x2c2>
    5288:	e0fc      	b.n	5484 <usart_init+0x2b8>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    528a:	2310      	movs	r3, #16
    528c:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
			break;
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    528e:	3b0f      	subs	r3, #15
    5290:	9307      	str	r3, [sp, #28]
    5292:	e100      	b.n	5496 <usart_init+0x2ca>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    5294:	2308      	movs	r3, #8
    5296:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_FRACTIONAL:
			mode = SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL;
    5298:	3b07      	subs	r3, #7
    529a:	9307      	str	r3, [sp, #28]
    529c:	e0fb      	b.n	5496 <usart_init+0x2ca>
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    529e:	6833      	ldr	r3, [r6, #0]
    52a0:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    52a2:	68f3      	ldr	r3, [r6, #12]
    52a4:	9303      	str	r3, [sp, #12]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    52a6:	6973      	ldr	r3, [r6, #20]
    52a8:	4698      	mov	r8, r3
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    52aa:	7e33      	ldrb	r3, [r6, #24]
    52ac:	469b      	mov	fp, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    52ae:	2326      	movs	r3, #38	; 0x26
    52b0:	5cf3      	ldrb	r3, [r6, r3]
    52b2:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    52b4:	6873      	ldr	r3, [r6, #4]
    52b6:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    52b8:	2b00      	cmp	r3, #0
    52ba:	d015      	beq.n	52e8 <usart_init+0x11c>
    52bc:	2380      	movs	r3, #128	; 0x80
    52be:	055b      	lsls	r3, r3, #21
    52c0:	459a      	cmp	sl, r3
    52c2:	d136      	bne.n	5332 <usart_init+0x166>
	{
		case USART_TRANSFER_SYNCHRONOUSLY:
			if (!config->use_external_clock) {
    52c4:	2327      	movs	r3, #39	; 0x27
    52c6:	5cf3      	ldrb	r3, [r6, r3]
    52c8:	2b00      	cmp	r3, #0
    52ca:	d136      	bne.n	533a <usart_init+0x16e>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    52cc:	6a33      	ldr	r3, [r6, #32]
    52ce:	001f      	movs	r7, r3
    52d0:	b2c0      	uxtb	r0, r0
    52d2:	4b85      	ldr	r3, [pc, #532]	; (54e8 <usart_init+0x31c>)
    52d4:	4798      	blx	r3
    52d6:	0001      	movs	r1, r0
    52d8:	220e      	movs	r2, #14
    52da:	ab06      	add	r3, sp, #24
    52dc:	469c      	mov	ip, r3
    52de:	4462      	add	r2, ip
    52e0:	0038      	movs	r0, r7
    52e2:	4b82      	ldr	r3, [pc, #520]	; (54ec <usart_init+0x320>)
    52e4:	4798      	blx	r3
    52e6:	e025      	b.n	5334 <usart_init+0x168>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    52e8:	2308      	movs	r3, #8
    52ea:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_16X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
			break;
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    52ec:	2300      	movs	r3, #0
    52ee:	9307      	str	r3, [sp, #28]
			}

			break;

		case USART_TRANSFER_ASYNCHRONOUSLY:
			if (config->use_external_clock) {
    52f0:	2327      	movs	r3, #39	; 0x27
    52f2:	5cf3      	ldrb	r3, [r6, r3]
    52f4:	2b00      	cmp	r3, #0
    52f6:	d00b      	beq.n	5310 <usart_init+0x144>
				status_code =
    52f8:	9b06      	ldr	r3, [sp, #24]
    52fa:	9300      	str	r3, [sp, #0]
    52fc:	9b07      	ldr	r3, [sp, #28]
    52fe:	220e      	movs	r2, #14
    5300:	a906      	add	r1, sp, #24
    5302:	468c      	mov	ip, r1
    5304:	4462      	add	r2, ip
    5306:	6ab1      	ldr	r1, [r6, #40]	; 0x28
    5308:	6a30      	ldr	r0, [r6, #32]
    530a:	4f79      	ldr	r7, [pc, #484]	; (54f0 <usart_init+0x324>)
    530c:	47b8      	blx	r7
    530e:	e011      	b.n	5334 <usart_init+0x168>
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
    5310:	6a33      	ldr	r3, [r6, #32]
    5312:	001f      	movs	r7, r3
    5314:	b2c0      	uxtb	r0, r0
    5316:	4b74      	ldr	r3, [pc, #464]	; (54e8 <usart_init+0x31c>)
    5318:	4798      	blx	r3
    531a:	0001      	movs	r1, r0
			if (config->use_external_clock) {
				status_code =
						_sercom_get_async_baud_val(config->baudrate,
							config->ext_clock_freq, &baud, mode, sample_num);
			} else {
				status_code =
    531c:	9b06      	ldr	r3, [sp, #24]
    531e:	9300      	str	r3, [sp, #0]
    5320:	9b07      	ldr	r3, [sp, #28]
    5322:	220e      	movs	r2, #14
    5324:	a806      	add	r0, sp, #24
    5326:	4684      	mov	ip, r0
    5328:	4462      	add	r2, ip
    532a:	0038      	movs	r0, r7
    532c:	4f70      	ldr	r7, [pc, #448]	; (54f0 <usart_init+0x324>)
    532e:	47b8      	blx	r7
    5330:	e000      	b.n	5334 <usart_init+0x168>
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);

	enum status_code status_code = STATUS_OK;
    5332:	2000      	movs	r0, #0
    5334:	1e03      	subs	r3, r0, #0

			break;
	}

	/* Check if calculating the baudrate failed */
	if (status_code != STATUS_OK) {
    5336:	d000      	beq.n	533a <usart_init+0x16e>
    5338:	e0c3      	b.n	54c2 <usart_init+0x2f6>
#ifdef FEATURE_USART_ISO7816
	}
#endif

#ifdef FEATURE_USART_IRDA
	if(config->encoding_format_enable) {
    533a:	7e73      	ldrb	r3, [r6, #25]
    533c:	2b00      	cmp	r3, #0
    533e:	d002      	beq.n	5346 <usart_init+0x17a>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    5340:	7eb3      	ldrb	r3, [r6, #26]
    5342:	464a      	mov	r2, r9
    5344:	7393      	strb	r3, [r2, #14]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    5346:	682a      	ldr	r2, [r5, #0]
    5348:	9f02      	ldr	r7, [sp, #8]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    534a:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    534c:	2b00      	cmp	r3, #0
    534e:	d1fc      	bne.n	534a <usart_init+0x17e>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/*Set baud val */
	usart_hw->BAUD.reg = baud;
    5350:	330e      	adds	r3, #14
    5352:	aa06      	add	r2, sp, #24
    5354:	4694      	mov	ip, r2
    5356:	4463      	add	r3, ip
    5358:	881b      	ldrh	r3, [r3, #0]
    535a:	464a      	mov	r2, r9
    535c:	8193      	strh	r3, [r2, #12]

	/* Set sample mode */
	ctrla |= transfer_mode;
    535e:	9b04      	ldr	r3, [sp, #16]
    5360:	9a03      	ldr	r2, [sp, #12]
    5362:	4313      	orrs	r3, r2
    5364:	4642      	mov	r2, r8
    5366:	4313      	orrs	r3, r2
    5368:	4652      	mov	r2, sl
    536a:	4313      	orrs	r3, r2
    536c:	433b      	orrs	r3, r7
    536e:	465a      	mov	r2, fp
    5370:	0212      	lsls	r2, r2, #8
    5372:	4313      	orrs	r3, r2
    5374:	9a05      	ldr	r2, [sp, #20]
    5376:	0757      	lsls	r7, r2, #29
    5378:	431f      	orrs	r7, r3

	if (config->use_external_clock == false) {
    537a:	2327      	movs	r3, #39	; 0x27
    537c:	5cf3      	ldrb	r3, [r6, r3]
    537e:	2b00      	cmp	r3, #0
    5380:	d101      	bne.n	5386 <usart_init+0x1ba>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    5382:	3304      	adds	r3, #4
    5384:	431f      	orrs	r7, r3
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    5386:	7e71      	ldrb	r1, [r6, #25]
    5388:	0289      	lsls	r1, r1, #10
    538a:	7f33      	ldrb	r3, [r6, #28]
    538c:	025b      	lsls	r3, r3, #9
    538e:	4319      	orrs	r1, r3
    5390:	7f73      	ldrb	r3, [r6, #29]
    5392:	021b      	lsls	r3, r3, #8
    5394:	4319      	orrs	r1, r3
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    5396:	2324      	movs	r3, #36	; 0x24
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    5398:	5cf3      	ldrb	r3, [r6, r3]
    539a:	045b      	lsls	r3, r3, #17
    539c:	4319      	orrs	r1, r3
		#endif
		#ifdef FEATURE_USART_COLLISION_DECTION
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
		#endif
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    539e:	2325      	movs	r3, #37	; 0x25
	else {
		ctrla |= SERCOM_USART_CTRLA_MODE(0x0);
	}

	/* Set stopbits and enable transceivers */
	ctrlb =  
    53a0:	5cf0      	ldrb	r0, [r6, r3]
    53a2:	0400      	lsls	r0, r0, #16
    53a4:	000a      	movs	r2, r1
    53a6:	4302      	orrs	r2, r0
				break;		
		}
	} else {
#endif
	ctrlb |= (uint32_t)config->stopbits;
	ctrlb |= (uint32_t)config->character_size;
    53a8:	7ab1      	ldrb	r1, [r6, #10]
    53aa:	7af3      	ldrb	r3, [r6, #11]
    53ac:	4319      	orrs	r1, r3
    53ae:	4311      	orrs	r1, r2
	/* Check parity mode bits */
	if (config->parity != USART_PARITY_NONE) {
    53b0:	8933      	ldrh	r3, [r6, #8]
    53b2:	2bff      	cmp	r3, #255	; 0xff
    53b4:	d004      	beq.n	53c0 <usart_init+0x1f4>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    53b6:	2280      	movs	r2, #128	; 0x80
    53b8:	0452      	lsls	r2, r2, #17
    53ba:	4317      	orrs	r7, r2
		ctrlb |= config->parity;
    53bc:	4319      	orrs	r1, r3
    53be:	e005      	b.n	53cc <usart_init+0x200>
	} else {
#ifdef FEATURE_USART_LIN_SLAVE
		if(config->lin_slave_enable) {
    53c0:	7ef3      	ldrb	r3, [r6, #27]
    53c2:	2b00      	cmp	r3, #0
    53c4:	d002      	beq.n	53cc <usart_init+0x200>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    53c6:	2380      	movs	r3, #128	; 0x80
    53c8:	04db      	lsls	r3, r3, #19
    53ca:	431f      	orrs	r7, r3
		ctrla |= config->lin_node;
	}
#endif

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    53cc:	232c      	movs	r3, #44	; 0x2c
    53ce:	5cf3      	ldrb	r3, [r6, r3]
    53d0:	2b00      	cmp	r3, #0
    53d2:	d103      	bne.n	53dc <usart_init+0x210>
    53d4:	4b47      	ldr	r3, [pc, #284]	; (54f4 <usart_init+0x328>)
    53d6:	789b      	ldrb	r3, [r3, #2]
    53d8:	079b      	lsls	r3, r3, #30
    53da:	d501      	bpl.n	53e0 <usart_init+0x214>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    53dc:	2380      	movs	r3, #128	; 0x80
    53de:	431f      	orrs	r7, r3
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    53e0:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    53e2:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    53e4:	2b00      	cmp	r3, #0
    53e6:	d1fc      	bne.n	53e2 <usart_init+0x216>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLB */
	usart_hw->CTRLB.reg = ctrlb;
    53e8:	464b      	mov	r3, r9
    53ea:	6059      	str	r1, [r3, #4]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    53ec:	682a      	ldr	r2, [r5, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    53ee:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    53f0:	2b00      	cmp	r3, #0
    53f2:	d1fc      	bne.n	53ee <usart_init+0x222>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write configuration to CTRLA */
	usart_hw->CTRLA.reg = ctrla;
    53f4:	464b      	mov	r3, r9
    53f6:	601f      	str	r7, [r3, #0]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    53f8:	ab0e      	add	r3, sp, #56	; 0x38
    53fa:	2280      	movs	r2, #128	; 0x80
    53fc:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    53fe:	2200      	movs	r2, #0
    5400:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
	config->powersave    = false;
    5402:	70da      	strb	r2, [r3, #3]
	}

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    5404:	709a      	strb	r2, [r3, #2]

	uint32_t pad_pinmuxes[] = {
    5406:	6b33      	ldr	r3, [r6, #48]	; 0x30
    5408:	930a      	str	r3, [sp, #40]	; 0x28
    540a:	6b73      	ldr	r3, [r6, #52]	; 0x34
    540c:	930b      	str	r3, [sp, #44]	; 0x2c
    540e:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    5410:	930c      	str	r3, [sp, #48]	; 0x30
    5412:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
    5414:	9302      	str	r3, [sp, #8]
    5416:	930d      	str	r3, [sp, #52]	; 0x34
    5418:	2700      	movs	r7, #0
		if (current_pinmux == PINMUX_DEFAULT) {
			current_pinmux = _sercom_get_default_pad(hw, pad);
		}

		if (current_pinmux != PINMUX_UNUSED) {
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    541a:	ae0e      	add	r6, sp, #56	; 0x38
    541c:	b2f9      	uxtb	r1, r7
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    541e:	00bb      	lsls	r3, r7, #2
    5420:	aa0a      	add	r2, sp, #40	; 0x28
    5422:	5898      	ldr	r0, [r3, r2]

		if (current_pinmux == PINMUX_DEFAULT) {
    5424:	2800      	cmp	r0, #0
    5426:	d102      	bne.n	542e <usart_init+0x262>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    5428:	0020      	movs	r0, r4
    542a:	4b33      	ldr	r3, [pc, #204]	; (54f8 <usart_init+0x32c>)
    542c:	4798      	blx	r3
		}

		if (current_pinmux != PINMUX_UNUSED) {
    542e:	1c43      	adds	r3, r0, #1
    5430:	d005      	beq.n	543e <usart_init+0x272>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    5432:	7030      	strb	r0, [r6, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    5434:	0c00      	lsrs	r0, r0, #16
    5436:	b2c0      	uxtb	r0, r0
    5438:	0031      	movs	r1, r6
    543a:	4b30      	ldr	r3, [pc, #192]	; (54fc <usart_init+0x330>)
    543c:	4798      	blx	r3
    543e:	3701      	adds	r7, #1
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    5440:	2f04      	cmp	r7, #4
    5442:	d1eb      	bne.n	541c <usart_init+0x250>
	}

#if USART_CALLBACK_MODE == true
	/* Initialize parameters */
	for (uint32_t i = 0; i < USART_CALLBACK_N; i++) {
		module->callback[i]            = NULL;
    5444:	2300      	movs	r3, #0
    5446:	60eb      	str	r3, [r5, #12]
    5448:	612b      	str	r3, [r5, #16]
    544a:	616b      	str	r3, [r5, #20]
    544c:	61ab      	str	r3, [r5, #24]
    544e:	61eb      	str	r3, [r5, #28]
    5450:	622b      	str	r3, [r5, #32]
	}

	module->tx_buffer_ptr              = NULL;
    5452:	62ab      	str	r3, [r5, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    5454:	626b      	str	r3, [r5, #36]	; 0x24
	module->remaining_tx_buffer_length = 0x0000;
    5456:	2200      	movs	r2, #0
    5458:	85eb      	strh	r3, [r5, #46]	; 0x2e
	module->remaining_rx_buffer_length = 0x0000;
    545a:	85ab      	strh	r3, [r5, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    545c:	3330      	adds	r3, #48	; 0x30
    545e:	54ea      	strb	r2, [r5, r3]
	module->callback_enable_mask       = 0x00;
    5460:	3301      	adds	r3, #1
    5462:	54ea      	strb	r2, [r5, r3]
	module->rx_status                  = STATUS_OK;
    5464:	3301      	adds	r3, #1
    5466:	54ea      	strb	r2, [r5, r3]
	module->tx_status                  = STATUS_OK;
    5468:	3301      	adds	r3, #1
    546a:	54ea      	strb	r2, [r5, r3]

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    546c:	6828      	ldr	r0, [r5, #0]
    546e:	4b19      	ldr	r3, [pc, #100]	; (54d4 <usart_init+0x308>)
    5470:	4798      	blx	r3
    5472:	0004      	movs	r4, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    5474:	4922      	ldr	r1, [pc, #136]	; (5500 <usart_init+0x334>)
    5476:	4b23      	ldr	r3, [pc, #140]	; (5504 <usart_init+0x338>)
    5478:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    547a:	00a4      	lsls	r4, r4, #2
    547c:	4b22      	ldr	r3, [pc, #136]	; (5508 <usart_init+0x33c>)
    547e:	50e5      	str	r5, [r4, r3]
#endif

	return status_code;
    5480:	2300      	movs	r3, #0
    5482:	e01e      	b.n	54c2 <usart_init+0x2f6>
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    5484:	2310      	movs	r3, #16
    5486:	9306      	str	r3, [sp, #24]
	uint32_t ctrlc = 0;
#endif
	uint16_t baud  = 0;
	uint32_t transfer_mode;

	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    5488:	2300      	movs	r3, #0
    548a:	9307      	str	r3, [sp, #28]
    548c:	e003      	b.n	5496 <usart_init+0x2ca>
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    548e:	2303      	movs	r3, #3
    5490:	9306      	str	r3, [sp, #24]
		case USART_SAMPLE_RATE_8X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
			break;
		case USART_SAMPLE_RATE_3X_ARITHMETIC:
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    5492:	2300      	movs	r3, #0
    5494:	9307      	str	r3, [sp, #28]
			break;
	}
#endif

	/* Set data order, internal muxing, and clock polarity */
	ctrla = (uint32_t)config->data_order |
    5496:	6833      	ldr	r3, [r6, #0]
    5498:	9304      	str	r3, [sp, #16]
		(uint32_t)config->mux_setting |
    549a:	68f3      	ldr	r3, [r6, #12]
    549c:	9303      	str	r3, [sp, #12]
	#ifdef FEATURE_USART_OVER_SAMPLE
		config->sample_adjustment |
    549e:	6973      	ldr	r3, [r6, #20]
    54a0:	4698      	mov	r8, r3
		config->sample_rate |
	#endif
	#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    54a2:	7e33      	ldrb	r3, [r6, #24]
    54a4:	469b      	mov	fp, r3
	#endif
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    54a6:	2326      	movs	r3, #38	; 0x26
    54a8:	5cf3      	ldrb	r3, [r6, r3]
    54aa:	9305      	str	r3, [sp, #20]

	enum status_code status_code = STATUS_OK;

	transfer_mode = (uint32_t)config->transfer_mode;
    54ac:	6873      	ldr	r3, [r6, #4]
    54ae:	469a      	mov	sl, r3
#ifdef FEATURE_USART_ISO7816
	if(config->iso7816_config.enabled) {
		baud = config->baudrate;
	} else {
#endif
	switch (transfer_mode)
    54b0:	2b00      	cmp	r3, #0
    54b2:	d100      	bne.n	54b6 <usart_init+0x2ea>
    54b4:	e71c      	b.n	52f0 <usart_init+0x124>
    54b6:	2380      	movs	r3, #128	; 0x80
    54b8:	055b      	lsls	r3, r3, #21
    54ba:	459a      	cmp	sl, r3
    54bc:	d100      	bne.n	54c0 <usart_init+0x2f4>
    54be:	e701      	b.n	52c4 <usart_init+0xf8>
    54c0:	e73b      	b.n	533a <usart_init+0x16e>
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
}
    54c2:	0018      	movs	r0, r3
    54c4:	b011      	add	sp, #68	; 0x44
    54c6:	bc3c      	pop	{r2, r3, r4, r5}
    54c8:	4690      	mov	r8, r2
    54ca:	4699      	mov	r9, r3
    54cc:	46a2      	mov	sl, r4
    54ce:	46ab      	mov	fp, r5
    54d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    54d2:	46c0      	nop			; (mov r8, r8)
    54d4:	00004a2d 	.word	0x00004a2d
    54d8:	40000400 	.word	0x40000400
    54dc:	00005d9d 	.word	0x00005d9d
    54e0:	00005d11 	.word	0x00005d11
    54e4:	00004859 	.word	0x00004859
    54e8:	00005db9 	.word	0x00005db9
    54ec:	0000479d 	.word	0x0000479d
    54f0:	000047c5 	.word	0x000047c5
    54f4:	41002000 	.word	0x41002000
    54f8:	000048a5 	.word	0x000048a5
    54fc:	00005e95 	.word	0x00005e95
    5500:	000055a9 	.word	0x000055a9
    5504:	00004a6d 	.word	0x00004a6d
    5508:	20000364 	.word	0x20000364

0000550c <usart_write_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    550c:	79c2      	ldrb	r2, [r0, #7]
		return STATUS_ERR_DENIED;
    550e:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    5510:	2a00      	cmp	r2, #0
    5512:	d00e      	beq.n	5532 <usart_write_wait+0x26>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    5514:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
    5516:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    5518:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    551a:	2a00      	cmp	r2, #0
    551c:	d109      	bne.n	5532 <usart_write_wait+0x26>
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    551e:	6803      	ldr	r3, [r0, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    5520:	69da      	ldr	r2, [r3, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    5522:	2a00      	cmp	r2, #0
    5524:	d1fc      	bne.n	5520 <usart_write_wait+0x14>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;
    5526:	8519      	strh	r1, [r3, #40]	; 0x28

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    5528:	2102      	movs	r1, #2
    552a:	7e1a      	ldrb	r2, [r3, #24]
    552c:	420a      	tst	r2, r1
    552e:	d0fc      	beq.n	552a <usart_write_wait+0x1e>
		/* Wait until data is sent */
	}

	return STATUS_OK;
    5530:	2300      	movs	r3, #0
}
    5532:	0018      	movs	r0, r3
    5534:	4770      	bx	lr
    5536:	46c0      	nop			; (mov r8, r8)

00005538 <usart_read_wait>:

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    5538:	7982      	ldrb	r2, [r0, #6]
		return STATUS_ERR_DENIED;
    553a:	231c      	movs	r3, #28

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the receiver is enabled */
	if (!(module->receiver_enabled)) {
    553c:	2a00      	cmp	r2, #0
    553e:	d030      	beq.n	55a2 <usart_read_wait+0x6a>
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    5540:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    5542:	b292      	uxth	r2, r2
		return STATUS_BUSY;
    5544:	3b17      	subs	r3, #23
		return STATUS_ERR_DENIED;
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_rx_buffer_length > 0) {
    5546:	2a00      	cmp	r2, #0
    5548:	d12b      	bne.n	55a2 <usart_read_wait+0x6a>

	/* Error variable */
	uint8_t error_code;

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    554a:	6802      	ldr	r2, [r0, #0]
		return STATUS_BUSY;
	}
#endif

	/* Check if USART has new data */
	if (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_RXC)) {
    554c:	7e10      	ldrb	r0, [r2, #24]
    554e:	0740      	lsls	r0, r0, #29
    5550:	d527      	bpl.n	55a2 <usart_read_wait+0x6a>
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    5552:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    5554:	2b00      	cmp	r3, #0
    5556:	d1fc      	bne.n	5552 <usart_read_wait+0x1a>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Read out the status code and mask away all but the 3 LSBs*/
	error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    5558:	8b53      	ldrh	r3, [r2, #26]
    555a:	b2db      	uxtb	r3, r3

	/* Check if an error has occurred during the receiving */
	if (error_code) {
    555c:	0698      	lsls	r0, r3, #26
    555e:	d01d      	beq.n	559c <usart_read_wait+0x64>
		/* Check which error occurred */
		if (error_code & SERCOM_USART_STATUS_FERR) {
    5560:	0798      	lsls	r0, r3, #30
    5562:	d503      	bpl.n	556c <usart_read_wait+0x34>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    5564:	2302      	movs	r3, #2
    5566:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_FORMAT;
    5568:	3318      	adds	r3, #24
    556a:	e01a      	b.n	55a2 <usart_read_wait+0x6a>
		} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    556c:	0758      	lsls	r0, r3, #29
    556e:	d503      	bpl.n	5578 <usart_read_wait+0x40>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    5570:	2304      	movs	r3, #4
    5572:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_OVERFLOW;
    5574:	331a      	adds	r3, #26
    5576:	e014      	b.n	55a2 <usart_read_wait+0x6a>
		} else if (error_code & SERCOM_USART_STATUS_PERR) {
    5578:	07d8      	lsls	r0, r3, #31
    557a:	d503      	bpl.n	5584 <usart_read_wait+0x4c>
			/* Clear flag by writing a 1 to it and
			 * return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    557c:	2301      	movs	r3, #1
    557e:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_BAD_DATA;
    5580:	3312      	adds	r3, #18
    5582:	e00e      	b.n	55a2 <usart_read_wait+0x6a>
		}
#ifdef FEATURE_USART_LIN_SLAVE
		else if (error_code & SERCOM_USART_STATUS_ISF) {
    5584:	06d8      	lsls	r0, r3, #27
    5586:	d503      	bpl.n	5590 <usart_read_wait+0x58>
			/* Clear flag by writing 1 to it  and
			 *  return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
    5588:	2310      	movs	r3, #16
    558a:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PROTOCOL;
    558c:	3332      	adds	r3, #50	; 0x32
    558e:	e008      	b.n	55a2 <usart_read_wait+0x6a>
		}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
		else if (error_code & SERCOM_USART_STATUS_COLL) {
    5590:	069b      	lsls	r3, r3, #26
    5592:	d503      	bpl.n	559c <usart_read_wait+0x64>
			/* Clear flag by writing 1 to it
			 *  return with an error code */
			usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
    5594:	2320      	movs	r3, #32
    5596:	8353      	strh	r3, [r2, #26]

			return STATUS_ERR_PACKET_COLLISION;
    5598:	3321      	adds	r3, #33	; 0x21
    559a:	e002      	b.n	55a2 <usart_read_wait+0x6a>
		}
#endif
	}

	/* Read data from USART module */
	*rx_data = usart_hw->DATA.reg;
    559c:	8d13      	ldrh	r3, [r2, #40]	; 0x28
    559e:	800b      	strh	r3, [r1, #0]

	return STATUS_OK;
    55a0:	2300      	movs	r3, #0
}
    55a2:	0018      	movs	r0, r3
    55a4:	4770      	bx	lr
    55a6:	46c0      	nop			; (mov r8, r8)

000055a8 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    55a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    55aa:	0080      	lsls	r0, r0, #2
    55ac:	4b60      	ldr	r3, [pc, #384]	; (5730 <_usart_interrupt_handler+0x188>)
    55ae:	58c5      	ldr	r5, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    55b0:	682c      	ldr	r4, [r5, #0]
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    55b2:	69e3      	ldr	r3, [r4, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    55b4:	2b00      	cmp	r3, #0
    55b6:	d1fc      	bne.n	55b2 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    55b8:	7e23      	ldrb	r3, [r4, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    55ba:	7da6      	ldrb	r6, [r4, #22]
    55bc:	401e      	ands	r6, r3
	callback_status = module->callback_reg_mask &
    55be:	2330      	movs	r3, #48	; 0x30
    55c0:	5ceb      	ldrb	r3, [r5, r3]
    55c2:	2231      	movs	r2, #49	; 0x31
    55c4:	5caf      	ldrb	r7, [r5, r2]
    55c6:	401f      	ands	r7, r3
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    55c8:	07f3      	lsls	r3, r6, #31
    55ca:	d522      	bpl.n	5612 <_usart_interrupt_handler+0x6a>
		if (module->remaining_tx_buffer_length) {
    55cc:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    55ce:	b29b      	uxth	r3, r3
    55d0:	2b00      	cmp	r3, #0
    55d2:	d01c      	beq.n	560e <_usart_interrupt_handler+0x66>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    55d4:	6aaa      	ldr	r2, [r5, #40]	; 0x28
    55d6:	7813      	ldrb	r3, [r2, #0]
    55d8:	b2db      	uxtb	r3, r3
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    55da:	1c51      	adds	r1, r2, #1
    55dc:	62a9      	str	r1, [r5, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    55de:	7969      	ldrb	r1, [r5, #5]
    55e0:	2901      	cmp	r1, #1
    55e2:	d001      	beq.n	55e8 <_usart_interrupt_handler+0x40>
	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
		if (module->remaining_tx_buffer_length) {
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    55e4:	b29b      	uxth	r3, r3
    55e6:	e004      	b.n	55f2 <_usart_interrupt_handler+0x4a>
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    55e8:	7851      	ldrb	r1, [r2, #1]
    55ea:	0209      	lsls	r1, r1, #8
    55ec:	430b      	orrs	r3, r1
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
    55ee:	3202      	adds	r2, #2
    55f0:	62aa      	str	r2, [r5, #40]	; 0x28
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    55f2:	05db      	lsls	r3, r3, #23
    55f4:	0ddb      	lsrs	r3, r3, #23
    55f6:	8523      	strh	r3, [r4, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    55f8:	8deb      	ldrh	r3, [r5, #46]	; 0x2e
    55fa:	3b01      	subs	r3, #1
    55fc:	b29b      	uxth	r3, r3
    55fe:	85eb      	strh	r3, [r5, #46]	; 0x2e
    5600:	2b00      	cmp	r3, #0
    5602:	d106      	bne.n	5612 <_usart_interrupt_handler+0x6a>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    5604:	3301      	adds	r3, #1
    5606:	7523      	strb	r3, [r4, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    5608:	3301      	adds	r3, #1
    560a:	75a3      	strb	r3, [r4, #22]
    560c:	e001      	b.n	5612 <_usart_interrupt_handler+0x6a>

			}
		} else {
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    560e:	2301      	movs	r3, #1
    5610:	7523      	strb	r3, [r4, #20]
		}
	}

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    5612:	07b3      	lsls	r3, r6, #30
    5614:	d509      	bpl.n	562a <_usart_interrupt_handler+0x82>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    5616:	2302      	movs	r3, #2
    5618:	7523      	strb	r3, [r4, #20]
		module->tx_status = STATUS_OK;
    561a:	2200      	movs	r2, #0
    561c:	3331      	adds	r3, #49	; 0x31
    561e:	54ea      	strb	r2, [r5, r3]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    5620:	07fb      	lsls	r3, r7, #31
    5622:	d502      	bpl.n	562a <_usart_interrupt_handler+0x82>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    5624:	0028      	movs	r0, r5
    5626:	68eb      	ldr	r3, [r5, #12]
    5628:	4798      	blx	r3
		}
	}

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    562a:	0773      	lsls	r3, r6, #29
    562c:	d560      	bpl.n	56f0 <_usart_interrupt_handler+0x148>

		if (module->remaining_rx_buffer_length) {
    562e:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    5630:	b29b      	uxth	r3, r3
    5632:	2b00      	cmp	r3, #0
    5634:	d05a      	beq.n	56ec <_usart_interrupt_handler+0x144>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    5636:	8b63      	ldrh	r3, [r4, #26]
    5638:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    563a:	071a      	lsls	r2, r3, #28
    563c:	d402      	bmi.n	5644 <_usart_interrupt_handler+0x9c>
	 * there's more data to receive */
	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {

		if (module->remaining_rx_buffer_length) {
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    563e:	223f      	movs	r2, #63	; 0x3f
    5640:	4013      	ands	r3, r2
    5642:	e001      	b.n	5648 <_usart_interrupt_handler+0xa0>
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
				error_code &= ~SERCOM_USART_STATUS_CTS;
    5644:	2237      	movs	r2, #55	; 0x37
    5646:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    5648:	2b00      	cmp	r3, #0
    564a:	d02d      	beq.n	56a8 <_usart_interrupt_handler+0x100>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    564c:	079a      	lsls	r2, r3, #30
    564e:	d505      	bpl.n	565c <_usart_interrupt_handler+0xb4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    5650:	221a      	movs	r2, #26
    5652:	2332      	movs	r3, #50	; 0x32
    5654:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_FERR;
    5656:	3b30      	subs	r3, #48	; 0x30
    5658:	8363      	strh	r3, [r4, #26]
    565a:	e01f      	b.n	569c <_usart_interrupt_handler+0xf4>
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    565c:	075a      	lsls	r2, r3, #29
    565e:	d505      	bpl.n	566c <_usart_interrupt_handler+0xc4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    5660:	221e      	movs	r2, #30
    5662:	2332      	movs	r3, #50	; 0x32
    5664:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_BUFOVF;
    5666:	3b2e      	subs	r3, #46	; 0x2e
    5668:	8363      	strh	r3, [r4, #26]
    566a:	e017      	b.n	569c <_usart_interrupt_handler+0xf4>
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    566c:	07da      	lsls	r2, r3, #31
    566e:	d505      	bpl.n	567c <_usart_interrupt_handler+0xd4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    5670:	2213      	movs	r2, #19
    5672:	2332      	movs	r3, #50	; 0x32
    5674:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_PERR;
    5676:	3b31      	subs	r3, #49	; 0x31
    5678:	8363      	strh	r3, [r4, #26]
    567a:	e00f      	b.n	569c <_usart_interrupt_handler+0xf4>
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    567c:	06da      	lsls	r2, r3, #27
    567e:	d505      	bpl.n	568c <_usart_interrupt_handler+0xe4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    5680:	2242      	movs	r2, #66	; 0x42
    5682:	2332      	movs	r3, #50	; 0x32
    5684:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_ISF;
    5686:	3b22      	subs	r3, #34	; 0x22
    5688:	8363      	strh	r3, [r4, #26]
    568a:	e007      	b.n	569c <_usart_interrupt_handler+0xf4>
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    568c:	2220      	movs	r2, #32
    568e:	421a      	tst	r2, r3
    5690:	d004      	beq.n	569c <_usart_interrupt_handler+0xf4>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    5692:	3221      	adds	r2, #33	; 0x21
    5694:	2332      	movs	r3, #50	; 0x32
    5696:	54ea      	strb	r2, [r5, r3]
					usart_hw->STATUS.reg = SERCOM_USART_STATUS_COLL;
    5698:	3b12      	subs	r3, #18
    569a:	8363      	strh	r3, [r4, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    569c:	077b      	lsls	r3, r7, #29
    569e:	d527      	bpl.n	56f0 <_usart_interrupt_handler+0x148>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    56a0:	0028      	movs	r0, r5
    56a2:	696b      	ldr	r3, [r5, #20]
    56a4:	4798      	blx	r3
    56a6:	e023      	b.n	56f0 <_usart_interrupt_handler+0x148>

			} else {

				/* Read current packet from DATA register,
				 * increment buffer pointer and decrement buffer length */
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    56a8:	8d23      	ldrh	r3, [r4, #40]	; 0x28
    56aa:	05db      	lsls	r3, r3, #23
    56ac:	0ddb      	lsrs	r3, r3, #23

				/* Read value will be at least 8-bits long */
				*(module->rx_buffer_ptr) = received_data;
    56ae:	b2da      	uxtb	r2, r3
    56b0:	6a69      	ldr	r1, [r5, #36]	; 0x24
    56b2:	700a      	strb	r2, [r1, #0]
				/* Increment 8-bit pointer */
				module->rx_buffer_ptr += 1;
    56b4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    56b6:	1c51      	adds	r1, r2, #1
    56b8:	6269      	str	r1, [r5, #36]	; 0x24

				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    56ba:	7969      	ldrb	r1, [r5, #5]
    56bc:	2901      	cmp	r1, #1
    56be:	d104      	bne.n	56ca <_usart_interrupt_handler+0x122>
					/* 9-bit data, write next received byte to the buffer */
					*(module->rx_buffer_ptr) = (received_data >> 8);
    56c0:	0a1b      	lsrs	r3, r3, #8
    56c2:	7053      	strb	r3, [r2, #1]
					/* Increment 8-bit pointer */
					module->rx_buffer_ptr += 1;
    56c4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    56c6:	3301      	adds	r3, #1
    56c8:	626b      	str	r3, [r5, #36]	; 0x24
				}

				/* Check if the last character have been received */
				if(--(module->remaining_rx_buffer_length) == 0) {
    56ca:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
    56cc:	3b01      	subs	r3, #1
    56ce:	b29b      	uxth	r3, r3
    56d0:	85ab      	strh	r3, [r5, #44]	; 0x2c
    56d2:	2b00      	cmp	r3, #0
    56d4:	d10c      	bne.n	56f0 <_usart_interrupt_handler+0x148>
					/* Disable RX Complete Interrupt,
					 * and set STATUS_OK */
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    56d6:	3304      	adds	r3, #4
    56d8:	7523      	strb	r3, [r4, #20]
					module->rx_status = STATUS_OK;
    56da:	2200      	movs	r2, #0
    56dc:	332e      	adds	r3, #46	; 0x2e
    56de:	54ea      	strb	r2, [r5, r3]

					/* Run callback if registered and enabled */
					if (callback_status
    56e0:	07bb      	lsls	r3, r7, #30
    56e2:	d505      	bpl.n	56f0 <_usart_interrupt_handler+0x148>
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    56e4:	0028      	movs	r0, r5
    56e6:	692b      	ldr	r3, [r5, #16]
    56e8:	4798      	blx	r3
    56ea:	e001      	b.n	56f0 <_usart_interrupt_handler+0x148>
					}
				}
			}
		} else {
			/* This should not happen. Disable Receive Complete interrupt. */
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    56ec:	2304      	movs	r3, #4
    56ee:	7523      	strb	r3, [r4, #20]
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    56f0:	06f3      	lsls	r3, r6, #27
    56f2:	d507      	bpl.n	5704 <_usart_interrupt_handler+0x15c>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    56f4:	2310      	movs	r3, #16
    56f6:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    56f8:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    56fa:	06fb      	lsls	r3, r7, #27
    56fc:	d502      	bpl.n	5704 <_usart_interrupt_handler+0x15c>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    56fe:	0028      	movs	r0, r5
    5700:	69eb      	ldr	r3, [r5, #28]
    5702:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    5704:	06b3      	lsls	r3, r6, #26
    5706:	d507      	bpl.n	5718 <_usart_interrupt_handler+0x170>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    5708:	2320      	movs	r3, #32
    570a:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    570c:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    570e:	073b      	lsls	r3, r7, #28
    5710:	d502      	bpl.n	5718 <_usart_interrupt_handler+0x170>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    5712:	0028      	movs	r0, r5
    5714:	69ab      	ldr	r3, [r5, #24]
    5716:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    5718:	0733      	lsls	r3, r6, #28
    571a:	d507      	bpl.n	572c <_usart_interrupt_handler+0x184>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    571c:	2308      	movs	r3, #8
    571e:	7523      	strb	r3, [r4, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    5720:	7623      	strb	r3, [r4, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    5722:	06bb      	lsls	r3, r7, #26
    5724:	d502      	bpl.n	572c <_usart_interrupt_handler+0x184>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    5726:	6a2b      	ldr	r3, [r5, #32]
    5728:	0028      	movs	r0, r5
    572a:	4798      	blx	r3
		}
	}
#endif
}
    572c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    572e:	46c0      	nop			; (mov r8, r8)
    5730:	20000364 	.word	0x20000364

00005734 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    5734:	b510      	push	{r4, lr}
	switch (clock_source) {
    5736:	2808      	cmp	r0, #8
    5738:	d803      	bhi.n	5742 <system_clock_source_get_hz+0xe>
    573a:	0080      	lsls	r0, r0, #2
    573c:	4b1b      	ldr	r3, [pc, #108]	; (57ac <system_clock_source_get_hz+0x78>)
    573e:	581b      	ldr	r3, [r3, r0]
    5740:	469f      	mov	pc, r3

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    5742:	2000      	movs	r0, #0
    5744:	e030      	b.n	57a8 <system_clock_source_get_hz+0x74>
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    5746:	4b1a      	ldr	r3, [pc, #104]	; (57b0 <system_clock_source_get_hz+0x7c>)
    5748:	6918      	ldr	r0, [r3, #16]
    574a:	e02d      	b.n	57a8 <system_clock_source_get_hz+0x74>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    574c:	4b19      	ldr	r3, [pc, #100]	; (57b4 <system_clock_source_get_hz+0x80>)
    574e:	6a1b      	ldr	r3, [r3, #32]
    5750:	059b      	lsls	r3, r3, #22
    5752:	0f9b      	lsrs	r3, r3, #30
    5754:	4818      	ldr	r0, [pc, #96]	; (57b8 <system_clock_source_get_hz+0x84>)
    5756:	40d8      	lsrs	r0, r3
    5758:	e026      	b.n	57a8 <system_clock_source_get_hz+0x74>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    575a:	4b15      	ldr	r3, [pc, #84]	; (57b0 <system_clock_source_get_hz+0x7c>)
    575c:	6958      	ldr	r0, [r3, #20]
    575e:	e023      	b.n	57a8 <system_clock_source_get_hz+0x74>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    5760:	4b13      	ldr	r3, [pc, #76]	; (57b0 <system_clock_source_get_hz+0x7c>)
    5762:	681b      	ldr	r3, [r3, #0]
    5764:	2002      	movs	r0, #2
    5766:	4018      	ands	r0, r3
    5768:	d01e      	beq.n	57a8 <system_clock_source_get_hz+0x74>
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    576a:	4912      	ldr	r1, [pc, #72]	; (57b4 <system_clock_source_get_hz+0x80>)
    576c:	2210      	movs	r2, #16
    576e:	68cb      	ldr	r3, [r1, #12]
    5770:	421a      	tst	r2, r3
    5772:	d0fc      	beq.n	576e <system_clock_source_get_hz+0x3a>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    5774:	4b0e      	ldr	r3, [pc, #56]	; (57b0 <system_clock_source_get_hz+0x7c>)
    5776:	681b      	ldr	r3, [r3, #0]
    5778:	075b      	lsls	r3, r3, #29
    577a:	d514      	bpl.n	57a6 <system_clock_source_get_hz+0x72>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    577c:	2000      	movs	r0, #0
    577e:	4b0f      	ldr	r3, [pc, #60]	; (57bc <system_clock_source_get_hz+0x88>)
    5780:	4798      	blx	r3
					(_system_clock_inst.dfll.mul & 0xffff);
    5782:	4b0b      	ldr	r3, [pc, #44]	; (57b0 <system_clock_source_get_hz+0x7c>)
    5784:	689b      	ldr	r3, [r3, #8]
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    5786:	041b      	lsls	r3, r3, #16
    5788:	0c1b      	lsrs	r3, r3, #16
    578a:	4358      	muls	r0, r3
    578c:	e00c      	b.n	57a8 <system_clock_source_get_hz+0x74>

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    578e:	2350      	movs	r3, #80	; 0x50
    5790:	4a08      	ldr	r2, [pc, #32]	; (57b4 <system_clock_source_get_hz+0x80>)
    5792:	5cd3      	ldrb	r3, [r2, r3]
			return 0;
    5794:	2000      	movs	r0, #0

		return 48000000UL;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    5796:	075b      	lsls	r3, r3, #29
    5798:	d506      	bpl.n	57a8 <system_clock_source_get_hz+0x74>
			return 0;
		}

		return _system_clock_inst.dpll.frequency;
    579a:	4b05      	ldr	r3, [pc, #20]	; (57b0 <system_clock_source_get_hz+0x7c>)
    579c:	68d8      	ldr	r0, [r3, #12]
    579e:	e003      	b.n	57a8 <system_clock_source_get_hz+0x74>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    57a0:	2080      	movs	r0, #128	; 0x80
    57a2:	0200      	lsls	r0, r0, #8
    57a4:	e000      	b.n	57a8 <system_clock_source_get_hz+0x74>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    57a6:	4806      	ldr	r0, [pc, #24]	; (57c0 <system_clock_source_get_hz+0x8c>)
#endif

	default:
		return 0;
	}
}
    57a8:	bd10      	pop	{r4, pc}
    57aa:	46c0      	nop			; (mov r8, r8)
    57ac:	0000ae74 	.word	0x0000ae74
    57b0:	2000014c 	.word	0x2000014c
    57b4:	40000800 	.word	0x40000800
    57b8:	007a1200 	.word	0x007a1200
    57bc:	00005db9 	.word	0x00005db9
    57c0:	02dc6c00 	.word	0x02dc6c00

000057c4 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    57c4:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    57c6:	4c0c      	ldr	r4, [pc, #48]	; (57f8 <system_clock_source_osc8m_set_config+0x34>)
    57c8:	6a23      	ldr	r3, [r4, #32]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    57ca:	7801      	ldrb	r1, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    57cc:	7885      	ldrb	r5, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    57ce:	7842      	ldrb	r2, [r0, #1]
    57d0:	2001      	movs	r0, #1
    57d2:	4002      	ands	r2, r0
    57d4:	0192      	lsls	r2, r2, #6
    57d6:	2640      	movs	r6, #64	; 0x40
    57d8:	43b3      	bics	r3, r6
    57da:	4313      	orrs	r3, r2
    57dc:	0002      	movs	r2, r0
    57de:	402a      	ands	r2, r5
    57e0:	01d2      	lsls	r2, r2, #7
    57e2:	307f      	adds	r0, #127	; 0x7f
    57e4:	4383      	bics	r3, r0
    57e6:	4313      	orrs	r3, r2
    57e8:	2203      	movs	r2, #3
    57ea:	400a      	ands	r2, r1
    57ec:	0212      	lsls	r2, r2, #8
    57ee:	4903      	ldr	r1, [pc, #12]	; (57fc <system_clock_source_osc8m_set_config+0x38>)
    57f0:	400b      	ands	r3, r1
    57f2:	4313      	orrs	r3, r2
    57f4:	6223      	str	r3, [r4, #32]
}
    57f6:	bd70      	pop	{r4, r5, r6, pc}
    57f8:	40000800 	.word	0x40000800
    57fc:	fffffcff 	.word	0xfffffcff

00005800 <system_clock_source_xosc32k_set_config>:
 *
 * \param[in] config  XOSC32K configuration structure containing the new config
 */
void system_clock_source_xosc32k_set_config(
		struct system_clock_source_xosc32k_config *const config)
{
    5800:	b5f0      	push	{r4, r5, r6, r7, lr}
    5802:	465f      	mov	r7, fp
    5804:	4656      	mov	r6, sl
    5806:	464d      	mov	r5, r9
    5808:	4644      	mov	r4, r8
    580a:	b4f0      	push	{r4, r5, r6, r7}
    580c:	b083      	sub	sp, #12
	SYSCTRL_XOSC32K_Type temp = SYSCTRL->XOSC32K;
    580e:	4e2e      	ldr	r6, [pc, #184]	; (58c8 <system_clock_source_xosc32k_set_config+0xc8>)
    5810:	8ab3      	ldrh	r3, [r6, #20]
    5812:	469c      	mov	ip, r3

	temp.bit.STARTUP = config->startup_time;
    5814:	7845      	ldrb	r5, [r0, #1]

	if (config->external_clock == SYSTEM_CLOCK_EXTERNAL_CRYSTAL) {
    5816:	7803      	ldrb	r3, [r0, #0]
    5818:	425a      	negs	r2, r3
    581a:	415a      	adcs	r2, r3
    581c:	4691      	mov	r9, r2
		temp.bit.XTALEN = 1;
	} else {
		temp.bit.XTALEN = 0;
	}

	temp.bit.AAMPEN = config->auto_gain_control;
    581e:	7883      	ldrb	r3, [r0, #2]
    5820:	469b      	mov	fp, r3
	temp.bit.EN1K = config->enable_1khz_output;
    5822:	78c3      	ldrb	r3, [r0, #3]
	temp.bit.EN32K = config->enable_32khz_output;
    5824:	7902      	ldrb	r2, [r0, #4]
    5826:	4690      	mov	r8, r2

	temp.bit.ONDEMAND = config->on_demand;
    5828:	7b47      	ldrb	r7, [r0, #13]
	temp.bit.RUNSTDBY = config->run_in_standby;
    582a:	7b02      	ldrb	r2, [r0, #12]
    582c:	9201      	str	r2, [sp, #4]
	temp.bit.WRTLOCK  = config->write_once;
    582e:	7b84      	ldrb	r4, [r0, #14]

	/* Cache the new frequency in case the user needs to check the current
	 * operating frequency later */
	_system_clock_inst.xosc32k.frequency = config->frequency;
    5830:	6882      	ldr	r2, [r0, #8]
    5832:	4826      	ldr	r0, [pc, #152]	; (58cc <system_clock_source_xosc32k_set_config+0xcc>)
    5834:	6142      	str	r2, [r0, #20]

	SYSCTRL->XOSC32K = temp;
    5836:	2001      	movs	r0, #1
    5838:	464a      	mov	r2, r9
    583a:	0092      	lsls	r2, r2, #2
    583c:	4691      	mov	r9, r2
    583e:	2204      	movs	r2, #4
    5840:	4692      	mov	sl, r2
    5842:	4662      	mov	r2, ip
    5844:	4651      	mov	r1, sl
    5846:	438a      	bics	r2, r1
    5848:	4694      	mov	ip, r2
    584a:	464a      	mov	r2, r9
    584c:	4661      	mov	r1, ip
    584e:	430a      	orrs	r2, r1
    5850:	4694      	mov	ip, r2
    5852:	4642      	mov	r2, r8
    5854:	4002      	ands	r2, r0
    5856:	00d2      	lsls	r2, r2, #3
    5858:	4690      	mov	r8, r2
    585a:	2208      	movs	r2, #8
    585c:	4691      	mov	r9, r2
    585e:	4662      	mov	r2, ip
    5860:	4649      	mov	r1, r9
    5862:	438a      	bics	r2, r1
    5864:	4694      	mov	ip, r2
    5866:	4642      	mov	r2, r8
    5868:	4661      	mov	r1, ip
    586a:	430a      	orrs	r2, r1
    586c:	4694      	mov	ip, r2
    586e:	4003      	ands	r3, r0
    5870:	011b      	lsls	r3, r3, #4
    5872:	2210      	movs	r2, #16
    5874:	4690      	mov	r8, r2
    5876:	4662      	mov	r2, ip
    5878:	4641      	mov	r1, r8
    587a:	438a      	bics	r2, r1
    587c:	4313      	orrs	r3, r2
    587e:	4659      	mov	r1, fp
    5880:	4001      	ands	r1, r0
    5882:	0149      	lsls	r1, r1, #5
    5884:	2220      	movs	r2, #32
    5886:	4393      	bics	r3, r2
    5888:	430b      	orrs	r3, r1
    588a:	9a01      	ldr	r2, [sp, #4]
    588c:	4002      	ands	r2, r0
    588e:	0192      	lsls	r2, r2, #6
    5890:	2140      	movs	r1, #64	; 0x40
    5892:	438b      	bics	r3, r1
    5894:	4313      	orrs	r3, r2
    5896:	4007      	ands	r7, r0
    5898:	01ff      	lsls	r7, r7, #7
    589a:	2280      	movs	r2, #128	; 0x80
    589c:	4393      	bics	r3, r2
    589e:	433b      	orrs	r3, r7
    58a0:	3a79      	subs	r2, #121	; 0x79
    58a2:	4015      	ands	r5, r2
    58a4:	022d      	lsls	r5, r5, #8
    58a6:	4f0a      	ldr	r7, [pc, #40]	; (58d0 <system_clock_source_xosc32k_set_config+0xd0>)
    58a8:	403b      	ands	r3, r7
    58aa:	432b      	orrs	r3, r5
    58ac:	4004      	ands	r4, r0
    58ae:	0320      	lsls	r0, r4, #12
    58b0:	4c08      	ldr	r4, [pc, #32]	; (58d4 <system_clock_source_xosc32k_set_config+0xd4>)
    58b2:	401c      	ands	r4, r3
    58b4:	4304      	orrs	r4, r0
    58b6:	82b4      	strh	r4, [r6, #20]
}
    58b8:	b003      	add	sp, #12
    58ba:	bc3c      	pop	{r2, r3, r4, r5}
    58bc:	4690      	mov	r8, r2
    58be:	4699      	mov	r9, r3
    58c0:	46a2      	mov	sl, r4
    58c2:	46ab      	mov	fp, r5
    58c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    58c6:	46c0      	nop			; (mov r8, r8)
    58c8:	40000800 	.word	0x40000800
    58cc:	2000014c 	.word	0x2000014c
    58d0:	fffff8ff 	.word	0xfffff8ff
    58d4:	ffffefff 	.word	0xffffefff

000058d8 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    58d8:	b510      	push	{r4, lr}
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
    58da:	7a03      	ldrb	r3, [r0, #8]
    58dc:	069b      	lsls	r3, r3, #26
    58de:	0c1a      	lsrs	r2, r3, #16
    58e0:	8943      	ldrh	r3, [r0, #10]
    58e2:	059b      	lsls	r3, r3, #22
    58e4:	0d9b      	lsrs	r3, r3, #22
    58e6:	4313      	orrs	r3, r2
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
	_system_clock_inst.dfll.val =
    58e8:	4c19      	ldr	r4, [pc, #100]	; (5950 <system_clock_source_dfll_set_config+0x78>)
    58ea:	6063      	str	r3, [r4, #4]

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    58ec:	7981      	ldrb	r1, [r0, #6]
    58ee:	79c3      	ldrb	r3, [r0, #7]
    58f0:	4319      	orrs	r1, r3
    58f2:	8843      	ldrh	r3, [r0, #2]
    58f4:	8882      	ldrh	r2, [r0, #4]
    58f6:	4313      	orrs	r3, r2
    58f8:	430b      	orrs	r3, r1
    58fa:	7842      	ldrb	r2, [r0, #1]
    58fc:	01d2      	lsls	r2, r2, #7
    58fe:	4313      	orrs	r3, r2
{
	_system_clock_inst.dfll.val =
			SYSCTRL_DFLLVAL_COARSE(config->coarse_value) |
			SYSCTRL_DFLLVAL_FINE(config->fine_value);

	_system_clock_inst.dfll.control =
    5900:	6023      	str	r3, [r4, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    5902:	7803      	ldrb	r3, [r0, #0]
    5904:	2b04      	cmp	r3, #4
    5906:	d10f      	bne.n	5928 <system_clock_source_dfll_set_config+0x50>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    5908:	7b03      	ldrb	r3, [r0, #12]
    590a:	069b      	lsls	r3, r3, #26
    590c:	8a02      	ldrh	r2, [r0, #16]
    590e:	4313      	orrs	r3, r2
    5910:	0019      	movs	r1, r3
    5912:	89c3      	ldrh	r3, [r0, #14]
    5914:	041b      	lsls	r3, r3, #16
    5916:	4a0f      	ldr	r2, [pc, #60]	; (5954 <system_clock_source_dfll_set_config+0x7c>)
    5918:	4013      	ands	r3, r2
    591a:	430b      	orrs	r3, r1
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		_system_clock_inst.dfll.mul =
    591c:	60a3      	str	r3, [r4, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    591e:	6821      	ldr	r1, [r4, #0]
    5920:	2304      	movs	r3, #4
    5922:	430b      	orrs	r3, r1
    5924:	6023      	str	r3, [r4, #0]
    5926:	e011      	b.n	594c <system_clock_source_dfll_set_config+0x74>
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {
    5928:	2b20      	cmp	r3, #32
    592a:	d10f      	bne.n	594c <system_clock_source_dfll_set_config+0x74>

		_system_clock_inst.dfll.mul =
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
    592c:	7b03      	ldrb	r3, [r0, #12]
    592e:	069b      	lsls	r3, r3, #26
    5930:	8a02      	ldrh	r2, [r0, #16]
    5932:	4313      	orrs	r3, r2
    5934:	0019      	movs	r1, r3
    5936:	89c3      	ldrh	r3, [r0, #14]
    5938:	041b      	lsls	r3, r3, #16
    593a:	4a06      	ldr	r2, [pc, #24]	; (5954 <system_clock_source_dfll_set_config+0x7c>)
    593c:	4013      	ands	r3, r2
    593e:	430b      	orrs	r3, r1
		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
	}
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_USB_RECOVERY) {

		_system_clock_inst.dfll.mul =
    5940:	4a03      	ldr	r2, [pc, #12]	; (5950 <system_clock_source_dfll_set_config+0x78>)
    5942:	6093      	str	r3, [r2, #8]
				SYSCTRL_DFLLMUL_CSTEP(config->coarse_max_step) |
				SYSCTRL_DFLLMUL_FSTEP(config->fine_max_step)   |
				SYSCTRL_DFLLMUL_MUL(config->multiply_factor);

		/* Enable the USB recovery mode */
		_system_clock_inst.dfll.control |= config->loop_mode |
    5944:	6813      	ldr	r3, [r2, #0]
    5946:	4904      	ldr	r1, [pc, #16]	; (5958 <system_clock_source_dfll_set_config+0x80>)
    5948:	430b      	orrs	r3, r1
    594a:	6013      	str	r3, [r2, #0]
				SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_BPLCKC;
	}
}
    594c:	bd10      	pop	{r4, pc}
    594e:	46c0      	nop			; (mov r8, r8)
    5950:	2000014c 	.word	0x2000014c
    5954:	03ff0000 	.word	0x03ff0000
    5958:	00000424 	.word	0x00000424

0000595c <system_clock_source_enable>:
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
    595c:	2808      	cmp	r0, #8
    595e:	d803      	bhi.n	5968 <system_clock_source_enable+0xc>
    5960:	0080      	lsls	r0, r0, #2
    5962:	4b25      	ldr	r3, [pc, #148]	; (59f8 <system_clock_source_enable+0x9c>)
    5964:	581b      	ldr	r3, [r3, r0]
    5966:	469f      	mov	pc, r3
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    5968:	2017      	movs	r0, #23
    596a:	e044      	b.n	59f6 <system_clock_source_enable+0x9a>
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
	switch (clock_source) {
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    596c:	4a23      	ldr	r2, [pc, #140]	; (59fc <system_clock_source_enable+0xa0>)
    596e:	6a11      	ldr	r1, [r2, #32]
    5970:	2302      	movs	r3, #2
    5972:	430b      	orrs	r3, r1
    5974:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    5976:	2000      	movs	r0, #0
    5978:	e03d      	b.n	59f6 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    597a:	4a20      	ldr	r2, [pc, #128]	; (59fc <system_clock_source_enable+0xa0>)
    597c:	6991      	ldr	r1, [r2, #24]
    597e:	2302      	movs	r3, #2
    5980:	430b      	orrs	r3, r1
    5982:	6193      	str	r3, [r2, #24]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5984:	2000      	movs	r0, #0
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
		return STATUS_OK;

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;
    5986:	e036      	b.n	59f6 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    5988:	4a1c      	ldr	r2, [pc, #112]	; (59fc <system_clock_source_enable+0xa0>)
    598a:	8a11      	ldrh	r1, [r2, #16]
    598c:	2302      	movs	r3, #2
    598e:	430b      	orrs	r3, r1
    5990:	8213      	strh	r3, [r2, #16]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    5992:	2000      	movs	r0, #0
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;
    5994:	e02f      	b.n	59f6 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    5996:	4a19      	ldr	r2, [pc, #100]	; (59fc <system_clock_source_enable+0xa0>)
    5998:	8a91      	ldrh	r1, [r2, #20]
    599a:	2302      	movs	r3, #2
    599c:	430b      	orrs	r3, r1
    599e:	8293      	strh	r3, [r2, #20]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    59a0:	2000      	movs	r0, #0
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
		break;

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
		break;
    59a2:	e028      	b.n	59f6 <system_clock_source_enable+0x9a>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    59a4:	4916      	ldr	r1, [pc, #88]	; (5a00 <system_clock_source_enable+0xa4>)
    59a6:	680b      	ldr	r3, [r1, #0]
    59a8:	2202      	movs	r2, #2
    59aa:	4313      	orrs	r3, r2
    59ac:	600b      	str	r3, [r1, #0]

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    59ae:	4b13      	ldr	r3, [pc, #76]	; (59fc <system_clock_source_enable+0xa0>)
    59b0:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    59b2:	0019      	movs	r1, r3
    59b4:	320e      	adds	r2, #14
    59b6:	68cb      	ldr	r3, [r1, #12]
    59b8:	421a      	tst	r2, r3
    59ba:	d0fc      	beq.n	59b6 <system_clock_source_enable+0x5a>

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
	_system_dfll_wait_for_sync();

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    59bc:	4a10      	ldr	r2, [pc, #64]	; (5a00 <system_clock_source_enable+0xa4>)
    59be:	6891      	ldr	r1, [r2, #8]
    59c0:	4b0e      	ldr	r3, [pc, #56]	; (59fc <system_clock_source_enable+0xa0>)
    59c2:	62d9      	str	r1, [r3, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    59c4:	6852      	ldr	r2, [r2, #4]
    59c6:	629a      	str	r2, [r3, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
    59c8:	2200      	movs	r2, #0
    59ca:	849a      	strh	r2, [r3, #36]	; 0x24
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    59cc:	0019      	movs	r1, r3
    59ce:	3210      	adds	r2, #16
    59d0:	68cb      	ldr	r3, [r1, #12]
    59d2:	421a      	tst	r2, r3
    59d4:	d0fc      	beq.n	59d0 <system_clock_source_enable+0x74>
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = 0;
	_system_dfll_wait_for_sync();
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    59d6:	4b0a      	ldr	r3, [pc, #40]	; (5a00 <system_clock_source_enable+0xa4>)
    59d8:	681b      	ldr	r3, [r3, #0]
    59da:	b29b      	uxth	r3, r3
    59dc:	4a07      	ldr	r2, [pc, #28]	; (59fc <system_clock_source_enable+0xa0>)
    59de:	8493      	strh	r3, [r2, #36]	; 0x24
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    59e0:	2000      	movs	r0, #0
    59e2:	e008      	b.n	59f6 <system_clock_source_enable+0x9a>
		_system_clock_source_dfll_set_config_errata_9905();
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    59e4:	4905      	ldr	r1, [pc, #20]	; (59fc <system_clock_source_enable+0xa0>)
    59e6:	2244      	movs	r2, #68	; 0x44
    59e8:	5c88      	ldrb	r0, [r1, r2]
    59ea:	2302      	movs	r3, #2
    59ec:	4303      	orrs	r3, r0
    59ee:	548b      	strb	r3, [r1, r2]
	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    59f0:	2000      	movs	r0, #0
		break;

#ifdef FEATURE_SYSTEM_CLOCK_DPLL
	case SYSTEM_CLOCK_SOURCE_DPLL:
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
		break;
    59f2:	e000      	b.n	59f6 <system_clock_source_enable+0x9a>
#endif

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    59f4:	2000      	movs	r0, #0
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
}
    59f6:	4770      	bx	lr
    59f8:	0000ae98 	.word	0x0000ae98
    59fc:	40000800 	.word	0x40000800
    5a00:	2000014c 	.word	0x2000014c

00005a04 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    5a04:	b5f0      	push	{r4, r5, r6, r7, lr}
    5a06:	b08f      	sub	sp, #60	; 0x3c
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    5a08:	22c2      	movs	r2, #194	; 0xc2
    5a0a:	00d2      	lsls	r2, r2, #3
    5a0c:	4b47      	ldr	r3, [pc, #284]	; (5b2c <system_clock_init+0x128>)
    5a0e:	609a      	str	r2, [r3, #8]
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    5a10:	4947      	ldr	r1, [pc, #284]	; (5b30 <system_clock_init+0x12c>)
    5a12:	684b      	ldr	r3, [r1, #4]
    5a14:	221e      	movs	r2, #30
    5a16:	4393      	bics	r3, r2
    5a18:	3a1a      	subs	r2, #26
    5a1a:	4313      	orrs	r3, r2
    5a1c:	604b      	str	r3, [r1, #4]
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    5a1e:	3a02      	subs	r2, #2
    5a20:	ab01      	add	r3, sp, #4
    5a22:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    5a24:	2400      	movs	r4, #0
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    5a26:	4d43      	ldr	r5, [pc, #268]	; (5b34 <system_clock_init+0x130>)
    5a28:	b2e0      	uxtb	r0, r4
    5a2a:	a901      	add	r1, sp, #4
    5a2c:	47a8      	blx	r5
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    5a2e:	3401      	adds	r4, #1
    5a30:	2c25      	cmp	r4, #37	; 0x25
    5a32:	d1f9      	bne.n	5a28 <system_clock_init+0x24>
static inline void system_clock_source_xosc32k_get_config_defaults(
		struct system_clock_source_xosc32k_config *const config)
{
	Assert(config);

	config->external_clock      = SYSTEM_CLOCK_EXTERNAL_CRYSTAL;
    5a34:	a80a      	add	r0, sp, #40	; 0x28
    5a36:	2300      	movs	r3, #0
    5a38:	7003      	strb	r3, [r0, #0]
	config->startup_time        = SYSTEM_XOSC32K_STARTUP_16384;
	config->auto_gain_control   = false;
    5a3a:	7083      	strb	r3, [r0, #2]
	config->frequency           = 32768UL;
    5a3c:	2280      	movs	r2, #128	; 0x80
    5a3e:	0212      	lsls	r2, r2, #8
    5a40:	6082      	str	r2, [r0, #8]
	config->enable_1khz_output  = false;
    5a42:	70c3      	strb	r3, [r0, #3]
	config->enable_32khz_output = true;
    5a44:	2201      	movs	r2, #1
    5a46:	7102      	strb	r2, [r0, #4]
	config->run_in_standby      = false;
    5a48:	7303      	strb	r3, [r0, #12]
	config->on_demand           = true;
	config->write_once          = false;
    5a4a:	7383      	strb	r3, [r0, #14]
	struct system_clock_source_xosc32k_config xosc32k_conf;
	system_clock_source_xosc32k_get_config_defaults(&xosc32k_conf);

	xosc32k_conf.frequency           = 32768UL;
	xosc32k_conf.external_clock      = CONF_CLOCK_XOSC32K_EXTERNAL_CRYSTAL;
	xosc32k_conf.startup_time        = CONF_CLOCK_XOSC32K_STARTUP_TIME;
    5a4c:	3202      	adds	r2, #2
    5a4e:	7042      	strb	r2, [r0, #1]
	xosc32k_conf.auto_gain_control   = CONF_CLOCK_XOSC32K_AUTO_AMPLITUDE_CONTROL;
	xosc32k_conf.enable_1khz_output  = CONF_CLOCK_XOSC32K_ENABLE_1KHZ_OUPUT;
	xosc32k_conf.enable_32khz_output = CONF_CLOCK_XOSC32K_ENABLE_32KHZ_OUTPUT;
	xosc32k_conf.on_demand           = false;
    5a50:	7343      	strb	r3, [r0, #13]
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
    5a52:	4b39      	ldr	r3, [pc, #228]	; (5b38 <system_clock_init+0x134>)
    5a54:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
    5a56:	2005      	movs	r0, #5
    5a58:	4b38      	ldr	r3, [pc, #224]	; (5b3c <system_clock_init+0x138>)
    5a5a:	4798      	blx	r3

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    5a5c:	4933      	ldr	r1, [pc, #204]	; (5b2c <system_clock_init+0x128>)
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    5a5e:	2202      	movs	r2, #2

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    5a60:	68cb      	ldr	r3, [r1, #12]
	xosc32k_conf.on_demand           = false;
	xosc32k_conf.run_in_standby      = CONF_CLOCK_XOSC32K_RUN_IN_STANDBY;

	system_clock_source_xosc32k_set_config(&xosc32k_conf);
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_XOSC32K);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_XOSC32K));
    5a62:	421a      	tst	r2, r3
    5a64:	d0fc      	beq.n	5a60 <system_clock_init+0x5c>
	if (CONF_CLOCK_XOSC32K_ON_DEMAND) {
		SYSCTRL->XOSC32K.bit.ONDEMAND = 1;
    5a66:	4a31      	ldr	r2, [pc, #196]	; (5b2c <system_clock_init+0x128>)
    5a68:	8a91      	ldrh	r1, [r2, #20]
    5a6a:	2380      	movs	r3, #128	; 0x80
    5a6c:	430b      	orrs	r3, r1
    5a6e:	8293      	strh	r3, [r2, #20]
		struct system_clock_source_dfll_config *const config)
{
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    5a70:	ab05      	add	r3, sp, #20
    5a72:	2100      	movs	r1, #0
    5a74:	2200      	movs	r2, #0
    5a76:	8059      	strh	r1, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    5a78:	8099      	strh	r1, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    5a7a:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    5a7c:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
	config->fine_value      = 0xff / 4; /* Midpoint */
    5a7e:	313f      	adds	r1, #63	; 0x3f
    5a80:	8159      	strh	r1, [r3, #10]
	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    5a82:	393b      	subs	r1, #59	; 0x3b
    5a84:	7019      	strb	r1, [r3, #0]
	dfll_conf.on_demand      = false;
    5a86:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping 
	   in DFLL.COARSE helps to output a frequency close to 48 MHz.*/
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

	uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    5a88:	4b2d      	ldr	r3, [pc, #180]	; (5b40 <system_clock_init+0x13c>)
    5a8a:	681b      	ldr	r3, [r3, #0]
    5a8c:	0e9b      	lsrs	r3, r3, #26
			+ (NVM_DFLL_COARSE_POS / 32))
		>> (NVM_DFLL_COARSE_POS % 32))
		& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
	/* In some revision chip, the coarse calibration value is not correct. */
	if (coarse == 0x3f) {
    5a8e:	2b3f      	cmp	r3, #63	; 0x3f
    5a90:	d100      	bne.n	5a94 <system_clock_init+0x90>
		coarse = 0x1f;
    5a92:	3b20      	subs	r3, #32
	}
	dfll_conf.coarse_value = coarse;
    5a94:	a805      	add	r0, sp, #20
    5a96:	7203      	strb	r3, [r0, #8]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    5a98:	4b2a      	ldr	r3, [pc, #168]	; (5b44 <system_clock_init+0x140>)
    5a9a:	8203      	strh	r3, [r0, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    5a9c:	2307      	movs	r3, #7
    5a9e:	7303      	strb	r3, [r0, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    5aa0:	3338      	adds	r3, #56	; 0x38
    5aa2:	81c3      	strh	r3, [r0, #14]
		dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;

		dfll_conf.multiply_factor = 48000;
	}

	system_clock_source_dfll_set_config(&dfll_conf);
    5aa4:	4b28      	ldr	r3, [pc, #160]	; (5b48 <system_clock_init+0x144>)
    5aa6:	4798      	blx	r3
		struct system_clock_source_osc8m_config *const config)
{
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
	config->run_in_standby  = false;
    5aa8:	a804      	add	r0, sp, #16
    5aaa:	2500      	movs	r5, #0
    5aac:	7045      	strb	r5, [r0, #1]
	config->on_demand       = true;
    5aae:	2601      	movs	r6, #1
    5ab0:	7086      	strb	r6, [r0, #2]

	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    5ab2:	7005      	strb	r5, [r0, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    5ab4:	4b25      	ldr	r3, [pc, #148]	; (5b4c <system_clock_init+0x148>)
    5ab6:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    5ab8:	2006      	movs	r0, #6
    5aba:	4f20      	ldr	r7, [pc, #128]	; (5b3c <system_clock_init+0x138>)
    5abc:	47b8      	blx	r7


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    5abe:	4b24      	ldr	r3, [pc, #144]	; (5b50 <system_clock_init+0x14c>)
    5ac0:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    5ac2:	ac01      	add	r4, sp, #4
    5ac4:	9602      	str	r6, [sp, #8]
	config->high_when_disabled = false;
    5ac6:	7065      	strb	r5, [r4, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    5ac8:	7225      	strb	r5, [r4, #8]
	config->output_enable      = false;
    5aca:	7265      	strb	r5, [r4, #9]

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    5acc:	2305      	movs	r3, #5
    5ace:	7023      	strb	r3, [r4, #0]
    5ad0:	0021      	movs	r1, r4
    5ad2:	2001      	movs	r0, #1
    5ad4:	4b1f      	ldr	r3, [pc, #124]	; (5b54 <system_clock_init+0x150>)
    5ad6:	4798      	blx	r3
    5ad8:	2001      	movs	r0, #1
    5ada:	4b1f      	ldr	r3, [pc, #124]	; (5b58 <system_clock_init+0x154>)
    5adc:	4798      	blx	r3
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    5ade:	7026      	strb	r6, [r4, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    5ae0:	0021      	movs	r1, r4
    5ae2:	2000      	movs	r0, #0
    5ae4:	4b13      	ldr	r3, [pc, #76]	; (5b34 <system_clock_init+0x130>)
    5ae6:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    5ae8:	2000      	movs	r0, #0
    5aea:	4b1c      	ldr	r3, [pc, #112]	; (5b5c <system_clock_init+0x158>)
    5aec:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    5aee:	2007      	movs	r0, #7
    5af0:	47b8      	blx	r7

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    5af2:	490e      	ldr	r1, [pc, #56]	; (5b2c <system_clock_init+0x128>)


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    5af4:	22d0      	movs	r2, #208	; 0xd0

	default:
		return false;
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    5af6:	68cb      	ldr	r3, [r1, #12]


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    5af8:	4013      	ands	r3, r2
    5afa:	2bd0      	cmp	r3, #208	; 0xd0
    5afc:	d1fb      	bne.n	5af6 <system_clock_init+0xf2>
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    5afe:	4a18      	ldr	r2, [pc, #96]	; (5b60 <system_clock_init+0x15c>)
    5b00:	2300      	movs	r3, #0
    5b02:	7213      	strb	r3, [r2, #8]
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    5b04:	7253      	strb	r3, [r2, #9]
			break;
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    5b06:	7293      	strb	r3, [r2, #10]
			break;
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    5b08:	72d3      	strb	r3, [r2, #11]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    5b0a:	a901      	add	r1, sp, #4
    5b0c:	2201      	movs	r2, #1
    5b0e:	604a      	str	r2, [r1, #4]
	config->high_when_disabled = false;
    5b10:	704b      	strb	r3, [r1, #1]
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
#endif
	config->run_in_standby     = false;
    5b12:	720b      	strb	r3, [r1, #8]
	config->output_enable      = false;
    5b14:	724b      	strb	r3, [r1, #9]
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    5b16:	3307      	adds	r3, #7
    5b18:	700b      	strb	r3, [r1, #0]
    5b1a:	2000      	movs	r0, #0
    5b1c:	4b0d      	ldr	r3, [pc, #52]	; (5b54 <system_clock_init+0x150>)
    5b1e:	4798      	blx	r3
    5b20:	2000      	movs	r0, #0
    5b22:	4b0d      	ldr	r3, [pc, #52]	; (5b58 <system_clock_init+0x154>)
    5b24:	4798      	blx	r3
#endif
}
    5b26:	b00f      	add	sp, #60	; 0x3c
    5b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5b2a:	46c0      	nop			; (mov r8, r8)
    5b2c:	40000800 	.word	0x40000800
    5b30:	41004000 	.word	0x41004000
    5b34:	00005d9d 	.word	0x00005d9d
    5b38:	00005801 	.word	0x00005801
    5b3c:	0000595d 	.word	0x0000595d
    5b40:	00806024 	.word	0x00806024
    5b44:	000005b9 	.word	0x000005b9
    5b48:	000058d9 	.word	0x000058d9
    5b4c:	000057c5 	.word	0x000057c5
    5b50:	00005b65 	.word	0x00005b65
    5b54:	00005b89 	.word	0x00005b89
    5b58:	00005c41 	.word	0x00005c41
    5b5c:	00005d11 	.word	0x00005d11
    5b60:	40000400 	.word	0x40000400

00005b64 <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    5b64:	4a06      	ldr	r2, [pc, #24]	; (5b80 <system_gclk_init+0x1c>)
    5b66:	6991      	ldr	r1, [r2, #24]
    5b68:	2308      	movs	r3, #8
    5b6a:	430b      	orrs	r3, r1
    5b6c:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    5b6e:	2201      	movs	r2, #1
    5b70:	4b04      	ldr	r3, [pc, #16]	; (5b84 <system_gclk_init+0x20>)
    5b72:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    5b74:	0019      	movs	r1, r3
    5b76:	780b      	ldrb	r3, [r1, #0]
    5b78:	4213      	tst	r3, r2
    5b7a:	d1fc      	bne.n	5b76 <system_gclk_init+0x12>
		/* Wait for reset to complete */
	}
}
    5b7c:	4770      	bx	lr
    5b7e:	46c0      	nop			; (mov r8, r8)
    5b80:	40000400 	.word	0x40000400
    5b84:	40000c00 	.word	0x40000c00

00005b88 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    5b88:	b570      	push	{r4, r5, r6, lr}
    5b8a:	0006      	movs	r6, r0
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    5b8c:	0005      	movs	r5, r0
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    5b8e:	780c      	ldrb	r4, [r1, #0]
    5b90:	0224      	lsls	r4, r4, #8
    5b92:	4304      	orrs	r4, r0

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    5b94:	784b      	ldrb	r3, [r1, #1]
    5b96:	2b00      	cmp	r3, #0
    5b98:	d002      	beq.n	5ba0 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    5b9a:	2380      	movs	r3, #128	; 0x80
    5b9c:	02db      	lsls	r3, r3, #11
    5b9e:	431c      	orrs	r4, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    5ba0:	7a4b      	ldrb	r3, [r1, #9]
    5ba2:	2b00      	cmp	r3, #0
    5ba4:	d002      	beq.n	5bac <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    5ba6:	2380      	movs	r3, #128	; 0x80
    5ba8:	031b      	lsls	r3, r3, #12
    5baa:	431c      	orrs	r4, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    5bac:	6848      	ldr	r0, [r1, #4]
    5bae:	2801      	cmp	r0, #1
    5bb0:	d918      	bls.n	5be4 <system_gclk_gen_set_config+0x5c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    5bb2:	1e43      	subs	r3, r0, #1
    5bb4:	4218      	tst	r0, r3
    5bb6:	d110      	bne.n	5bda <system_gclk_gen_set_config+0x52>
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    5bb8:	2802      	cmp	r0, #2
    5bba:	d906      	bls.n	5bca <system_gclk_gen_set_config+0x42>
    5bbc:	2302      	movs	r3, #2
    5bbe:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
    5bc0:	3201      	adds	r2, #1

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    5bc2:	005b      	lsls	r3, r3, #1
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    5bc4:	4298      	cmp	r0, r3
    5bc6:	d8fb      	bhi.n	5bc0 <system_gclk_gen_set_config+0x38>
    5bc8:	e000      	b.n	5bcc <system_gclk_gen_set_config+0x44>
    5bca:	2200      	movs	r2, #0
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    5bcc:	0212      	lsls	r2, r2, #8
    5bce:	4332      	orrs	r2, r6
    5bd0:	0015      	movs	r5, r2
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    5bd2:	2380      	movs	r3, #128	; 0x80
    5bd4:	035b      	lsls	r3, r3, #13
    5bd6:	431c      	orrs	r4, r3
    5bd8:	e004      	b.n	5be4 <system_gclk_gen_set_config+0x5c>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    5bda:	0205      	lsls	r5, r0, #8
    5bdc:	4335      	orrs	r5, r6
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    5bde:	2380      	movs	r3, #128	; 0x80
    5be0:	029b      	lsls	r3, r3, #10
    5be2:	431c      	orrs	r4, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    5be4:	7a0b      	ldrb	r3, [r1, #8]
    5be6:	2b00      	cmp	r3, #0
    5be8:	d002      	beq.n	5bf0 <system_gclk_gen_set_config+0x68>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    5bea:	2380      	movs	r3, #128	; 0x80
    5bec:	039b      	lsls	r3, r3, #14
    5bee:	431c      	orrs	r4, r3
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5bf0:	4a0f      	ldr	r2, [pc, #60]	; (5c30 <system_gclk_gen_set_config+0xa8>)
    5bf2:	7853      	ldrb	r3, [r2, #1]
	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
	}

	while (system_gclk_is_syncing()) {
    5bf4:	b25b      	sxtb	r3, r3
    5bf6:	2b00      	cmp	r3, #0
    5bf8:	dbfb      	blt.n	5bf2 <system_gclk_gen_set_config+0x6a>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5bfa:	4b0e      	ldr	r3, [pc, #56]	; (5c34 <system_gclk_gen_set_config+0xac>)
    5bfc:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    5bfe:	4b0e      	ldr	r3, [pc, #56]	; (5c38 <system_gclk_gen_set_config+0xb0>)
    5c00:	701e      	strb	r6, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c02:	4a0b      	ldr	r2, [pc, #44]	; (5c30 <system_gclk_gen_set_config+0xa8>)
    5c04:	7853      	ldrb	r3, [r2, #1]

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    5c06:	b25b      	sxtb	r3, r3
    5c08:	2b00      	cmp	r3, #0
    5c0a:	dbfb      	blt.n	5c04 <system_gclk_gen_set_config+0x7c>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    5c0c:	4b08      	ldr	r3, [pc, #32]	; (5c30 <system_gclk_gen_set_config+0xa8>)
    5c0e:	609d      	str	r5, [r3, #8]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c10:	001a      	movs	r2, r3
    5c12:	7853      	ldrb	r3, [r2, #1]
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;

	while (system_gclk_is_syncing()) {
    5c14:	b25b      	sxtb	r3, r3
    5c16:	2b00      	cmp	r3, #0
    5c18:	dbfb      	blt.n	5c12 <system_gclk_gen_set_config+0x8a>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    5c1a:	4a05      	ldr	r2, [pc, #20]	; (5c30 <system_gclk_gen_set_config+0xa8>)
    5c1c:	6851      	ldr	r1, [r2, #4]
    5c1e:	2380      	movs	r3, #128	; 0x80
    5c20:	025b      	lsls	r3, r3, #9
    5c22:	400b      	ands	r3, r1
    5c24:	431c      	orrs	r4, r3
    5c26:	6054      	str	r4, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5c28:	4b04      	ldr	r3, [pc, #16]	; (5c3c <system_gclk_gen_set_config+0xb4>)
    5c2a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5c2c:	bd70      	pop	{r4, r5, r6, pc}
    5c2e:	46c0      	nop			; (mov r8, r8)
    5c30:	40000c00 	.word	0x40000c00
    5c34:	00004371 	.word	0x00004371
    5c38:	40000c08 	.word	0x40000c08
    5c3c:	000043b1 	.word	0x000043b1

00005c40 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    5c40:	b510      	push	{r4, lr}
    5c42:	0004      	movs	r4, r0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c44:	4a0b      	ldr	r2, [pc, #44]	; (5c74 <system_gclk_gen_enable+0x34>)
    5c46:	7853      	ldrb	r3, [r2, #1]
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    5c48:	b25b      	sxtb	r3, r3
    5c4a:	2b00      	cmp	r3, #0
    5c4c:	dbfb      	blt.n	5c46 <system_gclk_gen_enable+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5c4e:	4b0a      	ldr	r3, [pc, #40]	; (5c78 <system_gclk_gen_enable+0x38>)
    5c50:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    5c52:	4b0a      	ldr	r3, [pc, #40]	; (5c7c <system_gclk_gen_enable+0x3c>)
    5c54:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c56:	4a07      	ldr	r2, [pc, #28]	; (5c74 <system_gclk_gen_enable+0x34>)
    5c58:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    5c5a:	b25b      	sxtb	r3, r3
    5c5c:	2b00      	cmp	r3, #0
    5c5e:	dbfb      	blt.n	5c58 <system_gclk_gen_enable+0x18>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    5c60:	4a04      	ldr	r2, [pc, #16]	; (5c74 <system_gclk_gen_enable+0x34>)
    5c62:	6853      	ldr	r3, [r2, #4]
    5c64:	2180      	movs	r1, #128	; 0x80
    5c66:	0249      	lsls	r1, r1, #9
    5c68:	430b      	orrs	r3, r1
    5c6a:	6053      	str	r3, [r2, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5c6c:	4b04      	ldr	r3, [pc, #16]	; (5c80 <system_gclk_gen_enable+0x40>)
    5c6e:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5c70:	bd10      	pop	{r4, pc}
    5c72:	46c0      	nop			; (mov r8, r8)
    5c74:	40000c00 	.word	0x40000c00
    5c78:	00004371 	.word	0x00004371
    5c7c:	40000c04 	.word	0x40000c04
    5c80:	000043b1 	.word	0x000043b1

00005c84 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    5c84:	b570      	push	{r4, r5, r6, lr}
    5c86:	0004      	movs	r4, r0
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c88:	4a1a      	ldr	r2, [pc, #104]	; (5cf4 <system_gclk_gen_get_hz+0x70>)
    5c8a:	7853      	ldrb	r3, [r2, #1]
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
	while (system_gclk_is_syncing()) {
    5c8c:	b25b      	sxtb	r3, r3
    5c8e:	2b00      	cmp	r3, #0
    5c90:	dbfb      	blt.n	5c8a <system_gclk_gen_get_hz+0x6>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5c92:	4b19      	ldr	r3, [pc, #100]	; (5cf8 <system_gclk_gen_get_hz+0x74>)
    5c94:	4798      	blx	r3
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    5c96:	4b19      	ldr	r3, [pc, #100]	; (5cfc <system_gclk_gen_get_hz+0x78>)
    5c98:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5c9a:	4a16      	ldr	r2, [pc, #88]	; (5cf4 <system_gclk_gen_get_hz+0x70>)
    5c9c:	7853      	ldrb	r3, [r2, #1]

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
	while (system_gclk_is_syncing()) {
    5c9e:	b25b      	sxtb	r3, r3
    5ca0:	2b00      	cmp	r3, #0
    5ca2:	dbfb      	blt.n	5c9c <system_gclk_gen_get_hz+0x18>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    5ca4:	4e13      	ldr	r6, [pc, #76]	; (5cf4 <system_gclk_gen_get_hz+0x70>)
    5ca6:	6870      	ldr	r0, [r6, #4]
    5ca8:	04c0      	lsls	r0, r0, #19
    5caa:	0ec0      	lsrs	r0, r0, #27
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    5cac:	4b14      	ldr	r3, [pc, #80]	; (5d00 <system_gclk_gen_get_hz+0x7c>)
    5cae:	4798      	blx	r3
    5cb0:	0005      	movs	r5, r0
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    5cb2:	4b12      	ldr	r3, [pc, #72]	; (5cfc <system_gclk_gen_get_hz+0x78>)
    5cb4:	701c      	strb	r4, [r3, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    5cb6:	6876      	ldr	r6, [r6, #4]
    5cb8:	02f6      	lsls	r6, r6, #11
    5cba:	0ff6      	lsrs	r6, r6, #31

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    5cbc:	4b11      	ldr	r3, [pc, #68]	; (5d04 <system_gclk_gen_get_hz+0x80>)
    5cbe:	701c      	strb	r4, [r3, #0]
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    5cc0:	4a0c      	ldr	r2, [pc, #48]	; (5cf4 <system_gclk_gen_get_hz+0x70>)
    5cc2:	7853      	ldrb	r3, [r2, #1]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
	while (system_gclk_is_syncing()) {
    5cc4:	b25b      	sxtb	r3, r3
    5cc6:	2b00      	cmp	r3, #0
    5cc8:	dbfb      	blt.n	5cc2 <system_gclk_gen_get_hz+0x3e>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    5cca:	4b0a      	ldr	r3, [pc, #40]	; (5cf4 <system_gclk_gen_get_hz+0x70>)
    5ccc:	689c      	ldr	r4, [r3, #8]
    5cce:	0224      	lsls	r4, r4, #8
    5cd0:	0c24      	lsrs	r4, r4, #16
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5cd2:	4b0d      	ldr	r3, [pc, #52]	; (5d08 <system_gclk_gen_get_hz+0x84>)
    5cd4:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    5cd6:	2e00      	cmp	r6, #0
    5cd8:	d107      	bne.n	5cea <system_gclk_gen_get_hz+0x66>
    5cda:	2c01      	cmp	r4, #1
    5cdc:	d907      	bls.n	5cee <system_gclk_gen_get_hz+0x6a>
		gen_input_hz /= divider;
    5cde:	0021      	movs	r1, r4
    5ce0:	0028      	movs	r0, r5
    5ce2:	4b0a      	ldr	r3, [pc, #40]	; (5d0c <system_gclk_gen_get_hz+0x88>)
    5ce4:	4798      	blx	r3
    5ce6:	0005      	movs	r5, r0
    5ce8:	e001      	b.n	5cee <system_gclk_gen_get_hz+0x6a>
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
    5cea:	3401      	adds	r4, #1
    5cec:	40e5      	lsrs	r5, r4
	}

	return gen_input_hz;
}
    5cee:	0028      	movs	r0, r5
    5cf0:	bd70      	pop	{r4, r5, r6, pc}
    5cf2:	46c0      	nop			; (mov r8, r8)
    5cf4:	40000c00 	.word	0x40000c00
    5cf8:	00004371 	.word	0x00004371
    5cfc:	40000c04 	.word	0x40000c04
    5d00:	00005735 	.word	0x00005735
    5d04:	40000c08 	.word	0x40000c08
    5d08:	000043b1 	.word	0x000043b1
    5d0c:	000082fd 	.word	0x000082fd

00005d10 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    5d10:	b510      	push	{r4, lr}
    5d12:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5d14:	4b06      	ldr	r3, [pc, #24]	; (5d30 <system_gclk_chan_enable+0x20>)
    5d16:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    5d18:	4b06      	ldr	r3, [pc, #24]	; (5d34 <system_gclk_chan_enable+0x24>)
    5d1a:	701c      	strb	r4, [r3, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    5d1c:	4a06      	ldr	r2, [pc, #24]	; (5d38 <system_gclk_chan_enable+0x28>)
    5d1e:	8851      	ldrh	r1, [r2, #2]
    5d20:	2380      	movs	r3, #128	; 0x80
    5d22:	01db      	lsls	r3, r3, #7
    5d24:	430b      	orrs	r3, r1
    5d26:	8053      	strh	r3, [r2, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5d28:	4b04      	ldr	r3, [pc, #16]	; (5d3c <system_gclk_chan_enable+0x2c>)
    5d2a:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5d2c:	bd10      	pop	{r4, pc}
    5d2e:	46c0      	nop			; (mov r8, r8)
    5d30:	00004371 	.word	0x00004371
    5d34:	40000c02 	.word	0x40000c02
    5d38:	40000c00 	.word	0x40000c00
    5d3c:	000043b1 	.word	0x000043b1

00005d40 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    5d40:	b510      	push	{r4, lr}
    5d42:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5d44:	4b0f      	ldr	r3, [pc, #60]	; (5d84 <system_gclk_chan_disable+0x44>)
    5d46:	4798      	blx	r3
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    5d48:	4b0f      	ldr	r3, [pc, #60]	; (5d88 <system_gclk_chan_disable+0x48>)
    5d4a:	701c      	strb	r4, [r3, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    5d4c:	4b0f      	ldr	r3, [pc, #60]	; (5d8c <system_gclk_chan_disable+0x4c>)
    5d4e:	885a      	ldrh	r2, [r3, #2]
    5d50:	0512      	lsls	r2, r2, #20
    5d52:	0f10      	lsrs	r0, r2, #28
	GCLK->CLKCTRL.bit.GEN = 0;
    5d54:	8859      	ldrh	r1, [r3, #2]
    5d56:	4a0e      	ldr	r2, [pc, #56]	; (5d90 <system_gclk_chan_disable+0x50>)
    5d58:	400a      	ands	r2, r1
    5d5a:	805a      	strh	r2, [r3, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    5d5c:	8859      	ldrh	r1, [r3, #2]
    5d5e:	4a0d      	ldr	r2, [pc, #52]	; (5d94 <system_gclk_chan_disable+0x54>)
    5d60:	400a      	ands	r2, r1
    5d62:	805a      	strh	r2, [r3, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    5d64:	0019      	movs	r1, r3
    5d66:	2280      	movs	r2, #128	; 0x80
    5d68:	01d2      	lsls	r2, r2, #7
    5d6a:	884b      	ldrh	r3, [r1, #2]
    5d6c:	4213      	tst	r3, r2
    5d6e:	d1fc      	bne.n	5d6a <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    5d70:	4906      	ldr	r1, [pc, #24]	; (5d8c <system_gclk_chan_disable+0x4c>)
    5d72:	884c      	ldrh	r4, [r1, #2]
    5d74:	0202      	lsls	r2, r0, #8
    5d76:	4b06      	ldr	r3, [pc, #24]	; (5d90 <system_gclk_chan_disable+0x50>)
    5d78:	4023      	ands	r3, r4
    5d7a:	4313      	orrs	r3, r2
    5d7c:	804b      	strh	r3, [r1, #2]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5d7e:	4b06      	ldr	r3, [pc, #24]	; (5d98 <system_gclk_chan_disable+0x58>)
    5d80:	4798      	blx	r3

	system_interrupt_leave_critical_section();
}
    5d82:	bd10      	pop	{r4, pc}
    5d84:	00004371 	.word	0x00004371
    5d88:	40000c02 	.word	0x40000c02
    5d8c:	40000c00 	.word	0x40000c00
    5d90:	fffff0ff 	.word	0xfffff0ff
    5d94:	ffffbfff 	.word	0xffffbfff
    5d98:	000043b1 	.word	0x000043b1

00005d9c <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    5d9c:	b510      	push	{r4, lr}

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    5d9e:	780c      	ldrb	r4, [r1, #0]
    5da0:	0224      	lsls	r4, r4, #8
    5da2:	4304      	orrs	r4, r0

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    5da4:	4b02      	ldr	r3, [pc, #8]	; (5db0 <system_gclk_chan_set_config+0x14>)
    5da6:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    5da8:	b2a4      	uxth	r4, r4
    5daa:	4b02      	ldr	r3, [pc, #8]	; (5db4 <system_gclk_chan_set_config+0x18>)
    5dac:	805c      	strh	r4, [r3, #2]
}
    5dae:	bd10      	pop	{r4, pc}
    5db0:	00005d41 	.word	0x00005d41
    5db4:	40000c00 	.word	0x40000c00

00005db8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    5db8:	b510      	push	{r4, lr}
    5dba:	0004      	movs	r4, r0
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    5dbc:	4b06      	ldr	r3, [pc, #24]	; (5dd8 <system_gclk_chan_get_hz+0x20>)
    5dbe:	4798      	blx	r3
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    5dc0:	4b06      	ldr	r3, [pc, #24]	; (5ddc <system_gclk_chan_get_hz+0x24>)
    5dc2:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    5dc4:	4b06      	ldr	r3, [pc, #24]	; (5de0 <system_gclk_chan_get_hz+0x28>)
    5dc6:	885c      	ldrh	r4, [r3, #2]
    5dc8:	0524      	lsls	r4, r4, #20
    5dca:	0f24      	lsrs	r4, r4, #28
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    5dcc:	4b05      	ldr	r3, [pc, #20]	; (5de4 <system_gclk_chan_get_hz+0x2c>)
    5dce:	4798      	blx	r3

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    5dd0:	0020      	movs	r0, r4
    5dd2:	4b05      	ldr	r3, [pc, #20]	; (5de8 <system_gclk_chan_get_hz+0x30>)
    5dd4:	4798      	blx	r3
}
    5dd6:	bd10      	pop	{r4, pc}
    5dd8:	00004371 	.word	0x00004371
    5ddc:	40000c02 	.word	0x40000c02
    5de0:	40000c00 	.word	0x40000c00
    5de4:	000043b1 	.word	0x000043b1
    5de8:	00005c85 	.word	0x00005c85

00005dec <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    5dec:	b530      	push	{r4, r5, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    5dee:	78d3      	ldrb	r3, [r2, #3]
    5df0:	2b00      	cmp	r3, #0
    5df2:	d11e      	bne.n	5e32 <_system_pinmux_config+0x46>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    5df4:	7813      	ldrb	r3, [r2, #0]
    5df6:	2b80      	cmp	r3, #128	; 0x80
    5df8:	d004      	beq.n	5e04 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    5dfa:	061b      	lsls	r3, r3, #24
    5dfc:	2480      	movs	r4, #128	; 0x80
    5dfe:	0264      	lsls	r4, r4, #9
    5e00:	4323      	orrs	r3, r4
    5e02:	e000      	b.n	5e06 <_system_pinmux_config+0x1a>
{
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    5e04:	2300      	movs	r3, #0
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    5e06:	7854      	ldrb	r4, [r2, #1]
    5e08:	2502      	movs	r5, #2
    5e0a:	43ac      	bics	r4, r5
    5e0c:	d10a      	bne.n	5e24 <_system_pinmux_config+0x38>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    5e0e:	7894      	ldrb	r4, [r2, #2]
    5e10:	2c00      	cmp	r4, #0
    5e12:	d103      	bne.n	5e1c <_system_pinmux_config+0x30>

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    5e14:	2480      	movs	r4, #128	; 0x80
    5e16:	02a4      	lsls	r4, r4, #10
    5e18:	4323      	orrs	r3, r4
    5e1a:	e002      	b.n	5e22 <_system_pinmux_config+0x36>

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    5e1c:	24c0      	movs	r4, #192	; 0xc0
    5e1e:	02e4      	lsls	r4, r4, #11
    5e20:	4323      	orrs	r3, r4
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    5e22:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    5e24:	7854      	ldrb	r4, [r2, #1]
    5e26:	3c01      	subs	r4, #1
    5e28:	2c01      	cmp	r4, #1
    5e2a:	d812      	bhi.n	5e52 <_system_pinmux_config+0x66>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    5e2c:	4c18      	ldr	r4, [pc, #96]	; (5e90 <_system_pinmux_config+0xa4>)
    5e2e:	4023      	ands	r3, r4
    5e30:	e00f      	b.n	5e52 <_system_pinmux_config+0x66>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    5e32:	6041      	str	r1, [r0, #4]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    5e34:	040b      	lsls	r3, r1, #16
    5e36:	0c1b      	lsrs	r3, r3, #16
    5e38:	24a0      	movs	r4, #160	; 0xa0
    5e3a:	05e4      	lsls	r4, r4, #23
    5e3c:	4323      	orrs	r3, r4
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5e3e:	6283      	str	r3, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    5e40:	0c0b      	lsrs	r3, r1, #16
    5e42:	24d0      	movs	r4, #208	; 0xd0
    5e44:	0624      	lsls	r4, r4, #24
    5e46:	4323      	orrs	r3, r4
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5e48:	6283      	str	r3, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    5e4a:	78d3      	ldrb	r3, [r2, #3]
    5e4c:	2b00      	cmp	r3, #0
    5e4e:	d018      	beq.n	5e82 <_system_pinmux_config+0x96>
    5e50:	e01c      	b.n	5e8c <_system_pinmux_config+0xa0>

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    5e52:	040c      	lsls	r4, r1, #16
    5e54:	0c24      	lsrs	r4, r4, #16
    5e56:	25a0      	movs	r5, #160	; 0xa0
    5e58:	05ed      	lsls	r5, r5, #23
    5e5a:	432c      	orrs	r4, r5
    5e5c:	431c      	orrs	r4, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5e5e:	6284      	str	r4, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    5e60:	0c0c      	lsrs	r4, r1, #16
    5e62:	25d0      	movs	r5, #208	; 0xd0
    5e64:	062d      	lsls	r5, r5, #24
    5e66:	432c      	orrs	r4, r5
    5e68:	431c      	orrs	r4, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    5e6a:	6284      	str	r4, [r0, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    5e6c:	78d4      	ldrb	r4, [r2, #3]
    5e6e:	2c00      	cmp	r4, #0
    5e70:	d10c      	bne.n	5e8c <_system_pinmux_config+0xa0>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    5e72:	035b      	lsls	r3, r3, #13
    5e74:	d505      	bpl.n	5e82 <_system_pinmux_config+0x96>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    5e76:	7893      	ldrb	r3, [r2, #2]
    5e78:	2b01      	cmp	r3, #1
    5e7a:	d101      	bne.n	5e80 <_system_pinmux_config+0x94>
				port->OUTSET.reg = pin_mask;
    5e7c:	6181      	str	r1, [r0, #24]
    5e7e:	e000      	b.n	5e82 <_system_pinmux_config+0x96>
			} else {
				port->OUTCLR.reg = pin_mask;
    5e80:	6141      	str	r1, [r0, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    5e82:	7853      	ldrb	r3, [r2, #1]
    5e84:	3b01      	subs	r3, #1
    5e86:	2b01      	cmp	r3, #1
    5e88:	d800      	bhi.n	5e8c <_system_pinmux_config+0xa0>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    5e8a:	6081      	str	r1, [r0, #8]
		}
	}
}
    5e8c:	bd30      	pop	{r4, r5, pc}
    5e8e:	46c0      	nop			; (mov r8, r8)
    5e90:	fffbffff 	.word	0xfffbffff

00005e94 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    5e94:	b510      	push	{r4, lr}
    5e96:	0003      	movs	r3, r0
    5e98:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    5e9a:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    5e9c:	2000      	movs	r0, #0
	uint8_t group_index = (gpio_pin / 32);

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    5e9e:	2900      	cmp	r1, #0
    5ea0:	d104      	bne.n	5eac <system_pinmux_pin_set_config+0x18>
		return &(ports[port_index]->Group[group_index]);
    5ea2:	0958      	lsrs	r0, r3, #5
    5ea4:	01c0      	lsls	r0, r0, #7
    5ea6:	4905      	ldr	r1, [pc, #20]	; (5ebc <system_pinmux_pin_set_config+0x28>)
    5ea8:	468c      	mov	ip, r1
    5eaa:	4460      	add	r0, ip
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));

	_system_pinmux_config(port, pin_mask, config);
    5eac:	211f      	movs	r1, #31
    5eae:	400b      	ands	r3, r1
    5eb0:	391e      	subs	r1, #30
    5eb2:	4099      	lsls	r1, r3
    5eb4:	4b02      	ldr	r3, [pc, #8]	; (5ec0 <system_pinmux_pin_set_config+0x2c>)
    5eb6:	4798      	blx	r3
}
    5eb8:	bd10      	pop	{r4, pc}
    5eba:	46c0      	nop			; (mov r8, r8)
    5ebc:	41004400 	.word	0x41004400
    5ec0:	00005ded 	.word	0x00005ded

00005ec4 <_system_dummy_init>:
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
	return;
}
    5ec4:	4770      	bx	lr
    5ec6:	46c0      	nop			; (mov r8, r8)

00005ec8 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    5ec8:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    5eca:	4b05      	ldr	r3, [pc, #20]	; (5ee0 <system_init+0x18>)
    5ecc:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    5ece:	4b05      	ldr	r3, [pc, #20]	; (5ee4 <system_init+0x1c>)
    5ed0:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    5ed2:	4b05      	ldr	r3, [pc, #20]	; (5ee8 <system_init+0x20>)
    5ed4:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    5ed6:	4b05      	ldr	r3, [pc, #20]	; (5eec <system_init+0x24>)
    5ed8:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    5eda:	4b05      	ldr	r3, [pc, #20]	; (5ef0 <system_init+0x28>)
    5edc:	4798      	blx	r3
}
    5ede:	bd10      	pop	{r4, pc}
    5ee0:	00005a05 	.word	0x00005a05
    5ee4:	000043e1 	.word	0x000043e1
    5ee8:	00005ec5 	.word	0x00005ec5
    5eec:	00004505 	.word	0x00004505
    5ef0:	00005ec5 	.word	0x00005ec5

00005ef4 <_tcc_get_inst_index>:
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
		if (hw == tcc_modules[i]) {
    5ef4:	4b08      	ldr	r3, [pc, #32]	; (5f18 <_tcc_get_inst_index+0x24>)
    5ef6:	4298      	cmp	r0, r3
    5ef8:	d00a      	beq.n	5f10 <_tcc_get_inst_index+0x1c>
    5efa:	4b08      	ldr	r3, [pc, #32]	; (5f1c <_tcc_get_inst_index+0x28>)
    5efc:	4298      	cmp	r0, r3
    5efe:	d005      	beq.n	5f0c <_tcc_get_inst_index+0x18>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    5f00:	2300      	movs	r3, #0
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
		if (hw == tcc_modules[i]) {
    5f02:	4a07      	ldr	r2, [pc, #28]	; (5f20 <_tcc_get_inst_index+0x2c>)
    5f04:	4290      	cmp	r0, r2
    5f06:	d105      	bne.n	5f14 <_tcc_get_inst_index+0x20>
 */
uint8_t _tcc_get_inst_index(
		Tcc *const hw)
{
	/* Find index for TCC instance. */
	for (uint32_t i = 0; i < TCC_INST_NUM; i++) {
    5f08:	3302      	adds	r3, #2
    5f0a:	e002      	b.n	5f12 <_tcc_get_inst_index+0x1e>
    5f0c:	2301      	movs	r3, #1
    5f0e:	e000      	b.n	5f12 <_tcc_get_inst_index+0x1e>
    5f10:	2300      	movs	r3, #0
		if (hw == tcc_modules[i]) {
			return i;
    5f12:	b2db      	uxtb	r3, r3
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
}
    5f14:	0018      	movs	r0, r3
    5f16:	4770      	bx	lr
    5f18:	42002000 	.word	0x42002000
    5f1c:	42002400 	.word	0x42002400
    5f20:	42002800 	.word	0x42002800

00005f24 <tcc_get_config_defaults>:
 *
 */
void tcc_get_config_defaults(
		struct tcc_config *const config,
		Tcc *const hw)
{
    5f24:	b510      	push	{r4, lr}
    5f26:	0004      	movs	r4, r0
	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
    5f28:	0008      	movs	r0, r1
    5f2a:	4b4f      	ldr	r3, [pc, #316]	; (6068 <tcc_get_config_defaults+0x144>)
    5f2c:	4798      	blx	r3

	/* Base counter defaults */
	config->counter.count                  = 0;
    5f2e:	2300      	movs	r3, #0
    5f30:	6023      	str	r3, [r4, #0]

	config->counter.period                 = _tcc_maxs[module_index];
    5f32:	0080      	lsls	r0, r0, #2
    5f34:	4a4d      	ldr	r2, [pc, #308]	; (606c <tcc_get_config_defaults+0x148>)
    5f36:	5882      	ldr	r2, [r0, r2]
    5f38:	6062      	str	r2, [r4, #4]

	config->counter.clock_source           = GCLK_GENERATOR_0;
    5f3a:	72a3      	strb	r3, [r4, #10]
	config->counter.clock_prescaler        = TCC_CLOCK_PRESCALER_DIV1;
    5f3c:	72e3      	strb	r3, [r4, #11]
	config->counter.reload_action          = TCC_RELOAD_ACTION_GCLK;
    5f3e:	7323      	strb	r3, [r4, #12]

	config->counter.direction              = TCC_COUNT_DIRECTION_UP;
    5f40:	7263      	strb	r3, [r4, #9]
	config->counter.oneshot                = false;
    5f42:	7223      	strb	r3, [r4, #8]
#endif

	/* Match/Capture defaults */
#  define _TCC_CHANNEL_MATCH_VALUE_INIT(n, value) \
		config->compare.match[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5f44:	61e3      	str	r3, [r4, #28]
    5f46:	6223      	str	r3, [r4, #32]
    5f48:	6263      	str	r3, [r4, #36]	; 0x24
    5f4a:	62a3      	str	r3, [r4, #40]	; 0x28
#  undef _TCC_CHANNEL_MATCH_VALUE_INIT

	/* Wave polarity defaults */
#  define _TCC_CHANNEL_WAVE_POLARITY_INIT(n, value) \
		config->compare.wave_polarity[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5f4c:	7523      	strb	r3, [r4, #20]
    5f4e:	7563      	strb	r3, [r4, #21]
    5f50:	75a3      	strb	r3, [r4, #22]
    5f52:	75e3      	strb	r3, [r4, #23]
		_TCC_CHANNEL_WAVE_POLARITY_INIT, TCC_WAVE_POLARITY_0)
#  undef _TCC_CHANNEL_WAVE_POLARITY_INIT

	config->compare.wave_generation = TCC_WAVE_GENERATION_NORMAL_FREQ;
    5f54:	7623      	strb	r3, [r4, #24]
	config->compare.wave_ramp       = TCC_RAMP_RAMP1;
    5f56:	7663      	strb	r3, [r4, #25]

#  define _TCC_CHANNEL_FUNCTION_INIT(n, value) \
		config->compare.channel_function[n] = value;
	MREPEAT(TCC_NUM_CHANNELS,
    5f58:	7423      	strb	r3, [r4, #16]
    5f5a:	7463      	strb	r3, [r4, #17]
    5f5c:	74a3      	strb	r3, [r4, #18]
    5f5e:	74e3      	strb	r3, [r4, #19]
		config->wave_ext.recoverable_fault[n].source = TCC_FAULT_SOURCE_DISABLE;           \
		config->wave_ext.recoverable_fault[n].blanking = TCC_FAULT_BLANKING_DISABLE;       \
		config->wave_ext.recoverable_fault[n].halt_action = TCC_FAULT_HALT_ACTION_DISABLE; \
		config->wave_ext.recoverable_fault[n].capture_action = TCC_FAULT_CAPTURE_DISABLE;  \
		config->wave_ext.recoverable_fault[n].capture_channel = TCC_FAULT_CAPTURE_CHANNEL_0;
	MREPEAT(TCC_NUM_FAULTS, _TCC_FAULT_FUNCTION_INIT, 0)
    5f60:	222c      	movs	r2, #44	; 0x2c
    5f62:	54a3      	strb	r3, [r4, r2]
    5f64:	3201      	adds	r2, #1
    5f66:	54a3      	strb	r3, [r4, r2]
    5f68:	3201      	adds	r2, #1
    5f6a:	54a3      	strb	r3, [r4, r2]
    5f6c:	3201      	adds	r2, #1
    5f6e:	54a3      	strb	r3, [r4, r2]
    5f70:	3201      	adds	r2, #1
    5f72:	54a3      	strb	r3, [r4, r2]
    5f74:	3201      	adds	r2, #1
    5f76:	54a3      	strb	r3, [r4, r2]
    5f78:	3201      	adds	r2, #1
    5f7a:	54a3      	strb	r3, [r4, r2]
    5f7c:	3201      	adds	r2, #1
    5f7e:	54a3      	strb	r3, [r4, r2]
    5f80:	3201      	adds	r2, #1
    5f82:	54a3      	strb	r3, [r4, r2]
    5f84:	3201      	adds	r2, #1
    5f86:	54a3      	strb	r3, [r4, r2]
    5f88:	3201      	adds	r2, #1
    5f8a:	54a3      	strb	r3, [r4, r2]
    5f8c:	3201      	adds	r2, #1
    5f8e:	54a3      	strb	r3, [r4, r2]
    5f90:	3201      	adds	r2, #1
    5f92:	54a3      	strb	r3, [r4, r2]
    5f94:	3201      	adds	r2, #1
    5f96:	54a3      	strb	r3, [r4, r2]
    5f98:	3201      	adds	r2, #1
    5f9a:	54a3      	strb	r3, [r4, r2]
    5f9c:	3201      	adds	r2, #1
    5f9e:	54a3      	strb	r3, [r4, r2]
    5fa0:	3201      	adds	r2, #1
    5fa2:	54a3      	strb	r3, [r4, r2]
    5fa4:	3201      	adds	r2, #1
    5fa6:	54a3      	strb	r3, [r4, r2]
    5fa8:	3201      	adds	r2, #1
    5faa:	54a3      	strb	r3, [r4, r2]
    5fac:	3201      	adds	r2, #1
    5fae:	54a3      	strb	r3, [r4, r2]

	/* Non-recoverable fault defaults */
#  define _TCC_NRF_FUNCTION_INIT(n, dummy) \
		config->wave_ext.non_recoverable_fault[n].filter_value = 0; \
		config->wave_ext.non_recoverable_fault[n].output = TCC_FAULT_STATE_OUTPUT_OFF;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_NRF_FUNCTION_INIT, 0)
    5fb0:	3201      	adds	r2, #1
    5fb2:	54a3      	strb	r3, [r4, r2]
    5fb4:	3201      	adds	r2, #1
    5fb6:	54a3      	strb	r3, [r4, r2]
    5fb8:	3201      	adds	r2, #1
    5fba:	54a3      	strb	r3, [r4, r2]
    5fbc:	3201      	adds	r2, #1
    5fbe:	54a3      	strb	r3, [r4, r2]
    5fc0:	3201      	adds	r2, #1
    5fc2:	54a3      	strb	r3, [r4, r2]
    5fc4:	3201      	adds	r2, #1
    5fc6:	54a3      	strb	r3, [r4, r2]
    5fc8:	3201      	adds	r2, #1
    5fca:	54a3      	strb	r3, [r4, r2]
    5fcc:	3201      	adds	r2, #1
    5fce:	54a3      	strb	r3, [r4, r2]
    5fd0:	3201      	adds	r2, #1
    5fd2:	54a3      	strb	r3, [r4, r2]
    5fd4:	3201      	adds	r2, #1
    5fd6:	54a3      	strb	r3, [r4, r2]
    5fd8:	3201      	adds	r2, #1
    5fda:	54a3      	strb	r3, [r4, r2]
    5fdc:	3201      	adds	r2, #1
    5fde:	54a3      	strb	r3, [r4, r2]
    5fe0:	3201      	adds	r2, #1
    5fe2:	54a3      	strb	r3, [r4, r2]
    5fe4:	3201      	adds	r2, #1
    5fe6:	54a3      	strb	r3, [r4, r2]
    5fe8:	3201      	adds	r2, #1
    5fea:	54a3      	strb	r3, [r4, r2]
    5fec:	3201      	adds	r2, #1
    5fee:	54a3      	strb	r3, [r4, r2]
#  undef _TCC_NRF_FUNCTION_INIT

	/* Output inversion defaults */
#  define _TCC_OUT_INVERT_INIT(n, value) \
		config->wave_ext.invert[n] = value;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_OUT_INVERT_INIT, false)
    5ff0:	3201      	adds	r2, #1
    5ff2:	54a3      	strb	r3, [r4, r2]
    5ff4:	3201      	adds	r2, #1
    5ff6:	54a3      	strb	r3, [r4, r2]
    5ff8:	3201      	adds	r2, #1
    5ffa:	54a3      	strb	r3, [r4, r2]
    5ffc:	3201      	adds	r2, #1
    5ffe:	54a3      	strb	r3, [r4, r2]
    6000:	3201      	adds	r2, #1
    6002:	54a3      	strb	r3, [r4, r2]
    6004:	3201      	adds	r2, #1
    6006:	54a3      	strb	r3, [r4, r2]
    6008:	3201      	adds	r2, #1
    600a:	54a3      	strb	r3, [r4, r2]
    600c:	3201      	adds	r2, #1
    600e:	54a3      	strb	r3, [r4, r2]

#  define _TCC_CHANNEL_OUT_PIN_INIT(n, dummy) \
		config->pins.enable_wave_out_pin[n]                = false;\
		config->pins.wave_out_pin[TCC_WAVE_OUTPUT_##n]     = 0;    \
		config->pins.wave_out_pin_mux[TCC_WAVE_OUTPUT_##n] = 0;
	MREPEAT(TCC_NUM_WAVE_OUTPUTS, _TCC_CHANNEL_OUT_PIN_INIT, 0)
    6010:	3241      	adds	r2, #65	; 0x41
    6012:	54a3      	strb	r3, [r4, r2]
    6014:	65a3      	str	r3, [r4, #88]	; 0x58
    6016:	67a3      	str	r3, [r4, #120]	; 0x78
    6018:	3201      	adds	r2, #1
    601a:	54a3      	strb	r3, [r4, r2]
    601c:	65e3      	str	r3, [r4, #92]	; 0x5c
    601e:	67e3      	str	r3, [r4, #124]	; 0x7c
    6020:	3201      	adds	r2, #1
    6022:	54a3      	strb	r3, [r4, r2]
    6024:	6623      	str	r3, [r4, #96]	; 0x60
    6026:	3a1a      	subs	r2, #26
    6028:	50a3      	str	r3, [r4, r2]
    602a:	321b      	adds	r2, #27
    602c:	54a3      	strb	r3, [r4, r2]
    602e:	6663      	str	r3, [r4, #100]	; 0x64
    6030:	3a17      	subs	r2, #23
    6032:	50a3      	str	r3, [r4, r2]
    6034:	3218      	adds	r2, #24
    6036:	54a3      	strb	r3, [r4, r2]
    6038:	66a3      	str	r3, [r4, #104]	; 0x68
    603a:	3a14      	subs	r2, #20
    603c:	50a3      	str	r3, [r4, r2]
    603e:	3215      	adds	r2, #21
    6040:	54a3      	strb	r3, [r4, r2]
    6042:	66e3      	str	r3, [r4, #108]	; 0x6c
    6044:	3a11      	subs	r2, #17
    6046:	50a3      	str	r3, [r4, r2]
    6048:	3212      	adds	r2, #18
    604a:	54a3      	strb	r3, [r4, r2]
    604c:	6723      	str	r3, [r4, #112]	; 0x70
    604e:	3a0e      	subs	r2, #14
    6050:	50a3      	str	r3, [r4, r2]
    6052:	320f      	adds	r2, #15
    6054:	54a3      	strb	r3, [r4, r2]
    6056:	6763      	str	r3, [r4, #116]	; 0x74
    6058:	3a0b      	subs	r2, #11
    605a:	50a3      	str	r3, [r4, r2]
#  undef _TCC_CHANNEL_OUT_PIN_INIT

	config->double_buffering_enabled  = true;
    605c:	2101      	movs	r1, #1
    605e:	320c      	adds	r2, #12
    6060:	54a1      	strb	r1, [r4, r2]
	config->run_in_standby            = false;
    6062:	3201      	adds	r2, #1
    6064:	54a3      	strb	r3, [r4, r2]
}
    6066:	bd10      	pop	{r4, pc}
    6068:	00005ef5 	.word	0x00005ef5
    606c:	0000aecc 	.word	0x0000aecc

00006070 <tcc_init>:
 */
enum status_code tcc_init(
		struct tcc_module *const module_inst,
		Tcc *const hw,
		const struct tcc_config *const config)
{
    6070:	b5f0      	push	{r4, r5, r6, r7, lr}
    6072:	465f      	mov	r7, fp
    6074:	4656      	mov	r6, sl
    6076:	464d      	mov	r5, r9
    6078:	4644      	mov	r4, r8
    607a:	b4f0      	push	{r4, r5, r6, r7}
    607c:	b08f      	sub	sp, #60	; 0x3c
    607e:	9001      	str	r0, [sp, #4]
    6080:	000c      	movs	r4, r1
    6082:	0016      	movs	r6, r2
	Assert(hw);
	Assert(module_inst);
	Assert(config);

	/* TCC instance index */
	uint8_t module_index = _tcc_get_inst_index(hw);
    6084:	0008      	movs	r0, r1
    6086:	4b83      	ldr	r3, [pc, #524]	; (6294 <tcc_init+0x224>)
    6088:	4798      	blx	r3
    608a:	0003      	movs	r3, r0

	/* Enable the user interface clock for TCC */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    608c:	0001      	movs	r1, r0
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
			break;

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    608e:	4882      	ldr	r0, [pc, #520]	; (6298 <tcc_init+0x228>)
    6090:	6a07      	ldr	r7, [r0, #32]
    6092:	009d      	lsls	r5, r3, #2
    6094:	4a81      	ldr	r2, [pc, #516]	; (629c <tcc_init+0x22c>)
    6096:	58aa      	ldr	r2, [r5, r2]
    6098:	433a      	orrs	r2, r7
    609a:	6202      	str	r2, [r0, #32]
			_tcc_apbcmasks[module_index]);

	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    609c:	6822      	ldr	r2, [r4, #0]
		return STATUS_ERR_DENIED;
    609e:	201c      	movs	r0, #28
	/* Enable the user interface clock for TCC */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
			_tcc_apbcmasks[module_index]);

	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
    60a0:	0792      	lsls	r2, r2, #30
    60a2:	d500      	bpl.n	60a6 <tcc_init+0x36>
    60a4:	e1c5      	b.n	6432 <tcc_init+0x3c2>
		return STATUS_ERR_DENIED;
	}
	/* Check if it's resetting */
	if (hw->CTRLA.reg & TCC_CTRLA_SWRST) {
    60a6:	6822      	ldr	r2, [r4, #0]
    60a8:	381b      	subs	r0, #27
    60aa:	4002      	ands	r2, r0
		return STATUS_ERR_DENIED;
    60ac:	301b      	adds	r0, #27
	/* Check if it's enabled. */
	if (hw->CTRLA.reg & TCC_CTRLA_ENABLE) {
		return STATUS_ERR_DENIED;
	}
	/* Check if it's resetting */
	if (hw->CTRLA.reg & TCC_CTRLA_SWRST) {
    60ae:	2a00      	cmp	r2, #0
    60b0:	d000      	beq.n	60b4 <tcc_init+0x44>
    60b2:	e1be      	b.n	6432 <tcc_init+0x3c2>
	}

	enum status_code status;

	/* Check COUNT, PER, CCx */
	uint32_t count_max  = _tcc_maxs[module_index];
    60b4:	4f7a      	ldr	r7, [pc, #488]	; (62a0 <tcc_init+0x230>)
    60b6:	59ef      	ldr	r7, [r5, r7]

	/* Check all counter values */
	if ((config->counter.count > count_max)
		|| (config->counter.period > count_max)
		) {
		return STATUS_ERR_INVALID_ARG;
    60b8:	2017      	movs	r0, #23

	/* Check COUNT, PER, CCx */
	uint32_t count_max  = _tcc_maxs[module_index];

	/* Check all counter values */
	if ((config->counter.count > count_max)
    60ba:	6835      	ldr	r5, [r6, #0]
    60bc:	42af      	cmp	r7, r5
    60be:	d200      	bcs.n	60c2 <tcc_init+0x52>
    60c0:	e1b7      	b.n	6432 <tcc_init+0x3c2>
		|| (config->counter.period > count_max)
    60c2:	6875      	ldr	r5, [r6, #4]
    60c4:	42af      	cmp	r7, r5
    60c6:	d200      	bcs.n	60ca <tcc_init+0x5a>
    60c8:	e1b3      	b.n	6432 <tcc_init+0x3c2>
		return STATUS_ERR_INVALID_ARG;
	}

	/* Check all channel values */
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if ((config->compare.match[i] > count_max)
    60ca:	69f0      	ldr	r0, [r6, #28]
    60cc:	4287      	cmp	r7, r0
    60ce:	d200      	bcs.n	60d2 <tcc_init+0x62>
    60d0:	e19a      	b.n	6408 <tcc_init+0x398>
    60d2:	6a30      	ldr	r0, [r6, #32]
    60d4:	4287      	cmp	r7, r0
    60d6:	d200      	bcs.n	60da <tcc_init+0x6a>
    60d8:	e198      	b.n	640c <tcc_init+0x39c>
    60da:	6a70      	ldr	r0, [r6, #36]	; 0x24
    60dc:	4287      	cmp	r7, r0
    60de:	d200      	bcs.n	60e2 <tcc_init+0x72>
    60e0:	e196      	b.n	6410 <tcc_init+0x3a0>
    60e2:	6ab0      	ldr	r0, [r6, #40]	; 0x28
    60e4:	4287      	cmp	r7, r0
    60e6:	d200      	bcs.n	60ea <tcc_init+0x7a>
    60e8:	e194      	b.n	6414 <tcc_init+0x3a4>
    60ea:	2098      	movs	r0, #152	; 0x98
    60ec:	4684      	mov	ip, r0
    60ee:	44b4      	add	ip, r6
    60f0:	4660      	mov	r0, ip
    60f2:	9006      	str	r0, [sp, #24]
    60f4:	2700      	movs	r7, #0
		}
	}

	/* Check all outputs */
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (!config->pins.enable_wave_out_pin[i]) {
    60f6:	7805      	ldrb	r5, [r0, #0]
    60f8:	2d00      	cmp	r5, #0
    60fa:	d004      	beq.n	6106 <tcc_init+0x96>
			continue;
		}
		/* Output line is not supported */
		if (i >= _tcc_ow_nums[module_index]) {
    60fc:	4d69      	ldr	r5, [pc, #420]	; (62a4 <tcc_init+0x234>)
    60fe:	5c6d      	ldrb	r5, [r5, r1]
    6100:	42bd      	cmp	r5, r7
    6102:	dc00      	bgt.n	6106 <tcc_init+0x96>
    6104:	e188      	b.n	6418 <tcc_init+0x3a8>
			return STATUS_ERR_INVALID_ARG;
		}
	}

	/* Check all outputs */
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    6106:	3701      	adds	r7, #1
    6108:	3001      	adds	r0, #1
    610a:	2f08      	cmp	r7, #8
    610c:	d1f3      	bne.n	60f6 <tcc_init+0x86>
    610e:	2000      	movs	r0, #0
    6110:	9002      	str	r0, [sp, #8]

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
    6112:	2580      	movs	r5, #128	; 0x80
    6114:	046d      	lsls	r5, r5, #17
    6116:	46ac      	mov	ip, r5
{
	uint32_t ctrla = 0;

	int i;
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if (config->capture.channel_function[i] ==
    6118:	1835      	adds	r5, r6, r0
    611a:	7c2d      	ldrb	r5, [r5, #16]
    611c:	2d01      	cmp	r5, #1
    611e:	d109      	bne.n	6134 <tcc_init+0xc4>
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
    6120:	4d61      	ldr	r5, [pc, #388]	; (62a8 <tcc_init+0x238>)
    6122:	5c6d      	ldrb	r5, [r5, r1]
    6124:	4285      	cmp	r5, r0
    6126:	da00      	bge.n	612a <tcc_init+0xba>
    6128:	e178      	b.n	641c <tcc_init+0x3ac>
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
    612a:	4665      	mov	r5, ip
    612c:	4085      	lsls	r5, r0
    612e:	9f02      	ldr	r7, [sp, #8]
    6130:	432f      	orrs	r7, r5
    6132:	9702      	str	r7, [sp, #8]
		uint32_t *value_buffer)
{
	uint32_t ctrla = 0;

	int i;
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
    6134:	3001      	adds	r0, #1
    6136:	2804      	cmp	r0, #4
    6138:	d1ee      	bne.n	6118 <tcc_init+0xa8>
			}
			ctrla |= (TCC_CTRLA_CPTEN0 << i);
		}
	}

	if (config->run_in_standby) {
    613a:	21a1      	movs	r1, #161	; 0xa1
    613c:	5c71      	ldrb	r1, [r6, r1]
    613e:	2900      	cmp	r1, #0
    6140:	d004      	beq.n	614c <tcc_init+0xdc>
		ctrla |= TCC_CTRLA_RUNSTDBY;
    6142:	2180      	movs	r1, #128	; 0x80
    6144:	0109      	lsls	r1, r1, #4
    6146:	9802      	ldr	r0, [sp, #8]
    6148:	4308      	orrs	r0, r1
    614a:	9002      	str	r0, [sp, #8]
		const struct tcc_config *const config,
		uint8_t *value_buffer)
{
	uint8_t ctrlb = 0;

	if (config->counter.oneshot) {
    614c:	7a31      	ldrb	r1, [r6, #8]
		ctrlb |= TCC_CTRLBSET_ONESHOT;
    614e:	1e48      	subs	r0, r1, #1
    6150:	4181      	sbcs	r1, r0
    6152:	0089      	lsls	r1, r1, #2
    6154:	9105      	str	r1, [sp, #20]
	}
	if (config->counter.direction == TCC_COUNT_DIRECTION_DOWN) {
    6156:	7a71      	ldrb	r1, [r6, #9]
    6158:	2901      	cmp	r1, #1
    615a:	d102      	bne.n	6162 <tcc_init+0xf2>
		ctrlb |= TCC_CTRLBSET_DIR;
    615c:	9805      	ldr	r0, [sp, #20]
    615e:	4308      	orrs	r0, r1
    6160:	9005      	str	r0, [sp, #20]
		const uint8_t module_index,
		const struct tcc_config *const config,
		uint32_t *value_buffer)
{
	struct tcc_recoverable_fault_config *cfg;
	uint8_t cc_num = _tcc_cc_nums[module_index];
    6162:	4951      	ldr	r1, [pc, #324]	; (62a8 <tcc_init+0x238>)
    6164:	5cc9      	ldrb	r1, [r1, r3]
    6166:	0008      	movs	r0, r1
    6168:	9104      	str	r1, [sp, #16]
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
		cfg = (struct tcc_recoverable_fault_config *)
				&config->wave_ext.recoverable_fault[i];
		if (cfg->capture_channel >= cc_num) {
    616a:	2135      	movs	r1, #53	; 0x35
    616c:	5c77      	ldrb	r7, [r6, r1]
    616e:	4287      	cmp	r7, r0
    6170:	d300      	bcc.n	6174 <tcc_init+0x104>
    6172:	e15d      	b.n	6430 <tcc_init+0x3c0>
			return STATUS_ERR_INVALID_ARG;
		}
		if (cfg->filter_value > 0xF) {
    6174:	212c      	movs	r1, #44	; 0x2c
    6176:	5c71      	ldrb	r1, [r6, r1]
    6178:	290f      	cmp	r1, #15
    617a:	d900      	bls.n	617e <tcc_init+0x10e>
    617c:	e158      	b.n	6430 <tcc_init+0x3c0>
	}

	if (config->run_in_standby) {
		ctrla |= TCC_CTRLA_RUNSTDBY;
	}
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
    617e:	7b30      	ldrb	r0, [r6, #12]
    6180:	9008      	str	r0, [sp, #32]
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    6182:	7af0      	ldrb	r0, [r6, #11]
    6184:	9009      	str	r0, [sp, #36]	; 0x24
    6186:	0030      	movs	r0, r6
    6188:	302d      	adds	r0, #45	; 0x2d
    618a:	2500      	movs	r5, #0
    618c:	4690      	mov	r8, r2
    618e:	46a1      	mov	r9, r4
    6190:	002c      	movs	r4, r5
    6192:	46b3      	mov	fp, r6
    6194:	0006      	movs	r6, r0
    6196:	9307      	str	r3, [sp, #28]
    6198:	e00a      	b.n	61b0 <tcc_init+0x140>
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
		cfg = (struct tcc_recoverable_fault_config *)
				&config->wave_ext.recoverable_fault[i];
		if (cfg->capture_channel >= cc_num) {
    619a:	7c9f      	ldrb	r7, [r3, #18]
    619c:	9a04      	ldr	r2, [sp, #16]
    619e:	42ba      	cmp	r2, r7
    61a0:	d800      	bhi.n	61a4 <tcc_init+0x134>
    61a2:	e145      	b.n	6430 <tcc_init+0x3c0>
			return STATUS_ERR_INVALID_ARG;
		}
		if (cfg->filter_value > 0xF) {
    61a4:	7a59      	ldrb	r1, [r3, #9]
    61a6:	360a      	adds	r6, #10
    61a8:	3404      	adds	r4, #4
    61aa:	290f      	cmp	r1, #15
    61ac:	d900      	bls.n	61b0 <tcc_init+0x140>
    61ae:	e13f      	b.n	6430 <tcc_init+0x3c0>
			return STATUS_ERR_INVALID_ARG;
		}
		fault = TCC_FCTRLA_FILTERVAL(cfg->filter_value)
    61b0:	0609      	lsls	r1, r1, #24
    61b2:	23f0      	movs	r3, #240	; 0xf0
    61b4:	051b      	lsls	r3, r3, #20
    61b6:	4019      	ands	r1, r3
    61b8:	0033      	movs	r3, r6
				| TCC_FCTRLA_BLANKVAL(cfg->blanking_cycles)
    61ba:	7835      	ldrb	r5, [r6, #0]
    61bc:	042d      	lsls	r5, r5, #16
    61be:	22ff      	movs	r2, #255	; 0xff
    61c0:	0412      	lsls	r2, r2, #16
    61c2:	4015      	ands	r5, r2
    61c4:	46aa      	mov	sl, r5
				| (cfg->restart ? TCC_FCTRLA_RESTART : 0)
    61c6:	7872      	ldrb	r2, [r6, #1]
    61c8:	2080      	movs	r0, #128	; 0x80
    61ca:	9003      	str	r0, [sp, #12]
    61cc:	2a00      	cmp	r2, #0
    61ce:	d101      	bne.n	61d4 <tcc_init+0x164>
    61d0:	4642      	mov	r2, r8
    61d2:	9203      	str	r2, [sp, #12]
				| (cfg->keep ? TCC_FCTRLA_KEEP : 0)
    61d4:	789a      	ldrb	r2, [r3, #2]
    61d6:	2008      	movs	r0, #8
    61d8:	2a00      	cmp	r2, #0
    61da:	d100      	bne.n	61de <tcc_init+0x16e>
    61dc:	4640      	mov	r0, r8
				| (cfg->qualification ? TCC_FCTRLA_QUAL : 0)
    61de:	78da      	ldrb	r2, [r3, #3]
    61e0:	4694      	mov	ip, r2
    61e2:	2210      	movs	r2, #16
    61e4:	4665      	mov	r5, ip
    61e6:	2d00      	cmp	r5, #0
    61e8:	d100      	bne.n	61ec <tcc_init+0x17c>
    61ea:	4642      	mov	r2, r8
				| TCC_FCTRLA_SRC(cfg->source)
				| TCC_FCTRLA_BLANK(cfg->blanking)
				| TCC_FCTRLA_HALT(cfg->halt_action)
				| TCC_FCTRLA_CAPTURE(cfg->capture_action)
				| TCC_FCTRLA_CHSEL(cfg->capture_channel);
		value_buffer[i] = fault;
    61ec:	02bf      	lsls	r7, r7, #10
    61ee:	25c0      	movs	r5, #192	; 0xc0
    61f0:	012d      	lsls	r5, r5, #4
    61f2:	402f      	ands	r7, r5
    61f4:	4339      	orrs	r1, r7
    61f6:	791f      	ldrb	r7, [r3, #4]
    61f8:	2503      	movs	r5, #3
    61fa:	402f      	ands	r7, r5
    61fc:	4339      	orrs	r1, r7
    61fe:	4655      	mov	r5, sl
    6200:	430d      	orrs	r5, r1
    6202:	795f      	ldrb	r7, [r3, #5]
    6204:	017f      	lsls	r7, r7, #5
    6206:	2160      	movs	r1, #96	; 0x60
    6208:	400f      	ands	r7, r1
    620a:	433d      	orrs	r5, r7
    620c:	7999      	ldrb	r1, [r3, #6]
    620e:	0209      	lsls	r1, r1, #8
    6210:	27c0      	movs	r7, #192	; 0xc0
    6212:	00bf      	lsls	r7, r7, #2
    6214:	4039      	ands	r1, r7
    6216:	430d      	orrs	r5, r1
    6218:	79d9      	ldrb	r1, [r3, #7]
    621a:	0309      	lsls	r1, r1, #12
    621c:	27e0      	movs	r7, #224	; 0xe0
    621e:	01ff      	lsls	r7, r7, #7
    6220:	4039      	ands	r1, r7
    6222:	430d      	orrs	r5, r1
    6224:	9903      	ldr	r1, [sp, #12]
    6226:	430d      	orrs	r5, r1
    6228:	4328      	orrs	r0, r5
    622a:	4302      	orrs	r2, r0
    622c:	a90c      	add	r1, sp, #48	; 0x30
    622e:	5062      	str	r2, [r4, r1]
{
	struct tcc_recoverable_fault_config *cfg;
	uint8_t cc_num = _tcc_cc_nums[module_index];
	uint32_t fault;
	int i;
	for (i = 0; i < TCC_NUM_FAULTS; i ++) {
    6230:	2c04      	cmp	r4, #4
    6232:	d1b2      	bne.n	619a <tcc_init+0x12a>
    6234:	464c      	mov	r4, r9
    6236:	465e      	mov	r6, fp
    6238:	9b07      	ldr	r3, [sp, #28]
		const uint8_t module_index,
		const struct tcc_config *const config,
		uint32_t *value_buffer)
{
	uint32_t i;
	uint8_t ow_num = _tcc_ow_nums[module_index];
    623a:	4a1a      	ldr	r2, [pc, #104]	; (62a4 <tcc_init+0x234>)
    623c:	5cd2      	ldrb	r2, [r2, r3]
    623e:	4691      	mov	r9, r2
    6240:	4659      	mov	r1, fp
    6242:	3150      	adds	r1, #80	; 0x50
    6244:	4658      	mov	r0, fp
    6246:	3041      	adds	r0, #65	; 0x41
	uint32_t drvctrl;

	drvctrl = 0;
    6248:	2700      	movs	r7, #0

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    624a:	2200      	movs	r2, #0
			}
			if (config->wave_ext.non_recoverable_fault[i].output ==
				TCC_FAULT_STATE_OUTPUT_1) {
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
			} else {
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    624c:	2501      	movs	r5, #1
    624e:	46aa      	mov	sl, r5
			if (i >= ow_num) {
				return STATUS_ERR_INVALID_ARG;
			}
			if (config->wave_ext.non_recoverable_fault[i].output ==
				TCC_FAULT_STATE_OUTPUT_1) {
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
    6250:	2502      	movs	r5, #2
    6252:	35ff      	adds	r5, #255	; 0xff
    6254:	46ab      	mov	fp, r5
	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
			if (i >= ow_num) {
				return STATUS_ERR_INVALID_ARG;
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    6256:	2580      	movs	r5, #128	; 0x80
    6258:	026d      	lsls	r5, r5, #9
    625a:	46a8      	mov	r8, r5
    625c:	46a4      	mov	ip, r4
    625e:	001c      	movs	r4, r3
    6260:	464b      	mov	r3, r9
	uint32_t drvctrl;

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
    6262:	780d      	ldrb	r5, [r1, #0]
    6264:	2d00      	cmp	r5, #0
    6266:	d009      	beq.n	627c <tcc_init+0x20c>
			if (i >= ow_num) {
    6268:	4293      	cmp	r3, r2
    626a:	d800      	bhi.n	626e <tcc_init+0x1fe>
    626c:	e0d8      	b.n	6420 <tcc_init+0x3b0>
				return STATUS_ERR_INVALID_ARG;
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
    626e:	4645      	mov	r5, r8
    6270:	4095      	lsls	r5, r2
    6272:	432f      	orrs	r7, r5
		}
		if (config->wave_ext.non_recoverable_fault[i].output !=
    6274:	7805      	ldrb	r5, [r0, #0]
    6276:	2d00      	cmp	r5, #0
    6278:	d106      	bne.n	6288 <tcc_init+0x218>
    627a:	e01a      	b.n	62b2 <tcc_init+0x242>
    627c:	7805      	ldrb	r5, [r0, #0]
    627e:	2d00      	cmp	r5, #0
    6280:	d017      	beq.n	62b2 <tcc_init+0x242>
			TCC_FAULT_STATE_OUTPUT_OFF) {
			if (i >= ow_num) {
    6282:	4293      	cmp	r3, r2
    6284:	d800      	bhi.n	6288 <tcc_init+0x218>
    6286:	e0cd      	b.n	6424 <tcc_init+0x3b4>
				return STATUS_ERR_INVALID_ARG;
			}
			if (config->wave_ext.non_recoverable_fault[i].output ==
    6288:	2d02      	cmp	r5, #2
    628a:	d10f      	bne.n	62ac <tcc_init+0x23c>
				TCC_FAULT_STATE_OUTPUT_1) {
				drvctrl |= (TCC_DRVCTRL_NRE0 | TCC_DRVCTRL_NRV0) << i;
    628c:	465d      	mov	r5, fp
    628e:	4095      	lsls	r5, r2
    6290:	432f      	orrs	r7, r5
    6292:	e00e      	b.n	62b2 <tcc_init+0x242>
    6294:	00005ef5 	.word	0x00005ef5
    6298:	40000400 	.word	0x40000400
    629c:	0000aec0 	.word	0x0000aec0
    62a0:	0000aecc 	.word	0x0000aecc
    62a4:	0000aedc 	.word	0x0000aedc
    62a8:	0000aed8 	.word	0x0000aed8
			} else {
				drvctrl |= (TCC_DRVCTRL_NRE0) << i;
    62ac:	4655      	mov	r5, sl
    62ae:	4095      	lsls	r5, r2
    62b0:	432f      	orrs	r7, r5
	uint8_t ow_num = _tcc_ow_nums[module_index];
	uint32_t drvctrl;

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
    62b2:	3201      	adds	r2, #1
    62b4:	3101      	adds	r1, #1
    62b6:	3002      	adds	r0, #2
    62b8:	2a08      	cmp	r2, #8
    62ba:	d1d2      	bne.n	6262 <tcc_init+0x1f2>
    62bc:	4699      	mov	r9, r3
    62be:	0023      	movs	r3, r4
    62c0:	4664      	mov	r4, ip
	uint8_t cc_num = _tcc_cc_nums[module_index];
	struct tcc_match_wave_config const *wav_cfg = &config->compare;

	uint32_t wave;

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
    62c2:	7e72      	ldrb	r2, [r6, #25]
    62c4:	0112      	lsls	r2, r2, #4
    62c6:	2130      	movs	r1, #48	; 0x30
    62c8:	400a      	ands	r2, r1
    62ca:	7e31      	ldrb	r1, [r6, #24]
    62cc:	2007      	movs	r0, #7
    62ce:	4001      	ands	r1, r0
    62d0:	430a      	orrs	r2, r1
    62d2:	4692      	mov	sl, r2
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    62d4:	2200      	movs	r2, #0
		if (wav_cfg->wave_polarity[n]) {
			if (n >= cc_num) {
				return STATUS_ERR_INVALID_ARG;
			}
			wave |= (TCC_WAVE_POL0 << n);
    62d6:	2080      	movs	r0, #128	; 0x80
    62d8:	0240      	lsls	r0, r0, #9
    62da:	4655      	mov	r5, sl

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
		if (wav_cfg->wave_polarity[n]) {
    62dc:	18b1      	adds	r1, r6, r2
    62de:	7d09      	ldrb	r1, [r1, #20]
    62e0:	2900      	cmp	r1, #0
    62e2:	d006      	beq.n	62f2 <tcc_init+0x282>
			if (n >= cc_num) {
    62e4:	9904      	ldr	r1, [sp, #16]
    62e6:	4291      	cmp	r1, r2
    62e8:	dc00      	bgt.n	62ec <tcc_init+0x27c>
    62ea:	e09d      	b.n	6428 <tcc_init+0x3b8>
				return STATUS_ERR_INVALID_ARG;
			}
			wave |= (TCC_WAVE_POL0 << n);
    62ec:	0001      	movs	r1, r0
    62ee:	4091      	lsls	r1, r2
    62f0:	430d      	orrs	r5, r1
	uint32_t wave;

	wave = TCC_WAVE_RAMP(wav_cfg->wave_ramp) |
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
    62f2:	3201      	adds	r2, #1
    62f4:	2a04      	cmp	r2, #4
    62f6:	d1f1      	bne.n	62dc <tcc_init+0x26c>
    62f8:	46aa      	mov	sl, r5
    62fa:	9801      	ldr	r0, [sp, #4]
    62fc:	0002      	movs	r2, r0
    62fe:	3204      	adds	r2, #4
    6300:	3034      	adds	r0, #52	; 0x34

	/* Initialize module */
#if TCC_ASYNC
	/* Initialize parameters */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		module_inst->callback[i] = NULL;
    6302:	2100      	movs	r1, #0
    6304:	c202      	stmia	r2!, {r1}
	}

	/* Initialize module */
#if TCC_ASYNC
	/* Initialize parameters */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    6306:	4282      	cmp	r2, r0
    6308:	d1fc      	bne.n	6304 <tcc_init+0x294>
		module_inst->callback[i] = NULL;
	}
	module_inst->register_callback_mask = 0;
    630a:	2200      	movs	r2, #0
    630c:	9801      	ldr	r0, [sp, #4]
    630e:	6342      	str	r2, [r0, #52]	; 0x34
	module_inst->enable_callback_mask = 0;
    6310:	6382      	str	r2, [r0, #56]	; 0x38
	_tcc_instances[module_index] = module_inst;
    6312:	0099      	lsls	r1, r3, #2
    6314:	4a4a      	ldr	r2, [pc, #296]	; (6440 <tcc_init+0x3d0>)
    6316:	5088      	str	r0, [r1, r2]
#endif

	module_inst->hw = hw;
    6318:	6004      	str	r4, [r0, #0]

	module_inst->double_buffering_enabled = config->double_buffering_enabled;
    631a:	22a0      	movs	r2, #160	; 0xa0
    631c:	5cb1      	ldrb	r1, [r6, r2]
    631e:	3a64      	subs	r2, #100	; 0x64
    6320:	5481      	strb	r1, [r0, r2]

	/* Setup clock for module */
	struct system_gclk_chan_config gclk_chan_config;
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->counter.clock_source;
    6322:	a90b      	add	r1, sp, #44	; 0x2c
    6324:	7ab2      	ldrb	r2, [r6, #10]
    6326:	700a      	strb	r2, [r1, #0]
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
    6328:	4a46      	ldr	r2, [pc, #280]	; (6444 <tcc_init+0x3d4>)
    632a:	5cd5      	ldrb	r5, [r2, r3]
    632c:	0028      	movs	r0, r5
    632e:	4b46      	ldr	r3, [pc, #280]	; (6448 <tcc_init+0x3d8>)
    6330:	4798      	blx	r3
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);
    6332:	0028      	movs	r0, r5
    6334:	4b45      	ldr	r3, [pc, #276]	; (644c <tcc_init+0x3dc>)
    6336:	4798      	blx	r3

	/* Initialize pins */
	struct system_pinmux_config pin_config;
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
    6338:	464b      	mov	r3, r9
    633a:	2b00      	cmp	r3, #0
    633c:	dd22      	ble.n	6384 <tcc_init+0x314>
    633e:	0035      	movs	r5, r6
    6340:	3558      	adds	r5, #88	; 0x58
    6342:	3398      	adds	r3, #152	; 0x98
    6344:	4698      	mov	r8, r3
    6346:	44b0      	add	r8, r6
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    6348:	2301      	movs	r3, #1
    634a:	4699      	mov	r9, r3
		}

		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
		system_pinmux_pin_set_config(
    634c:	46b3      	mov	fp, r6
    634e:	4646      	mov	r6, r8
    6350:	46a0      	mov	r8, r4
    6352:	9c06      	ldr	r4, [sp, #24]
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);

	/* Initialize pins */
	struct system_pinmux_config pin_config;
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
		if (!config->pins.enable_wave_out_pin[i]) {
    6354:	7823      	ldrb	r3, [r4, #0]
    6356:	2b00      	cmp	r3, #0
    6358:	d00e      	beq.n	6378 <tcc_init+0x308>
    635a:	ab0a      	add	r3, sp, #40	; 0x28
    635c:	464a      	mov	r2, r9
    635e:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    6360:	2300      	movs	r3, #0
    6362:	aa0a      	add	r2, sp, #40	; 0x28
    6364:	70d3      	strb	r3, [r2, #3]
			continue;
		}

		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pins.wave_out_pin_mux[i];
    6366:	6a2b      	ldr	r3, [r5, #32]
    6368:	7013      	strb	r3, [r2, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    636a:	0013      	movs	r3, r2
    636c:	464a      	mov	r2, r9
    636e:	705a      	strb	r2, [r3, #1]
		system_pinmux_pin_set_config(
    6370:	7828      	ldrb	r0, [r5, #0]
    6372:	0019      	movs	r1, r3
    6374:	4b36      	ldr	r3, [pc, #216]	; (6450 <tcc_init+0x3e0>)
    6376:	4798      	blx	r3
    6378:	3401      	adds	r4, #1
    637a:	3504      	adds	r5, #4
	system_gclk_chan_set_config(_tcc_gclk_ids[module_index], &gclk_chan_config);
	system_gclk_chan_enable(_tcc_gclk_ids[module_index]);

	/* Initialize pins */
	struct system_pinmux_config pin_config;
	for (i = 0; i <  _tcc_ow_nums[module_index]; i ++) {
    637c:	42b4      	cmp	r4, r6
    637e:	d1e9      	bne.n	6354 <tcc_init+0x2e4>
    6380:	4644      	mov	r4, r8
    6382:	465e      	mov	r6, fp

	if (config->run_in_standby) {
		ctrla |= TCC_CTRLA_RUNSTDBY;
	}
	ctrla |= config->counter.reload_action << TCC_CTRLA_PRESCSYNC_Pos;
	ctrla |= config->counter.clock_prescaler << TCC_CTRLA_PRESCALER_Pos;
    6384:	9b08      	ldr	r3, [sp, #32]
    6386:	031a      	lsls	r2, r3, #12
    6388:	9b09      	ldr	r3, [sp, #36]	; 0x24
    638a:	021b      	lsls	r3, r3, #8
    638c:	4313      	orrs	r3, r2
    638e:	9a02      	ldr	r2, [sp, #8]
    6390:	4313      	orrs	r3, r2
				config->pins.wave_out_pin[i], &pin_config);
	}

	/* Write to registers */

	hw->CTRLA.reg = ctrla;
    6392:	6023      	str	r3, [r4, #0]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    6394:	2204      	movs	r2, #4
    6396:	68a3      	ldr	r3, [r4, #8]
    6398:	421a      	tst	r2, r3
    639a:	d1fc      	bne.n	6396 <tcc_init+0x326>
		/* Wait for sync */
	}

	hw->CTRLBCLR.reg = 0xFF;
    639c:	23ff      	movs	r3, #255	; 0xff
    639e:	7123      	strb	r3, [r4, #4]
	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_CTRLB) {
    63a0:	2204      	movs	r2, #4
    63a2:	68a3      	ldr	r3, [r4, #8]
    63a4:	421a      	tst	r2, r3
    63a6:	d1fc      	bne.n	63a2 <tcc_init+0x332>
		/* Wait for sync */
	}
	hw->CTRLBSET.reg = ctrlb;
    63a8:	466b      	mov	r3, sp
    63aa:	7d1b      	ldrb	r3, [r3, #20]
    63ac:	7163      	strb	r3, [r4, #5]

	hw->FCTRLA.reg = faults[0];
    63ae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    63b0:	60e3      	str	r3, [r4, #12]
	hw->FCTRLB.reg = faults[1];
    63b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    63b4:	6123      	str	r3, [r4, #16]

	hw->DRVCTRL.reg = drvctrl;
    63b6:	61a7      	str	r7, [r4, #24]

#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22) && (!SAMR30)
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_WAVE | TCC_SYNCBUSY_WAVEB)) {
    63b8:	4a26      	ldr	r2, [pc, #152]	; (6454 <tcc_init+0x3e4>)
    63ba:	68a3      	ldr	r3, [r4, #8]
    63bc:	4213      	tst	r3, r2
    63be:	d1fc      	bne.n	63ba <tcc_init+0x34a>
		/* Wait for sync */
	}
#endif
	hw->WAVE.reg = waves[0];
    63c0:	4653      	mov	r3, sl
    63c2:	63e3      	str	r3, [r4, #60]	; 0x3c

	while (hw->SYNCBUSY.reg & TCC_SYNCBUSY_COUNT) {
    63c4:	2210      	movs	r2, #16
    63c6:	68a3      	ldr	r3, [r4, #8]
    63c8:	421a      	tst	r2, r3
    63ca:	d1fc      	bne.n	63c6 <tcc_init+0x356>
		/* Wait for sync */
	}
	hw->COUNT.reg = config->counter.count;
    63cc:	6833      	ldr	r3, [r6, #0]
    63ce:	6363      	str	r3, [r4, #52]	; 0x34

#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22) && (!SAMR30)
	while (hw->SYNCBUSY.reg & (TCC_SYNCBUSY_PER | TCC_SYNCBUSY_PERB)) {
    63d0:	4a21      	ldr	r2, [pc, #132]	; (6458 <tcc_init+0x3e8>)
    63d2:	68a3      	ldr	r3, [r4, #8]
    63d4:	4213      	tst	r3, r2
    63d6:	d1fc      	bne.n	63d2 <tcc_init+0x362>
		/* Wait for sync */
	}
#endif
	hw->PER.reg = (config->counter.period);
    63d8:	6873      	ldr	r3, [r6, #4]
    63da:	6423      	str	r3, [r4, #64]	; 0x40

	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    63dc:	9804      	ldr	r0, [sp, #16]
    63de:	2800      	cmp	r0, #0
    63e0:	dd24      	ble.n	642c <tcc_init+0x3bc>
    63e2:	361c      	adds	r6, #28
    63e4:	2100      	movs	r1, #0
#if (!SAML21) && (!SAMC20) && (!SAMC21) && (!SAML22) && (!SAMR30)
		while (hw->SYNCBUSY.reg & (
    63e6:	4d1d      	ldr	r5, [pc, #116]	; (645c <tcc_init+0x3ec>)
    63e8:	002a      	movs	r2, r5
    63ea:	408a      	lsls	r2, r1
    63ec:	68a3      	ldr	r3, [r4, #8]
    63ee:	421a      	tst	r2, r3
    63f0:	d1fc      	bne.n	63ec <tcc_init+0x37c>
			(TCC_SYNCBUSY_CC0 | TCC_SYNCBUSY_CCB0) << i)) {
			/* Wait for sync */
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
    63f2:	ce04      	ldmia	r6!, {r2}
    63f4:	000b      	movs	r3, r1
    63f6:	3310      	adds	r3, #16
    63f8:	009b      	lsls	r3, r3, #2
    63fa:	18e3      	adds	r3, r4, r3
    63fc:	605a      	str	r2, [r3, #4]
		/* Wait for sync */
	}
#endif
	hw->PER.reg = (config->counter.period);

	for (i = 0; i <  _tcc_cc_nums[module_index]; i ++) {
    63fe:	3101      	adds	r1, #1
    6400:	4288      	cmp	r0, r1
    6402:	dcf1      	bgt.n	63e8 <tcc_init+0x378>
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
    6404:	2000      	movs	r0, #0
    6406:	e014      	b.n	6432 <tcc_init+0x3c2>

	/* Check all channel values */
	for (i = 0; i < TCC_NUM_CHANNELS; i ++) {
		if ((config->compare.match[i] > count_max)
			) {
			return STATUS_ERR_INVALID_ARG;
    6408:	2017      	movs	r0, #23
    640a:	e012      	b.n	6432 <tcc_init+0x3c2>
    640c:	2017      	movs	r0, #23
    640e:	e010      	b.n	6432 <tcc_init+0x3c2>
    6410:	2017      	movs	r0, #23
    6412:	e00e      	b.n	6432 <tcc_init+0x3c2>
    6414:	2017      	movs	r0, #23
    6416:	e00c      	b.n	6432 <tcc_init+0x3c2>
		if (!config->pins.enable_wave_out_pin[i]) {
			continue;
		}
		/* Output line is not supported */
		if (i >= _tcc_ow_nums[module_index]) {
			return STATUS_ERR_INVALID_ARG;
    6418:	2017      	movs	r0, #23
    641a:	e00a      	b.n	6432 <tcc_init+0x3c2>
		if (config->capture.channel_function[i] ==
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
    641c:	2017      	movs	r0, #23
    641e:	e008      	b.n	6432 <tcc_init+0x3c2>

	drvctrl = 0;

	for (i = 0; i < TCC_NUM_WAVE_OUTPUTS; i ++) {
		if (config->wave_ext.invert[i]) {
			if (i >= ow_num) {
    6420:	2017      	movs	r0, #23
    6422:	e006      	b.n	6432 <tcc_init+0x3c2>
			}
			drvctrl |= (TCC_DRVCTRL_INVEN0 << i);
		}
		if (config->wave_ext.non_recoverable_fault[i].output !=
			TCC_FAULT_STATE_OUTPUT_OFF) {
			if (i >= ow_num) {
    6424:	2017      	movs	r0, #23
    6426:	e004      	b.n	6432 <tcc_init+0x3c2>
			TCC_WAVE_WAVEGEN(wav_cfg->wave_generation);

	for (n = 0; n < TCC_NUM_CHANNELS; n++) {
		if (wav_cfg->wave_polarity[n]) {
			if (n >= cc_num) {
				return STATUS_ERR_INVALID_ARG;
    6428:	2017      	movs	r0, #23
    642a:	e002      	b.n	6432 <tcc_init+0x3c2>
		}
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
    642c:	2000      	movs	r0, #0
    642e:	e000      	b.n	6432 <tcc_init+0x3c2>
		if (config->capture.channel_function[i] ==
			TCC_CHANNEL_FUNCTION_CAPTURE) {

			if (i > _tcc_cc_nums[module_index]) {
				/* Channel not supported */
				return STATUS_ERR_INVALID_ARG;
    6430:	2017      	movs	r0, #23
#endif
		hw->CC[i].reg = (config->compare.match[i]);
	}

	return STATUS_OK;
}
    6432:	b00f      	add	sp, #60	; 0x3c
    6434:	bc3c      	pop	{r2, r3, r4, r5}
    6436:	4690      	mov	r8, r2
    6438:	4699      	mov	r9, r3
    643a:	46a2      	mov	sl, r4
    643c:	46ab      	mov	fp, r5
    643e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6440:	20000380 	.word	0x20000380
    6444:	0000aebc 	.word	0x0000aebc
    6448:	00005d9d 	.word	0x00005d9d
    644c:	00005d11 	.word	0x00005d11
    6450:	00005e95 	.word	0x00005e95
    6454:	00020040 	.word	0x00020040
    6458:	00040080 	.word	0x00040080
    645c:	00080100 	.word	0x00080100

00006460 <tcc_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    6460:	0092      	lsls	r2, r2, #2
    6462:	1883      	adds	r3, r0, r2
    6464:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->register_callback_mask |= _tcc_intflag[callback_type];
    6466:	4b03      	ldr	r3, [pc, #12]	; (6474 <tcc_register_callback+0x14>)
    6468:	58d3      	ldr	r3, [r2, r3]
    646a:	6b42      	ldr	r2, [r0, #52]	; 0x34
    646c:	4313      	orrs	r3, r2
    646e:	6343      	str	r3, [r0, #52]	; 0x34

	return STATUS_OK;
}
    6470:	2000      	movs	r0, #0
    6472:	4770      	bx	lr
    6474:	0000aee0 	.word	0x0000aee0

00006478 <tcc_enable_callback>:
 * \param[in]     callback_type Callback type given by an enum
 */
void tcc_enable_callback(
		struct tcc_module *const module,
		const enum tcc_callback callback_type)
{
    6478:	b570      	push	{r4, r5, r6, lr}
    647a:	0004      	movs	r4, r0
    647c:	000d      	movs	r5, r1
	Assert(module);
	Assert(module->hw);

	/* Enable interrupts for this TCC module */
	system_interrupt_enable(_tcc_interrupt_get_interrupt_vector(
			_tcc_get_inst_index(module->hw)));
    647e:	6800      	ldr	r0, [r0, #0]
    6480:	4b09      	ldr	r3, [pc, #36]	; (64a8 <tcc_enable_callback+0x30>)
    6482:	4798      	blx	r3
{
	static uint8_t tcc_interrupt_vectors[TCC_INST_NUM] = {
		MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_VECT_NUM, 0)
	};

	return (enum system_interrupt_vector)tcc_interrupt_vectors[inst_num];
    6484:	4b09      	ldr	r3, [pc, #36]	; (64ac <tcc_enable_callback+0x34>)
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    6486:	5c1b      	ldrb	r3, [r3, r0]
    6488:	221f      	movs	r2, #31
    648a:	401a      	ands	r2, r3
    648c:	2301      	movs	r3, #1
    648e:	4093      	lsls	r3, r2
    6490:	4a07      	ldr	r2, [pc, #28]	; (64b0 <tcc_enable_callback+0x38>)
    6492:	6013      	str	r3, [r2, #0]
	/* Enable interrupts for this TCC module */
	system_interrupt_enable(_tcc_interrupt_get_interrupt_vector(
			_tcc_get_inst_index(module->hw)));

	/* Enable channel or other callbacks */
	module->enable_callback_mask |= _tcc_intflag[callback_type];
    6494:	00ad      	lsls	r5, r5, #2
    6496:	4b07      	ldr	r3, [pc, #28]	; (64b4 <tcc_enable_callback+0x3c>)
    6498:	58ea      	ldr	r2, [r5, r3]
    649a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    649c:	4313      	orrs	r3, r2
    649e:	63a3      	str	r3, [r4, #56]	; 0x38
	module->hw->INTENSET.reg = _tcc_intflag[callback_type];
    64a0:	6823      	ldr	r3, [r4, #0]
    64a2:	629a      	str	r2, [r3, #40]	; 0x28
}
    64a4:	bd70      	pop	{r4, r5, r6, pc}
    64a6:	46c0      	nop			; (mov r8, r8)
    64a8:	00005ef5 	.word	0x00005ef5
    64ac:	0000af10 	.word	0x0000af10
    64b0:	e000e100 	.word	0xe000e100
    64b4:	0000aee0 	.word	0x0000aee0

000064b8 <_tcc_interrupt_handler>:
 * \param[in]  module_index  ID of the TCC instance calling the interrupt
 *                           handler
 */
void _tcc_interrupt_handler(
		uint8_t module_index)
{
    64b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    64ba:	464f      	mov	r7, r9
    64bc:	4646      	mov	r6, r8
    64be:	b4c0      	push	{r6, r7}
	int i;

	uint32_t interrupt_and_callback_status_mask;

	struct tcc_module *module =
    64c0:	0080      	lsls	r0, r0, #2
    64c2:	4b11      	ldr	r3, [pc, #68]	; (6508 <_tcc_interrupt_handler+0x50>)
    64c4:	58c3      	ldr	r3, [r0, r3]
    64c6:	4699      	mov	r9, r3
			(struct tcc_module *)_tcc_instances[module_index];

	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
    64c8:	681b      	ldr	r3, [r3, #0]
    64ca:	6adf      	ldr	r7, [r3, #44]	; 0x2c
    64cc:	464b      	mov	r3, r9
    64ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    64d0:	401f      	ands	r7, r3
    64d2:	464b      	mov	r3, r9
    64d4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    64d6:	401f      	ands	r7, r3
    64d8:	4d0c      	ldr	r5, [pc, #48]	; (650c <_tcc_interrupt_handler+0x54>)
    64da:	464b      	mov	r3, r9
    64dc:	1d1c      	adds	r4, r3, #4
    64de:	2334      	movs	r3, #52	; 0x34
    64e0:	444b      	add	r3, r9
    64e2:	4698      	mov	r8, r3
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
		if (interrupt_and_callback_status_mask & _tcc_intflag[i]) {
    64e4:	682e      	ldr	r6, [r5, #0]
    64e6:	423e      	tst	r6, r7
    64e8:	d005      	beq.n	64f6 <_tcc_interrupt_handler+0x3e>
			/* Invoke the registered and enabled callback function */
			(module->callback[i])(module);
    64ea:	4648      	mov	r0, r9
    64ec:	6823      	ldr	r3, [r4, #0]
    64ee:	4798      	blx	r3
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
    64f0:	464b      	mov	r3, r9
    64f2:	681b      	ldr	r3, [r3, #0]
    64f4:	62de      	str	r6, [r3, #44]	; 0x2c
    64f6:	3504      	adds	r5, #4
    64f8:	3404      	adds	r4, #4
	interrupt_and_callback_status_mask = (module->hw->INTFLAG.reg &
			module->register_callback_mask &
			module->enable_callback_mask);

	/* Check if callback interrupt has occured */
	for (i = 0; i < TCC_CALLBACK_N; i ++) {
    64fa:	4544      	cmp	r4, r8
    64fc:	d1f2      	bne.n	64e4 <_tcc_interrupt_handler+0x2c>
			(module->callback[i])(module);
			/* Clear interrupt flag */
			module->hw->INTFLAG.reg = _tcc_intflag[i];
		}
	}
}
    64fe:	bc0c      	pop	{r2, r3}
    6500:	4690      	mov	r8, r2
    6502:	4699      	mov	r9, r3
    6504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6506:	46c0      	nop			; (mov r8, r8)
    6508:	20000380 	.word	0x20000380
    650c:	0000aee0 	.word	0x0000aee0

00006510 <TCC0_Handler>:
		void TCC##n##_Handler(void) \
		{ \
			_tcc_interrupt_handler(n); \
		}

MREPEAT(TCC_INST_NUM, _TCC_INTERRUPT_HANDLER, 0)
    6510:	b510      	push	{r4, lr}
    6512:	2000      	movs	r0, #0
    6514:	4b01      	ldr	r3, [pc, #4]	; (651c <TCC0_Handler+0xc>)
    6516:	4798      	blx	r3
    6518:	bd10      	pop	{r4, pc}
    651a:	46c0      	nop			; (mov r8, r8)
    651c:	000064b9 	.word	0x000064b9

00006520 <TCC1_Handler>:
    6520:	b510      	push	{r4, lr}
    6522:	2001      	movs	r0, #1
    6524:	4b01      	ldr	r3, [pc, #4]	; (652c <TCC1_Handler+0xc>)
    6526:	4798      	blx	r3
    6528:	bd10      	pop	{r4, pc}
    652a:	46c0      	nop			; (mov r8, r8)
    652c:	000064b9 	.word	0x000064b9

00006530 <TCC2_Handler>:
    6530:	b510      	push	{r4, lr}
    6532:	2002      	movs	r0, #2
    6534:	4b01      	ldr	r3, [pc, #4]	; (653c <TCC2_Handler+0xc>)
    6536:	4798      	blx	r3
    6538:	bd10      	pop	{r4, pc}
    653a:	46c0      	nop			; (mov r8, r8)
    653c:	000064b9 	.word	0x000064b9

00006540 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    6540:	e7fe      	b.n	6540 <Dummy_Handler>
    6542:	46c0      	nop			; (mov r8, r8)

00006544 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    6544:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
    6546:	4b2e      	ldr	r3, [pc, #184]	; (6600 <Reset_Handler+0xbc>)
    6548:	4a2e      	ldr	r2, [pc, #184]	; (6604 <Reset_Handler+0xc0>)
    654a:	429a      	cmp	r2, r3
    654c:	d003      	beq.n	6556 <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
    654e:	4b2e      	ldr	r3, [pc, #184]	; (6608 <Reset_Handler+0xc4>)
    6550:	4a2b      	ldr	r2, [pc, #172]	; (6600 <Reset_Handler+0xbc>)
    6552:	429a      	cmp	r2, r3
    6554:	d304      	bcc.n	6560 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    6556:	4b2d      	ldr	r3, [pc, #180]	; (660c <Reset_Handler+0xc8>)
    6558:	4a2d      	ldr	r2, [pc, #180]	; (6610 <Reset_Handler+0xcc>)
    655a:	429a      	cmp	r2, r3
    655c:	d310      	bcc.n	6580 <Reset_Handler+0x3c>
    655e:	e01e      	b.n	659e <Reset_Handler+0x5a>
    6560:	4a2c      	ldr	r2, [pc, #176]	; (6614 <Reset_Handler+0xd0>)
    6562:	4b29      	ldr	r3, [pc, #164]	; (6608 <Reset_Handler+0xc4>)
    6564:	3303      	adds	r3, #3
    6566:	1a9b      	subs	r3, r3, r2
    6568:	089b      	lsrs	r3, r3, #2
    656a:	3301      	adds	r3, #1
    656c:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    656e:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    6570:	4823      	ldr	r0, [pc, #140]	; (6600 <Reset_Handler+0xbc>)
    6572:	4924      	ldr	r1, [pc, #144]	; (6604 <Reset_Handler+0xc0>)
    6574:	588c      	ldr	r4, [r1, r2]
    6576:	5084      	str	r4, [r0, r2]
    6578:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    657a:	429a      	cmp	r2, r3
    657c:	d1fa      	bne.n	6574 <Reset_Handler+0x30>
    657e:	e7ea      	b.n	6556 <Reset_Handler+0x12>
    6580:	4a25      	ldr	r2, [pc, #148]	; (6618 <Reset_Handler+0xd4>)
    6582:	4b22      	ldr	r3, [pc, #136]	; (660c <Reset_Handler+0xc8>)
    6584:	3303      	adds	r3, #3
    6586:	1a9b      	subs	r3, r3, r2
    6588:	089b      	lsrs	r3, r3, #2
    658a:	3301      	adds	r3, #1
    658c:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    658e:	2200      	movs	r2, #0
                *pDest++ = 0;
    6590:	481f      	ldr	r0, [pc, #124]	; (6610 <Reset_Handler+0xcc>)
    6592:	2100      	movs	r1, #0
    6594:	1814      	adds	r4, r2, r0
    6596:	6021      	str	r1, [r4, #0]
    6598:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    659a:	429a      	cmp	r2, r3
    659c:	d1fa      	bne.n	6594 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    659e:	4a1f      	ldr	r2, [pc, #124]	; (661c <Reset_Handler+0xd8>)
    65a0:	21ff      	movs	r1, #255	; 0xff
    65a2:	4b1f      	ldr	r3, [pc, #124]	; (6620 <Reset_Handler+0xdc>)
    65a4:	438b      	bics	r3, r1
    65a6:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    65a8:	39fd      	subs	r1, #253	; 0xfd
    65aa:	2390      	movs	r3, #144	; 0x90
    65ac:	005b      	lsls	r3, r3, #1
    65ae:	4a1d      	ldr	r2, [pc, #116]	; (6624 <Reset_Handler+0xe0>)
    65b0:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    65b2:	481d      	ldr	r0, [pc, #116]	; (6628 <Reset_Handler+0xe4>)
    65b4:	78c3      	ldrb	r3, [r0, #3]
    65b6:	2403      	movs	r4, #3
    65b8:	43a3      	bics	r3, r4
    65ba:	2202      	movs	r2, #2
    65bc:	4313      	orrs	r3, r2
    65be:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    65c0:	78c3      	ldrb	r3, [r0, #3]
    65c2:	260c      	movs	r6, #12
    65c4:	43b3      	bics	r3, r6
    65c6:	2108      	movs	r1, #8
    65c8:	430b      	orrs	r3, r1
    65ca:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
    65cc:	4b17      	ldr	r3, [pc, #92]	; (662c <Reset_Handler+0xe8>)
    65ce:	7b98      	ldrb	r0, [r3, #14]
    65d0:	2530      	movs	r5, #48	; 0x30
    65d2:	43a8      	bics	r0, r5
    65d4:	0005      	movs	r5, r0
    65d6:	2020      	movs	r0, #32
    65d8:	4328      	orrs	r0, r5
    65da:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    65dc:	7b98      	ldrb	r0, [r3, #14]
    65de:	43b0      	bics	r0, r6
    65e0:	4301      	orrs	r1, r0
    65e2:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    65e4:	7b99      	ldrb	r1, [r3, #14]
    65e6:	43a1      	bics	r1, r4
    65e8:	430a      	orrs	r2, r1
    65ea:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    65ec:	4a10      	ldr	r2, [pc, #64]	; (6630 <Reset_Handler+0xec>)
    65ee:	6851      	ldr	r1, [r2, #4]
    65f0:	2380      	movs	r3, #128	; 0x80
    65f2:	430b      	orrs	r3, r1
    65f4:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    65f6:	4b0f      	ldr	r3, [pc, #60]	; (6634 <Reset_Handler+0xf0>)
    65f8:	4798      	blx	r3

        /* Branch to main function */
        main();
    65fa:	4b0f      	ldr	r3, [pc, #60]	; (6638 <Reset_Handler+0xf4>)
    65fc:	4798      	blx	r3
    65fe:	e7fe      	b.n	65fe <Reset_Handler+0xba>
    6600:	20000000 	.word	0x20000000
    6604:	0000b7a0 	.word	0x0000b7a0
    6608:	20000098 	.word	0x20000098
    660c:	200004f0 	.word	0x200004f0
    6610:	20000098 	.word	0x20000098
    6614:	20000004 	.word	0x20000004
    6618:	2000009c 	.word	0x2000009c
    661c:	e000ed00 	.word	0xe000ed00
    6620:	00000000 	.word	0x00000000
    6624:	41007000 	.word	0x41007000
    6628:	41005000 	.word	0x41005000
    662c:	41004800 	.word	0x41004800
    6630:	41004000 	.word	0x41004000
    6634:	0000864d 	.word	0x0000864d
    6638:	000080a5 	.word	0x000080a5

0000663c <_read>:
int __attribute__((weak))
_read (int file, char * ptr, int len); // Remove GCC compiler warning

int __attribute__((weak))
_read (int file, char * ptr, int len)
{
    663c:	b5f0      	push	{r4, r5, r6, r7, lr}
    663e:	4647      	mov	r7, r8
    6640:	b480      	push	{r7}
    6642:	000c      	movs	r4, r1
    6644:	4690      	mov	r8, r2
	int nChars = 0;

	if (file != 0) {
    6646:	2800      	cmp	r0, #0
    6648:	d10d      	bne.n	6666 <_read+0x2a>
		return -1;
	}

	for (; len > 0; --len) {
    664a:	2a00      	cmp	r2, #0
    664c:	dd0e      	ble.n	666c <_read+0x30>
    664e:	188f      	adds	r7, r1, r2
		ptr_get(stdio_base, ptr);
    6650:	4e08      	ldr	r6, [pc, #32]	; (6674 <_read+0x38>)
    6652:	4d09      	ldr	r5, [pc, #36]	; (6678 <_read+0x3c>)
    6654:	6830      	ldr	r0, [r6, #0]
    6656:	0021      	movs	r1, r4
    6658:	682b      	ldr	r3, [r5, #0]
    665a:	4798      	blx	r3
		ptr++;
    665c:	3401      	adds	r4, #1

	if (file != 0) {
		return -1;
	}

	for (; len > 0; --len) {
    665e:	42a7      	cmp	r7, r4
    6660:	d1f8      	bne.n	6654 <_read+0x18>
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
    6662:	4640      	mov	r0, r8
    6664:	e003      	b.n	666e <_read+0x32>
_read (int file, char * ptr, int len)
{
	int nChars = 0;

	if (file != 0) {
		return -1;
    6666:	2001      	movs	r0, #1
    6668:	4240      	negs	r0, r0
    666a:	e000      	b.n	666e <_read+0x32>
	}

	for (; len > 0; --len) {
    666c:	2000      	movs	r0, #0
		ptr_get(stdio_base, ptr);
		ptr++;
		nChars++;
	}
	return nChars;
}
    666e:	bc04      	pop	{r2}
    6670:	4690      	mov	r8, r2
    6672:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6674:	20000394 	.word	0x20000394
    6678:	2000038c 	.word	0x2000038c

0000667c <_write>:
int __attribute__((weak))
_write (int file, char * ptr, int len);

int __attribute__((weak))
_write (int file, char * ptr, int len)
{
    667c:	b5f0      	push	{r4, r5, r6, r7, lr}
    667e:	4647      	mov	r7, r8
    6680:	b480      	push	{r7}
    6682:	000e      	movs	r6, r1
    6684:	0015      	movs	r5, r2
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
    6686:	3801      	subs	r0, #1
    6688:	2802      	cmp	r0, #2
    668a:	d811      	bhi.n	66b0 <_write+0x34>
		return -1;
	}

	for (; len != 0; --len) {
    668c:	2a00      	cmp	r2, #0
    668e:	d012      	beq.n	66b6 <_write+0x3a>
    6690:	2400      	movs	r4, #0
		if (ptr_put(stdio_base, *ptr++) < 0) {
    6692:	4b0c      	ldr	r3, [pc, #48]	; (66c4 <_write+0x48>)
    6694:	4698      	mov	r8, r3
    6696:	4f0c      	ldr	r7, [pc, #48]	; (66c8 <_write+0x4c>)
    6698:	4643      	mov	r3, r8
    669a:	6818      	ldr	r0, [r3, #0]
    669c:	5d31      	ldrb	r1, [r6, r4]
    669e:	683b      	ldr	r3, [r7, #0]
    66a0:	4798      	blx	r3
    66a2:	2800      	cmp	r0, #0
    66a4:	db09      	blt.n	66ba <_write+0x3e>
			return -1;
		}
		++nChars;
    66a6:	3401      	adds	r4, #1

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
	}

	for (; len != 0; --len) {
    66a8:	42a5      	cmp	r5, r4
    66aa:	d1f5      	bne.n	6698 <_write+0x1c>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
		}
		++nChars;
    66ac:	0020      	movs	r0, r4
    66ae:	e006      	b.n	66be <_write+0x42>
_write (int file, char * ptr, int len)
{
	int nChars = 0;

	if ((file != 1) && (file != 2) && (file!=3)) {
		return -1;
    66b0:	2001      	movs	r0, #1
    66b2:	4240      	negs	r0, r0
    66b4:	e003      	b.n	66be <_write+0x42>
	}

	for (; len != 0; --len) {
    66b6:	2000      	movs	r0, #0
    66b8:	e001      	b.n	66be <_write+0x42>
		if (ptr_put(stdio_base, *ptr++) < 0) {
			return -1;
    66ba:	2001      	movs	r0, #1
    66bc:	4240      	negs	r0, r0
		}
		++nChars;
	}
	return nChars;
}
    66be:	bc04      	pop	{r2}
    66c0:	4690      	mov	r8, r2
    66c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    66c4:	20000394 	.word	0x20000394
    66c8:	20000390 	.word	0x20000390

000066cc <_sbrk>:
extern void _exit(int status);
extern void _kill(int pid, int sig);
extern int _getpid(void);

extern caddr_t _sbrk(int incr)
{
    66cc:	0003      	movs	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;

	if (heap == NULL) {
    66ce:	4a06      	ldr	r2, [pc, #24]	; (66e8 <_sbrk+0x1c>)
    66d0:	6812      	ldr	r2, [r2, #0]
    66d2:	2a00      	cmp	r2, #0
    66d4:	d102      	bne.n	66dc <_sbrk+0x10>
		heap = (unsigned char *)&_end;
    66d6:	4905      	ldr	r1, [pc, #20]	; (66ec <_sbrk+0x20>)
    66d8:	4a03      	ldr	r2, [pc, #12]	; (66e8 <_sbrk+0x1c>)
    66da:	6011      	str	r1, [r2, #0]
	}
	prev_heap = heap;
    66dc:	4a02      	ldr	r2, [pc, #8]	; (66e8 <_sbrk+0x1c>)
    66de:	6810      	ldr	r0, [r2, #0]

	heap += incr;
    66e0:	18c3      	adds	r3, r0, r3
    66e2:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap;
}
    66e4:	4770      	bx	lr
    66e6:	46c0      	nop			; (mov r8, r8)
    66e8:	20000164 	.word	0x20000164
    66ec:	200024f0 	.word	0x200024f0

000066f0 <_close>:
}

extern int _close(int file)
{
	return -1;
}
    66f0:	2001      	movs	r0, #1
    66f2:	4240      	negs	r0, r0
    66f4:	4770      	bx	lr
    66f6:	46c0      	nop			; (mov r8, r8)

000066f8 <_fstat>:

extern int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
    66f8:	2380      	movs	r3, #128	; 0x80
    66fa:	019b      	lsls	r3, r3, #6
    66fc:	604b      	str	r3, [r1, #4]

	return 0;
}
    66fe:	2000      	movs	r0, #0
    6700:	4770      	bx	lr
    6702:	46c0      	nop			; (mov r8, r8)

00006704 <_isatty>:

extern int _isatty(int file)
{
	return 1;
}
    6704:	2001      	movs	r0, #1
    6706:	4770      	bx	lr

00006708 <_lseek>:

extern int _lseek(int file, int ptr, int dir)
{
	return 0;
}
    6708:	2000      	movs	r0, #0
    670a:	4770      	bx	lr

0000670c <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
    670c:	b510      	push	{r4, lr}
	switch (mem_test_unit_ready(drv)) {
    670e:	4b05      	ldr	r3, [pc, #20]	; (6724 <disk_status+0x18>)
    6710:	4798      	blx	r3
    6712:	1e03      	subs	r3, r0, #0
    6714:	d004      	beq.n	6720 <disk_status+0x14>
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
    6716:	2003      	movs	r0, #3
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
	switch (mem_test_unit_ready(drv)) {
    6718:	2b02      	cmp	r3, #2
    671a:	d002      	beq.n	6722 <disk_status+0x16>
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
    671c:	3802      	subs	r0, #2
    671e:	e000      	b.n	6722 <disk_status+0x16>
 */
DSTATUS disk_status(BYTE drv)
{
	switch (mem_test_unit_ready(drv)) {
	case CTRL_GOOD:
		return 0;
    6720:	2000      	movs	r0, #0
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
	}
}
    6722:	bd10      	pop	{r4, pc}
    6724:	00004301 	.word	0x00004301

00006728 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
    6728:	b5f0      	push	{r4, r5, r6, r7, lr}
    672a:	4657      	mov	r7, sl
    672c:	464e      	mov	r6, r9
    672e:	4645      	mov	r5, r8
    6730:	b4e0      	push	{r5, r6, r7}
    6732:	b084      	sub	sp, #16
    6734:	9001      	str	r0, [sp, #4]
    6736:	000f      	movs	r7, r1
    6738:	0015      	movs	r5, r2
    673a:	001c      	movs	r4, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
    673c:	4b17      	ldr	r3, [pc, #92]	; (679c <disk_read+0x74>)
    673e:	4798      	blx	r3
    6740:	0006      	movs	r6, r0
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
		return RES_ERROR;
    6742:	2001      	movs	r0, #1
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
    6744:	2e00      	cmp	r6, #0
    6746:	d023      	beq.n	6790 <disk_read+0x68>
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
    6748:	a903      	add	r1, sp, #12
    674a:	9801      	ldr	r0, [sp, #4]
    674c:	4b14      	ldr	r3, [pc, #80]	; (67a0 <disk_read+0x78>)
    674e:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
    6750:	46b0      	mov	r8, r6
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
    6752:	0032      	movs	r2, r6
    6754:	4362      	muls	r2, r4
    6756:	1952      	adds	r2, r2, r5
    6758:	9b03      	ldr	r3, [sp, #12]
    675a:	3301      	adds	r3, #1
    675c:	4373      	muls	r3, r6
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
    675e:	2004      	movs	r0, #4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
    6760:	429a      	cmp	r2, r3
    6762:	d815      	bhi.n	6790 <disk_read+0x68>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
    6764:	46a1      	mov	r9, r4
    6766:	2c00      	cmp	r4, #0
    6768:	d00f      	beq.n	678a <disk_read+0x62>
    676a:	0273      	lsls	r3, r6, #9
    676c:	469a      	mov	sl, r3
    676e:	2400      	movs	r4, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
    6770:	4e0c      	ldr	r6, [pc, #48]	; (67a4 <disk_read+0x7c>)
    6772:	003a      	movs	r2, r7
    6774:	0029      	movs	r1, r5
    6776:	9801      	ldr	r0, [sp, #4]
    6778:	47b0      	blx	r6
    677a:	2800      	cmp	r0, #0
    677c:	d107      	bne.n	678e <disk_read+0x66>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
    677e:	3401      	adds	r4, #1
    6780:	4445      	add	r5, r8
    6782:	4457      	add	r7, sl
    6784:	454c      	cmp	r4, r9
    6786:	d3f4      	bcc.n	6772 <disk_read+0x4a>
    6788:	e002      	b.n	6790 <disk_read+0x68>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
    678a:	2000      	movs	r0, #0
    678c:	e000      	b.n	6790 <disk_read+0x68>
	/* Read the data */
	for (i = 0; i < count; i++) {
		if (memory_2_ram(drv, sector + uc_sector_size * i,
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
    678e:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
    6790:	b004      	add	sp, #16
    6792:	bc1c      	pop	{r2, r3, r4}
    6794:	4690      	mov	r8, r2
    6796:	4699      	mov	r9, r3
    6798:	46a2      	mov	sl, r4
    679a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    679c:	00004331 	.word	0x00004331
    67a0:	00004319 	.word	0x00004319
    67a4:	00004339 	.word	0x00004339

000067a8 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
    67a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    67aa:	4657      	mov	r7, sl
    67ac:	464e      	mov	r6, r9
    67ae:	4645      	mov	r5, r8
    67b0:	b4e0      	push	{r5, r6, r7}
    67b2:	b084      	sub	sp, #16
    67b4:	9001      	str	r0, [sp, #4]
    67b6:	000f      	movs	r7, r1
    67b8:	0015      	movs	r5, r2
    67ba:	001c      	movs	r4, r3
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
    67bc:	4b17      	ldr	r3, [pc, #92]	; (681c <disk_write+0x74>)
    67be:	4798      	blx	r3
    67c0:	0006      	movs	r6, r0
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
		return RES_ERROR;
    67c2:	2001      	movs	r0, #1
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
    67c4:	2e00      	cmp	r6, #0
    67c6:	d023      	beq.n	6810 <disk_write+0x68>
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
    67c8:	a903      	add	r1, sp, #12
    67ca:	9801      	ldr	r0, [sp, #4]
    67cc:	4b14      	ldr	r3, [pc, #80]	; (6820 <disk_write+0x78>)
    67ce:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
    67d0:	46b0      	mov	r8, r6
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
    67d2:	0032      	movs	r2, r6
    67d4:	4362      	muls	r2, r4
    67d6:	1952      	adds	r2, r2, r5
    67d8:	9b03      	ldr	r3, [sp, #12]
    67da:	3301      	adds	r3, #1
    67dc:	4373      	muls	r3, r6
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
    67de:	2004      	movs	r0, #4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
    67e0:	429a      	cmp	r2, r3
    67e2:	d815      	bhi.n	6810 <disk_write+0x68>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
    67e4:	46a1      	mov	r9, r4
    67e6:	2c00      	cmp	r4, #0
    67e8:	d00f      	beq.n	680a <disk_write+0x62>
    67ea:	0273      	lsls	r3, r6, #9
    67ec:	469a      	mov	sl, r3
    67ee:	2400      	movs	r4, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
    67f0:	4e0c      	ldr	r6, [pc, #48]	; (6824 <disk_write+0x7c>)
    67f2:	003a      	movs	r2, r7
    67f4:	0029      	movs	r1, r5
    67f6:	9801      	ldr	r0, [sp, #4]
    67f8:	47b0      	blx	r6
    67fa:	2800      	cmp	r0, #0
    67fc:	d107      	bne.n	680e <disk_write+0x66>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
    67fe:	3401      	adds	r4, #1
    6800:	4445      	add	r5, r8
    6802:	4457      	add	r7, sl
    6804:	454c      	cmp	r4, r9
    6806:	d3f4      	bcc.n	67f2 <disk_write+0x4a>
    6808:	e002      	b.n	6810 <disk_write+0x68>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
    680a:	2000      	movs	r0, #0
    680c:	e000      	b.n	6810 <disk_write+0x68>
	/* Write the data */
	for (i = 0; i < count; i++) {
		if (ram_2_memory(drv, sector + uc_sector_size * i,
				buff + uc_sector_size * SECTOR_SIZE_DEFAULT * i) !=
				CTRL_GOOD) {
			return RES_ERROR;
    680e:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
    6810:	b004      	add	sp, #16
    6812:	bc1c      	pop	{r2, r3, r4}
    6814:	4690      	mov	r8, r2
    6816:	4699      	mov	r9, r3
    6818:	46a2      	mov	sl, r4
    681a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    681c:	00004331 	.word	0x00004331
    6820:	00004319 	.word	0x00004319
    6824:	00004355 	.word	0x00004355

00006828 <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
    6828:	b510      	push	{r4, lr}
    682a:	b082      	sub	sp, #8
    682c:	0014      	movs	r4, r2
	DRESULT res = RES_PARERR;

	switch (ctrl) {
    682e:	2901      	cmp	r1, #1
    6830:	d00a      	beq.n	6848 <disk_ioctl+0x20>
    6832:	2900      	cmp	r1, #0
    6834:	d01f      	beq.n	6876 <disk_ioctl+0x4e>
    6836:	2902      	cmp	r1, #2
    6838:	d00e      	beq.n	6858 <disk_ioctl+0x30>
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
    683a:	2004      	movs	r0, #4
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
	DRESULT res = RES_PARERR;

	switch (ctrl) {
    683c:	2903      	cmp	r1, #3
    683e:	d121      	bne.n	6884 <disk_ioctl+0x5c>
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
    6840:	2301      	movs	r3, #1
    6842:	6013      	str	r3, [r2, #0]
		res = RES_OK;
    6844:	2000      	movs	r0, #0
		break;
    6846:	e01d      	b.n	6884 <disk_ioctl+0x5c>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
    6848:	a901      	add	r1, sp, #4
    684a:	4b0f      	ldr	r3, [pc, #60]	; (6888 <disk_ioctl+0x60>)
    684c:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
    684e:	9b01      	ldr	r3, [sp, #4]
    6850:	3301      	adds	r3, #1
    6852:	6023      	str	r3, [r4, #0]

		res = RES_OK;
    6854:	2000      	movs	r0, #0
	}
	break;
    6856:	e015      	b.n	6884 <disk_ioctl+0x5c>

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
    6858:	4b0c      	ldr	r3, [pc, #48]	; (688c <disk_ioctl+0x64>)
    685a:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
    685c:	1e43      	subs	r3, r0, #1
    685e:	b2db      	uxtb	r3, r3
    6860:	2b01      	cmp	r3, #1
    6862:	d904      	bls.n	686e <disk_ioctl+0x46>
				(uc_sector_size != SECTOR_SIZE_1024) &&
    6864:	1f03      	subs	r3, r0, #4
				(uc_sector_size != SECTOR_SIZE_2048) &&
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
    6866:	2001      	movs	r0, #1
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);

		if ((uc_sector_size != SECTOR_SIZE_512) &&
				(uc_sector_size != SECTOR_SIZE_1024) &&
    6868:	22fb      	movs	r2, #251	; 0xfb
    686a:	4213      	tst	r3, r2
    686c:	d10a      	bne.n	6884 <disk_ioctl+0x5c>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
    686e:	2300      	movs	r3, #0
    6870:	7023      	strb	r3, [r4, #0]

		res = RES_OK;
    6872:	2000      	movs	r0, #0
	}
	break;
    6874:	e006      	b.n	6884 <disk_ioctl+0x5c>

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
    6876:	4b06      	ldr	r3, [pc, #24]	; (6890 <disk_ioctl+0x68>)
    6878:	4798      	blx	r3
    687a:	2800      	cmp	r0, #0
    687c:	d001      	beq.n	6882 <disk_ioctl+0x5a>
			res = RES_OK;
		} else {
			res = RES_NOTRDY;
    687e:	2003      	movs	r0, #3
    6880:	e000      	b.n	6884 <disk_ioctl+0x5c>
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
			res = RES_OK;
    6882:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
    6884:	b002      	add	sp, #8
    6886:	bd10      	pop	{r4, pc}
    6888:	00004319 	.word	0x00004319
    688c:	00004331 	.word	0x00004331
    6890:	00004301 	.word	0x00004301

00006894 <get_fattime>:
 * bit4:0    Second (0..29)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
    6894:	b500      	push	{lr}
    6896:	b083      	sub	sp, #12
	uint32_t ul_time;
	struct rtc_calendar_time current_time;

	/* Retrieve date and time */
	rtc_calendar_get_time(&rtc_instance, &current_time);
    6898:	4669      	mov	r1, sp
    689a:	480f      	ldr	r0, [pc, #60]	; (68d8 <get_fattime+0x44>)
    689c:	4b0f      	ldr	r3, [pc, #60]	; (68dc <get_fattime+0x48>)
    689e:	4798      	blx	r3

	ul_time = ((current_time.year - 1980) << 25)
    68a0:	466b      	mov	r3, sp
    68a2:	7958      	ldrb	r0, [r3, #5]
    68a4:	0540      	lsls	r0, r0, #21
    68a6:	791b      	ldrb	r3, [r3, #4]
    68a8:	041b      	lsls	r3, r3, #16
    68aa:	4318      	orrs	r0, r3
    68ac:	466b      	mov	r3, sp
    68ae:	789b      	ldrb	r3, [r3, #2]
    68b0:	02db      	lsls	r3, r3, #11
    68b2:	4318      	orrs	r0, r3
    68b4:	466b      	mov	r3, sp
    68b6:	785b      	ldrb	r3, [r3, #1]
    68b8:	015b      	lsls	r3, r3, #5
    68ba:	4318      	orrs	r0, r3
    68bc:	466b      	mov	r3, sp
    68be:	781b      	ldrb	r3, [r3, #0]
    68c0:	085b      	lsrs	r3, r3, #1
    68c2:	4318      	orrs	r0, r3
    68c4:	466b      	mov	r3, sp
    68c6:	88db      	ldrh	r3, [r3, #6]
    68c8:	4a05      	ldr	r2, [pc, #20]	; (68e0 <get_fattime+0x4c>)
    68ca:	4694      	mov	ip, r2
    68cc:	4463      	add	r3, ip
    68ce:	065b      	lsls	r3, r3, #25
    68d0:	4318      	orrs	r0, r3
			| (current_time.hour << 11)
			| (current_time.minute << 5)
			| ((current_time.second >> 1) << 0);

	return ul_time;
}
    68d2:	b003      	add	sp, #12
    68d4:	bd00      	pop	{pc}
    68d6:	46c0      	nop			; (mov r8, r8)
    68d8:	20000398 	.word	0x20000398
    68dc:	0000465d 	.word	0x0000465d
    68e0:	fffff844 	.word	0xfffff844

000068e4 <mem_set>:
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    68e4:	2a00      	cmp	r2, #0
    68e6:	d005      	beq.n	68f4 <mem_set+0x10>
    68e8:	0003      	movs	r3, r0
    68ea:	1882      	adds	r2, r0, r2
		*d++ = (BYTE)val;
    68ec:	7019      	strb	r1, [r3, #0]
    68ee:	3301      	adds	r3, #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    68f0:	4293      	cmp	r3, r2
    68f2:	d1fb      	bne.n	68ec <mem_set+0x8>
		*d++ = (BYTE)val;
}
    68f4:	4770      	bx	lr
    68f6:	46c0      	nop			; (mov r8, r8)

000068f8 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
    68f8:	b510      	push	{r4, lr}
	if (!fs || !fs->fs_type || fs->id != id)
    68fa:	2800      	cmp	r0, #0
    68fc:	d00e      	beq.n	691c <validate+0x24>
    68fe:	7802      	ldrb	r2, [r0, #0]
		return FR_INVALID_OBJECT;
    6900:	2309      	movs	r3, #9
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
    6902:	2a00      	cmp	r2, #0
    6904:	d00b      	beq.n	691e <validate+0x26>
    6906:	88c2      	ldrh	r2, [r0, #6]
    6908:	428a      	cmp	r2, r1
    690a:	d108      	bne.n	691e <validate+0x26>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
    690c:	7840      	ldrb	r0, [r0, #1]
    690e:	4b05      	ldr	r3, [pc, #20]	; (6924 <validate+0x2c>)
    6910:	4798      	blx	r3
		return FR_NOT_READY;
    6912:	2303      	movs	r3, #3

	return FR_OK;
    6914:	07c0      	lsls	r0, r0, #31
    6916:	17c0      	asrs	r0, r0, #31
    6918:	4003      	ands	r3, r0
    691a:	e000      	b.n	691e <validate+0x26>
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
		return FR_INVALID_OBJECT;
    691c:	2309      	movs	r3, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
    691e:	0018      	movs	r0, r3
    6920:	bd10      	pop	{r4, pc}
    6922:	46c0      	nop			; (mov r8, r8)
    6924:	0000670d 	.word	0x0000670d

00006928 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    6928:	b5f0      	push	{r4, r5, r6, r7, lr}
    692a:	464f      	mov	r7, r9
    692c:	b480      	push	{r7}
    692e:	b082      	sub	sp, #8
    6930:	0004      	movs	r4, r0
    6932:	000f      	movs	r7, r1
	DWORD wsect;


	wsect = fs->winsect;
    6934:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
    6936:	428d      	cmp	r5, r1
    6938:	d039      	beq.n	69ae <move_window+0x86>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
    693a:	7903      	ldrb	r3, [r0, #4]
    693c:	2b00      	cmp	r3, #0
    693e:	d026      	beq.n	698e <move_window+0x66>
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    6940:	2330      	movs	r3, #48	; 0x30
    6942:	469c      	mov	ip, r3
    6944:	4484      	add	ip, r0
    6946:	4663      	mov	r3, ip
    6948:	4661      	mov	r1, ip
    694a:	9301      	str	r3, [sp, #4]
    694c:	7840      	ldrb	r0, [r0, #1]
    694e:	2301      	movs	r3, #1
    6950:	002a      	movs	r2, r5
    6952:	4e1a      	ldr	r6, [pc, #104]	; (69bc <move_window+0x94>)
    6954:	47b0      	blx	r6
				return FR_DISK_ERR;
    6956:	2301      	movs	r3, #1

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    6958:	2800      	cmp	r0, #0
    695a:	d129      	bne.n	69b0 <move_window+0x88>
				return FR_DISK_ERR;
			fs->wflag = 0;
    695c:	2300      	movs	r3, #0
    695e:	7123      	strb	r3, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    6960:	6a23      	ldr	r3, [r4, #32]
    6962:	69e2      	ldr	r2, [r4, #28]
    6964:	4694      	mov	ip, r2
    6966:	4463      	add	r3, ip
    6968:	429d      	cmp	r5, r3
    696a:	d210      	bcs.n	698e <move_window+0x66>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    696c:	78e6      	ldrb	r6, [r4, #3]
    696e:	2e01      	cmp	r6, #1
    6970:	d90d      	bls.n	698e <move_window+0x66>
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
    6972:	4b12      	ldr	r3, [pc, #72]	; (69bc <move_window+0x94>)
    6974:	4699      	mov	r9, r3
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
					wsect += fs->fsize;
    6976:	69e3      	ldr	r3, [r4, #28]
    6978:	469c      	mov	ip, r3
    697a:	4465      	add	r5, ip
					disk_write(fs->drv, fs->win, wsect, 1);
    697c:	7860      	ldrb	r0, [r4, #1]
    697e:	2301      	movs	r3, #1
    6980:	002a      	movs	r2, r5
    6982:	9901      	ldr	r1, [sp, #4]
    6984:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    6986:	3e01      	subs	r6, #1
    6988:	b2f6      	uxtb	r6, r6
    698a:	2e01      	cmp	r6, #1
    698c:	d1f3      	bne.n	6976 <move_window+0x4e>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
    698e:	2300      	movs	r3, #0
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    6990:	2f00      	cmp	r7, #0
    6992:	d00d      	beq.n	69b0 <move_window+0x88>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    6994:	0021      	movs	r1, r4
    6996:	3130      	adds	r1, #48	; 0x30
    6998:	7860      	ldrb	r0, [r4, #1]
    699a:	3301      	adds	r3, #1
    699c:	003a      	movs	r2, r7
    699e:	4d08      	ldr	r5, [pc, #32]	; (69c0 <move_window+0x98>)
    69a0:	47a8      	blx	r5
				return FR_DISK_ERR;
    69a2:	2301      	movs	r3, #1
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    69a4:	2800      	cmp	r0, #0
    69a6:	d103      	bne.n	69b0 <move_window+0x88>
				return FR_DISK_ERR;
			fs->winsect = sector;
    69a8:	62e7      	str	r7, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
    69aa:	2300      	movs	r3, #0
    69ac:	e000      	b.n	69b0 <move_window+0x88>
    69ae:	2300      	movs	r3, #0
}
    69b0:	0018      	movs	r0, r3
    69b2:	b002      	add	sp, #8
    69b4:	bc04      	pop	{r2}
    69b6:	4691      	mov	r9, r2
    69b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    69ba:	46c0      	nop			; (mov r8, r8)
    69bc:	000067a9 	.word	0x000067a9
    69c0:	00006729 	.word	0x00006729

000069c4 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
    69c4:	b570      	push	{r4, r5, r6, lr}
    69c6:	0004      	movs	r4, r0
	FRESULT res;


	res = move_window(fs, 0);
    69c8:	2100      	movs	r1, #0
    69ca:	4b2c      	ldr	r3, [pc, #176]	; (6a7c <sync+0xb8>)
    69cc:	4798      	blx	r3
	if (res == FR_OK) {
    69ce:	2800      	cmp	r0, #0
    69d0:	d152      	bne.n	6a78 <sync+0xb4>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    69d2:	7823      	ldrb	r3, [r4, #0]
    69d4:	2b03      	cmp	r3, #3
    69d6:	d147      	bne.n	6a68 <sync+0xa4>
    69d8:	7963      	ldrb	r3, [r4, #5]
    69da:	2b00      	cmp	r3, #0
    69dc:	d044      	beq.n	6a68 <sync+0xa4>
			fs->winsect = 0;
    69de:	2600      	movs	r6, #0
    69e0:	62e6      	str	r6, [r4, #44]	; 0x2c
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
    69e2:	0025      	movs	r5, r4
    69e4:	3530      	adds	r5, #48	; 0x30
    69e6:	2280      	movs	r2, #128	; 0x80
    69e8:	0092      	lsls	r2, r2, #2
    69ea:	2100      	movs	r1, #0
    69ec:	0028      	movs	r0, r5
    69ee:	4b24      	ldr	r3, [pc, #144]	; (6a80 <sync+0xbc>)
    69f0:	4798      	blx	r3
			ST_WORD(fs->win+BS_55AA, 0xAA55);
    69f2:	2255      	movs	r2, #85	; 0x55
    69f4:	4b23      	ldr	r3, [pc, #140]	; (6a84 <sync+0xc0>)
    69f6:	54e2      	strb	r2, [r4, r3]
    69f8:	3255      	adds	r2, #85	; 0x55
    69fa:	4b23      	ldr	r3, [pc, #140]	; (6a88 <sync+0xc4>)
    69fc:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    69fe:	3bde      	subs	r3, #222	; 0xde
    6a00:	3bff      	subs	r3, #255	; 0xff
    6a02:	3a7a      	subs	r2, #122	; 0x7a
    6a04:	54a3      	strb	r3, [r4, r2]
    6a06:	3201      	adds	r2, #1
    6a08:	54a3      	strb	r3, [r4, r2]
    6a0a:	330f      	adds	r3, #15
    6a0c:	3201      	adds	r2, #1
    6a0e:	54a3      	strb	r3, [r4, r2]
    6a10:	320f      	adds	r2, #15
    6a12:	2133      	movs	r1, #51	; 0x33
    6a14:	5462      	strb	r2, [r4, r1]
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    6a16:	313f      	adds	r1, #63	; 0x3f
    6a18:	2085      	movs	r0, #133	; 0x85
    6a1a:	0080      	lsls	r0, r0, #2
    6a1c:	5421      	strb	r1, [r4, r0]
    6a1e:	481b      	ldr	r0, [pc, #108]	; (6a8c <sync+0xc8>)
    6a20:	5421      	strb	r1, [r4, r0]
    6a22:	491b      	ldr	r1, [pc, #108]	; (6a90 <sync+0xcc>)
    6a24:	5462      	strb	r2, [r4, r1]
    6a26:	4a1b      	ldr	r2, [pc, #108]	; (6a94 <sync+0xd0>)
    6a28:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    6a2a:	6923      	ldr	r3, [r4, #16]
    6a2c:	3201      	adds	r2, #1
    6a2e:	54a3      	strb	r3, [r4, r2]
    6a30:	1219      	asrs	r1, r3, #8
    6a32:	4a19      	ldr	r2, [pc, #100]	; (6a98 <sync+0xd4>)
    6a34:	54a1      	strb	r1, [r4, r2]
    6a36:	0c19      	lsrs	r1, r3, #16
    6a38:	4a18      	ldr	r2, [pc, #96]	; (6a9c <sync+0xd8>)
    6a3a:	54a1      	strb	r1, [r4, r2]
    6a3c:	0e1b      	lsrs	r3, r3, #24
    6a3e:	4a18      	ldr	r2, [pc, #96]	; (6aa0 <sync+0xdc>)
    6a40:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    6a42:	68e3      	ldr	r3, [r4, #12]
    6a44:	3201      	adds	r2, #1
    6a46:	54a3      	strb	r3, [r4, r2]
    6a48:	1219      	asrs	r1, r3, #8
    6a4a:	4a16      	ldr	r2, [pc, #88]	; (6aa4 <sync+0xe0>)
    6a4c:	54a1      	strb	r1, [r4, r2]
    6a4e:	0c19      	lsrs	r1, r3, #16
    6a50:	4a15      	ldr	r2, [pc, #84]	; (6aa8 <sync+0xe4>)
    6a52:	54a1      	strb	r1, [r4, r2]
    6a54:	0e1b      	lsrs	r3, r3, #24
    6a56:	4a15      	ldr	r2, [pc, #84]	; (6aac <sync+0xe8>)
    6a58:	54a3      	strb	r3, [r4, r2]
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    6a5a:	7860      	ldrb	r0, [r4, #1]
    6a5c:	2301      	movs	r3, #1
    6a5e:	6962      	ldr	r2, [r4, #20]
    6a60:	0029      	movs	r1, r5
    6a62:	4d13      	ldr	r5, [pc, #76]	; (6ab0 <sync+0xec>)
    6a64:	47a8      	blx	r5
			fs->fsi_flag = 0;
    6a66:	7166      	strb	r6, [r4, #5]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    6a68:	7860      	ldrb	r0, [r4, #1]
    6a6a:	2200      	movs	r2, #0
    6a6c:	2100      	movs	r1, #0
    6a6e:	4b11      	ldr	r3, [pc, #68]	; (6ab4 <sync+0xf0>)
    6a70:	4798      	blx	r3
)
{
	FRESULT res;


	res = move_window(fs, 0);
    6a72:	1e43      	subs	r3, r0, #1
    6a74:	4198      	sbcs	r0, r3
    6a76:	b2c0      	uxtb	r0, r0
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
			res = FR_DISK_ERR;
	}

	return res;
}
    6a78:	bd70      	pop	{r4, r5, r6, pc}
    6a7a:	46c0      	nop			; (mov r8, r8)
    6a7c:	00006929 	.word	0x00006929
    6a80:	000068e5 	.word	0x000068e5
    6a84:	0000022e 	.word	0x0000022e
    6a88:	0000022f 	.word	0x0000022f
    6a8c:	00000215 	.word	0x00000215
    6a90:	00000216 	.word	0x00000216
    6a94:	00000217 	.word	0x00000217
    6a98:	00000219 	.word	0x00000219
    6a9c:	0000021a 	.word	0x0000021a
    6aa0:	0000021b 	.word	0x0000021b
    6aa4:	0000021d 	.word	0x0000021d
    6aa8:	0000021e 	.word	0x0000021e
    6aac:	0000021f 	.word	0x0000021f
    6ab0:	000067a9 	.word	0x000067a9
    6ab4:	00006829 	.word	0x00006829

00006ab8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
    6ab8:	b570      	push	{r4, r5, r6, lr}
    6aba:	0004      	movs	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    6abc:	8881      	ldrh	r1, [r0, #4]
    6abe:	6800      	ldr	r0, [r0, #0]
    6ac0:	4b1c      	ldr	r3, [pc, #112]	; (6b34 <f_sync+0x7c>)
    6ac2:	4798      	blx	r3
	if (res == FR_OK) {
    6ac4:	2800      	cmp	r0, #0
    6ac6:	d133      	bne.n	6b30 <f_sync+0x78>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    6ac8:	79a3      	ldrb	r3, [r4, #6]
    6aca:	069b      	lsls	r3, r3, #26
    6acc:	d530      	bpl.n	6b30 <f_sync+0x78>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    6ace:	69e1      	ldr	r1, [r4, #28]
    6ad0:	6820      	ldr	r0, [r4, #0]
    6ad2:	4b19      	ldr	r3, [pc, #100]	; (6b38 <f_sync+0x80>)
    6ad4:	4798      	blx	r3
			if (res == FR_OK) {
    6ad6:	2800      	cmp	r0, #0
    6ad8:	d12a      	bne.n	6b30 <f_sync+0x78>
				dir = fp->dir_ptr;
    6ada:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    6adc:	7aea      	ldrb	r2, [r5, #11]
    6ade:	2320      	movs	r3, #32
    6ae0:	4313      	orrs	r3, r2
    6ae2:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    6ae4:	7b23      	ldrb	r3, [r4, #12]
    6ae6:	772b      	strb	r3, [r5, #28]
    6ae8:	68e3      	ldr	r3, [r4, #12]
    6aea:	121b      	asrs	r3, r3, #8
    6aec:	776b      	strb	r3, [r5, #29]
    6aee:	89e3      	ldrh	r3, [r4, #14]
    6af0:	77ab      	strb	r3, [r5, #30]
    6af2:	7be3      	ldrb	r3, [r4, #15]
    6af4:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    6af6:	7c23      	ldrb	r3, [r4, #16]
    6af8:	76ab      	strb	r3, [r5, #26]
    6afa:	6923      	ldr	r3, [r4, #16]
    6afc:	121b      	asrs	r3, r3, #8
    6afe:	76eb      	strb	r3, [r5, #27]
    6b00:	8a63      	ldrh	r3, [r4, #18]
    6b02:	752b      	strb	r3, [r5, #20]
    6b04:	8a63      	ldrh	r3, [r4, #18]
    6b06:	121b      	asrs	r3, r3, #8
    6b08:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
    6b0a:	4b0c      	ldr	r3, [pc, #48]	; (6b3c <f_sync+0x84>)
    6b0c:	4798      	blx	r3
				ST_DWORD(dir+DIR_WrtTime, tim);
    6b0e:	75a8      	strb	r0, [r5, #22]
    6b10:	1203      	asrs	r3, r0, #8
    6b12:	75eb      	strb	r3, [r5, #23]
    6b14:	0c03      	lsrs	r3, r0, #16
    6b16:	762b      	strb	r3, [r5, #24]
    6b18:	0e00      	lsrs	r0, r0, #24
    6b1a:	7668      	strb	r0, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
    6b1c:	79a3      	ldrb	r3, [r4, #6]
    6b1e:	2220      	movs	r2, #32
    6b20:	4393      	bics	r3, r2
    6b22:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    6b24:	2301      	movs	r3, #1
    6b26:	6822      	ldr	r2, [r4, #0]
    6b28:	7113      	strb	r3, [r2, #4]
				res = sync(fp->fs);
    6b2a:	6820      	ldr	r0, [r4, #0]
    6b2c:	4b04      	ldr	r3, [pc, #16]	; (6b40 <f_sync+0x88>)
    6b2e:	4798      	blx	r3
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    6b30:	bd70      	pop	{r4, r5, r6, pc}
    6b32:	46c0      	nop			; (mov r8, r8)
    6b34:	000068f9 	.word	0x000068f9
    6b38:	00006929 	.word	0x00006929
    6b3c:	00006895 	.word	0x00006895
    6b40:	000069c5 	.word	0x000069c5

00006b44 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    6b44:	b510      	push	{r4, lr}
    6b46:	0004      	movs	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
    6b48:	4b03      	ldr	r3, [pc, #12]	; (6b58 <f_close+0x14>)
    6b4a:	4798      	blx	r3
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    6b4c:	2800      	cmp	r0, #0
    6b4e:	d101      	bne.n	6b54 <f_close+0x10>
    6b50:	2300      	movs	r3, #0
    6b52:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
    6b54:	bd10      	pop	{r4, pc}
    6b56:	46c0      	nop			; (mov r8, r8)
    6b58:	00006ab9 	.word	0x00006ab9

00006b5c <_http_client_send_wait>:
		module->cb(module, HTTP_CLIENT_CALLBACK_DISCONNECTED, &data);
	}
}

int _http_client_send_wait(void *_module, char *buffer, size_t buffer_len)
{
    6b5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6b5e:	0004      	movs	r4, r0
	int result;
	struct http_client_module *const module = (struct http_client_module *const)_module;
	
	module->sending = 1;
    6b60:	2041      	movs	r0, #65	; 0x41
    6b62:	5c25      	ldrb	r5, [r4, r0]
    6b64:	2301      	movs	r3, #1
    6b66:	432b      	orrs	r3, r5
    6b68:	5423      	strb	r3, [r4, r0]

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
    6b6a:	b292      	uxth	r2, r2
    6b6c:	2000      	movs	r0, #0
    6b6e:	5620      	ldrsb	r0, [r4, r0]
    6b70:	2300      	movs	r3, #0
    6b72:	4d13      	ldr	r5, [pc, #76]	; (6bc0 <_http_client_send_wait+0x64>)
    6b74:	47a8      	blx	r5
    6b76:	2800      	cmp	r0, #0
    6b78:	db08      	blt.n	6b8c <_http_client_send_wait+0x30>
		module->sending = 0;
		return result;
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
    6b7a:	2341      	movs	r3, #65	; 0x41
    6b7c:	5ce3      	ldrb	r3, [r4, r3]
    6b7e:	07db      	lsls	r3, r3, #31
    6b80:	d519      	bpl.n	6bb6 <_http_client_send_wait+0x5a>
    6b82:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
		m2m_wifi_handle_events(NULL);
		sw_timer_task(module->config.timer_inst);
	}

	return 0;
    6b84:	2000      	movs	r0, #0

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
		module->sending = 0;
		return result;
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
    6b86:	2b02      	cmp	r3, #2
    6b88:	d918      	bls.n	6bbc <_http_client_send_wait+0x60>
    6b8a:	e005      	b.n	6b98 <_http_client_send_wait+0x3c>
	struct http_client_module *const module = (struct http_client_module *const)_module;
	
	module->sending = 1;

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
		module->sending = 0;
    6b8c:	2241      	movs	r2, #65	; 0x41
    6b8e:	5ca3      	ldrb	r3, [r4, r2]
    6b90:	2101      	movs	r1, #1
    6b92:	438b      	bics	r3, r1
    6b94:	54a3      	strb	r3, [r4, r2]
		return result;
    6b96:	e011      	b.n	6bbc <_http_client_send_wait+0x60>
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
		m2m_wifi_handle_events(NULL);
    6b98:	4f0a      	ldr	r7, [pc, #40]	; (6bc4 <_http_client_send_wait+0x68>)
		sw_timer_task(module->config.timer_inst);
    6b9a:	4e0b      	ldr	r6, [pc, #44]	; (6bc8 <_http_client_send_wait+0x6c>)

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
		module->sending = 0;
		return result;
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
    6b9c:	2541      	movs	r5, #65	; 0x41
		m2m_wifi_handle_events(NULL);
    6b9e:	2000      	movs	r0, #0
    6ba0:	47b8      	blx	r7
		sw_timer_task(module->config.timer_inst);
    6ba2:	6d60      	ldr	r0, [r4, #84]	; 0x54
    6ba4:	47b0      	blx	r6

	if ((result = send(module->sock, (void*)buffer, buffer_len, 0)) < 0) {
		module->sending = 0;
		return result;
	}
	while (module->sending == 1 && module->req.state > STATE_SOCK_CONNECTED){
    6ba6:	5d63      	ldrb	r3, [r4, r5]
    6ba8:	07db      	lsls	r3, r3, #31
    6baa:	d506      	bpl.n	6bba <_http_client_send_wait+0x5e>
    6bac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6bae:	2b02      	cmp	r3, #2
    6bb0:	d8f5      	bhi.n	6b9e <_http_client_send_wait+0x42>
		m2m_wifi_handle_events(NULL);
		sw_timer_task(module->config.timer_inst);
	}

	return 0;
    6bb2:	2000      	movs	r0, #0
    6bb4:	e002      	b.n	6bbc <_http_client_send_wait+0x60>
    6bb6:	2000      	movs	r0, #0
    6bb8:	e000      	b.n	6bbc <_http_client_send_wait+0x60>
    6bba:	2000      	movs	r0, #0
}
    6bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6bbe:	46c0      	nop			; (mov r8, r8)
    6bc0:	00003fad 	.word	0x00003fad
    6bc4:	00002279 	.word	0x00002279
    6bc8:	00007d15 	.word	0x00007d15

00006bcc <http_client_get_config_defaults>:
 */
static struct http_client_module *module_ref_inst[TCP_SOCK_MAX] = {NULL,};

void http_client_get_config_defaults(struct http_client_config *const config)
{
	config->port = 80;
    6bcc:	2350      	movs	r3, #80	; 0x50
    6bce:	8003      	strh	r3, [r0, #0]
	config->tls = 0;
    6bd0:	2300      	movs	r3, #0
    6bd2:	7083      	strb	r3, [r0, #2]
	config->timeout = 20000;
    6bd4:	4a05      	ldr	r2, [pc, #20]	; (6bec <http_client_get_config_defaults+0x20>)
    6bd6:	8102      	strh	r2, [r0, #8]
	config->timer_inst = NULL;
    6bd8:	6043      	str	r3, [r0, #4]
	config->recv_buffer = NULL;
    6bda:	60c3      	str	r3, [r0, #12]
	config->recv_buffer_size = 256;
    6bdc:	3301      	adds	r3, #1
    6bde:	33ff      	adds	r3, #255	; 0xff
    6be0:	6103      	str	r3, [r0, #16]
	config->send_buffer_size = MIN_SEND_BUFFER_SIZE;
    6be2:	3bae      	subs	r3, #174	; 0xae
    6be4:	6143      	str	r3, [r0, #20]
	config->user_agent = DEFAULT_USER_AGENT;
    6be6:	4b02      	ldr	r3, [pc, #8]	; (6bf0 <http_client_get_config_defaults+0x24>)
    6be8:	6183      	str	r3, [r0, #24]
}
    6bea:	4770      	bx	lr
    6bec:	00004e20 	.word	0x00004e20
    6bf0:	0000afd4 	.word	0x0000afd4

00006bf4 <http_client_init>:

int http_client_init(struct http_client_module *const module, struct http_client_config *config)
{
    6bf4:	b570      	push	{r4, r5, r6, lr}
    6bf6:	0004      	movs	r4, r0
    6bf8:	000d      	movs	r5, r1
	/* Checks the parameters. */
	if (module == NULL || config == NULL) {
    6bfa:	2800      	cmp	r0, #0
    6bfc:	d034      	beq.n	6c68 <http_client_init+0x74>
    6bfe:	2900      	cmp	r1, #0
    6c00:	d035      	beq.n	6c6e <http_client_init+0x7a>
		return -EINVAL;
	}

	if (config->recv_buffer_size == 0) {
    6c02:	690b      	ldr	r3, [r1, #16]
    6c04:	2b00      	cmp	r3, #0
    6c06:	d035      	beq.n	6c74 <http_client_init+0x80>
		return -EINVAL;
	}

	if (config->timer_inst == NULL) {
    6c08:	684b      	ldr	r3, [r1, #4]
    6c0a:	2b00      	cmp	r3, #0
    6c0c:	d035      	beq.n	6c7a <http_client_init+0x86>
		return -EINVAL;
	}

	if (config->send_buffer_size < MIN_SEND_BUFFER_SIZE) {
    6c0e:	694b      	ldr	r3, [r1, #20]
    6c10:	2b51      	cmp	r3, #81	; 0x51
    6c12:	d935      	bls.n	6c80 <http_client_init+0x8c>
		return -EINVAL;
	}

	memset(module, 0, sizeof(struct http_client_module));
    6c14:	22e8      	movs	r2, #232	; 0xe8
    6c16:	2100      	movs	r1, #0
    6c18:	4b1e      	ldr	r3, [pc, #120]	; (6c94 <http_client_init+0xa0>)
    6c1a:	4798      	blx	r3
	memcpy(&module->config, config, sizeof(struct http_client_config));
    6c1c:	0020      	movs	r0, r4
    6c1e:	3050      	adds	r0, #80	; 0x50
    6c20:	221c      	movs	r2, #28
    6c22:	0029      	movs	r1, r5
    6c24:	4b1c      	ldr	r3, [pc, #112]	; (6c98 <http_client_init+0xa4>)
    6c26:	4798      	blx	r3

	/* Allocate the buffer in the heap. */
	if (module->config.recv_buffer == NULL) {
    6c28:	6de3      	ldr	r3, [r4, #92]	; 0x5c
    6c2a:	2b00      	cmp	r3, #0
    6c2c:	d10a      	bne.n	6c44 <http_client_init+0x50>
		module->config.recv_buffer = malloc(config->recv_buffer_size);
    6c2e:	6928      	ldr	r0, [r5, #16]
    6c30:	4b1a      	ldr	r3, [pc, #104]	; (6c9c <http_client_init+0xa8>)
    6c32:	4798      	blx	r3
    6c34:	65e0      	str	r0, [r4, #92]	; 0x5c
		if (module->config.recv_buffer == NULL) {
    6c36:	2800      	cmp	r0, #0
    6c38:	d025      	beq.n	6c86 <http_client_init+0x92>
			return -ENOMEM;
		}
		module->alloc_buffer = 1;
    6c3a:	2241      	movs	r2, #65	; 0x41
    6c3c:	5ca1      	ldrb	r1, [r4, r2]
    6c3e:	2304      	movs	r3, #4
    6c40:	430b      	orrs	r3, r1
    6c42:	54a3      	strb	r3, [r4, r2]
	}

	if (config->timeout > 0) {
    6c44:	892b      	ldrh	r3, [r5, #8]
    6c46:	2b00      	cmp	r3, #0
    6c48:	d008      	beq.n	6c5c <http_client_init+0x68>
		/* Enable the timer. */
		module->timer_id = sw_timer_register_callback(config->timer_inst, http_client_timer_callback, (void *)module, 0);
    6c4a:	6868      	ldr	r0, [r5, #4]
    6c4c:	2300      	movs	r3, #0
    6c4e:	0022      	movs	r2, r4
    6c50:	4913      	ldr	r1, [pc, #76]	; (6ca0 <http_client_init+0xac>)
    6c52:	4d14      	ldr	r5, [pc, #80]	; (6ca4 <http_client_init+0xb0>)
    6c54:	47a8      	blx	r5
    6c56:	64a0      	str	r0, [r4, #72]	; 0x48

		if (module->timer_id < 0) {
    6c58:	2800      	cmp	r0, #0
    6c5a:	db17      	blt.n	6c8c <http_client_init+0x98>
			return -ENOSPC;
		}
	}

	module->req.state = STATE_INIT;
    6c5c:	2300      	movs	r3, #0
    6c5e:	66e3      	str	r3, [r4, #108]	; 0x6c
	module->resp.state = STATE_PARSE_HEADER;
    6c60:	22d8      	movs	r2, #216	; 0xd8
    6c62:	50a3      	str	r3, [r4, r2]

	return 0;
    6c64:	2000      	movs	r0, #0
    6c66:	e013      	b.n	6c90 <http_client_init+0x9c>

int http_client_init(struct http_client_module *const module, struct http_client_config *config)
{
	/* Checks the parameters. */
	if (module == NULL || config == NULL) {
		return -EINVAL;
    6c68:	2016      	movs	r0, #22
    6c6a:	4240      	negs	r0, r0
    6c6c:	e010      	b.n	6c90 <http_client_init+0x9c>
    6c6e:	2016      	movs	r0, #22
    6c70:	4240      	negs	r0, r0
    6c72:	e00d      	b.n	6c90 <http_client_init+0x9c>
	}

	if (config->recv_buffer_size == 0) {
		return -EINVAL;
    6c74:	2016      	movs	r0, #22
    6c76:	4240      	negs	r0, r0
    6c78:	e00a      	b.n	6c90 <http_client_init+0x9c>
	}

	if (config->timer_inst == NULL) {
		return -EINVAL;
    6c7a:	2016      	movs	r0, #22
    6c7c:	4240      	negs	r0, r0
    6c7e:	e007      	b.n	6c90 <http_client_init+0x9c>
	}

	if (config->send_buffer_size < MIN_SEND_BUFFER_SIZE) {
		return -EINVAL;
    6c80:	2016      	movs	r0, #22
    6c82:	4240      	negs	r0, r0
    6c84:	e004      	b.n	6c90 <http_client_init+0x9c>

	/* Allocate the buffer in the heap. */
	if (module->config.recv_buffer == NULL) {
		module->config.recv_buffer = malloc(config->recv_buffer_size);
		if (module->config.recv_buffer == NULL) {
			return -ENOMEM;
    6c86:	200c      	movs	r0, #12
    6c88:	4240      	negs	r0, r0
    6c8a:	e001      	b.n	6c90 <http_client_init+0x9c>
	if (config->timeout > 0) {
		/* Enable the timer. */
		module->timer_id = sw_timer_register_callback(config->timer_inst, http_client_timer_callback, (void *)module, 0);

		if (module->timer_id < 0) {
			return -ENOSPC;
    6c8c:	201c      	movs	r0, #28
    6c8e:	4240      	negs	r0, r0

	module->req.state = STATE_INIT;
	module->resp.state = STATE_PARSE_HEADER;

	return 0;
}
    6c90:	bd70      	pop	{r4, r5, r6, pc}
    6c92:	46c0      	nop			; (mov r8, r8)
    6c94:	000086fd 	.word	0x000086fd
    6c98:	000086c1 	.word	0x000086c1
    6c9c:	00008699 	.word	0x00008699
    6ca0:	00006db9 	.word	0x00006db9
    6ca4:	00007ca1 	.word	0x00007ca1

00006ca8 <http_client_register_callback>:
}

int http_client_register_callback(struct http_client_module *const module, http_client_callback_t callback)
{
	/* Checks the parameters. */
	if (module == NULL) {
    6ca8:	2800      	cmp	r0, #0
    6caa:	d002      	beq.n	6cb2 <http_client_register_callback+0xa>
		return -EINVAL;
	}

	module->cb = callback;
    6cac:	64c1      	str	r1, [r0, #76]	; 0x4c

	return 0;
    6cae:	2000      	movs	r0, #0
    6cb0:	e001      	b.n	6cb6 <http_client_register_callback+0xe>

int http_client_register_callback(struct http_client_module *const module, http_client_callback_t callback)
{
	/* Checks the parameters. */
	if (module == NULL) {
		return -EINVAL;
    6cb2:	2016      	movs	r0, #22
    6cb4:	4240      	negs	r0, r0
	}

	module->cb = callback;

	return 0;
}
    6cb6:	4770      	bx	lr

00006cb8 <_http_client_clear_conn>:

	return 0;
}

void _http_client_clear_conn(struct http_client_module *const module, int reason)
{
    6cb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    6cba:	b085      	sub	sp, #20
    6cbc:	0004      	movs	r4, r0
    6cbe:	000e      	movs	r6, r1
	union http_client_data data;

	if (module->req.entity.close) {
    6cc0:	23c0      	movs	r3, #192	; 0xc0
    6cc2:	58c3      	ldr	r3, [r0, r3]
    6cc4:	2b00      	cmp	r3, #0
    6cc6:	d002      	beq.n	6cce <_http_client_clear_conn+0x16>
		module->req.entity.close(module->req.entity.priv_data);
    6cc8:	22c4      	movs	r2, #196	; 0xc4
    6cca:	5880      	ldr	r0, [r0, r2]
    6ccc:	4798      	blx	r3
	}

	memset(&module->req.entity, 0, sizeof(struct http_entity));
    6cce:	0020      	movs	r0, r4
    6cd0:	30b0      	adds	r0, #176	; 0xb0
    6cd2:	2218      	movs	r2, #24
    6cd4:	2100      	movs	r1, #0
    6cd6:	4b17      	ldr	r3, [pc, #92]	; (6d34 <_http_client_clear_conn+0x7c>)
    6cd8:	4798      	blx	r3

	if (module->req.state >= STATE_TRY_SOCK_CONNECT) {
    6cda:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6cdc:	2b00      	cmp	r3, #0
    6cde:	d003      	beq.n	6ce8 <_http_client_clear_conn+0x30>
		close(module->sock);
    6ce0:	2000      	movs	r0, #0
    6ce2:	5620      	ldrsb	r0, [r4, r0]
    6ce4:	4b14      	ldr	r3, [pc, #80]	; (6d38 <_http_client_clear_conn+0x80>)
    6ce6:	4798      	blx	r3
	}

	module_ref_inst[module->sock] = NULL;
    6ce8:	2300      	movs	r3, #0
    6cea:	56e3      	ldrsb	r3, [r4, r3]
    6cec:	009b      	lsls	r3, r3, #2
    6cee:	2500      	movs	r5, #0
    6cf0:	4a12      	ldr	r2, [pc, #72]	; (6d3c <_http_client_clear_conn+0x84>)
    6cf2:	509d      	str	r5, [r3, r2]
	memset(&module->req, 0, sizeof(struct http_client_req));
    6cf4:	0020      	movs	r0, r4
    6cf6:	306c      	adds	r0, #108	; 0x6c
    6cf8:	226c      	movs	r2, #108	; 0x6c
    6cfa:	2100      	movs	r1, #0
    6cfc:	4f0d      	ldr	r7, [pc, #52]	; (6d34 <_http_client_clear_conn+0x7c>)
    6cfe:	47b8      	blx	r7
	memset(&module->resp, 0, sizeof(struct http_client_resp));
    6d00:	0020      	movs	r0, r4
    6d02:	30d8      	adds	r0, #216	; 0xd8
    6d04:	2210      	movs	r2, #16
    6d06:	2100      	movs	r1, #0
    6d08:	47b8      	blx	r7
	module->req.state = STATE_INIT;
    6d0a:	66e5      	str	r5, [r4, #108]	; 0x6c
	module->resp.state = STATE_PARSE_HEADER;
    6d0c:	23d8      	movs	r3, #216	; 0xd8
    6d0e:	50e5      	str	r5, [r4, r3]

	module->sending = 0;
    6d10:	2241      	movs	r2, #65	; 0x41
    6d12:	5ca3      	ldrb	r3, [r4, r2]
	module->permanent = 0;
    6d14:	2101      	movs	r1, #1
    6d16:	438b      	bics	r3, r1
    6d18:	3101      	adds	r1, #1
    6d1a:	438b      	bics	r3, r1
    6d1c:	54a3      	strb	r3, [r4, r2]
	data.disconnected.reason = reason;
    6d1e:	9601      	str	r6, [sp, #4]
	if (module->cb) {
    6d20:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    6d22:	2b00      	cmp	r3, #0
    6d24:	d003      	beq.n	6d2e <_http_client_clear_conn+0x76>
		module->cb(module, HTTP_CLIENT_CALLBACK_DISCONNECTED, &data);
    6d26:	aa01      	add	r2, sp, #4
    6d28:	3102      	adds	r1, #2
    6d2a:	0020      	movs	r0, r4
    6d2c:	4798      	blx	r3
	}
}
    6d2e:	b005      	add	sp, #20
    6d30:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6d32:	46c0      	nop			; (mov r8, r8)
    6d34:	000086fd 	.word	0x000086fd
    6d38:	000040d9 	.word	0x000040d9
    6d3c:	20000168 	.word	0x20000168

00006d40 <http_client_socket_resolve_handler>:
	}

}

void http_client_socket_resolve_handler(uint8_t *doamin_name, uint32_t server_ip)
{
    6d40:	b5f0      	push	{r4, r5, r6, r7, lr}
    6d42:	b087      	sub	sp, #28
    6d44:	9000      	str	r0, [sp, #0]
    6d46:	9101      	str	r1, [sp, #4]
    6d48:	4c17      	ldr	r4, [pc, #92]	; (6da8 <http_client_socket_resolve_handler+0x68>)
    6d4a:	0026      	movs	r6, r4
    6d4c:	361c      	adds	r6, #28
	struct sockaddr_in addr_in;

	for (i = 0; i < TCP_SOCK_MAX; i++) {
		if (module_ref_inst[i] != NULL) {
			module = module_ref_inst[i];
			if (!strcmp((const char*)doamin_name, module->host) && module->req.state == STATE_TRY_SOCK_CONNECT) {
    6d4e:	4f17      	ldr	r7, [pc, #92]	; (6dac <http_client_socket_resolve_handler+0x6c>)
	int i;
	struct http_client_module *module;
	struct sockaddr_in addr_in;

	for (i = 0; i < TCP_SOCK_MAX; i++) {
		if (module_ref_inst[i] != NULL) {
    6d50:	6825      	ldr	r5, [r4, #0]
    6d52:	2d00      	cmp	r5, #0
    6d54:	d023      	beq.n	6d9e <http_client_socket_resolve_handler+0x5e>
			module = module_ref_inst[i];
			if (!strcmp((const char*)doamin_name, module->host) && module->req.state == STATE_TRY_SOCK_CONNECT) {
    6d56:	1c69      	adds	r1, r5, #1
    6d58:	9800      	ldr	r0, [sp, #0]
    6d5a:	47b8      	blx	r7
    6d5c:	2800      	cmp	r0, #0
    6d5e:	d11e      	bne.n	6d9e <http_client_socket_resolve_handler+0x5e>
    6d60:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
    6d62:	2b01      	cmp	r3, #1
    6d64:	d11b      	bne.n	6d9e <http_client_socket_resolve_handler+0x5e>
				if (server_ip == 0) { /* Host was not found or was not reachable. */ 
    6d66:	9b01      	ldr	r3, [sp, #4]
    6d68:	2b00      	cmp	r3, #0
    6d6a:	d105      	bne.n	6d78 <http_client_socket_resolve_handler+0x38>
					_http_client_clear_conn(module, -EHOSTUNREACH);
    6d6c:	2176      	movs	r1, #118	; 0x76
    6d6e:	4249      	negs	r1, r1
    6d70:	0028      	movs	r0, r5
    6d72:	4b0f      	ldr	r3, [pc, #60]	; (6db0 <http_client_socket_resolve_handler+0x70>)
    6d74:	4798      	blx	r3
					return;
    6d76:	e015      	b.n	6da4 <http_client_socket_resolve_handler+0x64>
				}
				addr_in.sin_family = AF_INET;
    6d78:	2302      	movs	r3, #2
    6d7a:	aa02      	add	r2, sp, #8
    6d7c:	8013      	strh	r3, [r2, #0]
				addr_in.sin_port = _htons(module->config.port);
    6d7e:	334e      	adds	r3, #78	; 0x4e
    6d80:	5aeb      	ldrh	r3, [r5, r3]
    6d82:	021a      	lsls	r2, r3, #8
    6d84:	0a1b      	lsrs	r3, r3, #8
    6d86:	4313      	orrs	r3, r2
    6d88:	aa02      	add	r2, sp, #8
    6d8a:	8053      	strh	r3, [r2, #2]
				addr_in.sin_addr.s_addr = server_ip;
    6d8c:	9b01      	ldr	r3, [sp, #4]
    6d8e:	9303      	str	r3, [sp, #12]
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
    6d90:	2000      	movs	r0, #0
    6d92:	5628      	ldrsb	r0, [r5, r0]
    6d94:	2210      	movs	r2, #16
    6d96:	a902      	add	r1, sp, #8
    6d98:	4b06      	ldr	r3, [pc, #24]	; (6db4 <http_client_socket_resolve_handler+0x74>)
    6d9a:	4798      	blx	r3
				return;
    6d9c:	e002      	b.n	6da4 <http_client_socket_resolve_handler+0x64>
    6d9e:	3404      	adds	r4, #4
{
	int i;
	struct http_client_module *module;
	struct sockaddr_in addr_in;

	for (i = 0; i < TCP_SOCK_MAX; i++) {
    6da0:	42b4      	cmp	r4, r6
    6da2:	d1d5      	bne.n	6d50 <http_client_socket_resolve_handler+0x10>
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
				return;
			}
		}
	}
}
    6da4:	b007      	add	sp, #28
    6da6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6da8:	20000168 	.word	0x20000168
    6dac:	00008b55 	.word	0x00008b55
    6db0:	00006cb9 	.word	0x00006cb9
    6db4:	00003f1d 	.word	0x00003f1d

00006db8 <http_client_timer_callback>:

void http_client_timer_callback(struct sw_timer_module *const module, int timer_id, void *context, int period)
{
    6db8:	b510      	push	{r4, lr}
	struct http_client_module *module_inst = (struct http_client_module *)context;

	/* Checks invalid arguments. */
	if (module_inst == NULL) {
    6dba:	2a00      	cmp	r2, #0
    6dbc:	d004      	beq.n	6dc8 <http_client_timer_callback+0x10>
		return;
	}

	_http_client_clear_conn(module_inst, -ETIME);
    6dbe:	213e      	movs	r1, #62	; 0x3e
    6dc0:	4249      	negs	r1, r1
    6dc2:	0010      	movs	r0, r2
    6dc4:	4b01      	ldr	r3, [pc, #4]	; (6dcc <http_client_timer_callback+0x14>)
    6dc6:	4798      	blx	r3
}
    6dc8:	bd10      	pop	{r4, pc}
    6dca:	46c0      	nop			; (mov r8, r8)
    6dcc:	00006cb9 	.word	0x00006cb9

00006dd0 <_http_client_request>:

	return 0;
}

void _http_client_request(struct http_client_module *const module)
{
    6dd0:	b5f0      	push	{r4, r5, r6, r7, lr}
    6dd2:	465f      	mov	r7, fp
    6dd4:	4656      	mov	r6, sl
    6dd6:	b4c0      	push	{r6, r7}
    6dd8:	b095      	sub	sp, #84	; 0x54
    6dda:	af02      	add	r7, sp, #8
    6ddc:	0004      	movs	r4, r0
    6dde:	46eb      	mov	fp, sp
	struct stream_writer writer;
	int size;
	int result;
	char length[11];
	char *ptr;
	const char CH_LUT[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    6de0:	2210      	movs	r2, #16
    6de2:	49dd      	ldr	r1, [pc, #884]	; (7158 <_http_client_request+0x388>)
    6de4:	2310      	movs	r3, #16
    6de6:	2008      	movs	r0, #8
    6de8:	1838      	adds	r0, r7, r0
    6dea:	18c0      	adds	r0, r0, r3
    6dec:	4bdb      	ldr	r3, [pc, #876]	; (715c <_http_client_request+0x38c>)
    6dee:	4798      	blx	r3
	struct http_entity * entity;
	union http_client_data data;
#define HTTP_CHUNKED_MAX_LENGTH 3 /*TCP MTU is 1400(0x578) */
	char buffer[module->config.send_buffer_size];
    6df0:	6e62      	ldr	r2, [r4, #100]	; 0x64
    6df2:	1dd3      	adds	r3, r2, #7
    6df4:	08db      	lsrs	r3, r3, #3
    6df6:	00db      	lsls	r3, r3, #3
    6df8:	4669      	mov	r1, sp
    6dfa:	1acb      	subs	r3, r1, r3
    6dfc:	469d      	mov	sp, r3
    6dfe:	ae02      	add	r6, sp, #8

	if (module == NULL) {
    6e00:	2c00      	cmp	r4, #0
    6e02:	d100      	bne.n	6e06 <_http_client_request+0x36>
    6e04:	e235      	b.n	7272 <_http_client_request+0x4a2>
		return;
	}

	if (module->sending != 0) {
    6e06:	2341      	movs	r3, #65	; 0x41
    6e08:	5ce3      	ldrb	r3, [r4, r3]
    6e0a:	07db      	lsls	r3, r3, #31
    6e0c:	d500      	bpl.n	6e10 <_http_client_request+0x40>
    6e0e:	e230      	b.n	7272 <_http_client_request+0x4a2>
		return;
	}

	entity = &module->req.entity;

	switch (module->req.state) {
    6e10:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    6e12:	2b03      	cmp	r3, #3
    6e14:	d003      	beq.n	6e1e <_http_client_request+0x4e>
    6e16:	2b04      	cmp	r3, #4
    6e18:	d100      	bne.n	6e1c <_http_client_request+0x4c>
    6e1a:	e11a      	b.n	7052 <_http_client_request+0x282>
    6e1c:	e227      	b.n	726e <_http_client_request+0x49e>
	case STATE_REQ_SEND_HEADER:
		/* Initializing variables. */
		module->req.content_length = 0;
    6e1e:	2300      	movs	r3, #0
    6e20:	21cc      	movs	r1, #204	; 0xcc
    6e22:	5063      	str	r3, [r4, r1]
		module->req.sent_length = 0;
    6e24:	3104      	adds	r1, #4
    6e26:	5063      	str	r3, [r4, r1]

		stream_writer_init(&writer, buffer, module->config.send_buffer_size, _http_client_send_wait, (void *)module);
    6e28:	9400      	str	r4, [sp, #0]
    6e2a:	4bcd      	ldr	r3, [pc, #820]	; (7160 <_http_client_request+0x390>)
    6e2c:	0031      	movs	r1, r6
    6e2e:	202c      	movs	r0, #44	; 0x2c
    6e30:	2508      	movs	r5, #8
    6e32:	46ac      	mov	ip, r5
    6e34:	44bc      	add	ip, r7
    6e36:	4460      	add	r0, ip
    6e38:	4dca      	ldr	r5, [pc, #808]	; (7164 <_http_client_request+0x394>)
    6e3a:	47a8      	blx	r5
		/* Write Method. */
		if (module->req.method == HTTP_METHOD_GET) {
    6e3c:	23c8      	movs	r3, #200	; 0xc8
    6e3e:	5ce3      	ldrb	r3, [r4, r3]
    6e40:	2b01      	cmp	r3, #1
    6e42:	d108      	bne.n	6e56 <_http_client_request+0x86>
			stream_writer_send_buffer(&writer, "GET ", 4);
    6e44:	2204      	movs	r2, #4
    6e46:	49c8      	ldr	r1, [pc, #800]	; (7168 <_http_client_request+0x398>)
    6e48:	332b      	adds	r3, #43	; 0x2b
    6e4a:	2008      	movs	r0, #8
    6e4c:	1838      	adds	r0, r7, r0
    6e4e:	18c0      	adds	r0, r0, r3
    6e50:	4bc6      	ldr	r3, [pc, #792]	; (716c <_http_client_request+0x39c>)
    6e52:	4798      	blx	r3
    6e54:	e035      	b.n	6ec2 <_http_client_request+0xf2>
		} else if (module->req.method == HTTP_METHOD_POST) {
    6e56:	2b02      	cmp	r3, #2
    6e58:	d108      	bne.n	6e6c <_http_client_request+0x9c>
			stream_writer_send_buffer(&writer, "POST ", 5);
    6e5a:	2205      	movs	r2, #5
    6e5c:	49c4      	ldr	r1, [pc, #784]	; (7170 <_http_client_request+0x3a0>)
    6e5e:	332a      	adds	r3, #42	; 0x2a
    6e60:	2008      	movs	r0, #8
    6e62:	1838      	adds	r0, r7, r0
    6e64:	18c0      	adds	r0, r0, r3
    6e66:	4bc1      	ldr	r3, [pc, #772]	; (716c <_http_client_request+0x39c>)
    6e68:	4798      	blx	r3
    6e6a:	e02a      	b.n	6ec2 <_http_client_request+0xf2>
		} else if (module->req.method == HTTP_METHOD_DELETE) {
    6e6c:	2b03      	cmp	r3, #3
    6e6e:	d108      	bne.n	6e82 <_http_client_request+0xb2>
			stream_writer_send_buffer(&writer, "DELETE ", 7);
    6e70:	2207      	movs	r2, #7
    6e72:	49c0      	ldr	r1, [pc, #768]	; (7174 <_http_client_request+0x3a4>)
    6e74:	3329      	adds	r3, #41	; 0x29
    6e76:	2008      	movs	r0, #8
    6e78:	1838      	adds	r0, r7, r0
    6e7a:	18c0      	adds	r0, r0, r3
    6e7c:	4bbb      	ldr	r3, [pc, #748]	; (716c <_http_client_request+0x39c>)
    6e7e:	4798      	blx	r3
    6e80:	e01f      	b.n	6ec2 <_http_client_request+0xf2>
		} else if (module->req.method == HTTP_METHOD_PUT) {
    6e82:	2b04      	cmp	r3, #4
    6e84:	d108      	bne.n	6e98 <_http_client_request+0xc8>
			stream_writer_send_buffer(&writer, "PUT ", 4);
    6e86:	2204      	movs	r2, #4
    6e88:	49bb      	ldr	r1, [pc, #748]	; (7178 <_http_client_request+0x3a8>)
    6e8a:	3328      	adds	r3, #40	; 0x28
    6e8c:	2008      	movs	r0, #8
    6e8e:	1838      	adds	r0, r7, r0
    6e90:	18c0      	adds	r0, r0, r3
    6e92:	4bb6      	ldr	r3, [pc, #728]	; (716c <_http_client_request+0x39c>)
    6e94:	4798      	blx	r3
    6e96:	e014      	b.n	6ec2 <_http_client_request+0xf2>
		} else if (module->req.method == HTTP_METHOD_OPTIONS) {
    6e98:	2b05      	cmp	r3, #5
    6e9a:	d108      	bne.n	6eae <_http_client_request+0xde>
			stream_writer_send_buffer(&writer, "OPTIONS ", 8);
    6e9c:	2208      	movs	r2, #8
    6e9e:	49b7      	ldr	r1, [pc, #732]	; (717c <_http_client_request+0x3ac>)
    6ea0:	3327      	adds	r3, #39	; 0x27
    6ea2:	2008      	movs	r0, #8
    6ea4:	1838      	adds	r0, r7, r0
    6ea6:	18c0      	adds	r0, r0, r3
    6ea8:	4bb0      	ldr	r3, [pc, #704]	; (716c <_http_client_request+0x39c>)
    6eaa:	4798      	blx	r3
    6eac:	e009      	b.n	6ec2 <_http_client_request+0xf2>
		} else if (module->req.method == HTTP_METHOD_HEAD) {
    6eae:	2b06      	cmp	r3, #6
    6eb0:	d107      	bne.n	6ec2 <_http_client_request+0xf2>
			stream_writer_send_buffer(&writer, "HEAD ", 5);
    6eb2:	2205      	movs	r2, #5
    6eb4:	49b2      	ldr	r1, [pc, #712]	; (7180 <_http_client_request+0x3b0>)
    6eb6:	3326      	adds	r3, #38	; 0x26
    6eb8:	2008      	movs	r0, #8
    6eba:	1838      	adds	r0, r7, r0
    6ebc:	18c0      	adds	r0, r0, r3
    6ebe:	4bab      	ldr	r3, [pc, #684]	; (716c <_http_client_request+0x39c>)
    6ec0:	4798      	blx	r3
		}

		/* Write URI. */
		stream_writer_send_buffer(&writer, module->req.uri, strlen(module->req.uri));
    6ec2:	0025      	movs	r5, r4
    6ec4:	3570      	adds	r5, #112	; 0x70
    6ec6:	0028      	movs	r0, r5
    6ec8:	4bae      	ldr	r3, [pc, #696]	; (7184 <_http_client_request+0x3b4>)
    6eca:	469a      	mov	sl, r3
    6ecc:	4798      	blx	r3
    6ece:	0002      	movs	r2, r0
    6ed0:	0029      	movs	r1, r5
    6ed2:	232c      	movs	r3, #44	; 0x2c
    6ed4:	2008      	movs	r0, #8
    6ed6:	1838      	adds	r0, r7, r0
    6ed8:	18c0      	adds	r0, r0, r3
    6eda:	4da4      	ldr	r5, [pc, #656]	; (716c <_http_client_request+0x39c>)
    6edc:	47a8      	blx	r5

		stream_writer_send_buffer(&writer, " "HTTP_PROTO_NAME"\r\n", strlen(" "HTTP_PROTO_NAME"\r\n"));
    6ede:	220b      	movs	r2, #11
    6ee0:	49a9      	ldr	r1, [pc, #676]	; (7188 <_http_client_request+0x3b8>)
    6ee2:	232c      	movs	r3, #44	; 0x2c
    6ee4:	2008      	movs	r0, #8
    6ee6:	1838      	adds	r0, r7, r0
    6ee8:	18c0      	adds	r0, r0, r3
    6eea:	47a8      	blx	r5

		/* Write HTTP headers. */
		/* Default value. */
		stream_writer_send_buffer(&writer, "User-Agent: ", strlen("User-agent: "));
    6eec:	220c      	movs	r2, #12
    6eee:	49a7      	ldr	r1, [pc, #668]	; (718c <_http_client_request+0x3bc>)
    6ef0:	232c      	movs	r3, #44	; 0x2c
    6ef2:	2008      	movs	r0, #8
    6ef4:	1838      	adds	r0, r7, r0
    6ef6:	18c0      	adds	r0, r0, r3
    6ef8:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, (char *)module->config.user_agent, strlen(module->config.user_agent));
    6efa:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    6efc:	607b      	str	r3, [r7, #4]
    6efe:	0018      	movs	r0, r3
    6f00:	47d0      	blx	sl
    6f02:	0002      	movs	r2, r0
    6f04:	6879      	ldr	r1, [r7, #4]
    6f06:	232c      	movs	r3, #44	; 0x2c
    6f08:	2008      	movs	r0, #8
    6f0a:	1838      	adds	r0, r7, r0
    6f0c:	18c0      	adds	r0, r0, r3
    6f0e:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
    6f10:	2202      	movs	r2, #2
    6f12:	499f      	ldr	r1, [pc, #636]	; (7190 <_http_client_request+0x3c0>)
    6f14:	232c      	movs	r3, #44	; 0x2c
    6f16:	2008      	movs	r0, #8
    6f18:	1838      	adds	r0, r7, r0
    6f1a:	18c0      	adds	r0, r0, r3
    6f1c:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Host: ", strlen("Host: "));
    6f1e:	2206      	movs	r2, #6
    6f20:	499c      	ldr	r1, [pc, #624]	; (7194 <_http_client_request+0x3c4>)
    6f22:	232c      	movs	r3, #44	; 0x2c
    6f24:	2008      	movs	r0, #8
    6f26:	1838      	adds	r0, r7, r0
    6f28:	18c0      	adds	r0, r0, r3
    6f2a:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, module->host, strlen(module->host));
    6f2c:	1c63      	adds	r3, r4, #1
    6f2e:	607b      	str	r3, [r7, #4]
    6f30:	0018      	movs	r0, r3
    6f32:	47d0      	blx	sl
    6f34:	0002      	movs	r2, r0
    6f36:	6879      	ldr	r1, [r7, #4]
    6f38:	232c      	movs	r3, #44	; 0x2c
    6f3a:	2008      	movs	r0, #8
    6f3c:	1838      	adds	r0, r7, r0
    6f3e:	18c0      	adds	r0, r0, r3
    6f40:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
    6f42:	2202      	movs	r2, #2
    6f44:	4992      	ldr	r1, [pc, #584]	; (7190 <_http_client_request+0x3c0>)
    6f46:	232c      	movs	r3, #44	; 0x2c
    6f48:	2008      	movs	r0, #8
    6f4a:	1838      	adds	r0, r7, r0
    6f4c:	18c0      	adds	r0, r0, r3
    6f4e:	47a8      	blx	r5
		/* It supported persistent connection. */
		stream_writer_send_buffer(&writer, "Connection: Keep-Alive\r\n", strlen("Connection: Keep-Alive\r\n"));
    6f50:	2218      	movs	r2, #24
    6f52:	4991      	ldr	r1, [pc, #580]	; (7198 <_http_client_request+0x3c8>)
    6f54:	232c      	movs	r3, #44	; 0x2c
    6f56:	2008      	movs	r0, #8
    6f58:	1838      	adds	r0, r7, r0
    6f5a:	18c0      	adds	r0, r0, r3
    6f5c:	47a8      	blx	r5
		/* Notify supported encoding type and character set. */
		stream_writer_send_buffer(&writer, "Accept-Encoding: \r\n", strlen("Accept-Encoding: \r\n"));
    6f5e:	2213      	movs	r2, #19
    6f60:	498e      	ldr	r1, [pc, #568]	; (719c <_http_client_request+0x3cc>)
    6f62:	232c      	movs	r3, #44	; 0x2c
    6f64:	2008      	movs	r0, #8
    6f66:	1838      	adds	r0, r7, r0
    6f68:	18c0      	adds	r0, r0, r3
    6f6a:	47a8      	blx	r5
		stream_writer_send_buffer(&writer, "Accept-Charset: utf-8\r\n", strlen("Accept-Charset: utf-8\r\n"));
    6f6c:	2217      	movs	r2, #23
    6f6e:	498c      	ldr	r1, [pc, #560]	; (71a0 <_http_client_request+0x3d0>)
    6f70:	232c      	movs	r3, #44	; 0x2c
    6f72:	2008      	movs	r0, #8
    6f74:	1838      	adds	r0, r7, r0
    6f76:	18c0      	adds	r0, r0, r3
    6f78:	47a8      	blx	r5

		if (entity->read != NULL) {
    6f7a:	0023      	movs	r3, r4
    6f7c:	33b0      	adds	r3, #176	; 0xb0
    6f7e:	68db      	ldr	r3, [r3, #12]
    6f80:	2b00      	cmp	r3, #0
    6f82:	d047      	beq.n	7014 <_http_client_request+0x244>
			/* HTTP Entity is exist. */
			if (entity->is_chunked) {
    6f84:	23b0      	movs	r3, #176	; 0xb0
    6f86:	5ce3      	ldrb	r3, [r4, r3]
    6f88:	2b00      	cmp	r3, #0
    6f8a:	d00c      	beq.n	6fa6 <_http_client_request+0x1d6>
				/* Chunked mode. */
				module->req.content_length = -1;
    6f8c:	2201      	movs	r2, #1
    6f8e:	4252      	negs	r2, r2
    6f90:	23cc      	movs	r3, #204	; 0xcc
    6f92:	50e2      	str	r2, [r4, r3]
				stream_writer_send_buffer(&writer, "Transfer-Encoding: chunked\r\n", strlen("Transfer-Encoding: chunked\r\n"));
    6f94:	321d      	adds	r2, #29
    6f96:	4983      	ldr	r1, [pc, #524]	; (71a4 <_http_client_request+0x3d4>)
    6f98:	3ba0      	subs	r3, #160	; 0xa0
    6f9a:	2008      	movs	r0, #8
    6f9c:	1838      	adds	r0, r7, r0
    6f9e:	18c0      	adds	r0, r0, r3
    6fa0:	4b72      	ldr	r3, [pc, #456]	; (716c <_http_client_request+0x39c>)
    6fa2:	4798      	blx	r3
    6fa4:	e036      	b.n	7014 <_http_client_request+0x244>
			} else if(entity->get_contents_length) {
    6fa6:	0023      	movs	r3, r4
    6fa8:	33b0      	adds	r3, #176	; 0xb0
    6faa:	689b      	ldr	r3, [r3, #8]
    6fac:	2b00      	cmp	r3, #0
    6fae:	d031      	beq.n	7014 <_http_client_request+0x244>
				module->req.content_length = entity->get_contents_length(entity->priv_data);
    6fb0:	0022      	movs	r2, r4
    6fb2:	32b0      	adds	r2, #176	; 0xb0
    6fb4:	6950      	ldr	r0, [r2, #20]
    6fb6:	4798      	blx	r3
    6fb8:	23cc      	movs	r3, #204	; 0xcc
    6fba:	50e0      	str	r0, [r4, r3]
				if (module->req.content_length < 0) {
    6fbc:	2800      	cmp	r0, #0
    6fbe:	da02      	bge.n	6fc6 <_http_client_request+0x1f6>
					/* Error was occurred. */
					/* Does not send any entity. */
					module->req.content_length = 0;
    6fc0:	2200      	movs	r2, #0
    6fc2:	50e2      	str	r2, [r4, r3]
    6fc4:	e026      	b.n	7014 <_http_client_request+0x244>
				} else {
					sprintf(length, "%u", (unsigned int)module->req.content_length);
    6fc6:	0002      	movs	r2, r0
    6fc8:	4977      	ldr	r1, [pc, #476]	; (71a8 <_http_client_request+0x3d8>)
    6fca:	2320      	movs	r3, #32
    6fcc:	2008      	movs	r0, #8
    6fce:	1838      	adds	r0, r7, r0
    6fd0:	18c0      	adds	r0, r0, r3
    6fd2:	4b76      	ldr	r3, [pc, #472]	; (71ac <_http_client_request+0x3dc>)
    6fd4:	4798      	blx	r3
					stream_writer_send_buffer(&writer, "Content-Length: ", strlen("Content-Length: "));
    6fd6:	2210      	movs	r2, #16
    6fd8:	4975      	ldr	r1, [pc, #468]	; (71b0 <_http_client_request+0x3e0>)
    6fda:	232c      	movs	r3, #44	; 0x2c
    6fdc:	2008      	movs	r0, #8
    6fde:	1838      	adds	r0, r7, r0
    6fe0:	18c0      	adds	r0, r0, r3
    6fe2:	4d62      	ldr	r5, [pc, #392]	; (716c <_http_client_request+0x39c>)
    6fe4:	47a8      	blx	r5
					stream_writer_send_buffer(&writer, length, strlen(length));
    6fe6:	2320      	movs	r3, #32
    6fe8:	2208      	movs	r2, #8
    6fea:	18ba      	adds	r2, r7, r2
    6fec:	18d0      	adds	r0, r2, r3
    6fee:	4b65      	ldr	r3, [pc, #404]	; (7184 <_http_client_request+0x3b4>)
    6ff0:	4798      	blx	r3
    6ff2:	0002      	movs	r2, r0
    6ff4:	2320      	movs	r3, #32
    6ff6:	2108      	movs	r1, #8
    6ff8:	1879      	adds	r1, r7, r1
    6ffa:	18c9      	adds	r1, r1, r3
    6ffc:	330c      	adds	r3, #12
    6ffe:	2008      	movs	r0, #8
    7000:	1838      	adds	r0, r7, r0
    7002:	18c0      	adds	r0, r0, r3
    7004:	47a8      	blx	r5
					stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
    7006:	2202      	movs	r2, #2
    7008:	4961      	ldr	r1, [pc, #388]	; (7190 <_http_client_request+0x3c0>)
    700a:	232c      	movs	r3, #44	; 0x2c
    700c:	2008      	movs	r0, #8
    700e:	1838      	adds	r0, r7, r0
    7010:	18c0      	adds	r0, r0, r3
    7012:	47a8      	blx	r5
				}
			}
		}
		if (module->req.ext_header != NULL ) {
    7014:	23d4      	movs	r3, #212	; 0xd4
    7016:	58e5      	ldr	r5, [r4, r3]
    7018:	2d00      	cmp	r5, #0
    701a:	d00a      	beq.n	7032 <_http_client_request+0x262>
			stream_writer_send_buffer(&writer,
    701c:	0028      	movs	r0, r5
    701e:	4b59      	ldr	r3, [pc, #356]	; (7184 <_http_client_request+0x3b4>)
    7020:	4798      	blx	r3
    7022:	0002      	movs	r2, r0
    7024:	0029      	movs	r1, r5
    7026:	232c      	movs	r3, #44	; 0x2c
    7028:	2008      	movs	r0, #8
    702a:	1838      	adds	r0, r7, r0
    702c:	18c0      	adds	r0, r0, r3
    702e:	4b4f      	ldr	r3, [pc, #316]	; (716c <_http_client_request+0x39c>)
    7030:	4798      	blx	r3
				module->req.ext_header,
				strlen(module->req.ext_header));
		}

		//See the module->header
		stream_writer_send_buffer(&writer, "\r\n", strlen("\r\n"));
    7032:	2202      	movs	r2, #2
    7034:	4956      	ldr	r1, [pc, #344]	; (7190 <_http_client_request+0x3c0>)
    7036:	232c      	movs	r3, #44	; 0x2c
    7038:	2008      	movs	r0, #8
    703a:	1838      	adds	r0, r7, r0
    703c:	18c0      	adds	r0, r0, r3
    703e:	4b4b      	ldr	r3, [pc, #300]	; (716c <_http_client_request+0x39c>)
    7040:	4798      	blx	r3
		stream_writer_send_remain(&writer);
    7042:	232c      	movs	r3, #44	; 0x2c
    7044:	2208      	movs	r2, #8
    7046:	18ba      	adds	r2, r7, r2
    7048:	18d0      	adds	r0, r2, r3
    704a:	4b5a      	ldr	r3, [pc, #360]	; (71b4 <_http_client_request+0x3e4>)
    704c:	4798      	blx	r3

		module->req.state = STATE_REQ_SEND_ENTITY;
    704e:	2304      	movs	r3, #4
    7050:	66e3      	str	r3, [r4, #108]	; 0x6c
		/* Send first part of entity. */
	case STATE_REQ_SEND_ENTITY:
		if (module->req.content_length < 0 && entity->read) {
    7052:	23cc      	movs	r3, #204	; 0xcc
    7054:	58e2      	ldr	r2, [r4, r3]
    7056:	2a00      	cmp	r2, #0
    7058:	db00      	blt.n	705c <_http_client_request+0x28c>
    705a:	e0b1      	b.n	71c0 <_http_client_request+0x3f0>
    705c:	0023      	movs	r3, r4
    705e:	33b0      	adds	r3, #176	; 0xb0
    7060:	68dd      	ldr	r5, [r3, #12]
    7062:	2d00      	cmp	r5, #0
    7064:	d100      	bne.n	7068 <_http_client_request+0x298>
    7066:	e0f8      	b.n	725a <_http_client_request+0x48a>
			/* Send chunked packet. */
			/*  Chunked header (size + \r\n) tail (\r\n) */
			size = entity->read(entity->priv_data, buffer + HTTP_CHUNKED_MAX_LENGTH + 2,
				module->config.send_buffer_size - HTTP_CHUNKED_MAX_LENGTH - 4, module->req.sent_length);
    7068:	23d0      	movs	r3, #208	; 0xd0
		/* Send first part of entity. */
	case STATE_REQ_SEND_ENTITY:
		if (module->req.content_length < 0 && entity->read) {
			/* Send chunked packet. */
			/*  Chunked header (size + \r\n) tail (\r\n) */
			size = entity->read(entity->priv_data, buffer + HTTP_CHUNKED_MAX_LENGTH + 2,
    706a:	58e3      	ldr	r3, [r4, r3]
    706c:	6e62      	ldr	r2, [r4, #100]	; 0x64
    706e:	3a07      	subs	r2, #7
    7070:	1d71      	adds	r1, r6, #5
    7072:	0020      	movs	r0, r4
    7074:	30b0      	adds	r0, #176	; 0xb0
    7076:	6940      	ldr	r0, [r0, #20]
    7078:	47a8      	blx	r5
    707a:	0005      	movs	r5, r0
    707c:	43c3      	mvns	r3, r0
    707e:	17db      	asrs	r3, r3, #31
    7080:	401d      	ands	r5, r3
				module->config.send_buffer_size - HTTP_CHUNKED_MAX_LENGTH - 4, module->req.sent_length);
			if (size < 0) {
				/* If occurs problem during the operation, Close this socket. */
				size = 0;
			}
			buffer[HTTP_CHUNKED_MAX_LENGTH + 1] = '\n';
    7082:	220a      	movs	r2, #10
    7084:	7132      	strb	r2, [r6, #4]
			buffer[HTTP_CHUNKED_MAX_LENGTH] = '\r';
    7086:	210d      	movs	r1, #13
    7088:	70f1      	strb	r1, [r6, #3]
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 2] = '\r';
    708a:	1973      	adds	r3, r6, r5
    708c:	7159      	strb	r1, [r3, #5]
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 3] = '\n';
    708e:	719a      	strb	r2, [r3, #6]
			if (size >= 0) {
				ptr = buffer + 2;
				*ptr = CH_LUT[size % 16];
    7090:	17eb      	asrs	r3, r5, #31
    7092:	0f19      	lsrs	r1, r3, #28
    7094:	186a      	adds	r2, r5, r1
    7096:	230f      	movs	r3, #15
    7098:	4013      	ands	r3, r2
    709a:	1a5b      	subs	r3, r3, r1
    709c:	2210      	movs	r2, #16
    709e:	2108      	movs	r1, #8
    70a0:	468c      	mov	ip, r1
    70a2:	44bc      	add	ip, r7
    70a4:	4462      	add	r2, ip
    70a6:	5cd3      	ldrb	r3, [r2, r3]
    70a8:	70b3      	strb	r3, [r6, #2]
			buffer[HTTP_CHUNKED_MAX_LENGTH + 1] = '\n';
			buffer[HTTP_CHUNKED_MAX_LENGTH] = '\r';
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 2] = '\r';
			buffer[size + HTTP_CHUNKED_MAX_LENGTH + 3] = '\n';
			if (size >= 0) {
				ptr = buffer + 2;
    70aa:	1cb1      	adds	r1, r6, #2
				*ptr = CH_LUT[size % 16];
			}
			if (size >= 0x10) {
    70ac:	2d0f      	cmp	r5, #15
    70ae:	dd11      	ble.n	70d4 <_http_client_request+0x304>
				ptr = buffer + 1;
    70b0:	1c71      	adds	r1, r6, #1
				*ptr = CH_LUT[(size / 0x10) % 16];
    70b2:	17eb      	asrs	r3, r5, #31
    70b4:	200f      	movs	r0, #15
    70b6:	4003      	ands	r3, r0
    70b8:	195b      	adds	r3, r3, r5
    70ba:	111a      	asrs	r2, r3, #4
    70bc:	17db      	asrs	r3, r3, #31
    70be:	0f1b      	lsrs	r3, r3, #28
    70c0:	18d2      	adds	r2, r2, r3
    70c2:	4002      	ands	r2, r0
    70c4:	1ad3      	subs	r3, r2, r3
    70c6:	2210      	movs	r2, #16
    70c8:	3807      	subs	r0, #7
    70ca:	4684      	mov	ip, r0
    70cc:	44bc      	add	ip, r7
    70ce:	4462      	add	r2, ip
    70d0:	5cd3      	ldrb	r3, [r2, r3]
    70d2:	7073      	strb	r3, [r6, #1]
			}
			if (size >= 0x100) {
    70d4:	2dff      	cmp	r5, #255	; 0xff
    70d6:	dd12      	ble.n	70fe <_http_client_request+0x32e>
				ptr = buffer;
				*ptr = CH_LUT[(size / 0x100) % 16];
    70d8:	17eb      	asrs	r3, r5, #31
    70da:	22ff      	movs	r2, #255	; 0xff
    70dc:	4013      	ands	r3, r2
    70de:	195b      	adds	r3, r3, r5
    70e0:	121a      	asrs	r2, r3, #8
    70e2:	17db      	asrs	r3, r3, #31
    70e4:	0f1b      	lsrs	r3, r3, #28
    70e6:	18d2      	adds	r2, r2, r3
    70e8:	210f      	movs	r1, #15
    70ea:	400a      	ands	r2, r1
    70ec:	1ad3      	subs	r3, r2, r3
    70ee:	2210      	movs	r2, #16
    70f0:	3907      	subs	r1, #7
    70f2:	468c      	mov	ip, r1
    70f4:	44bc      	add	ip, r7
    70f6:	4462      	add	r2, ip
    70f8:	5cd3      	ldrb	r3, [r2, r3]
    70fa:	7033      	strb	r3, [r6, #0]
			if (size >= 0x10) {
				ptr = buffer + 1;
				*ptr = CH_LUT[(size / 0x10) % 16];
			}
			if (size >= 0x100) {
				ptr = buffer;
    70fc:	0031      	movs	r1, r6
				*ptr = CH_LUT[(size / 0x100) % 16];
			}		
			//module->sending = 1;
			if ((result = send(module->sock, (void*)ptr, ptr + HTTP_CHUNKED_MAX_LENGTH - buffer + size + 4, 0)) < 0) {	
    70fe:	1cca      	adds	r2, r1, #3
    7100:	1b92      	subs	r2, r2, r6
    7102:	1d2b      	adds	r3, r5, #4
    7104:	18d2      	adds	r2, r2, r3
    7106:	b292      	uxth	r2, r2
    7108:	2000      	movs	r0, #0
    710a:	5620      	ldrsb	r0, [r4, r0]
    710c:	2300      	movs	r3, #0
    710e:	4e2a      	ldr	r6, [pc, #168]	; (71b8 <_http_client_request+0x3e8>)
    7110:	47b0      	blx	r6
    7112:	2800      	cmp	r0, #0
    7114:	da05      	bge.n	7122 <_http_client_request+0x352>
				_http_client_clear_conn(module, -EIO);
    7116:	2105      	movs	r1, #5
    7118:	4249      	negs	r1, r1
    711a:	0020      	movs	r0, r4
    711c:	4b27      	ldr	r3, [pc, #156]	; (71bc <_http_client_request+0x3ec>)
    711e:	4798      	blx	r3
				return;
    7120:	e0a7      	b.n	7272 <_http_client_request+0x4a2>
			}

			module->req.sent_length += size;
    7122:	22d0      	movs	r2, #208	; 0xd0
    7124:	58a3      	ldr	r3, [r4, r2]
    7126:	195b      	adds	r3, r3, r5
    7128:	50a3      	str	r3, [r4, r2]

			if(size == 0) {
    712a:	2d00      	cmp	r5, #0
    712c:	d000      	beq.n	7130 <_http_client_request+0x360>
    712e:	e09e      	b.n	726e <_http_client_request+0x49e>
				if (module->req.entity.close) {
    7130:	23c0      	movs	r3, #192	; 0xc0
    7132:	58e3      	ldr	r3, [r4, r3]
    7134:	2b00      	cmp	r3, #0
    7136:	d002      	beq.n	713e <_http_client_request+0x36e>
					module->req.entity.close(module->req.entity.priv_data);
    7138:	3a0c      	subs	r2, #12
    713a:	58a0      	ldr	r0, [r4, r2]
    713c:	4798      	blx	r3
				}
				module->req.state = STATE_SOCK_CONNECTED;
    713e:	2302      	movs	r3, #2
    7140:	66e3      	str	r3, [r4, #108]	; 0x6c
				if (module->cb) {
    7142:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7144:	2b00      	cmp	r3, #0
    7146:	d100      	bne.n	714a <_http_client_request+0x37a>
    7148:	e091      	b.n	726e <_http_client_request+0x49e>
					module->cb(module, HTTP_CLIENT_CALLBACK_REQUESTED, &data);
    714a:	220c      	movs	r2, #12
    714c:	18ba      	adds	r2, r7, r2
    714e:	2101      	movs	r1, #1
    7150:	0020      	movs	r0, r4
    7152:	4798      	blx	r3
    7154:	e08b      	b.n	726e <_http_client_request+0x49e>
    7156:	46c0      	nop			; (mov r8, r8)
    7158:	0000afc4 	.word	0x0000afc4
    715c:	000086c1 	.word	0x000086c1
    7160:	00006b5d 	.word	0x00006b5d
    7164:	00007b55 	.word	0x00007b55
    7168:	0000afe0 	.word	0x0000afe0
    716c:	00007ba1 	.word	0x00007ba1
    7170:	0000afe8 	.word	0x0000afe8
    7174:	0000aff0 	.word	0x0000aff0
    7178:	0000aff8 	.word	0x0000aff8
    717c:	0000b000 	.word	0x0000b000
    7180:	0000b00c 	.word	0x0000b00c
    7184:	00008bb3 	.word	0x00008bb3
    7188:	0000b014 	.word	0x0000b014
    718c:	0000b020 	.word	0x0000b020
    7190:	0000b580 	.word	0x0000b580
    7194:	0000b030 	.word	0x0000b030
    7198:	0000b038 	.word	0x0000b038
    719c:	0000b054 	.word	0x0000b054
    71a0:	0000b068 	.word	0x0000b068
    71a4:	0000b080 	.word	0x0000b080
    71a8:	0000b0a0 	.word	0x0000b0a0
    71ac:	00008b11 	.word	0x00008b11
    71b0:	0000b0a4 	.word	0x0000b0a4
    71b4:	00007b65 	.word	0x00007b65
    71b8:	00003fad 	.word	0x00003fad
    71bc:	00006cb9 	.word	0x00006cb9
				}
				break;
			}
		} else if (module->req.content_length > 0 && entity->read) {
    71c0:	2a00      	cmp	r2, #0
    71c2:	dd4a      	ble.n	725a <_http_client_request+0x48a>
    71c4:	0023      	movs	r3, r4
    71c6:	33b0      	adds	r3, #176	; 0xb0
    71c8:	68dd      	ldr	r5, [r3, #12]
    71ca:	2d00      	cmp	r5, #0
    71cc:	d045      	beq.n	725a <_http_client_request+0x48a>
			/* Send entity. */
			if (module->req.sent_length >= module->req.content_length) {
    71ce:	23d0      	movs	r3, #208	; 0xd0
    71d0:	58e3      	ldr	r3, [r4, r3]
    71d2:	429a      	cmp	r2, r3
    71d4:	dc11      	bgt.n	71fa <_http_client_request+0x42a>
				/* Complete to send the buffer. */
				if (module->req.entity.close) {
    71d6:	23c0      	movs	r3, #192	; 0xc0
    71d8:	58e3      	ldr	r3, [r4, r3]
    71da:	2b00      	cmp	r3, #0
    71dc:	d002      	beq.n	71e4 <_http_client_request+0x414>
					module->req.entity.close(module->req.entity.priv_data);
    71de:	22c4      	movs	r2, #196	; 0xc4
    71e0:	58a0      	ldr	r0, [r4, r2]
    71e2:	4798      	blx	r3
				}
				module->req.state = STATE_SOCK_CONNECTED;
    71e4:	2302      	movs	r3, #2
    71e6:	66e3      	str	r3, [r4, #108]	; 0x6c
				if (module->cb) {
    71e8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    71ea:	2b00      	cmp	r3, #0
    71ec:	d03f      	beq.n	726e <_http_client_request+0x49e>
					module->cb(module, HTTP_CLIENT_CALLBACK_REQUESTED, &data);
    71ee:	220c      	movs	r2, #12
    71f0:	18ba      	adds	r2, r7, r2
    71f2:	2101      	movs	r1, #1
    71f4:	0020      	movs	r0, r4
    71f6:	4798      	blx	r3
    71f8:	e039      	b.n	726e <_http_client_request+0x49e>
				}
				break;
			}
			size = entity->read(entity->priv_data, buffer, module->config.send_buffer_size, module->req.sent_length);
    71fa:	0022      	movs	r2, r4
    71fc:	32b0      	adds	r2, #176	; 0xb0
    71fe:	6950      	ldr	r0, [r2, #20]
    7200:	6e62      	ldr	r2, [r4, #100]	; 0x64
    7202:	0031      	movs	r1, r6
    7204:	47a8      	blx	r5

			if (size < 0) {
    7206:	2800      	cmp	r0, #0
    7208:	da09      	bge.n	721e <_http_client_request+0x44e>
				/* Entity occurs errors or EOS. */
				/* Disconnect it. */
				_http_client_clear_conn(module, (size == 0)?-EBADMSG:-EIO);
    720a:	d002      	beq.n	7212 <_http_client_request+0x442>
    720c:	2105      	movs	r1, #5
    720e:	4249      	negs	r1, r1
    7210:	e001      	b.n	7216 <_http_client_request+0x446>
    7212:	214d      	movs	r1, #77	; 0x4d
    7214:	4249      	negs	r1, r1
    7216:	0020      	movs	r0, r4
    7218:	4b19      	ldr	r3, [pc, #100]	; (7280 <_http_client_request+0x4b0>)
    721a:	4798      	blx	r3
    721c:	e027      	b.n	726e <_http_client_request+0x49e>
			} else {
				if (size > module->req.content_length - module->req.sent_length) {
    721e:	23cc      	movs	r3, #204	; 0xcc
    7220:	58e3      	ldr	r3, [r4, r3]
    7222:	22d0      	movs	r2, #208	; 0xd0
    7224:	58a2      	ldr	r2, [r4, r2]
    7226:	1a9b      	subs	r3, r3, r2
    7228:	1e05      	subs	r5, r0, #0
    722a:	429d      	cmp	r5, r3
    722c:	dd00      	ble.n	7230 <_http_client_request+0x460>
    722e:	001d      	movs	r5, r3
					size = module->req.content_length - module->req.sent_length;
				}
				
				//module->sending = 1;
				if ((result = send(module->sock, (void*)buffer, size, 0)) < 0) {
    7230:	b2aa      	uxth	r2, r5
    7232:	2000      	movs	r0, #0
    7234:	5620      	ldrsb	r0, [r4, r0]
    7236:	2300      	movs	r3, #0
    7238:	0031      	movs	r1, r6
    723a:	4e12      	ldr	r6, [pc, #72]	; (7284 <_http_client_request+0x4b4>)
    723c:	47b0      	blx	r6
    723e:	2800      	cmp	r0, #0
    7240:	da05      	bge.n	724e <_http_client_request+0x47e>
					_http_client_clear_conn(module, -EIO);
    7242:	2105      	movs	r1, #5
    7244:	4249      	negs	r1, r1
    7246:	0020      	movs	r0, r4
    7248:	4b0d      	ldr	r3, [pc, #52]	; (7280 <_http_client_request+0x4b0>)
    724a:	4798      	blx	r3
					return;
    724c:	e011      	b.n	7272 <_http_client_request+0x4a2>
				}
				module->req.sent_length += size;
    724e:	23d0      	movs	r3, #208	; 0xd0
    7250:	58e2      	ldr	r2, [r4, r3]
    7252:	4694      	mov	ip, r2
    7254:	4465      	add	r5, ip
    7256:	50e5      	str	r5, [r4, r3]
    7258:	e009      	b.n	726e <_http_client_request+0x49e>
			}
		} else {
			/* Has not any entity. */
			module->req.state = STATE_SOCK_CONNECTED;
    725a:	2302      	movs	r3, #2
    725c:	66e3      	str	r3, [r4, #108]	; 0x6c
			if (module->cb) {
    725e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7260:	2b00      	cmp	r3, #0
    7262:	d004      	beq.n	726e <_http_client_request+0x49e>
				module->cb(module, HTTP_CLIENT_CALLBACK_REQUESTED, &data);
    7264:	220c      	movs	r2, #12
    7266:	18ba      	adds	r2, r7, r2
    7268:	2101      	movs	r1, #1
    726a:	0020      	movs	r0, r4
    726c:	4798      	blx	r3
    726e:	46dd      	mov	sp, fp
    7270:	e000      	b.n	7274 <_http_client_request+0x4a4>
	union http_client_data data;
#define HTTP_CHUNKED_MAX_LENGTH 3 /*TCP MTU is 1400(0x578) */
	char buffer[module->config.send_buffer_size];

	if (module == NULL) {
		return;
    7272:	46dd      	mov	sp, fp
		break;
	default:
		/* Invalid status. */
		break;
	}
}
    7274:	46bd      	mov	sp, r7
    7276:	b013      	add	sp, #76	; 0x4c
    7278:	bc0c      	pop	{r2, r3}
    727a:	4692      	mov	sl, r2
    727c:	469b      	mov	fp, r3
    727e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7280:	00006cb9 	.word	0x00006cb9
    7284:	00003fad 	.word	0x00003fad

00007288 <http_client_send_request>:
	return 1;
}

int http_client_send_request(struct http_client_module *const module, const char *url,
	enum http_method method, struct http_entity *const entity, const char *ext_header)
{
    7288:	b5f0      	push	{r4, r5, r6, r7, lr}
    728a:	4647      	mov	r7, r8
    728c:	b480      	push	{r7}
    728e:	b088      	sub	sp, #32
    7290:	0004      	movs	r4, r0
    7292:	000e      	movs	r6, r1
    7294:	4690      	mov	r8, r2
    7296:	9302      	str	r3, [sp, #8]
	uint8_t flag = 0;
	struct sockaddr_in addr_in;
	const char *uri = NULL;
	int i = 0, j = 0, reconnect = 0;

	if (module == NULL) {
    7298:	2800      	cmp	r0, #0
    729a:	d100      	bne.n	729e <http_client_send_request+0x16>
    729c:	e0d3      	b.n	7446 <http_client_send_request+0x1be>
		return -EINVAL;
	}

	if (module->req.state > STATE_SOCK_CONNECTED) {
    729e:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    72a0:	2b02      	cmp	r3, #2
    72a2:	d900      	bls.n	72a6 <http_client_send_request+0x1e>
    72a4:	e0d2      	b.n	744c <http_client_send_request+0x1c4>
		return -EBUSY;
	}

	/* Separate host and uri */
	if (!strncmp(url, "http://", 7)) {
    72a6:	2207      	movs	r2, #7
    72a8:	4980      	ldr	r1, [pc, #512]	; (74ac <http_client_send_request+0x224>)
    72aa:	0030      	movs	r0, r6
    72ac:	4b80      	ldr	r3, [pc, #512]	; (74b0 <http_client_send_request+0x228>)
    72ae:	4798      	blx	r3
		i = 7;
    72b0:	2707      	movs	r7, #7
	if (module->req.state > STATE_SOCK_CONNECTED) {
		return -EBUSY;
	}

	/* Separate host and uri */
	if (!strncmp(url, "http://", 7)) {
    72b2:	2800      	cmp	r0, #0
    72b4:	d007      	beq.n	72c6 <http_client_send_request+0x3e>
		i = 7;
	} else if (!strncmp(url, "https://", 8)) {
    72b6:	2208      	movs	r2, #8
    72b8:	497e      	ldr	r1, [pc, #504]	; (74b4 <http_client_send_request+0x22c>)
    72ba:	0030      	movs	r0, r6
    72bc:	4b7c      	ldr	r3, [pc, #496]	; (74b0 <http_client_send_request+0x228>)
    72be:	4798      	blx	r3
		i = 8;
    72c0:	4241      	negs	r1, r0
    72c2:	4141      	adcs	r1, r0
    72c4:	00cf      	lsls	r7, r1, #3
	}
	reconnect = strncmp(module->host, url + i, strlen(module->host));
    72c6:	19f5      	adds	r5, r6, r7
    72c8:	1c63      	adds	r3, r4, #1
    72ca:	9301      	str	r3, [sp, #4]
    72cc:	0018      	movs	r0, r3
    72ce:	4b7a      	ldr	r3, [pc, #488]	; (74b8 <http_client_send_request+0x230>)
    72d0:	4798      	blx	r3
    72d2:	0002      	movs	r2, r0
    72d4:	0029      	movs	r1, r5
    72d6:	9801      	ldr	r0, [sp, #4]
    72d8:	4b75      	ldr	r3, [pc, #468]	; (74b0 <http_client_send_request+0x228>)
    72da:	4798      	blx	r3
    72dc:	9003      	str	r0, [sp, #12]

	for (; url[i] != '\0' && url[i] != '/'; i++) {
    72de:	782b      	ldrb	r3, [r5, #0]
    72e0:	2b00      	cmp	r3, #0
    72e2:	d00e      	beq.n	7302 <http_client_send_request+0x7a>
    72e4:	2b2f      	cmp	r3, #47	; 0x2f
    72e6:	d00e      	beq.n	7306 <http_client_send_request+0x7e>
    72e8:	1c79      	adds	r1, r7, #1
    72ea:	1871      	adds	r1, r6, r1
    72ec:	2200      	movs	r2, #0
		module->host[j++] = url[i];
    72ee:	3201      	adds	r2, #1
    72f0:	54a3      	strb	r3, [r4, r2]
	} else if (!strncmp(url, "https://", 8)) {
		i = 8;
	}
	reconnect = strncmp(module->host, url + i, strlen(module->host));

	for (; url[i] != '\0' && url[i] != '/'; i++) {
    72f2:	000d      	movs	r5, r1
    72f4:	780b      	ldrb	r3, [r1, #0]
    72f6:	2b00      	cmp	r3, #0
    72f8:	d006      	beq.n	7308 <http_client_send_request+0x80>
    72fa:	3101      	adds	r1, #1
    72fc:	2b2f      	cmp	r3, #47	; 0x2f
    72fe:	d1f6      	bne.n	72ee <http_client_send_request+0x66>
    7300:	e002      	b.n	7308 <http_client_send_request+0x80>
	enum http_method method, struct http_entity *const entity, const char *ext_header)
{
	uint8_t flag = 0;
	struct sockaddr_in addr_in;
	const char *uri = NULL;
	int i = 0, j = 0, reconnect = 0;
    7302:	2200      	movs	r2, #0
    7304:	e000      	b.n	7308 <http_client_send_request+0x80>
    7306:	2200      	movs	r2, #0
	reconnect = strncmp(module->host, url + i, strlen(module->host));

	for (; url[i] != '\0' && url[i] != '/'; i++) {
		module->host[j++] = url[i];
	}
	module->host[j] = '\0';
    7308:	18a2      	adds	r2, r4, r2
    730a:	2300      	movs	r3, #0
    730c:	7053      	strb	r3, [r2, #1]
	uri = url + i;

	/* Checks the parameters. */
	if (strlen(module->host) == 0) {
    730e:	7863      	ldrb	r3, [r4, #1]
    7310:	2b00      	cmp	r3, #0
    7312:	d100      	bne.n	7316 <http_client_send_request+0x8e>
    7314:	e09d      	b.n	7452 <http_client_send_request+0x1ca>
		return -EINVAL;
	}

	if (strlen(uri) >= HTTP_MAX_URI_LENGTH) {
    7316:	0028      	movs	r0, r5
    7318:	4b67      	ldr	r3, [pc, #412]	; (74b8 <http_client_send_request+0x230>)
    731a:	4798      	blx	r3
    731c:	283f      	cmp	r0, #63	; 0x3f
    731e:	d900      	bls.n	7322 <http_client_send_request+0x9a>
    7320:	e09a      	b.n	7458 <http_client_send_request+0x1d0>
		return -ENAMETOOLONG;
	}

	if (module->req.ext_header != NULL) {
    7322:	23d4      	movs	r3, #212	; 0xd4
    7324:	58e0      	ldr	r0, [r4, r3]
    7326:	2800      	cmp	r0, #0
    7328:	d001      	beq.n	732e <http_client_send_request+0xa6>
		free(module->req.ext_header);
    732a:	4b64      	ldr	r3, [pc, #400]	; (74bc <http_client_send_request+0x234>)
    732c:	4798      	blx	r3
	}
	if (ext_header != NULL) {
    732e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7330:	2b00      	cmp	r3, #0
    7332:	d007      	beq.n	7344 <http_client_send_request+0xbc>
		module->req.ext_header = strdup(ext_header);
    7334:	0018      	movs	r0, r3
    7336:	4b62      	ldr	r3, [pc, #392]	; (74c0 <http_client_send_request+0x238>)
    7338:	4798      	blx	r3
    733a:	23d4      	movs	r3, #212	; 0xd4
    733c:	50e0      	str	r0, [r4, r3]
		if (module->req.ext_header == NULL) {
    733e:	2800      	cmp	r0, #0
    7340:	d103      	bne.n	734a <http_client_send_request+0xc2>
    7342:	e08c      	b.n	745e <http_client_send_request+0x1d6>
			return -ENOMEM;
		}
	} else {
		module->req.ext_header = NULL;
    7344:	2200      	movs	r2, #0
    7346:	23d4      	movs	r3, #212	; 0xd4
    7348:	50e2      	str	r2, [r4, r3]
	}

	module->sending = 0;
    734a:	2241      	movs	r2, #65	; 0x41
    734c:	5ca3      	ldrb	r3, [r4, r2]
    734e:	2101      	movs	r1, #1
    7350:	438b      	bics	r3, r1
    7352:	54a3      	strb	r3, [r4, r2]
	module->recved_size = 0;
    7354:	2300      	movs	r3, #0
    7356:	6463      	str	r3, [r4, #68]	; 0x44
	if (uri[0] == '/') {
    7358:	782b      	ldrb	r3, [r5, #0]
    735a:	2b2f      	cmp	r3, #47	; 0x2f
    735c:	d105      	bne.n	736a <http_client_send_request+0xe2>
		strcpy(module->req.uri, uri);
    735e:	0020      	movs	r0, r4
    7360:	3070      	adds	r0, #112	; 0x70
    7362:	0029      	movs	r1, r5
    7364:	4b57      	ldr	r3, [pc, #348]	; (74c4 <http_client_send_request+0x23c>)
    7366:	4798      	blx	r3
    7368:	e00a      	b.n	7380 <http_client_send_request+0xf8>
		} else {
		module->req.uri[0] = '/';
    736a:	222f      	movs	r2, #47	; 0x2f
    736c:	2370      	movs	r3, #112	; 0x70
    736e:	54e2      	strb	r2, [r4, r3]
		if (uri[0] != 0) {
    7370:	782b      	ldrb	r3, [r5, #0]
    7372:	2b00      	cmp	r3, #0
    7374:	d004      	beq.n	7380 <http_client_send_request+0xf8>
			strcpy(module->req.uri + 1, uri);
    7376:	0029      	movs	r1, r5
    7378:	0020      	movs	r0, r4
    737a:	3071      	adds	r0, #113	; 0x71
    737c:	4b51      	ldr	r3, [pc, #324]	; (74c4 <http_client_send_request+0x23c>)
    737e:	4798      	blx	r3
		}
	}

	if (entity != NULL) {
    7380:	9b02      	ldr	r3, [sp, #8]
    7382:	2b00      	cmp	r3, #0
    7384:	d006      	beq.n	7394 <http_client_send_request+0x10c>
		memcpy(&module->req.entity, entity, sizeof(struct http_entity));
    7386:	0020      	movs	r0, r4
    7388:	30b0      	adds	r0, #176	; 0xb0
    738a:	2218      	movs	r2, #24
    738c:	0019      	movs	r1, r3
    738e:	4b4e      	ldr	r3, [pc, #312]	; (74c8 <http_client_send_request+0x240>)
    7390:	4798      	blx	r3
    7392:	e005      	b.n	73a0 <http_client_send_request+0x118>
		} else {
		memset(&module->req.entity, 0, sizeof(struct http_entity));
    7394:	0020      	movs	r0, r4
    7396:	30b0      	adds	r0, #176	; 0xb0
    7398:	2218      	movs	r2, #24
    739a:	2100      	movs	r1, #0
    739c:	4b4b      	ldr	r3, [pc, #300]	; (74cc <http_client_send_request+0x244>)
    739e:	4798      	blx	r3
	}

	module->req.method = method;
    73a0:	23c8      	movs	r3, #200	; 0xc8
    73a2:	4642      	mov	r2, r8
    73a4:	54e2      	strb	r2, [r4, r3]
	
	switch (module->req.state) {
    73a6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    73a8:	2b01      	cmp	r3, #1
    73aa:	d004      	beq.n	73b6 <http_client_send_request+0x12e>
    73ac:	2b00      	cmp	r3, #0
    73ae:	d015      	beq.n	73dc <http_client_send_request+0x154>
    73b0:	2b02      	cmp	r3, #2
    73b2:	d005      	beq.n	73c0 <http_client_send_request+0x138>
    73b4:	e056      	b.n	7464 <http_client_send_request+0x1dc>
		/* STATE_RECV_RESP */
		/* Session was busy. Try again later. */
		return -EAGAIN;
	}

	return 0;
    73b6:	2000      	movs	r0, #0

	module->req.method = method;
	
	switch (module->req.state) {
	case STATE_TRY_SOCK_CONNECT:
		if (!reconnect) {
    73b8:	9b03      	ldr	r3, [sp, #12]
    73ba:	2b00      	cmp	r3, #0
    73bc:	d10a      	bne.n	73d4 <http_client_send_request+0x14c>
    73be:	e070      	b.n	74a2 <http_client_send_request+0x21a>
			break; /* Currently try to connect to the same server. */
		}
	case STATE_SOCK_CONNECTED:
		if (!reconnect) {
    73c0:	9b03      	ldr	r3, [sp, #12]
    73c2:	2b00      	cmp	r3, #0
    73c4:	d106      	bne.n	73d4 <http_client_send_request+0x14c>
			module->req.state = STATE_REQ_SEND_HEADER;
    73c6:	3303      	adds	r3, #3
    73c8:	66e3      	str	r3, [r4, #108]	; 0x6c
			/* Send request immediately. */
			_http_client_request(module);
    73ca:	0020      	movs	r0, r4
    73cc:	4b40      	ldr	r3, [pc, #256]	; (74d0 <http_client_send_request+0x248>)
    73ce:	4798      	blx	r3
		/* STATE_RECV_RESP */
		/* Session was busy. Try again later. */
		return -EAGAIN;
	}

	return 0;
    73d0:	2000      	movs	r0, #0
	case STATE_SOCK_CONNECTED:
		if (!reconnect) {
			module->req.state = STATE_REQ_SEND_HEADER;
			/* Send request immediately. */
			_http_client_request(module);
			break;
    73d2:	e066      	b.n	74a2 <http_client_send_request+0x21a>
		} else {
			/* Request to another peer. Disconnect and try connect again. */
			_http_client_clear_conn(module, 0);
    73d4:	2100      	movs	r1, #0
    73d6:	0020      	movs	r0, r4
    73d8:	4b3e      	ldr	r3, [pc, #248]	; (74d4 <http_client_send_request+0x24c>)
    73da:	4798      	blx	r3
		}
	case STATE_INIT:
		if (module->config.tls) {
    73dc:	2352      	movs	r3, #82	; 0x52
			flag |= SOCKET_FLAGS_SSL;
		}
		module->sock = socket(AF_INET, SOCK_STREAM, flag);
    73de:	5ce2      	ldrb	r2, [r4, r3]
    73e0:	1e53      	subs	r3, r2, #1
    73e2:	419a      	sbcs	r2, r3
    73e4:	b2d2      	uxtb	r2, r2
    73e6:	2101      	movs	r1, #1
    73e8:	2002      	movs	r0, #2
    73ea:	4b3b      	ldr	r3, [pc, #236]	; (74d8 <http_client_send_request+0x250>)
    73ec:	4798      	blx	r3
    73ee:	7020      	strb	r0, [r4, #0]
		if (module->sock >= 0) {
    73f0:	2800      	cmp	r0, #0
    73f2:	db3a      	blt.n	746a <http_client_send_request+0x1e2>
			module_ref_inst[module->sock] = module;
    73f4:	0080      	lsls	r0, r0, #2
    73f6:	4b39      	ldr	r3, [pc, #228]	; (74dc <http_client_send_request+0x254>)
    73f8:	50c4      	str	r4, [r0, r3]
    73fa:	9d01      	ldr	r5, [sp, #4]
	_http_client_clear_conn(module_inst, -ETIME);
}

static int _is_ip(const char *host)
{
	uint32_t isv6 = 0;
    73fc:	2100      	movs	r1, #0
	char ch;

	while (*host != '\0') {
		ch = *host++;
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
    73fe:	2620      	movs	r6, #32
			isv6 = 1;
    7400:	2001      	movs	r0, #1
		} else if (ch == '.') {
			if (isv6) {
				return 0;
			}
		} else if ((ch & 0x30) != 0x30) {
    7402:	2730      	movs	r7, #48	; 0x30
    7404:	e017      	b.n	7436 <http_client_send_request+0x1ae>
{
	uint32_t isv6 = 0;
	char ch;

	while (*host != '\0') {
		ch = *host++;
    7406:	3501      	adds	r5, #1
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
    7408:	0013      	movs	r3, r2
    740a:	43b3      	bics	r3, r6
    740c:	3b41      	subs	r3, #65	; 0x41
    740e:	2b05      	cmp	r3, #5
    7410:	d90c      	bls.n	742c <http_client_send_request+0x1a4>
    7412:	2a3a      	cmp	r2, #58	; 0x3a
    7414:	d00c      	beq.n	7430 <http_client_send_request+0x1a8>
    7416:	2a2f      	cmp	r2, #47	; 0x2f
    7418:	d00c      	beq.n	7434 <http_client_send_request+0x1ac>
			isv6 = 1;
		} else if (ch == '.') {
    741a:	2a2e      	cmp	r2, #46	; 0x2e
    741c:	d102      	bne.n	7424 <http_client_send_request+0x19c>
			if (isv6) {
    741e:	2900      	cmp	r1, #0
    7420:	d009      	beq.n	7436 <http_client_send_request+0x1ae>
    7422:	e03a      	b.n	749a <http_client_send_request+0x212>
				return 0;
			}
		} else if ((ch & 0x30) != 0x30) {
    7424:	403a      	ands	r2, r7
    7426:	2a30      	cmp	r2, #48	; 0x30
    7428:	d005      	beq.n	7436 <http_client_send_request+0x1ae>
    742a:	e036      	b.n	749a <http_client_send_request+0x212>
	char ch;

	while (*host != '\0') {
		ch = *host++;
		if ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F') || ch == ':' || ch == '/') {
			isv6 = 1;
    742c:	0001      	movs	r1, r0
    742e:	e002      	b.n	7436 <http_client_send_request+0x1ae>
    7430:	0001      	movs	r1, r0
    7432:	e000      	b.n	7436 <http_client_send_request+0x1ae>
    7434:	0001      	movs	r1, r0
static int _is_ip(const char *host)
{
	uint32_t isv6 = 0;
	char ch;

	while (*host != '\0') {
    7436:	782a      	ldrb	r2, [r5, #0]
    7438:	2a00      	cmp	r2, #0
    743a:	d1e4      	bne.n	7406 <http_client_send_request+0x17e>
    743c:	e018      	b.n	7470 <http_client_send_request+0x1e8>
				addr_in.sin_addr.s_addr = nmi_inet_addr((char *)module->host);
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
			} else {
				gethostbyname((uint8*)module->host);
			}
			module->req.state = STATE_TRY_SOCK_CONNECT;
    743e:	2301      	movs	r3, #1
    7440:	66e3      	str	r3, [r4, #108]	; 0x6c
		/* STATE_RECV_RESP */
		/* Session was busy. Try again later. */
		return -EAGAIN;
	}

	return 0;
    7442:	2000      	movs	r0, #0
			}
			module->req.state = STATE_TRY_SOCK_CONNECT;
		} else {
			return -ENOSPC;
		}
		break;
    7444:	e02d      	b.n	74a2 <http_client_send_request+0x21a>
	struct sockaddr_in addr_in;
	const char *uri = NULL;
	int i = 0, j = 0, reconnect = 0;

	if (module == NULL) {
		return -EINVAL;
    7446:	2016      	movs	r0, #22
    7448:	4240      	negs	r0, r0
    744a:	e02a      	b.n	74a2 <http_client_send_request+0x21a>
	}

	if (module->req.state > STATE_SOCK_CONNECTED) {
		return -EBUSY;
    744c:	2010      	movs	r0, #16
    744e:	4240      	negs	r0, r0
    7450:	e027      	b.n	74a2 <http_client_send_request+0x21a>
	module->host[j] = '\0';
	uri = url + i;

	/* Checks the parameters. */
	if (strlen(module->host) == 0) {
		return -EINVAL;
    7452:	2016      	movs	r0, #22
    7454:	4240      	negs	r0, r0
    7456:	e024      	b.n	74a2 <http_client_send_request+0x21a>
	}

	if (strlen(uri) >= HTTP_MAX_URI_LENGTH) {
		return -ENAMETOOLONG;
    7458:	205b      	movs	r0, #91	; 0x5b
    745a:	4240      	negs	r0, r0
    745c:	e021      	b.n	74a2 <http_client_send_request+0x21a>
		free(module->req.ext_header);
	}
	if (ext_header != NULL) {
		module->req.ext_header = strdup(ext_header);
		if (module->req.ext_header == NULL) {
			return -ENOMEM;
    745e:	200c      	movs	r0, #12
    7460:	4240      	negs	r0, r0
    7462:	e01e      	b.n	74a2 <http_client_send_request+0x21a>
	default:
		/* STATE_TRY_REQ */
		/* STATE_WAIT_RESP */
		/* STATE_RECV_RESP */
		/* Session was busy. Try again later. */
		return -EAGAIN;
    7464:	200b      	movs	r0, #11
    7466:	4240      	negs	r0, r0
    7468:	e01b      	b.n	74a2 <http_client_send_request+0x21a>
			} else {
				gethostbyname((uint8*)module->host);
			}
			module->req.state = STATE_TRY_SOCK_CONNECT;
		} else {
			return -ENOSPC;
    746a:	201c      	movs	r0, #28
    746c:	4240      	negs	r0, r0
    746e:	e018      	b.n	74a2 <http_client_send_request+0x21a>
		}
		module->sock = socket(AF_INET, SOCK_STREAM, flag);
		if (module->sock >= 0) {
			module_ref_inst[module->sock] = module;
			if (_is_ip(module->host)) {
				addr_in.sin_family = AF_INET;
    7470:	2302      	movs	r3, #2
    7472:	aa04      	add	r2, sp, #16
    7474:	8013      	strh	r3, [r2, #0]
				addr_in.sin_port = _htons(module->config.port);
    7476:	334e      	adds	r3, #78	; 0x4e
    7478:	5ae3      	ldrh	r3, [r4, r3]
    747a:	021a      	lsls	r2, r3, #8
    747c:	0a1b      	lsrs	r3, r3, #8
    747e:	4313      	orrs	r3, r2
    7480:	aa04      	add	r2, sp, #16
    7482:	8053      	strh	r3, [r2, #2]
				addr_in.sin_addr.s_addr = nmi_inet_addr((char *)module->host);
    7484:	9801      	ldr	r0, [sp, #4]
    7486:	4b16      	ldr	r3, [pc, #88]	; (74e0 <http_client_send_request+0x258>)
    7488:	4798      	blx	r3
    748a:	9005      	str	r0, [sp, #20]
				connect(module->sock, (struct sockaddr *)&addr_in, sizeof(struct sockaddr_in));
    748c:	2000      	movs	r0, #0
    748e:	5620      	ldrsb	r0, [r4, r0]
    7490:	2210      	movs	r2, #16
    7492:	a904      	add	r1, sp, #16
    7494:	4b13      	ldr	r3, [pc, #76]	; (74e4 <http_client_send_request+0x25c>)
    7496:	4798      	blx	r3
    7498:	e7d1      	b.n	743e <http_client_send_request+0x1b6>
			} else {
				gethostbyname((uint8*)module->host);
    749a:	9801      	ldr	r0, [sp, #4]
    749c:	4b12      	ldr	r3, [pc, #72]	; (74e8 <http_client_send_request+0x260>)
    749e:	4798      	blx	r3
    74a0:	e7cd      	b.n	743e <http_client_send_request+0x1b6>
		/* Session was busy. Try again later. */
		return -EAGAIN;
	}

	return 0;
}
    74a2:	b008      	add	sp, #32
    74a4:	bc04      	pop	{r2}
    74a6:	4690      	mov	r8, r2
    74a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    74aa:	46c0      	nop			; (mov r8, r8)
    74ac:	0000b0b8 	.word	0x0000b0b8
    74b0:	00008bc1 	.word	0x00008bc1
    74b4:	0000b0c0 	.word	0x0000b0c0
    74b8:	00008bb3 	.word	0x00008bb3
    74bc:	000086ad 	.word	0x000086ad
    74c0:	00008b79 	.word	0x00008b79
    74c4:	00008b69 	.word	0x00008b69
    74c8:	000086c1 	.word	0x000086c1
    74cc:	000086fd 	.word	0x000086fd
    74d0:	00006dd1 	.word	0x00006dd1
    74d4:	00006cb9 	.word	0x00006cb9
    74d8:	00003d99 	.word	0x00003d99
    74dc:	20000168 	.word	0x20000168
    74e0:	00004175 	.word	0x00004175
    74e4:	00003f1d 	.word	0x00003f1d
    74e8:	000041e1 	.word	0x000041e1

000074ec <_http_client_recv_packet>:
		break;
	}
}

void _http_client_recv_packet(struct http_client_module *const module)
{
    74ec:	b510      	push	{r4, lr}
	if (module == NULL) {
    74ee:	2800      	cmp	r0, #0
    74f0:	d012      	beq.n	7518 <_http_client_recv_packet+0x2c>
		return;
	}
	
	if (module->recved_size >= module->config.recv_buffer_size) {
    74f2:	6c41      	ldr	r1, [r0, #68]	; 0x44
    74f4:	6e02      	ldr	r2, [r0, #96]	; 0x60
    74f6:	4291      	cmp	r1, r2
    74f8:	d304      	bcc.n	7504 <_http_client_recv_packet+0x18>
		/* Has not enough memory. */
		_http_client_clear_conn(module, -EOVERFLOW);
    74fa:	218b      	movs	r1, #139	; 0x8b
    74fc:	4249      	negs	r1, r1
    74fe:	4b07      	ldr	r3, [pc, #28]	; (751c <_http_client_recv_packet+0x30>)
    7500:	4798      	blx	r3
		return;
    7502:	e009      	b.n	7518 <_http_client_recv_packet+0x2c>
	/*
	while (recv(module->sock,
		module->config.recv_buffer + module->recved_size,
		module->config.recv_buffer_size - module->recved_size, 0) != 0);
	*/
	recv(module->sock,
    7504:	1a52      	subs	r2, r2, r1
    7506:	b292      	uxth	r2, r2
    7508:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    750a:	469c      	mov	ip, r3
    750c:	4461      	add	r1, ip
    750e:	7800      	ldrb	r0, [r0, #0]
    7510:	b240      	sxtb	r0, r0
    7512:	2300      	movs	r3, #0
    7514:	4c02      	ldr	r4, [pc, #8]	; (7520 <_http_client_recv_packet+0x34>)
    7516:	47a0      	blx	r4
		module->config.recv_buffer + module->recved_size,
		module->config.recv_buffer_size - module->recved_size, 0);
}
    7518:	bd10      	pop	{r4, pc}
    751a:	46c0      	nop			; (mov r8, r8)
    751c:	00006cb9 	.word	0x00006cb9
    7520:	00004045 	.word	0x00004045

00007524 <_http_client_move_buffer>:

	return 0;
}

void _http_client_move_buffer(struct http_client_module *const module, char *base)
{
    7524:	b570      	push	{r4, r5, r6, lr}
    7526:	0005      	movs	r5, r0
	char *buffer = module->config.recv_buffer;
    7528:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
	int remain = (int)module->recved_size - (int)base + (int)buffer;
    752a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    752c:	1a5c      	subs	r4, r3, r1
    752e:	1904      	adds	r4, r0, r4

	if (remain > 0) {
    7530:	2c00      	cmp	r4, #0
    7532:	dd04      	ble.n	753e <_http_client_move_buffer+0x1a>
		memmove(buffer, base, remain);
    7534:	0022      	movs	r2, r4
    7536:	4b03      	ldr	r3, [pc, #12]	; (7544 <_http_client_move_buffer+0x20>)
    7538:	4798      	blx	r3
		module->recved_size = remain;
    753a:	646c      	str	r4, [r5, #68]	; 0x44
    753c:	e001      	b.n	7542 <_http_client_move_buffer+0x1e>
	} else {
		module->recved_size = 0;
    753e:	2300      	movs	r3, #0
    7540:	646b      	str	r3, [r5, #68]	; 0x44
	}
}
    7542:	bd70      	pop	{r4, r5, r6, pc}
    7544:	000086d3 	.word	0x000086d3

00007548 <_http_client_handle_header>:
	}
	return 0;
}

int _http_client_handle_header(struct http_client_module *const module)
{
    7548:	b5f0      	push	{r4, r5, r6, r7, lr}
    754a:	464f      	mov	r7, r9
    754c:	b480      	push	{r7}
    754e:	b084      	sub	sp, #16
    7550:	0007      	movs	r7, r0
	/* New line character only used in this function. So variable registered in the code region. */
	static const char *new_line = "\r\n";

	//TODO : header filter

	for (ptr = module->config.recv_buffer ; ; ) {
    7552:	6dc4      	ldr	r4, [r0, #92]	; 0x5c
		ptr_line_end = strstr(ptr, new_line);
    7554:	4b64      	ldr	r3, [pc, #400]	; (76e8 <_http_client_handle_header+0x1a0>)
    7556:	4699      	mov	r9, r3
    7558:	4964      	ldr	r1, [pc, #400]	; (76ec <_http_client_handle_header+0x1a4>)
    755a:	0020      	movs	r0, r4
    755c:	47c8      	blx	r9
    755e:	1e05      	subs	r5, r0, #0
		if (ptr_line_end == NULL || ptr_line_end >= module->config.recv_buffer + module->recved_size) {
    7560:	d005      	beq.n	756e <_http_client_handle_header+0x26>
    7562:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    7564:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    7566:	4694      	mov	ip, r2
    7568:	4463      	add	r3, ip
    756a:	4298      	cmp	r0, r3
    756c:	d305      	bcc.n	757a <_http_client_handle_header+0x32>
			/* not enough buffer. */
			_http_client_move_buffer(module, ptr);
    756e:	0021      	movs	r1, r4
    7570:	0038      	movs	r0, r7
    7572:	4b5f      	ldr	r3, [pc, #380]	; (76f0 <_http_client_handle_header+0x1a8>)
    7574:	4798      	blx	r3
			return 0;
    7576:	2600      	movs	r6, #0
    7578:	e0b0      	b.n	76dc <_http_client_handle_header+0x194>
		}

		if (!strncmp(ptr, new_line, strlen(new_line))) {
    757a:	2202      	movs	r2, #2
    757c:	495b      	ldr	r1, [pc, #364]	; (76ec <_http_client_handle_header+0x1a4>)
    757e:	0020      	movs	r0, r4
    7580:	4b5c      	ldr	r3, [pc, #368]	; (76f4 <_http_client_handle_header+0x1ac>)
    7582:	4798      	blx	r3
    7584:	2800      	cmp	r0, #0
    7586:	d12c      	bne.n	75e2 <_http_client_handle_header+0x9a>
			/* Move remain data to forward part of buffer. */
			_http_client_move_buffer(module, ptr + strlen(new_line));
    7588:	1ca1      	adds	r1, r4, #2
    758a:	0038      	movs	r0, r7
    758c:	4b58      	ldr	r3, [pc, #352]	; (76f0 <_http_client_handle_header+0x1a8>)
    758e:	4798      	blx	r3

			/* Check validation first. */
			if (module->cb && module->resp.response_code) {
    7590:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
    7592:	2b00      	cmp	r3, #0
    7594:	d020      	beq.n	75d8 <_http_client_handle_header+0x90>
    7596:	22e4      	movs	r2, #228	; 0xe4
    7598:	5ab9      	ldrh	r1, [r7, r2]
    759a:	2900      	cmp	r1, #0
    759c:	d01c      	beq.n	75d8 <_http_client_handle_header+0x90>
				/* Chunked transfer */
				if (module->resp.content_length < 0) {
    759e:	3a08      	subs	r2, #8
    75a0:	58b8      	ldr	r0, [r7, r2]
    75a2:	2800      	cmp	r0, #0
    75a4:	da0b      	bge.n	75be <_http_client_handle_header+0x76>
					data.recv_response.response_code = module->resp.response_code;
    75a6:	aa01      	add	r2, sp, #4
    75a8:	8011      	strh	r1, [r2, #0]
					data.recv_response.is_chunked = 1;
    75aa:	2101      	movs	r1, #1
    75ac:	7091      	strb	r1, [r2, #2]
					module->resp.read_length = 0;
    75ae:	2100      	movs	r1, #0
    75b0:	20e0      	movs	r0, #224	; 0xe0
    75b2:	5039      	str	r1, [r7, r0]
					data.recv_response.content = NULL;
    75b4:	6091      	str	r1, [r2, #8]
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_RESPONSE, &data);
    75b6:	3102      	adds	r1, #2
    75b8:	0038      	movs	r0, r7
    75ba:	4798      	blx	r3
    75bc:	e00c      	b.n	75d8 <_http_client_handle_header+0x90>
				} else if (module->resp.content_length > (int)module->config.recv_buffer_size) {
    75be:	6e3a      	ldr	r2, [r7, #96]	; 0x60
    75c0:	4290      	cmp	r0, r2
    75c2:	dd09      	ble.n	75d8 <_http_client_handle_header+0x90>
					/* Entity is bigger than receive buffer. Sending the buffer to user like chunked transfer. */
					data.recv_response.response_code = module->resp.response_code;
    75c4:	aa01      	add	r2, sp, #4
    75c6:	8011      	strh	r1, [r2, #0]
					data.recv_response.content_length = module->resp.content_length;
    75c8:	6050      	str	r0, [r2, #4]
					data.recv_response.content = NULL;
    75ca:	2100      	movs	r1, #0
    75cc:	6091      	str	r1, [r2, #8]
					module->resp.read_length = 0;
    75ce:	20e0      	movs	r0, #224	; 0xe0
    75d0:	5039      	str	r1, [r7, r0]
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_RESPONSE, &data);
    75d2:	3102      	adds	r1, #2
    75d4:	0038      	movs	r0, r7
    75d6:	4798      	blx	r3
				}
			}

			module->resp.state = STATE_PARSE_ENTITY;
    75d8:	2201      	movs	r2, #1
    75da:	23d8      	movs	r3, #216	; 0xd8
    75dc:	50fa      	str	r2, [r7, r3]
			return 1;
    75de:	2601      	movs	r6, #1
    75e0:	e07c      	b.n	76dc <_http_client_handle_header+0x194>
		} else if (!strncmp(ptr, "Content-Length: ", strlen("Content-Length: "))) {
    75e2:	2210      	movs	r2, #16
    75e4:	4944      	ldr	r1, [pc, #272]	; (76f8 <_http_client_handle_header+0x1b0>)
    75e6:	0020      	movs	r0, r4
    75e8:	4b42      	ldr	r3, [pc, #264]	; (76f4 <_http_client_handle_header+0x1ac>)
    75ea:	4798      	blx	r3
    75ec:	2800      	cmp	r0, #0
    75ee:	d106      	bne.n	75fe <_http_client_handle_header+0xb6>
			module->resp.content_length = atoi(ptr + strlen("Content-Length: "));
    75f0:	0020      	movs	r0, r4
    75f2:	3010      	adds	r0, #16
    75f4:	4b41      	ldr	r3, [pc, #260]	; (76fc <_http_client_handle_header+0x1b4>)
    75f6:	4798      	blx	r3
    75f8:	23dc      	movs	r3, #220	; 0xdc
    75fa:	50f8      	str	r0, [r7, r3]
    75fc:	e06c      	b.n	76d8 <_http_client_handle_header+0x190>
		} else if (!strncmp(ptr, "Transfer-Encoding: ", strlen("Transfer-Encoding: "))) {
    75fe:	2213      	movs	r2, #19
    7600:	493f      	ldr	r1, [pc, #252]	; (7700 <_http_client_handle_header+0x1b8>)
    7602:	0020      	movs	r0, r4
    7604:	4b3b      	ldr	r3, [pc, #236]	; (76f4 <_http_client_handle_header+0x1ac>)
    7606:	4798      	blx	r3
    7608:	1e06      	subs	r6, r0, #0
    760a:	d11d      	bne.n	7648 <_http_client_handle_header+0x100>
			/* Currently does not support gzip or deflate encoding. If received this header, disconnect session immediately*/
			char *type_ptr = ptr + strlen("Transfer-Encoding: ");
    760c:	0022      	movs	r2, r4
    760e:	3213      	adds	r2, #19
			for (; ptr_line_end > type_ptr; type_ptr++) {
    7610:	4295      	cmp	r5, r2
    7612:	d815      	bhi.n	7640 <_http_client_handle_header+0xf8>
    7614:	e060      	b.n	76d8 <_http_client_handle_header+0x190>
				if (*type_ptr == ' ') {
    7616:	7813      	ldrb	r3, [r2, #0]
    7618:	2b20      	cmp	r3, #32
    761a:	d103      	bne.n	7624 <_http_client_handle_header+0xdc>
		} else if (!strncmp(ptr, "Content-Length: ", strlen("Content-Length: "))) {
			module->resp.content_length = atoi(ptr + strlen("Content-Length: "));
		} else if (!strncmp(ptr, "Transfer-Encoding: ", strlen("Transfer-Encoding: "))) {
			/* Currently does not support gzip or deflate encoding. If received this header, disconnect session immediately*/
			char *type_ptr = ptr + strlen("Transfer-Encoding: ");
			for (; ptr_line_end > type_ptr; type_ptr++) {
    761c:	3201      	adds	r2, #1
    761e:	4295      	cmp	r5, r2
    7620:	d1f9      	bne.n	7616 <_http_client_handle_header+0xce>
    7622:	e059      	b.n	76d8 <_http_client_handle_header+0x190>
				if (*type_ptr == ' ') {
					continue;
				} else if (*type_ptr == 'C' || *type_ptr == 'c') {
    7624:	2220      	movs	r2, #32
    7626:	4393      	bics	r3, r2
    7628:	2b43      	cmp	r3, #67	; 0x43
    762a:	d103      	bne.n	7634 <_http_client_handle_header+0xec>
					/* Chunked transfer */
					module->req.content_length = -1;
    762c:	3a21      	subs	r2, #33	; 0x21
    762e:	3389      	adds	r3, #137	; 0x89
    7630:	50fa      	str	r2, [r7, r3]
				} else {
					_http_client_clear_conn(module, -ENOTSUP);
					return 0;
				}
				break;
    7632:	e051      	b.n	76d8 <_http_client_handle_header+0x190>
					continue;
				} else if (*type_ptr == 'C' || *type_ptr == 'c') {
					/* Chunked transfer */
					module->req.content_length = -1;
				} else {
					_http_client_clear_conn(module, -ENOTSUP);
    7634:	2186      	movs	r1, #134	; 0x86
    7636:	4249      	negs	r1, r1
    7638:	0038      	movs	r0, r7
    763a:	4b32      	ldr	r3, [pc, #200]	; (7704 <_http_client_handle_header+0x1bc>)
    763c:	4798      	blx	r3
					return 0;
    763e:	e04d      	b.n	76dc <_http_client_handle_header+0x194>
			module->resp.content_length = atoi(ptr + strlen("Content-Length: "));
		} else if (!strncmp(ptr, "Transfer-Encoding: ", strlen("Transfer-Encoding: "))) {
			/* Currently does not support gzip or deflate encoding. If received this header, disconnect session immediately*/
			char *type_ptr = ptr + strlen("Transfer-Encoding: ");
			for (; ptr_line_end > type_ptr; type_ptr++) {
				if (*type_ptr == ' ') {
    7640:	7ce3      	ldrb	r3, [r4, #19]
    7642:	2b20      	cmp	r3, #32
    7644:	d1ee      	bne.n	7624 <_http_client_handle_header+0xdc>
    7646:	e7e9      	b.n	761c <_http_client_handle_header+0xd4>
					_http_client_clear_conn(module, -ENOTSUP);
					return 0;
				}
				break;
			}
		} else if (!strncmp(ptr, "Connection: ", strlen("Connection: "))) {
    7648:	220c      	movs	r2, #12
    764a:	492f      	ldr	r1, [pc, #188]	; (7708 <_http_client_handle_header+0x1c0>)
    764c:	0020      	movs	r0, r4
    764e:	4b29      	ldr	r3, [pc, #164]	; (76f4 <_http_client_handle_header+0x1ac>)
    7650:	4798      	blx	r3
    7652:	2800      	cmp	r0, #0
    7654:	d11f      	bne.n	7696 <_http_client_handle_header+0x14e>
			char *type_ptr = ptr + strlen("Connection: ");
    7656:	0022      	movs	r2, r4
    7658:	320c      	adds	r2, #12
			for (; ptr_line_end > type_ptr; type_ptr++) {
    765a:	4295      	cmp	r5, r2
    765c:	d817      	bhi.n	768e <_http_client_handle_header+0x146>
    765e:	e03b      	b.n	76d8 <_http_client_handle_header+0x190>
				if (*type_ptr == ' ') {
    7660:	7813      	ldrb	r3, [r2, #0]
    7662:	2b20      	cmp	r3, #32
    7664:	d103      	bne.n	766e <_http_client_handle_header+0x126>
				}
				break;
			}
		} else if (!strncmp(ptr, "Connection: ", strlen("Connection: "))) {
			char *type_ptr = ptr + strlen("Connection: ");
			for (; ptr_line_end > type_ptr; type_ptr++) {
    7666:	3201      	adds	r2, #1
    7668:	4295      	cmp	r5, r2
    766a:	d1f9      	bne.n	7660 <_http_client_handle_header+0x118>
    766c:	e034      	b.n	76d8 <_http_client_handle_header+0x190>
				if (*type_ptr == ' ') {
					continue;
				} else if (*type_ptr == 'K' || *type_ptr == 'k') {
    766e:	2220      	movs	r2, #32
    7670:	4393      	bics	r3, r2
    7672:	2b4b      	cmp	r3, #75	; 0x4b
    7674:	d105      	bne.n	7682 <_http_client_handle_header+0x13a>
					module->permanent = 1;
    7676:	3221      	adds	r2, #33	; 0x21
    7678:	5cb9      	ldrb	r1, [r7, r2]
    767a:	2302      	movs	r3, #2
    767c:	430b      	orrs	r3, r1
    767e:	54bb      	strb	r3, [r7, r2]
    7680:	e02a      	b.n	76d8 <_http_client_handle_header+0x190>
				} else {
					module->permanent = 0;
    7682:	2241      	movs	r2, #65	; 0x41
    7684:	5cbb      	ldrb	r3, [r7, r2]
    7686:	2102      	movs	r1, #2
    7688:	438b      	bics	r3, r1
    768a:	54bb      	strb	r3, [r7, r2]
    768c:	e024      	b.n	76d8 <_http_client_handle_header+0x190>
				break;
			}
		} else if (!strncmp(ptr, "Connection: ", strlen("Connection: "))) {
			char *type_ptr = ptr + strlen("Connection: ");
			for (; ptr_line_end > type_ptr; type_ptr++) {
				if (*type_ptr == ' ') {
    768e:	7b23      	ldrb	r3, [r4, #12]
    7690:	2b20      	cmp	r3, #32
    7692:	d1ec      	bne.n	766e <_http_client_handle_header+0x126>
    7694:	e7e7      	b.n	7666 <_http_client_handle_header+0x11e>
				} else {
					module->permanent = 0;
				}
				break;
			}
		} else if (!strncmp(ptr, "HTTP/", 5)) {
    7696:	2205      	movs	r2, #5
    7698:	491c      	ldr	r1, [pc, #112]	; (770c <_http_client_handle_header+0x1c4>)
    769a:	0020      	movs	r0, r4
    769c:	4b15      	ldr	r3, [pc, #84]	; (76f4 <_http_client_handle_header+0x1ac>)
    769e:	4798      	blx	r3
    76a0:	2800      	cmp	r0, #0
    76a2:	d119      	bne.n	76d8 <_http_client_handle_header+0x190>
			module->resp.response_code = atoi(ptr + 9); /* HTTP/{Ver} {Code} {Desc} : HTTP/1.1 200 OK */
    76a4:	0020      	movs	r0, r4
    76a6:	3009      	adds	r0, #9
    76a8:	4b14      	ldr	r3, [pc, #80]	; (76fc <_http_client_handle_header+0x1b4>)
    76aa:	4798      	blx	r3
    76ac:	23e4      	movs	r3, #228	; 0xe4
    76ae:	52f8      	strh	r0, [r7, r3]
			/* Initializing the variables */
			module->resp.content_length = 0;
    76b0:	2200      	movs	r2, #0
    76b2:	3b08      	subs	r3, #8
    76b4:	50fa      	str	r2, [r7, r3]
			/* persistent connection is turn on in the HTTP 1.1 or above version of protocols. */  
			if (ptr [5] > '1' || ptr[7] > '0') {
    76b6:	7963      	ldrb	r3, [r4, #5]
    76b8:	2b31      	cmp	r3, #49	; 0x31
    76ba:	d802      	bhi.n	76c2 <_http_client_handle_header+0x17a>
    76bc:	79e3      	ldrb	r3, [r4, #7]
    76be:	2b30      	cmp	r3, #48	; 0x30
    76c0:	d905      	bls.n	76ce <_http_client_handle_header+0x186>
				module->permanent = 1;
    76c2:	2241      	movs	r2, #65	; 0x41
    76c4:	5cb9      	ldrb	r1, [r7, r2]
    76c6:	2302      	movs	r3, #2
    76c8:	430b      	orrs	r3, r1
    76ca:	54bb      	strb	r3, [r7, r2]
    76cc:	e004      	b.n	76d8 <_http_client_handle_header+0x190>
			} else {
				module->permanent = 0;
    76ce:	2241      	movs	r2, #65	; 0x41
    76d0:	5cbb      	ldrb	r3, [r7, r2]
    76d2:	2102      	movs	r1, #2
    76d4:	438b      	bics	r3, r1
    76d6:	54bb      	strb	r3, [r7, r2]
			}
		}

		ptr = ptr_line_end + strlen(new_line);
    76d8:	1cac      	adds	r4, r5, #2
	}
    76da:	e73d      	b.n	7558 <_http_client_handle_header+0x10>
}
    76dc:	0030      	movs	r0, r6
    76de:	b004      	add	sp, #16
    76e0:	bc04      	pop	{r2}
    76e2:	4691      	mov	r9, r2
    76e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    76e6:	46c0      	nop			; (mov r8, r8)
    76e8:	00008be5 	.word	0x00008be5
    76ec:	0000b580 	.word	0x0000b580
    76f0:	00007525 	.word	0x00007525
    76f4:	00008bc1 	.word	0x00008bc1
    76f8:	0000b0a4 	.word	0x0000b0a4
    76fc:	00008641 	.word	0x00008641
    7700:	0000b0cc 	.word	0x0000b0cc
    7704:	00006cb9 	.word	0x00006cb9
    7708:	0000b0e0 	.word	0x0000b0e0
    770c:	0000b0f0 	.word	0x0000b0f0

00007710 <_http_client_handle_entity>:
		}
	} while(module->recved_size > 0);
}

int _http_client_handle_entity(struct http_client_module *const module)
{
    7710:	b5f0      	push	{r4, r5, r6, r7, lr}
    7712:	464f      	mov	r7, r9
    7714:	4646      	mov	r6, r8
    7716:	b4c0      	push	{r6, r7}
    7718:	b087      	sub	sp, #28
    771a:	0004      	movs	r4, r0
	union http_client_data data;
	char *buffer = module->config.recv_buffer;
    771c:	6dc5      	ldr	r5, [r0, #92]	; 0x5c

	/* If data size is lesser than buffer size, read all buffer and retransmission it to application. */
	if (module->resp.content_length >= 0 && module->resp.content_length <= (int)module->config.recv_buffer_size) {
    771e:	23dc      	movs	r3, #220	; 0xdc
    7720:	58c3      	ldr	r3, [r0, r3]
    7722:	2b00      	cmp	r3, #0
    7724:	db66      	blt.n	77f4 <_http_client_handle_entity+0xe4>
    7726:	6e02      	ldr	r2, [r0, #96]	; 0x60
    7728:	4293      	cmp	r3, r2
    772a:	dc2b      	bgt.n	7784 <_http_client_handle_entity+0x74>
		} else {
			_http_client_read_chuked_entity(module);
		}
	}

	return 0;
    772c:	2000      	movs	r0, #0
	union http_client_data data;
	char *buffer = module->config.recv_buffer;

	/* If data size is lesser than buffer size, read all buffer and retransmission it to application. */
	if (module->resp.content_length >= 0 && module->resp.content_length <= (int)module->config.recv_buffer_size) {
		if ((int)module->recved_size >= module->resp.content_length) {
    772e:	6c62      	ldr	r2, [r4, #68]	; 0x44
    7730:	4293      	cmp	r3, r2
    7732:	dd00      	ble.n	7736 <_http_client_handle_entity+0x26>
    7734:	e0f5      	b.n	7922 <_http_client_handle_entity+0x212>
			if (module->cb && module->resp.response_code) {
    7736:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
    7738:	2e00      	cmp	r6, #0
    773a:	d00c      	beq.n	7756 <_http_client_handle_entity+0x46>
    773c:	22e4      	movs	r2, #228	; 0xe4
    773e:	5aa1      	ldrh	r1, [r4, r2]
    7740:	2900      	cmp	r1, #0
    7742:	d008      	beq.n	7756 <_http_client_handle_entity+0x46>
				data.recv_response.response_code = module->resp.response_code;
    7744:	aa03      	add	r2, sp, #12
    7746:	8011      	strh	r1, [r2, #0]
				data.recv_response.is_chunked = 0;
    7748:	2100      	movs	r1, #0
    774a:	7091      	strb	r1, [r2, #2]
				data.recv_response.content_length = module->resp.content_length;
    774c:	6053      	str	r3, [r2, #4]
				data.recv_response.content = buffer;
    774e:	6095      	str	r5, [r2, #8]
				module->cb(module, HTTP_CLIENT_CALLBACK_RECV_RESPONSE, &data);
    7750:	3102      	adds	r1, #2
    7752:	0020      	movs	r0, r4
    7754:	47b0      	blx	r6
			}
			module->resp.state = STATE_PARSE_HEADER;
    7756:	2300      	movs	r3, #0
    7758:	22d8      	movs	r2, #216	; 0xd8
    775a:	50a3      	str	r3, [r4, r2]
			module->resp.response_code = 0;
    775c:	320c      	adds	r2, #12
    775e:	52a3      	strh	r3, [r4, r2]
			
			if (module->permanent == 0) {
    7760:	3341      	adds	r3, #65	; 0x41
    7762:	5ce3      	ldrb	r3, [r4, r3]
    7764:	079b      	lsls	r3, r3, #30
    7766:	d405      	bmi.n	7774 <_http_client_handle_entity+0x64>
				/* This server was not supported keep alive. */
				_http_client_clear_conn(module, 0);
    7768:	2100      	movs	r1, #0
    776a:	0020      	movs	r0, r4
    776c:	4b6f      	ldr	r3, [pc, #444]	; (792c <_http_client_handle_entity+0x21c>)
    776e:	4798      	blx	r3
		} else {
			_http_client_read_chuked_entity(module);
		}
	}

	return 0;
    7770:	2000      	movs	r0, #0
    7772:	e0d6      	b.n	7922 <_http_client_handle_entity+0x212>
			
			if (module->permanent == 0) {
				/* This server was not supported keep alive. */
				_http_client_clear_conn(module, 0);
			} else {
				_http_client_move_buffer(module, buffer + module->resp.content_length);
    7774:	23dc      	movs	r3, #220	; 0xdc
    7776:	58e1      	ldr	r1, [r4, r3]
    7778:	1869      	adds	r1, r5, r1
    777a:	0020      	movs	r0, r4
    777c:	4b6c      	ldr	r3, [pc, #432]	; (7930 <_http_client_handle_entity+0x220>)
    777e:	4798      	blx	r3
				return module->recved_size;
    7780:	6c60      	ldr	r0, [r4, #68]	; 0x44
    7782:	e0ce      	b.n	7922 <_http_client_handle_entity+0x212>
			}
		}
		/* else, buffer was not received enough size yet. */
	} else {
		if (module->resp.content_length >= 0) {
			data.recv_chunked_data.length = module->recved_size;
    7784:	6c42      	ldr	r2, [r0, #68]	; 0x44
    7786:	9203      	str	r2, [sp, #12]
			data.recv_chunked_data.data = buffer;
    7788:	9504      	str	r5, [sp, #16]
			module->resp.read_length += (int)module->recved_size;
    778a:	21e0      	movs	r1, #224	; 0xe0
    778c:	5840      	ldr	r0, [r0, r1]
    778e:	4684      	mov	ip, r0
    7790:	4462      	add	r2, ip
    7792:	5062      	str	r2, [r4, r1]
			if (module->resp.content_length <= module->resp.read_length) {
    7794:	4293      	cmp	r3, r2
    7796:	dc0b      	bgt.n	77b0 <_http_client_handle_entity+0xa0>
				/* Complete to receive the buffer. */
				module->resp.state = STATE_PARSE_HEADER;
    7798:	2300      	movs	r3, #0
    779a:	22d8      	movs	r2, #216	; 0xd8
    779c:	50a3      	str	r3, [r4, r2]
				module->resp.response_code = 0;
    779e:	320c      	adds	r2, #12
    77a0:	52a3      	strh	r3, [r4, r2]
				data.recv_chunked_data.is_complete = 1;
    77a2:	3ae3      	subs	r2, #227	; 0xe3
    77a4:	ab03      	add	r3, sp, #12
    77a6:	721a      	strb	r2, [r3, #8]
			} else {
				data.recv_chunked_data.is_complete = 0;
			}

			if (module->cb) {
    77a8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    77aa:	2b00      	cmp	r3, #0
    77ac:	d106      	bne.n	77bc <_http_client_handle_entity+0xac>
    77ae:	e00d      	b.n	77cc <_http_client_handle_entity+0xbc>
				/* Complete to receive the buffer. */
				module->resp.state = STATE_PARSE_HEADER;
				module->resp.response_code = 0;
				data.recv_chunked_data.is_complete = 1;
			} else {
				data.recv_chunked_data.is_complete = 0;
    77b0:	2200      	movs	r2, #0
    77b2:	ab03      	add	r3, sp, #12
    77b4:	721a      	strb	r2, [r3, #8]
			}

			if (module->cb) {
    77b6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    77b8:	2b00      	cmp	r3, #0
    77ba:	d014      	beq.n	77e6 <_http_client_handle_entity+0xd6>
				module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
    77bc:	ae03      	add	r6, sp, #12
    77be:	0032      	movs	r2, r6
    77c0:	2103      	movs	r1, #3
    77c2:	0020      	movs	r0, r4
    77c4:	4798      	blx	r3
			}
			
			if (data.recv_chunked_data.is_complete == 1) {
    77c6:	7a33      	ldrb	r3, [r6, #8]
    77c8:	2b01      	cmp	r3, #1
    77ca:	d10c      	bne.n	77e6 <_http_client_handle_entity+0xd6>
				if (module->permanent == 0) {
    77cc:	2341      	movs	r3, #65	; 0x41
    77ce:	5ce3      	ldrb	r3, [r4, r3]
    77d0:	079b      	lsls	r3, r3, #30
    77d2:	d408      	bmi.n	77e6 <_http_client_handle_entity+0xd6>
					/* This server was not supported keep alive. */
					printf("1\r\n");
    77d4:	4857      	ldr	r0, [pc, #348]	; (7934 <_http_client_handle_entity+0x224>)
    77d6:	4b58      	ldr	r3, [pc, #352]	; (7938 <_http_client_handle_entity+0x228>)
    77d8:	4798      	blx	r3
					_http_client_clear_conn(module, 0);
    77da:	2100      	movs	r1, #0
    77dc:	0020      	movs	r0, r4
    77de:	4b53      	ldr	r3, [pc, #332]	; (792c <_http_client_handle_entity+0x21c>)
    77e0:	4798      	blx	r3
					return 0;
    77e2:	2000      	movs	r0, #0
    77e4:	e09d      	b.n	7922 <_http_client_handle_entity+0x212>
				}
			}
			_http_client_move_buffer(module, buffer + module->recved_size);
    77e6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    77e8:	18e9      	adds	r1, r5, r3
    77ea:	0020      	movs	r0, r4
    77ec:	4b50      	ldr	r3, [pc, #320]	; (7930 <_http_client_handle_entity+0x220>)
    77ee:	4798      	blx	r3
		} else {
			_http_client_read_chuked_entity(module);
		}
	}

	return 0;
    77f0:	2000      	movs	r0, #0
    77f2:	e096      	b.n	7922 <_http_client_handle_entity+0x212>

static void _http_client_read_chuked_entity(struct http_client_module *const module)
{
	/* In chunked mode, read_length variable is means to remain data in the chunk. */
	union http_client_data data;
	int length = (int)module->recved_size;
    77f4:	6c47      	ldr	r7, [r0, #68]	; 0x44
	int extension = 0;
    77f6:	2300      	movs	r3, #0
    77f8:	4699      	mov	r9, r3
	char *buffer= module->config.recv_buffer;

	do {
		if (module->resp.read_length >= 0) {
    77fa:	26e0      	movs	r6, #224	; 0xe0
				if (module->permanent == 0) {
					/* This server was not supported keep alive. */
					_http_client_clear_conn(module, 0);
					return;
				}
				_http_client_move_buffer(module, buffer + 2);
    77fc:	4b4c      	ldr	r3, [pc, #304]	; (7930 <_http_client_handle_entity+0x220>)
    77fe:	4698      	mov	r8, r3
	int length = (int)module->recved_size;
	int extension = 0;
	char *buffer= module->config.recv_buffer;

	do {
		if (module->resp.read_length >= 0) {
    7800:	59a3      	ldr	r3, [r4, r6]
    7802:	2b00      	cmp	r3, #0
    7804:	db36      	blt.n	7874 <_http_client_handle_entity+0x164>
			if (module->resp.read_length == 0) {
    7806:	d11c      	bne.n	7842 <_http_client_handle_entity+0x132>
				/* Complete to receive the buffer. */
				module->resp.state = STATE_PARSE_HEADER;
    7808:	22d8      	movs	r2, #216	; 0xd8
    780a:	50a3      	str	r3, [r4, r2]
				module->resp.response_code = 0;
    780c:	320c      	adds	r2, #12
    780e:	52a3      	strh	r3, [r4, r2]
				data.recv_chunked_data.is_complete = 1;
    7810:	3ae3      	subs	r2, #227	; 0xe3
    7812:	4669      	mov	r1, sp
    7814:	720a      	strb	r2, [r1, #8]
				data.recv_chunked_data.length = 0;
    7816:	9300      	str	r3, [sp, #0]
				data.recv_chunked_data.data = NULL;
    7818:	9301      	str	r3, [sp, #4]
				if (module->cb) {
    781a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    781c:	2b00      	cmp	r3, #0
    781e:	d003      	beq.n	7828 <_http_client_handle_entity+0x118>
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
    7820:	466a      	mov	r2, sp
    7822:	2103      	movs	r1, #3
    7824:	0020      	movs	r0, r4
    7826:	4798      	blx	r3
				}
				if (module->permanent == 0) {
    7828:	2341      	movs	r3, #65	; 0x41
    782a:	5ce3      	ldrb	r3, [r4, r3]
    782c:	079b      	lsls	r3, r3, #30
    782e:	d404      	bmi.n	783a <_http_client_handle_entity+0x12a>
					/* This server was not supported keep alive. */
					_http_client_clear_conn(module, 0);
    7830:	2100      	movs	r1, #0
    7832:	0020      	movs	r0, r4
    7834:	4b3d      	ldr	r3, [pc, #244]	; (792c <_http_client_handle_entity+0x21c>)
    7836:	4798      	blx	r3
    7838:	e06b      	b.n	7912 <_http_client_handle_entity+0x202>
					return;
				}
				_http_client_move_buffer(module, buffer + 2);
    783a:	1ca9      	adds	r1, r5, #2
    783c:	0020      	movs	r0, r4
    783e:	47c0      	blx	r8
    7840:	e061      	b.n	7906 <_http_client_handle_entity+0x1f6>
			} else if (module->resp.read_length <= length) {
    7842:	42bb      	cmp	r3, r7
    7844:	dc5f      	bgt.n	7906 <_http_client_handle_entity+0x1f6>
				data.recv_chunked_data.length = module->resp.read_length;
    7846:	9300      	str	r3, [sp, #0]
				data.recv_chunked_data.data = buffer;
    7848:	9501      	str	r5, [sp, #4]
				data.recv_chunked_data.is_complete = 0;
    784a:	2300      	movs	r3, #0
    784c:	466a      	mov	r2, sp
    784e:	7213      	strb	r3, [r2, #8]

				if (module->cb) {
    7850:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7852:	2b00      	cmp	r3, #0
    7854:	d002      	beq.n	785c <_http_client_handle_entity+0x14c>
					module->cb(module, HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA, &data);
    7856:	2103      	movs	r1, #3
    7858:	0020      	movs	r0, r4
    785a:	4798      	blx	r3
				}
				/* Last two character in the chunk is '\r\n'. */
				_http_client_move_buffer(module, buffer + module->resp.read_length + 2 /* sizeof newline character */);
    785c:	59a3      	ldr	r3, [r4, r6]
    785e:	1c99      	adds	r1, r3, #2
    7860:	1869      	adds	r1, r5, r1
    7862:	0020      	movs	r0, r4
    7864:	4b32      	ldr	r3, [pc, #200]	; (7930 <_http_client_handle_entity+0x220>)
    7866:	4798      	blx	r3
				length = (int)module->recved_size;
    7868:	6c67      	ldr	r7, [r4, #68]	; 0x44
				buffer = module->config.recv_buffer;
    786a:	6de5      	ldr	r5, [r4, #92]	; 0x5c
				module->resp.read_length = -1;
    786c:	2301      	movs	r3, #1
    786e:	425b      	negs	r3, r3
    7870:	51a3      	str	r3, [r4, r6]
    7872:	e048      	b.n	7906 <_http_client_handle_entity+0x1f6>
			}
		} else {
			/* Read chunked length. */
			module->resp.read_length = 0;
    7874:	2300      	movs	r3, #0
    7876:	51a3      	str	r3, [r4, r6]
			for (; length > 0; buffer++, length--) {
    7878:	2f00      	cmp	r7, #0
    787a:	dd33      	ble.n	78e4 <_http_client_handle_entity+0x1d4>
				if (*buffer == '\n') {
    787c:	782b      	ldrb	r3, [r5, #0]
    787e:	2b0a      	cmp	r3, #10
    7880:	d003      	beq.n	788a <_http_client_handle_entity+0x17a>
    7882:	e005      	b.n	7890 <_http_client_handle_entity+0x180>
    7884:	782b      	ldrb	r3, [r5, #0]
    7886:	2b0a      	cmp	r3, #10
    7888:	d102      	bne.n	7890 <_http_client_handle_entity+0x180>
					buffer++;
    788a:	3501      	adds	r5, #1
					length--;
    788c:	3f01      	subs	r7, #1
    788e:	e029      	b.n	78e4 <_http_client_handle_entity+0x1d4>
					break;
				}
				if (extension != 0) {
    7890:	464a      	mov	r2, r9
    7892:	2a00      	cmp	r2, #0
    7894:	d121      	bne.n	78da <_http_client_handle_entity+0x1ca>
					continue;
				}
				if (*buffer >= '0' && *buffer <= '9') {
    7896:	001a      	movs	r2, r3
    7898:	3a30      	subs	r2, #48	; 0x30
    789a:	2a09      	cmp	r2, #9
    789c:	d805      	bhi.n	78aa <_http_client_handle_entity+0x19a>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - '0';
    789e:	59a2      	ldr	r2, [r4, r6]
    78a0:	0112      	lsls	r2, r2, #4
    78a2:	18d3      	adds	r3, r2, r3
    78a4:	3b30      	subs	r3, #48	; 0x30
    78a6:	51a3      	str	r3, [r4, r6]
    78a8:	e017      	b.n	78da <_http_client_handle_entity+0x1ca>
				} else if (*buffer >= 'a' && *buffer <= 'f') {
    78aa:	001a      	movs	r2, r3
    78ac:	3a61      	subs	r2, #97	; 0x61
    78ae:	2a05      	cmp	r2, #5
    78b0:	d805      	bhi.n	78be <_http_client_handle_entity+0x1ae>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - 'a';
    78b2:	59a2      	ldr	r2, [r4, r6]
    78b4:	0112      	lsls	r2, r2, #4
    78b6:	18d3      	adds	r3, r2, r3
    78b8:	3b61      	subs	r3, #97	; 0x61
    78ba:	51a3      	str	r3, [r4, r6]
    78bc:	e00d      	b.n	78da <_http_client_handle_entity+0x1ca>
				} else if (*buffer >= 'A' && *buffer <= 'F') {
    78be:	001a      	movs	r2, r3
    78c0:	3a41      	subs	r2, #65	; 0x41
    78c2:	2a05      	cmp	r2, #5
    78c4:	d805      	bhi.n	78d2 <_http_client_handle_entity+0x1c2>
					module->resp.read_length = module->resp.read_length * 0x10 + *buffer - 'A';
    78c6:	59a2      	ldr	r2, [r4, r6]
    78c8:	0112      	lsls	r2, r2, #4
    78ca:	18d3      	adds	r3, r2, r3
    78cc:	3b41      	subs	r3, #65	; 0x41
    78ce:	51a3      	str	r3, [r4, r6]
    78d0:	e003      	b.n	78da <_http_client_handle_entity+0x1ca>
    78d2:	3b3b      	subs	r3, #59	; 0x3b
    78d4:	425a      	negs	r2, r3
    78d6:	415a      	adcs	r2, r3
    78d8:	4691      	mov	r9, r2
				module->resp.read_length = -1;
			}
		} else {
			/* Read chunked length. */
			module->resp.read_length = 0;
			for (; length > 0; buffer++, length--) {
    78da:	3501      	adds	r5, #1
    78dc:	3f01      	subs	r7, #1
    78de:	2f00      	cmp	r7, #0
    78e0:	d1d0      	bne.n	7884 <_http_client_handle_entity+0x174>
    78e2:	e018      	b.n	7916 <_http_client_handle_entity+0x206>
				} else if (*buffer == ';') {
					extension = 1;
				}
			}

			if (module->resp.read_length > (int)module->config.recv_buffer_size) {
    78e4:	59a3      	ldr	r3, [r4, r6]
    78e6:	6e22      	ldr	r2, [r4, #96]	; 0x60
    78e8:	4293      	cmp	r3, r2
    78ea:	dd05      	ble.n	78f8 <_http_client_handle_entity+0x1e8>
				/* Chunked size is too big. */
				/* Through exception. */
				_http_client_clear_conn(module, -EOVERFLOW);
    78ec:	218b      	movs	r1, #139	; 0x8b
    78ee:	4249      	negs	r1, r1
    78f0:	0020      	movs	r0, r4
    78f2:	4b0e      	ldr	r3, [pc, #56]	; (792c <_http_client_handle_entity+0x21c>)
    78f4:	4798      	blx	r3
    78f6:	e00c      	b.n	7912 <_http_client_handle_entity+0x202>
				return;
			}

			if (length  == 0) {
    78f8:	2f00      	cmp	r7, #0
    78fa:	d104      	bne.n	7906 <_http_client_handle_entity+0x1f6>
				/* currently not received packet yet. */
				module->resp.read_length = -1;
    78fc:	2201      	movs	r2, #1
    78fe:	4252      	negs	r2, r2
    7900:	23e0      	movs	r3, #224	; 0xe0
    7902:	50e2      	str	r2, [r4, r3]
    7904:	e005      	b.n	7912 <_http_client_handle_entity+0x202>
				return;
			}
		}
	} while(module->recved_size > 0);
    7906:	6c63      	ldr	r3, [r4, #68]	; 0x44
    7908:	2b00      	cmp	r3, #0
    790a:	d000      	beq.n	790e <_http_client_handle_entity+0x1fe>
    790c:	e778      	b.n	7800 <_http_client_handle_entity+0xf0>
		} else {
			_http_client_read_chuked_entity(module);
		}
	}

	return 0;
    790e:	2000      	movs	r0, #0
    7910:	e007      	b.n	7922 <_http_client_handle_entity+0x212>
    7912:	2000      	movs	r0, #0
    7914:	e005      	b.n	7922 <_http_client_handle_entity+0x212>
				} else if (*buffer == ';') {
					extension = 1;
				}
			}

			if (module->resp.read_length > (int)module->config.recv_buffer_size) {
    7916:	23e0      	movs	r3, #224	; 0xe0
    7918:	58e3      	ldr	r3, [r4, r3]
    791a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    791c:	4293      	cmp	r3, r2
    791e:	dce5      	bgt.n	78ec <_http_client_handle_entity+0x1dc>
    7920:	e7ec      	b.n	78fc <_http_client_handle_entity+0x1ec>
			_http_client_read_chuked_entity(module);
		}
	}

	return 0;
}
    7922:	b007      	add	sp, #28
    7924:	bc0c      	pop	{r2, r3}
    7926:	4690      	mov	r8, r2
    7928:	4699      	mov	r9, r3
    792a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    792c:	00006cb9 	.word	0x00006cb9
    7930:	00007525 	.word	0x00007525
    7934:	0000b0f8 	.word	0x0000b0f8
    7938:	00008965 	.word	0x00008965

0000793c <_http_client_handle_response>:
	/* Recursive function call can be occurred overflow. */
	while(_http_client_handle_response(module) != 0);
}

int _http_client_handle_response(struct http_client_module *const module)
{
    793c:	b510      	push	{r4, lr}
	switch(module->resp.state) {
    793e:	23d8      	movs	r3, #216	; 0xd8
    7940:	58c3      	ldr	r3, [r0, r3]
    7942:	2b00      	cmp	r3, #0
    7944:	d002      	beq.n	794c <_http_client_handle_response+0x10>
    7946:	2b01      	cmp	r3, #1
    7948:	d003      	beq.n	7952 <_http_client_handle_response+0x16>
    794a:	e005      	b.n	7958 <_http_client_handle_response+0x1c>
	case STATE_PARSE_HEADER:
		return _http_client_handle_header(module);
    794c:	4b03      	ldr	r3, [pc, #12]	; (795c <_http_client_handle_response+0x20>)
    794e:	4798      	blx	r3
    7950:	e003      	b.n	795a <_http_client_handle_response+0x1e>
	case STATE_PARSE_ENTITY:
		return _http_client_handle_entity(module);
    7952:	4b03      	ldr	r3, [pc, #12]	; (7960 <_http_client_handle_response+0x24>)
    7954:	4798      	blx	r3
    7956:	e000      	b.n	795a <_http_client_handle_response+0x1e>
	}
	return 0;
    7958:	2000      	movs	r0, #0
}
    795a:	bd10      	pop	{r4, pc}
    795c:	00007549 	.word	0x00007549
    7960:	00007711 	.word	0x00007711

00007964 <_http_client_recved_packet>:
		module->config.recv_buffer + module->recved_size,
		module->config.recv_buffer_size - module->recved_size, 0);
}

void _http_client_recved_packet(struct http_client_module *const module, int read_len)
{
    7964:	b570      	push	{r4, r5, r6, lr}
    7966:	0004      	movs	r4, r0
	module->recved_size += read_len;
    7968:	6c43      	ldr	r3, [r0, #68]	; 0x44
    796a:	469c      	mov	ip, r3
    796c:	4461      	add	r1, ip
    796e:	6441      	str	r1, [r0, #68]	; 0x44
	if (module->config.timeout > 0) {
    7970:	2358      	movs	r3, #88	; 0x58
    7972:	5ac3      	ldrh	r3, [r0, r3]
    7974:	2b00      	cmp	r3, #0
    7976:	d003      	beq.n	7980 <_http_client_recved_packet+0x1c>
		sw_timer_disable_callback(module->config.timer_inst, module->timer_id);
    7978:	6c81      	ldr	r1, [r0, #72]	; 0x48
    797a:	6d40      	ldr	r0, [r0, #84]	; 0x54
    797c:	4b03      	ldr	r3, [pc, #12]	; (798c <_http_client_recved_packet+0x28>)
    797e:	4798      	blx	r3
	}

	/* Recursive function call can be occurred overflow. */
	while(_http_client_handle_response(module) != 0);
    7980:	4d03      	ldr	r5, [pc, #12]	; (7990 <_http_client_recved_packet+0x2c>)
    7982:	0020      	movs	r0, r4
    7984:	47a8      	blx	r5
    7986:	2800      	cmp	r0, #0
    7988:	d1fb      	bne.n	7982 <_http_client_recved_packet+0x1e>
}
    798a:	bd70      	pop	{r4, r5, r6, pc}
    798c:	00007d05 	.word	0x00007d05
    7990:	0000793d 	.word	0x0000793d

00007994 <http_client_socket_event_handler>:
			return 0;
	}
}

void http_client_socket_event_handler(SOCKET sock, uint8_t msg_type, void *msg_data)
{
    7994:	b510      	push	{r4, lr}
    7996:	b084      	sub	sp, #16
	tstrSocketRecvMsg *msg_recv;
	int16_t send_ret;
	union http_client_data data;

	/* Find instance using the socket descriptor. */
	struct http_client_module *module = module_ref_inst[sock];
    7998:	0080      	lsls	r0, r0, #2
    799a:	4b65      	ldr	r3, [pc, #404]	; (7b30 <http_client_socket_event_handler+0x19c>)
    799c:	58c4      	ldr	r4, [r0, r3]
	/* If cannot found reference, This socket is not HTTP client socket. */
	if (module == NULL) {
    799e:	2c00      	cmp	r4, #0
    79a0:	d100      	bne.n	79a4 <http_client_socket_event_handler+0x10>
    79a2:	e0c3      	b.n	7b2c <http_client_socket_event_handler+0x198>
		return;
	}

	switch (msg_type) {
    79a4:	2906      	cmp	r1, #6
    79a6:	d050      	beq.n	7a4a <http_client_socket_event_handler+0xb6>
    79a8:	2907      	cmp	r1, #7
    79aa:	d100      	bne.n	79ae <http_client_socket_event_handler+0x1a>
    79ac:	e089      	b.n	7ac2 <http_client_socket_event_handler+0x12e>
    79ae:	2905      	cmp	r1, #5
    79b0:	d000      	beq.n	79b4 <http_client_socket_event_handler+0x20>
    79b2:	e0bb      	b.n	7b2c <http_client_socket_event_handler+0x198>
	case SOCKET_MSG_CONNECT:
    	msg_connect = (tstrSocketConnectMsg*)msg_data;
    	data.sock_connected.result = msg_connect->s8Error;
    79b4:	2301      	movs	r3, #1
    79b6:	56d3      	ldrsb	r3, [r2, r3]
    79b8:	1e1a      	subs	r2, r3, #0
    79ba:	9301      	str	r3, [sp, #4]
    	if (msg_connect->s8Error < 0) {
    79bc:	da2f      	bge.n	7a1e <http_client_socket_event_handler+0x8a>
/**
 * \brief change HW error type to standard error.
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
    79be:	330e      	adds	r3, #14
    79c0:	b2d9      	uxtb	r1, r3
    79c2:	290e      	cmp	r1, #14
    79c4:	d81e      	bhi.n	7a04 <http_client_socket_event_handler+0x70>
    79c6:	008b      	lsls	r3, r1, #2
    79c8:	495a      	ldr	r1, [pc, #360]	; (7b34 <http_client_socket_event_handler+0x1a0>)
    79ca:	58cb      	ldr	r3, [r1, r3]
    79cc:	469f      	mov	pc, r3
		case 0:
			return -EIO;
		case SOCK_ERR_INVALID_ADDRESS:
			return -ENOENT;
    79ce:	2102      	movs	r1, #2
    79d0:	4249      	negs	r1, r1
    79d2:	e020      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_ADDR_ALREADY_IN_USE:
			return -EADDRINUSE;
    79d4:	2170      	movs	r1, #112	; 0x70
    79d6:	4249      	negs	r1, r1
    79d8:	e01d      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_MAX_TCP_SOCK:
		case SOCK_ERR_MAX_UDP_SOCK:
			return -ENOMEM;
    79da:	210c      	movs	r1, #12
    79dc:	4249      	negs	r1, r1
    79de:	e01a      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_INVALID_ARG:
			return -EINVAL;
    79e0:	2116      	movs	r1, #22
    79e2:	4249      	negs	r1, r1
    79e4:	e017      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_MAX_LISTEN_SOCK:
			return -ENOMEM;
    79e6:	210c      	movs	r1, #12
    79e8:	4249      	negs	r1, r1
    79ea:	e014      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_INVALID:
			return -EIO;
		case SOCK_ERR_ADDR_IS_REQUIRED:
			return -EDESTADDRREQ;
    79ec:	2179      	movs	r1, #121	; 0x79
    79ee:	4249      	negs	r1, r1
    79f0:	e011      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_CONN_ABORTED:
			return -ECONNRESET;
    79f2:	2168      	movs	r1, #104	; 0x68
    79f4:	4249      	negs	r1, r1
    79f6:	e00e      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_TIMEOUT:
			return -EAGAIN;
    79f8:	210b      	movs	r1, #11
    79fa:	4249      	negs	r1, r1
    79fc:	e00b      	b.n	7a16 <http_client_socket_event_handler+0x82>
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
    79fe:	2110      	movs	r1, #16
    7a00:	4249      	negs	r1, r1
    7a02:	e008      	b.n	7a16 <http_client_socket_event_handler+0x82>
		default:
			if (err < 0) {
    7a04:	2a00      	cmp	r2, #0
    7a06:	db04      	blt.n	7a12 <http_client_socket_event_handler+0x7e>
				return -EIO;
			}
			return 0;
    7a08:	2100      	movs	r1, #0
    7a0a:	e004      	b.n	7a16 <http_client_socket_event_handler+0x82>
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
		case 0:
			return -EIO;
    7a0c:	2105      	movs	r1, #5
    7a0e:	4249      	negs	r1, r1
    7a10:	e001      	b.n	7a16 <http_client_socket_event_handler+0x82>
			return -EAGAIN;
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
		default:
			if (err < 0) {
				return -EIO;
    7a12:	2105      	movs	r1, #5
    7a14:	4249      	negs	r1, r1
	case SOCKET_MSG_CONNECT:
    	msg_connect = (tstrSocketConnectMsg*)msg_data;
    	data.sock_connected.result = msg_connect->s8Error;
    	if (msg_connect->s8Error < 0) {
			/* Remove reference. */
			_http_client_clear_conn(module, _hwerr_to_stderr(msg_connect->s8Error));
    7a16:	0020      	movs	r0, r4
    7a18:	4b47      	ldr	r3, [pc, #284]	; (7b38 <http_client_socket_event_handler+0x1a4>)
    7a1a:	4798      	blx	r3
    7a1c:	e086      	b.n	7b2c <http_client_socket_event_handler+0x198>
		} else {
			/* Send event to callback. */
			if (module->cb != NULL) {
    7a1e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    7a20:	2b00      	cmp	r3, #0
    7a22:	d003      	beq.n	7a2c <http_client_socket_event_handler+0x98>
				module->cb(module, HTTP_CLIENT_CALLBACK_SOCK_CONNECTED, &data);
    7a24:	aa01      	add	r2, sp, #4
    7a26:	2100      	movs	r1, #0
    7a28:	0020      	movs	r0, r4
    7a2a:	4798      	blx	r3
			}
			module->req.state = STATE_REQ_SEND_HEADER;
    7a2c:	2303      	movs	r3, #3
    7a2e:	66e3      	str	r3, [r4, #108]	; 0x6c
			/* Start timer. */
			sw_timer_enable_callback(module->config.timer_inst, module->timer_id, module->config.timeout);
    7a30:	3355      	adds	r3, #85	; 0x55
    7a32:	5ae2      	ldrh	r2, [r4, r3]
    7a34:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    7a36:	6d60      	ldr	r0, [r4, #84]	; 0x54
    7a38:	4b40      	ldr	r3, [pc, #256]	; (7b3c <http_client_socket_event_handler+0x1a8>)
    7a3a:	4798      	blx	r3
    		/* Start receive packet. */
    		_http_client_recv_packet(module);
    7a3c:	0020      	movs	r0, r4
    7a3e:	4b40      	ldr	r3, [pc, #256]	; (7b40 <http_client_socket_event_handler+0x1ac>)
    7a40:	4798      	blx	r3
			/* Try to check the FSM. */
			_http_client_request(module);
    7a42:	0020      	movs	r0, r4
    7a44:	4b3f      	ldr	r3, [pc, #252]	; (7b44 <http_client_socket_event_handler+0x1b0>)
    7a46:	4798      	blx	r3
    7a48:	e070      	b.n	7b2c <http_client_socket_event_handler+0x198>
		}
    	break;
	case SOCKET_MSG_RECV:
    	msg_recv = (tstrSocketRecvMsg*)msg_data;
    	/* Start post processing. */
    	if (msg_recv->s16BufferSize > 0) {
    7a4a:	2304      	movs	r3, #4
    7a4c:	5ed1      	ldrsh	r1, [r2, r3]
    7a4e:	2900      	cmp	r1, #0
    7a50:	dd03      	ble.n	7a5a <http_client_socket_event_handler+0xc6>
    		_http_client_recved_packet(module, msg_recv->s16BufferSize);
    7a52:	0020      	movs	r0, r4
    7a54:	4b3c      	ldr	r3, [pc, #240]	; (7b48 <http_client_socket_event_handler+0x1b4>)
    7a56:	4798      	blx	r3
    7a58:	e02f      	b.n	7aba <http_client_socket_event_handler+0x126>
/**
 * \brief change HW error type to standard error.
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
    7a5a:	000b      	movs	r3, r1
    7a5c:	330e      	adds	r3, #14
    7a5e:	b29a      	uxth	r2, r3
    7a60:	2a0e      	cmp	r2, #14
    7a62:	d81e      	bhi.n	7aa2 <http_client_socket_event_handler+0x10e>
    7a64:	0093      	lsls	r3, r2, #2
    7a66:	4a39      	ldr	r2, [pc, #228]	; (7b4c <http_client_socket_event_handler+0x1b8>)
    7a68:	58d3      	ldr	r3, [r2, r3]
    7a6a:	469f      	mov	pc, r3
		case 0:
			return -EIO;
		case SOCK_ERR_INVALID_ADDRESS:
			return -ENOENT;
    7a6c:	2102      	movs	r1, #2
    7a6e:	4249      	negs	r1, r1
    7a70:	e020      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_ADDR_ALREADY_IN_USE:
			return -EADDRINUSE;
    7a72:	2170      	movs	r1, #112	; 0x70
    7a74:	4249      	negs	r1, r1
    7a76:	e01d      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_MAX_TCP_SOCK:
		case SOCK_ERR_MAX_UDP_SOCK:
			return -ENOMEM;
    7a78:	210c      	movs	r1, #12
    7a7a:	4249      	negs	r1, r1
    7a7c:	e01a      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_INVALID_ARG:
			return -EINVAL;
    7a7e:	2116      	movs	r1, #22
    7a80:	4249      	negs	r1, r1
    7a82:	e017      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_MAX_LISTEN_SOCK:
			return -ENOMEM;
    7a84:	210c      	movs	r1, #12
    7a86:	4249      	negs	r1, r1
    7a88:	e014      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_INVALID:
			return -EIO;
		case SOCK_ERR_ADDR_IS_REQUIRED:
			return -EDESTADDRREQ;
    7a8a:	2179      	movs	r1, #121	; 0x79
    7a8c:	4249      	negs	r1, r1
    7a8e:	e011      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_CONN_ABORTED:
			return -ECONNRESET;
    7a90:	2168      	movs	r1, #104	; 0x68
    7a92:	4249      	negs	r1, r1
    7a94:	e00e      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_TIMEOUT:
			return -EAGAIN;
    7a96:	210b      	movs	r1, #11
    7a98:	4249      	negs	r1, r1
    7a9a:	e00b      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
    7a9c:	2110      	movs	r1, #16
    7a9e:	4249      	negs	r1, r1
    7aa0:	e008      	b.n	7ab4 <http_client_socket_event_handler+0x120>
		default:
			if (err < 0) {
    7aa2:	2900      	cmp	r1, #0
    7aa4:	db04      	blt.n	7ab0 <http_client_socket_event_handler+0x11c>
				return -EIO;
			}
			return 0;
    7aa6:	2100      	movs	r1, #0
    7aa8:	e004      	b.n	7ab4 <http_client_socket_event_handler+0x120>
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
		case 0:
			return -EIO;
    7aaa:	2105      	movs	r1, #5
    7aac:	4249      	negs	r1, r1
    7aae:	e001      	b.n	7ab4 <http_client_socket_event_handler+0x120>
			return -EAGAIN;
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
		default:
			if (err < 0) {
				return -EIO;
    7ab0:	2105      	movs	r1, #5
    7ab2:	4249      	negs	r1, r1
    	/* Start post processing. */
    	if (msg_recv->s16BufferSize > 0) {
    		_http_client_recved_packet(module, msg_recv->s16BufferSize);
		} else {
			/* Socket was occurred errors. Close this session. */
			_http_client_clear_conn(module, _hwerr_to_stderr(msg_recv->s16BufferSize));
    7ab4:	0020      	movs	r0, r4
    7ab6:	4b20      	ldr	r3, [pc, #128]	; (7b38 <http_client_socket_event_handler+0x1a4>)
    7ab8:	4798      	blx	r3
		}
		/* COntinue to receive the packet. */
		_http_client_recv_packet(module);
    7aba:	0020      	movs	r0, r4
    7abc:	4b20      	ldr	r3, [pc, #128]	; (7b40 <http_client_socket_event_handler+0x1ac>)
    7abe:	4798      	blx	r3
		break;
    7ac0:	e034      	b.n	7b2c <http_client_socket_event_handler+0x198>
	case SOCKET_MSG_SEND:
		send_ret = *(int16_t*)msg_data;
    7ac2:	2300      	movs	r3, #0
    7ac4:	5ed3      	ldrsh	r3, [r2, r3]
		if (send_ret < 0) {
    7ac6:	2b00      	cmp	r3, #0
    7ac8:	da28      	bge.n	7b1c <http_client_socket_event_handler+0x188>
/**
 * \brief change HW error type to standard error.
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
    7aca:	330e      	adds	r3, #14
    7acc:	b29a      	uxth	r2, r3
    7ace:	2a0d      	cmp	r2, #13
    7ad0:	d81e      	bhi.n	7b10 <http_client_socket_event_handler+0x17c>
    7ad2:	0093      	lsls	r3, r2, #2
    7ad4:	4a1e      	ldr	r2, [pc, #120]	; (7b50 <http_client_socket_event_handler+0x1bc>)
    7ad6:	58d3      	ldr	r3, [r2, r3]
    7ad8:	469f      	mov	pc, r3
		case 0:
			return -EIO;
		case SOCK_ERR_INVALID_ADDRESS:
			return -ENOENT;
    7ada:	2102      	movs	r1, #2
    7adc:	4249      	negs	r1, r1
    7ade:	e019      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_ADDR_ALREADY_IN_USE:
			return -EADDRINUSE;
    7ae0:	2170      	movs	r1, #112	; 0x70
    7ae2:	4249      	negs	r1, r1
    7ae4:	e016      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_MAX_TCP_SOCK:
		case SOCK_ERR_MAX_UDP_SOCK:
			return -ENOMEM;
    7ae6:	210c      	movs	r1, #12
    7ae8:	4249      	negs	r1, r1
    7aea:	e013      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_INVALID_ARG:
			return -EINVAL;
    7aec:	2116      	movs	r1, #22
    7aee:	4249      	negs	r1, r1
    7af0:	e010      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_MAX_LISTEN_SOCK:
			return -ENOMEM;
    7af2:	210c      	movs	r1, #12
    7af4:	4249      	negs	r1, r1
    7af6:	e00d      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_INVALID:
			return -EIO;
		case SOCK_ERR_ADDR_IS_REQUIRED:
			return -EDESTADDRREQ;
    7af8:	2179      	movs	r1, #121	; 0x79
    7afa:	4249      	negs	r1, r1
    7afc:	e00a      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_CONN_ABORTED:
			return -ECONNRESET;
    7afe:	2168      	movs	r1, #104	; 0x68
    7b00:	4249      	negs	r1, r1
    7b02:	e007      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_TIMEOUT:
			return -EAGAIN;
    7b04:	210b      	movs	r1, #11
    7b06:	4249      	negs	r1, r1
    7b08:	e004      	b.n	7b14 <http_client_socket_event_handler+0x180>
		case SOCK_ERR_BUFFER_FULL:
			return -EBUSY; /* HW error occurred. Retry it*/
    7b0a:	2110      	movs	r1, #16
    7b0c:	4249      	negs	r1, r1
    7b0e:	e001      	b.n	7b14 <http_client_socket_event_handler+0x180>
 */
static inline int _hwerr_to_stderr(int err)
{
	switch (err) {
		case 0:
			return -EIO;
    7b10:	2105      	movs	r1, #5
    7b12:	4249      	negs	r1, r1
		break;
	case SOCKET_MSG_SEND:
		send_ret = *(int16_t*)msg_data;
		if (send_ret < 0) {
			/* Send failed. */
			_http_client_clear_conn(module, _hwerr_to_stderr(send_ret));
    7b14:	0020      	movs	r0, r4
    7b16:	4b08      	ldr	r3, [pc, #32]	; (7b38 <http_client_socket_event_handler+0x1a4>)
    7b18:	4798      	blx	r3
    7b1a:	e002      	b.n	7b22 <http_client_socket_event_handler+0x18e>
		} else {
			/* Try to check the FSM. */
    		_http_client_request(module);
    7b1c:	0020      	movs	r0, r4
    7b1e:	4b09      	ldr	r3, [pc, #36]	; (7b44 <http_client_socket_event_handler+0x1b0>)
    7b20:	4798      	blx	r3
		}
		/* Disable sending flag. */
		module->sending = 0;
    7b22:	2241      	movs	r2, #65	; 0x41
    7b24:	5ca3      	ldrb	r3, [r4, r2]
    7b26:	2101      	movs	r1, #1
    7b28:	438b      	bics	r3, r1
    7b2a:	54a3      	strb	r3, [r4, r2]
    	break;
	default:
		break;
	}

}
    7b2c:	b004      	add	sp, #16
    7b2e:	bd10      	pop	{r4, pc}
    7b30:	20000168 	.word	0x20000168
    7b34:	0000af14 	.word	0x0000af14
    7b38:	00006cb9 	.word	0x00006cb9
    7b3c:	00007cd9 	.word	0x00007cd9
    7b40:	000074ed 	.word	0x000074ed
    7b44:	00006dd1 	.word	0x00006dd1
    7b48:	00007965 	.word	0x00007965
    7b4c:	0000af50 	.word	0x0000af50
    7b50:	0000af8c 	.word	0x0000af8c

00007b54 <stream_writer_init>:
#include <string.h>
#include "iot/stream_writer.h"

void stream_writer_init(struct stream_writer * writer, char *buffer, size_t max_length, stream_writer_write_func_t func, void *priv_data)
{
	writer->max_size = max_length;
    7b54:	6002      	str	r2, [r0, #0]
	writer->buffer = buffer;
    7b56:	6101      	str	r1, [r0, #16]
	writer->written = 0;
    7b58:	2200      	movs	r2, #0
    7b5a:	6042      	str	r2, [r0, #4]
	writer->write_func = func;
    7b5c:	6083      	str	r3, [r0, #8]
	writer->priv_data = priv_data;
    7b5e:	9b00      	ldr	r3, [sp, #0]
    7b60:	60c3      	str	r3, [r0, #12]
}
    7b62:	4770      	bx	lr

00007b64 <stream_writer_send_remain>:
		stream_writer_send_8(writer, *buffer);
	}
}

void stream_writer_send_remain(struct stream_writer * writer)
{
    7b64:	b510      	push	{r4, lr}
    7b66:	0004      	movs	r4, r0
	if(writer->written > 0) {
    7b68:	6842      	ldr	r2, [r0, #4]
    7b6a:	2a00      	cmp	r2, #0
    7b6c:	d005      	beq.n	7b7a <stream_writer_send_remain+0x16>
		writer->write_func(writer->priv_data, writer->buffer, writer->written);
    7b6e:	6901      	ldr	r1, [r0, #16]
    7b70:	68c0      	ldr	r0, [r0, #12]
    7b72:	68a3      	ldr	r3, [r4, #8]
    7b74:	4798      	blx	r3
		writer->written = 0;
    7b76:	2300      	movs	r3, #0
    7b78:	6063      	str	r3, [r4, #4]
	}
}
    7b7a:	bd10      	pop	{r4, pc}

00007b7c <stream_writer_send_8>:
	writer->write_func = func;
	writer->priv_data = priv_data;
}

void stream_writer_send_8(struct stream_writer * writer, int8_t value)
{
    7b7c:	b570      	push	{r4, r5, r6, lr}
    7b7e:	0004      	movs	r4, r0
    7b80:	000d      	movs	r5, r1
	int remain = writer->max_size - writer->written;
	
	if (remain < 1) {
    7b82:	6803      	ldr	r3, [r0, #0]
    7b84:	6842      	ldr	r2, [r0, #4]
    7b86:	1a9b      	subs	r3, r3, r2
    7b88:	2b00      	cmp	r3, #0
    7b8a:	dc01      	bgt.n	7b90 <stream_writer_send_8+0x14>
		stream_writer_send_remain(writer);
    7b8c:	4b03      	ldr	r3, [pc, #12]	; (7b9c <stream_writer_send_8+0x20>)
    7b8e:	4798      	blx	r3
	}
	
	writer->buffer[writer->written++] = (char)value;
    7b90:	6922      	ldr	r2, [r4, #16]
    7b92:	6863      	ldr	r3, [r4, #4]
    7b94:	1c59      	adds	r1, r3, #1
    7b96:	6061      	str	r1, [r4, #4]
    7b98:	54d5      	strb	r5, [r2, r3]
}
    7b9a:	bd70      	pop	{r4, r5, r6, pc}
    7b9c:	00007b65 	.word	0x00007b65

00007ba0 <stream_writer_send_buffer>:
	stream_writer_send_8(writer, (value >> 16) & 0xFF);
	stream_writer_send_8(writer, (value >> 24) & 0xFF);
}

void stream_writer_send_buffer(struct stream_writer * writer, const char *buffer, size_t length)
{
    7ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7ba2:	0006      	movs	r6, r0
    7ba4:	000d      	movs	r5, r1
    7ba6:	1e14      	subs	r4, r2, #0
	for (; length > 0; length--, buffer++) {
    7ba8:	d008      	beq.n	7bbc <stream_writer_send_buffer+0x1c>
		stream_writer_send_8(writer, *buffer);
    7baa:	4f05      	ldr	r7, [pc, #20]	; (7bc0 <stream_writer_send_buffer+0x20>)
    7bac:	2100      	movs	r1, #0
    7bae:	5669      	ldrsb	r1, [r5, r1]
    7bb0:	0030      	movs	r0, r6
    7bb2:	47b8      	blx	r7
	stream_writer_send_8(writer, (value >> 24) & 0xFF);
}

void stream_writer_send_buffer(struct stream_writer * writer, const char *buffer, size_t length)
{
	for (; length > 0; length--, buffer++) {
    7bb4:	3c01      	subs	r4, #1
    7bb6:	3501      	adds	r5, #1
    7bb8:	2c00      	cmp	r4, #0
    7bba:	d1f7      	bne.n	7bac <stream_writer_send_buffer+0xc>
		stream_writer_send_8(writer, *buffer);
	}
}
    7bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7bbe:	46c0      	nop			; (mov r8, r8)
    7bc0:	00007b7d 	.word	0x00007b7d

00007bc4 <sw_timer_tcc_callback>:
 * \param[in] module Instance of the TCC.
 */
#if (SAMD21)
static void sw_timer_tcc_callback(struct tcc_module *const module)
{
	sw_timer_tick++;
    7bc4:	4a02      	ldr	r2, [pc, #8]	; (7bd0 <sw_timer_tcc_callback+0xc>)
    7bc6:	6813      	ldr	r3, [r2, #0]
    7bc8:	3301      	adds	r3, #1
    7bca:	6013      	str	r3, [r2, #0]
}
    7bcc:	4770      	bx	lr
    7bce:	46c0      	nop			; (mov r8, r8)
    7bd0:	20000184 	.word	0x20000184

00007bd4 <sw_timer_get_config_defaults>:

void sw_timer_get_config_defaults(struct sw_timer_config *const config)
{
	Assert(config);

	config->accuracy = 100;
    7bd4:	2364      	movs	r3, #100	; 0x64
    7bd6:	8043      	strh	r3, [r0, #2]
	config->tcc_dev = 0;
    7bd8:	2300      	movs	r3, #0
    7bda:	7003      	strb	r3, [r0, #0]
	config->tcc_callback_channel = 0;
    7bdc:	7043      	strb	r3, [r0, #1]
}
    7bde:	4770      	bx	lr

00007be0 <sw_timer_init>:

void sw_timer_init(struct sw_timer_module *const module_inst, struct sw_timer_config *const config)
{
    7be0:	b5f0      	push	{r4, r5, r6, r7, lr}
    7be2:	4647      	mov	r7, r8
    7be4:	b480      	push	{r7}
    7be6:	b0ac      	sub	sp, #176	; 0xb0
    7be8:	000d      	movs	r5, r1
#if (SAMD21)
	struct tcc_config tcc_conf;
	struct tcc_module *tcc_module;
	Tcc *hw[] = TCC_INSTS;
    7bea:	466e      	mov	r6, sp
    7bec:	4b1d      	ldr	r3, [pc, #116]	; (7c64 <sw_timer_init+0x84>)
    7bee:	466a      	mov	r2, sp
    7bf0:	cb92      	ldmia	r3!, {r1, r4, r7}
    7bf2:	c292      	stmia	r2!, {r1, r4, r7}
	Assert(module_inst);
	Assert(config);
	Assert(config->tcc_dev < TCC_INST_NUM);
	Assert(config->tcc_callback_channel < TCC_NUM_CHANNELS);

	module_inst->accuracy = config->accuracy;
    7bf4:	886b      	ldrh	r3, [r5, #2]
    7bf6:	6543      	str	r3, [r0, #84]	; 0x54
#if (SAMD21)
	/* Start the TCC module. */
	tcc_module = &module_inst->tcc_inst;
    7bf8:	3014      	adds	r0, #20
    7bfa:	0004      	movs	r4, r0
	tcc_get_config_defaults(&tcc_conf, hw[config->tcc_dev]);
    7bfc:	782b      	ldrb	r3, [r5, #0]
    7bfe:	009b      	lsls	r3, r3, #2
    7c00:	5999      	ldr	r1, [r3, r6]
    7c02:	0017      	movs	r7, r2
    7c04:	0010      	movs	r0, r2
    7c06:	4b18      	ldr	r3, [pc, #96]	; (7c68 <sw_timer_init+0x88>)
    7c08:	4798      	blx	r3
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> PM->CPUSEL.reg);
    7c0a:	2000      	movs	r0, #0
    7c0c:	4b17      	ldr	r3, [pc, #92]	; (7c6c <sw_timer_init+0x8c>)
    7c0e:	4798      	blx	r3
    7c10:	4b17      	ldr	r3, [pc, #92]	; (7c70 <sw_timer_init+0x90>)
    7c12:	7a1b      	ldrb	r3, [r3, #8]
    7c14:	b2db      	uxtb	r3, r3
	tcc_conf.counter.period = system_cpu_clock_get_hz() / (64 * 1000 / config->accuracy);
    7c16:	40d8      	lsrs	r0, r3
    7c18:	4680      	mov	r8, r0
    7c1a:	8869      	ldrh	r1, [r5, #2]
    7c1c:	20fa      	movs	r0, #250	; 0xfa
    7c1e:	0200      	lsls	r0, r0, #8
    7c20:	4b14      	ldr	r3, [pc, #80]	; (7c74 <sw_timer_init+0x94>)
    7c22:	4798      	blx	r3
    7c24:	0001      	movs	r1, r0
    7c26:	4640      	mov	r0, r8
    7c28:	4b13      	ldr	r3, [pc, #76]	; (7c78 <sw_timer_init+0x98>)
    7c2a:	4798      	blx	r3
    7c2c:	6078      	str	r0, [r7, #4]
	tcc_conf.counter.clock_prescaler = TCC_CLOCK_PRESCALER_DIV64;
    7c2e:	2305      	movs	r3, #5
    7c30:	72fb      	strb	r3, [r7, #11]
	tcc_init(tcc_module, hw[config->tcc_dev], &tcc_conf);
    7c32:	782b      	ldrb	r3, [r5, #0]
    7c34:	009b      	lsls	r3, r3, #2
    7c36:	5999      	ldr	r1, [r3, r6]
    7c38:	003a      	movs	r2, r7
    7c3a:	0020      	movs	r0, r4
    7c3c:	4b0f      	ldr	r3, [pc, #60]	; (7c7c <sw_timer_init+0x9c>)
    7c3e:	4798      	blx	r3
	tcc_register_callback(tcc_module, sw_timer_tcc_callback, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
    7c40:	786a      	ldrb	r2, [r5, #1]
    7c42:	3208      	adds	r2, #8
    7c44:	b2d2      	uxtb	r2, r2
    7c46:	490e      	ldr	r1, [pc, #56]	; (7c80 <sw_timer_init+0xa0>)
    7c48:	0020      	movs	r0, r4
    7c4a:	4b0e      	ldr	r3, [pc, #56]	; (7c84 <sw_timer_init+0xa4>)
    7c4c:	4798      	blx	r3
	tcc_enable_callback(tcc_module, config->tcc_callback_channel + TCC_CALLBACK_CHANNEL_0);
    7c4e:	7869      	ldrb	r1, [r5, #1]
    7c50:	3108      	adds	r1, #8
    7c52:	b2c9      	uxtb	r1, r1
    7c54:	0020      	movs	r0, r4
    7c56:	4b0c      	ldr	r3, [pc, #48]	; (7c88 <sw_timer_init+0xa8>)
    7c58:	4798      	blx	r3

	ul_previous_time = rtt_read_timer_value(RTT);
	while (ul_previous_time == rtt_read_timer_value(RTT)) {
	}
#endif
}
    7c5a:	b02c      	add	sp, #176	; 0xb0
    7c5c:	bc04      	pop	{r2}
    7c5e:	4690      	mov	r8, r2
    7c60:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7c62:	46c0      	nop			; (mov r8, r8)
    7c64:	0000b0fc 	.word	0x0000b0fc
    7c68:	00005f25 	.word	0x00005f25
    7c6c:	00005c85 	.word	0x00005c85
    7c70:	40000400 	.word	0x40000400
    7c74:	00008411 	.word	0x00008411
    7c78:	000082fd 	.word	0x000082fd
    7c7c:	00006071 	.word	0x00006071
    7c80:	00007bc5 	.word	0x00007bc5
    7c84:	00006461 	.word	0x00006461
    7c88:	00006479 	.word	0x00006479

00007c8c <sw_timer_enable>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tcc *const tcc_module = module_inst->hw;
    7c8c:	6942      	ldr	r2, [r0, #20]

	while (tcc_module->SYNCBUSY.reg & TCC_SYNCBUSY_ENABLE) {
    7c8e:	2102      	movs	r1, #2
    7c90:	6893      	ldr	r3, [r2, #8]
    7c92:	4219      	tst	r1, r3
    7c94:	d1fc      	bne.n	7c90 <sw_timer_enable+0x4>
		/* Wait for sync */
	}

	/* Enable the TCC module */
	tcc_module->CTRLA.reg |= TCC_CTRLA_ENABLE;
    7c96:	6811      	ldr	r1, [r2, #0]
    7c98:	2302      	movs	r3, #2
    7c9a:	430b      	orrs	r3, r1
    7c9c:	6013      	str	r3, [r2, #0]
	NVIC_ClearPendingIRQ(RTT_IRQn);
	NVIC_SetPriority(RTT_IRQn, 0);
	NVIC_EnableIRQ(RTT_IRQn);
	rtt_enable_interrupt(RTT, RTT_MR_RTTINCIEN);
#endif
}
    7c9e:	4770      	bx	lr

00007ca0 <sw_timer_register_callback>:
#endif
}

int sw_timer_register_callback(struct sw_timer_module *const module_inst,
		sw_timer_callback_t callback, void *context, uint32_t period)
{
    7ca0:	b570      	push	{r4, r5, r6, lr}
    7ca2:	0004      	movs	r4, r0
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used == 0) {
    7ca4:	7805      	ldrb	r5, [r0, #0]
    7ca6:	07e8      	lsls	r0, r5, #31
    7ca8:	d410      	bmi.n	7ccc <sw_timer_register_callback+0x2c>
			handler = &module_inst->handler[index];
			handler->callback = callback;
    7caa:	6061      	str	r1, [r4, #4]
			handler->callback_enable = 0;
    7cac:	0029      	movs	r1, r5
    7cae:	2002      	movs	r0, #2
    7cb0:	4381      	bics	r1, r0
    7cb2:	7021      	strb	r1, [r4, #0]
			handler->context = context;
    7cb4:	60a2      	str	r2, [r4, #8]
			handler->period = period / module_inst->accuracy;
    7cb6:	6d61      	ldr	r1, [r4, #84]	; 0x54
    7cb8:	0018      	movs	r0, r3
    7cba:	4b06      	ldr	r3, [pc, #24]	; (7cd4 <sw_timer_register_callback+0x34>)
    7cbc:	4798      	blx	r3
    7cbe:	60e0      	str	r0, [r4, #12]
			handler->used = 1;
    7cc0:	7822      	ldrb	r2, [r4, #0]
    7cc2:	2301      	movs	r3, #1
    7cc4:	4313      	orrs	r3, r2
    7cc6:	7023      	strb	r3, [r4, #0]
			return index;
    7cc8:	2000      	movs	r0, #0
    7cca:	e001      	b.n	7cd0 <sw_timer_register_callback+0x30>
		}
	}
	return -1;
    7ccc:	2001      	movs	r0, #1
    7cce:	4240      	negs	r0, r0
}
    7cd0:	bd70      	pop	{r4, r5, r6, pc}
    7cd2:	46c0      	nop			; (mov r8, r8)
    7cd4:	000082fd 	.word	0x000082fd

00007cd8 <sw_timer_enable_callback>:

	handler->used = 0;
}

void sw_timer_enable_callback(struct sw_timer_module *const module_inst, int timer_id, uint32_t delay)
{
    7cd8:	b570      	push	{r4, r5, r6, lr}
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 1;
    7cda:	008c      	lsls	r4, r1, #2
    7cdc:	1863      	adds	r3, r4, r1
    7cde:	009b      	lsls	r3, r3, #2
    7ce0:	5c1e      	ldrb	r6, [r3, r0]
    7ce2:	2502      	movs	r5, #2
    7ce4:	4335      	orrs	r5, r6
    7ce6:	541d      	strb	r5, [r3, r0]
	handler->expire_time = sw_timer_tick + (delay / module_inst->accuracy);
    7ce8:	18c4      	adds	r4, r0, r3
    7cea:	6d41      	ldr	r1, [r0, #84]	; 0x54
    7cec:	0010      	movs	r0, r2
    7cee:	4b03      	ldr	r3, [pc, #12]	; (7cfc <sw_timer_enable_callback+0x24>)
    7cf0:	4798      	blx	r3
    7cf2:	4b03      	ldr	r3, [pc, #12]	; (7d00 <sw_timer_enable_callback+0x28>)
    7cf4:	681b      	ldr	r3, [r3, #0]
    7cf6:	18c0      	adds	r0, r0, r3
    7cf8:	6120      	str	r0, [r4, #16]
}
    7cfa:	bd70      	pop	{r4, r5, r6, pc}
    7cfc:	000082fd 	.word	0x000082fd
    7d00:	20000184 	.word	0x20000184

00007d04 <sw_timer_disable_callback>:
	Assert(module_inst);
	Assert((timer_id >= 0 && timer_id < CONF_SW_TIMER_COUNT));

	handler = &module_inst->handler[timer_id];

	handler->callback_enable = 0;
    7d04:	008b      	lsls	r3, r1, #2
    7d06:	1859      	adds	r1, r3, r1
    7d08:	0089      	lsls	r1, r1, #2
    7d0a:	5c0b      	ldrb	r3, [r1, r0]
    7d0c:	2202      	movs	r2, #2
    7d0e:	4393      	bics	r3, r2
    7d10:	540b      	strb	r3, [r1, r0]
}
    7d12:	4770      	bx	lr

00007d14 <sw_timer_task>:

void sw_timer_task(struct sw_timer_module *const module_inst)
{
    7d14:	b570      	push	{r4, r5, r6, lr}
    7d16:	0004      	movs	r4, r0
	struct sw_timer_handle *handler;

	Assert(module_inst);

	for (index = 0; index < CONF_SW_TIMER_COUNT; index++) {
		if (module_inst->handler[index].used && module_inst->handler[index].callback_enable) {
    7d18:	7803      	ldrb	r3, [r0, #0]
    7d1a:	07db      	lsls	r3, r3, #31
    7d1c:	d521      	bpl.n	7d62 <sw_timer_task+0x4e>
    7d1e:	7803      	ldrb	r3, [r0, #0]
    7d20:	079b      	lsls	r3, r3, #30
    7d22:	d51e      	bpl.n	7d62 <sw_timer_task+0x4e>
			handler = &module_inst->handler[index];
			if ((int)(handler->expire_time - sw_timer_tick) < 0 && handler->busy == 0) {
    7d24:	4b0f      	ldr	r3, [pc, #60]	; (7d64 <sw_timer_task+0x50>)
    7d26:	681a      	ldr	r2, [r3, #0]
    7d28:	6903      	ldr	r3, [r0, #16]
    7d2a:	1a9b      	subs	r3, r3, r2
    7d2c:	d519      	bpl.n	7d62 <sw_timer_task+0x4e>
    7d2e:	7803      	ldrb	r3, [r0, #0]
    7d30:	075b      	lsls	r3, r3, #29
    7d32:	d416      	bmi.n	7d62 <sw_timer_task+0x4e>
				/* Enter critical section. */
				handler->busy = 1;
    7d34:	7801      	ldrb	r1, [r0, #0]
    7d36:	2304      	movs	r3, #4
    7d38:	430b      	orrs	r3, r1
    7d3a:	7003      	strb	r3, [r0, #0]
				/* Timer was expired. */
				if (handler->period > 0) {
    7d3c:	68c3      	ldr	r3, [r0, #12]
    7d3e:	2b00      	cmp	r3, #0
    7d40:	d002      	beq.n	7d48 <sw_timer_task+0x34>
					handler->expire_time = sw_timer_tick + handler->period;
    7d42:	18d2      	adds	r2, r2, r3
    7d44:	6102      	str	r2, [r0, #16]
    7d46:	e003      	b.n	7d50 <sw_timer_task+0x3c>
				} else {
					/* One shot. */
					handler->callback_enable = 0;
    7d48:	7802      	ldrb	r2, [r0, #0]
    7d4a:	2102      	movs	r1, #2
    7d4c:	438a      	bics	r2, r1
    7d4e:	7002      	strb	r2, [r0, #0]
				}
				/* Call callback function. */
				handler->callback(module_inst, index, handler->context, handler->period);
    7d50:	68a2      	ldr	r2, [r4, #8]
    7d52:	2100      	movs	r1, #0
    7d54:	0020      	movs	r0, r4
    7d56:	6865      	ldr	r5, [r4, #4]
    7d58:	47a8      	blx	r5
				/* Leave critical section. */
				handler->busy = 0;
    7d5a:	7823      	ldrb	r3, [r4, #0]
    7d5c:	2204      	movs	r2, #4
    7d5e:	4393      	bics	r3, r2
    7d60:	7023      	strb	r3, [r4, #0]
			}
		}
	}
}
    7d62:	bd70      	pop	{r4, r5, r6, pc}
    7d64:	20000184 	.word	0x20000184

00007d68 <add_state>:
 * \brief Add state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void add_state(download_state mask)
{
	down_state |= mask;
    7d68:	4a02      	ldr	r2, [pc, #8]	; (7d74 <add_state+0xc>)
    7d6a:	7813      	ldrb	r3, [r2, #0]
    7d6c:	4318      	orrs	r0, r3
    7d6e:	7010      	strb	r0, [r2, #0]
}
    7d70:	4770      	bx	lr
    7d72:	46c0      	nop			; (mov r8, r8)
    7d74:	200001bc 	.word	0x200001bc

00007d78 <store_file_packet>:
 * \brief Store received packet to file.
 * \param[in] data Packet data.
 * \param[in] length Packet data length.
 */
static void store_file_packet(char *data, uint32_t length)
{
    7d78:	b570      	push	{r4, r5, r6, lr}
    7d7a:	0004      	movs	r4, r0
    7d7c:	000d      	movs	r5, r1
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    7d7e:	4b12      	ldr	r3, [pc, #72]	; (7dc8 <store_file_packet+0x50>)
	//if ((data == NULL) || (length < 1)) {
		//printf("store_file_packet: empty data.\r\n");
		//return;
	//}

	if (!is_state_set(DOWNLOADING)) {
    7d80:	781b      	ldrb	r3, [r3, #0]
    7d82:	071b      	lsls	r3, r3, #28
    7d84:	d405      	bmi.n	7d92 <store_file_packet+0x1a>
		//if (ret != FR_OK) {
			//printf("store_file_packet: file creation error! ret:%d\r\n", ret);
			//return;
		//}

		received_file_size = 0;
    7d86:	2200      	movs	r2, #0
    7d88:	4b10      	ldr	r3, [pc, #64]	; (7dcc <store_file_packet+0x54>)
    7d8a:	601a      	str	r2, [r3, #0]
		add_state(DOWNLOADING);
    7d8c:	2008      	movs	r0, #8
    7d8e:	4b10      	ldr	r3, [pc, #64]	; (7dd0 <store_file_packet+0x58>)
    7d90:	4798      	blx	r3
	}

	if (data != NULL) {
    7d92:	2c00      	cmp	r4, #0
    7d94:	d016      	beq.n	7dc4 <store_file_packet+0x4c>
			//add_state(CANCELED);
			//printf("store_file_packet: file write error, download canceled.\r\n");
			//return;
		//}

		received_file_size += wsize;
    7d96:	4c0d      	ldr	r4, [pc, #52]	; (7dcc <store_file_packet+0x54>)
    7d98:	6823      	ldr	r3, [r4, #0]
    7d9a:	18e9      	adds	r1, r5, r3
    7d9c:	6021      	str	r1, [r4, #0]
		printf("store_file_packet: received[%lu], file size[%lu]\r\n", (unsigned long)received_file_size, (unsigned long)http_file_size);
    7d9e:	4d0d      	ldr	r5, [pc, #52]	; (7dd4 <store_file_packet+0x5c>)
    7da0:	682a      	ldr	r2, [r5, #0]
    7da2:	480d      	ldr	r0, [pc, #52]	; (7dd8 <store_file_packet+0x60>)
    7da4:	4b0d      	ldr	r3, [pc, #52]	; (7ddc <store_file_packet+0x64>)
    7da6:	4798      	blx	r3
		if (received_file_size >= http_file_size) {
    7da8:	6822      	ldr	r2, [r4, #0]
    7daa:	682b      	ldr	r3, [r5, #0]
    7dac:	429a      	cmp	r2, r3
    7dae:	d309      	bcc.n	7dc4 <store_file_packet+0x4c>
			//f_close(&file_object);
			printf("store_file_packet: file downloaded successfully.\r\n");
    7db0:	480b      	ldr	r0, [pc, #44]	; (7de0 <store_file_packet+0x68>)
    7db2:	4b0c      	ldr	r3, [pc, #48]	; (7de4 <store_file_packet+0x6c>)
    7db4:	4798      	blx	r3
	} else {
		port_base->OUTCLR.reg = pin_mask;
    7db6:	2280      	movs	r2, #128	; 0x80
    7db8:	0412      	lsls	r2, r2, #16
    7dba:	4b0b      	ldr	r3, [pc, #44]	; (7de8 <store_file_packet+0x70>)
    7dbc:	615a      	str	r2, [r3, #20]
			port_pin_set_output_level(LED_0_PIN, false);
			add_state(COMPLETED);
    7dbe:	2010      	movs	r0, #16
    7dc0:	4b03      	ldr	r3, [pc, #12]	; (7dd0 <store_file_packet+0x58>)
    7dc2:	4798      	blx	r3
			return;
		}
	}
}
    7dc4:	bd70      	pop	{r4, r5, r6, pc}
    7dc6:	46c0      	nop			; (mov r8, r8)
    7dc8:	200001bc 	.word	0x200001bc
    7dcc:	200001e8 	.word	0x200001e8
    7dd0:	00007d69 	.word	0x00007d69
    7dd4:	200001c0 	.word	0x200001c0
    7dd8:	0000b11c 	.word	0x0000b11c
    7ddc:	00008845 	.word	0x00008845
    7de0:	0000b150 	.word	0x0000b150
    7de4:	00008965 	.word	0x00008965
    7de8:	41004400 	.word	0x41004400

00007dec <resolve_cb>:
 * \brief Callback for the gethostbyname function (DNS Resolution callback).
 * \param[in] pu8DomainName Domain name of the host.
 * \param[in] u32ServerIP Server IPv4 address encoded in NW byte order format. If it is Zero, then the DNS resolution failed.
 */
static void resolve_cb(uint8_t *pu8DomainName, uint32_t u32ServerIP)
{
    7dec:	b570      	push	{r4, r5, r6, lr}
    7dee:	b082      	sub	sp, #8
    7df0:	0005      	movs	r5, r0
    7df2:	000c      	movs	r4, r1
	printf("resolve_cb: %s IP address is %d.%d.%d.%d\r\n\r\n", pu8DomainName,
    7df4:	0a0b      	lsrs	r3, r1, #8
    7df6:	20ff      	movs	r0, #255	; 0xff
    7df8:	4003      	ands	r3, r0
    7dfa:	0002      	movs	r2, r0
    7dfc:	400a      	ands	r2, r1
    7dfe:	0e09      	lsrs	r1, r1, #24
    7e00:	9101      	str	r1, [sp, #4]
    7e02:	0c21      	lsrs	r1, r4, #16
    7e04:	4001      	ands	r1, r0
    7e06:	9100      	str	r1, [sp, #0]
    7e08:	0029      	movs	r1, r5
    7e0a:	4804      	ldr	r0, [pc, #16]	; (7e1c <resolve_cb+0x30>)
    7e0c:	4e04      	ldr	r6, [pc, #16]	; (7e20 <resolve_cb+0x34>)
    7e0e:	47b0      	blx	r6
			(int)IPV4_BYTE(u32ServerIP, 0), (int)IPV4_BYTE(u32ServerIP, 1),
			(int)IPV4_BYTE(u32ServerIP, 2), (int)IPV4_BYTE(u32ServerIP, 3));
	http_client_socket_resolve_handler(pu8DomainName, u32ServerIP);
    7e10:	0021      	movs	r1, r4
    7e12:	0028      	movs	r0, r5
    7e14:	4b03      	ldr	r3, [pc, #12]	; (7e24 <resolve_cb+0x38>)
    7e16:	4798      	blx	r3
}
    7e18:	b002      	add	sp, #8
    7e1a:	bd70      	pop	{r4, r5, r6, pc}
    7e1c:	0000b184 	.word	0x0000b184
    7e20:	00008845 	.word	0x00008845
    7e24:	00006d41 	.word	0x00006d41

00007e28 <socket_cb>:
 *  - tstrSocketAcceptMsg
 *  - tstrSocketConnectMsg
 *  - tstrSocketRecvMsg
 */
static void socket_cb(SOCKET sock, uint8_t u8Msg, void *pvMsg)
{
    7e28:	b510      	push	{r4, lr}
	http_client_socket_event_handler(sock, u8Msg, pvMsg);
    7e2a:	4b01      	ldr	r3, [pc, #4]	; (7e30 <socket_cb+0x8>)
    7e2c:	4798      	blx	r3
}
    7e2e:	bd10      	pop	{r4, pc}
    7e30:	00007995 	.word	0x00007995

00007e34 <start_download>:

/**
 * \brief Start file download via HTTP connection.
 */
static void start_download(void)
{
    7e34:	b510      	push	{r4, lr}
    7e36:	b082      	sub	sp, #8
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    7e38:	4b12      	ldr	r3, [pc, #72]	; (7e84 <start_download+0x50>)
    7e3a:	781b      	ldrb	r3, [r3, #0]
/**
 * \brief Start file download via HTTP connection.
 */
static void start_download(void)
{
	if (!is_state_set(STORAGE_READY)) {
    7e3c:	07da      	lsls	r2, r3, #31
    7e3e:	d403      	bmi.n	7e48 <start_download+0x14>
		printf("start_download: MMC storage not ready.\r\n");
    7e40:	4811      	ldr	r0, [pc, #68]	; (7e88 <start_download+0x54>)
    7e42:	4b12      	ldr	r3, [pc, #72]	; (7e8c <start_download+0x58>)
    7e44:	4798      	blx	r3
		return;
    7e46:	e01b      	b.n	7e80 <start_download+0x4c>
	}

	if (!is_state_set(WIFI_CONNECTED)) {
    7e48:	079a      	lsls	r2, r3, #30
    7e4a:	d403      	bmi.n	7e54 <start_download+0x20>
		printf("start_download: Wi-Fi is not connected.\r\n");
    7e4c:	4810      	ldr	r0, [pc, #64]	; (7e90 <start_download+0x5c>)
    7e4e:	4b0f      	ldr	r3, [pc, #60]	; (7e8c <start_download+0x58>)
    7e50:	4798      	blx	r3
		return;
    7e52:	e015      	b.n	7e80 <start_download+0x4c>
	}

	if (is_state_set(GET_REQUESTED)) {
    7e54:	075a      	lsls	r2, r3, #29
    7e56:	d503      	bpl.n	7e60 <start_download+0x2c>
		printf("start_download: request is sent already.\r\n");
    7e58:	480e      	ldr	r0, [pc, #56]	; (7e94 <start_download+0x60>)
    7e5a:	4b0c      	ldr	r3, [pc, #48]	; (7e8c <start_download+0x58>)
    7e5c:	4798      	blx	r3
		return;
    7e5e:	e00f      	b.n	7e80 <start_download+0x4c>
	}

	if (is_state_set(DOWNLOADING)) {
    7e60:	071b      	lsls	r3, r3, #28
    7e62:	d503      	bpl.n	7e6c <start_download+0x38>
		printf("start_download: running download already.\r\n");
    7e64:	480c      	ldr	r0, [pc, #48]	; (7e98 <start_download+0x64>)
    7e66:	4b09      	ldr	r3, [pc, #36]	; (7e8c <start_download+0x58>)
    7e68:	4798      	blx	r3
		return;
    7e6a:	e009      	b.n	7e80 <start_download+0x4c>
	}

	/* Send the HTTP request. */
	printf("start_download: sending HTTP request...\r\n");
    7e6c:	480b      	ldr	r0, [pc, #44]	; (7e9c <start_download+0x68>)
    7e6e:	4b07      	ldr	r3, [pc, #28]	; (7e8c <start_download+0x58>)
    7e70:	4798      	blx	r3
	http_client_send_request(&http_client_module_inst, MAIN_HTTP_FILE_URL, HTTP_METHOD_GET, NULL, NULL);
    7e72:	2300      	movs	r3, #0
    7e74:	9300      	str	r3, [sp, #0]
    7e76:	2201      	movs	r2, #1
    7e78:	4909      	ldr	r1, [pc, #36]	; (7ea0 <start_download+0x6c>)
    7e7a:	480a      	ldr	r0, [pc, #40]	; (7ea4 <start_download+0x70>)
    7e7c:	4c0a      	ldr	r4, [pc, #40]	; (7ea8 <start_download+0x74>)
    7e7e:	47a0      	blx	r4
}
    7e80:	b002      	add	sp, #8
    7e82:	bd10      	pop	{r4, pc}
    7e84:	200001bc 	.word	0x200001bc
    7e88:	0000b1b4 	.word	0x0000b1b4
    7e8c:	00008965 	.word	0x00008965
    7e90:	0000b1dc 	.word	0x0000b1dc
    7e94:	0000b208 	.word	0x0000b208
    7e98:	0000b234 	.word	0x0000b234
    7e9c:	0000b260 	.word	0x0000b260
    7ea0:	0000b28c 	.word	0x0000b28c
    7ea4:	20000404 	.word	0x20000404
    7ea8:	00007289 	.word	0x00007289

00007eac <usart_serial_getchar>:
 * \param[out]    c       Destination for the read character.
 */
static inline void usart_serial_getchar(
		struct usart_module *const module,
		uint8_t *c)
{
    7eac:	b570      	push	{r4, r5, r6, lr}
    7eae:	b082      	sub	sp, #8
    7eb0:	0005      	movs	r5, r0
    7eb2:	000e      	movs	r6, r1
	uint16_t temp = 0;
    7eb4:	2200      	movs	r2, #0
    7eb6:	466b      	mov	r3, sp
    7eb8:	80da      	strh	r2, [r3, #6]

	while(STATUS_OK != usart_read_wait(module, &temp));
    7eba:	4c06      	ldr	r4, [pc, #24]	; (7ed4 <usart_serial_getchar+0x28>)
    7ebc:	466b      	mov	r3, sp
    7ebe:	1d99      	adds	r1, r3, #6
    7ec0:	0028      	movs	r0, r5
    7ec2:	47a0      	blx	r4
    7ec4:	2800      	cmp	r0, #0
    7ec6:	d1f9      	bne.n	7ebc <usart_serial_getchar+0x10>

	*c = temp;
    7ec8:	466b      	mov	r3, sp
    7eca:	3306      	adds	r3, #6
    7ecc:	881b      	ldrh	r3, [r3, #0]
    7ece:	7033      	strb	r3, [r6, #0]
}
    7ed0:	b002      	add	sp, #8
    7ed2:	bd70      	pop	{r4, r5, r6, pc}
    7ed4:	00005539 	.word	0x00005539

00007ed8 <usart_serial_putchar>:
 * \return Status code
 */
static inline enum status_code usart_serial_putchar(
		struct usart_module *const module,
		uint8_t c)
{
    7ed8:	b570      	push	{r4, r5, r6, lr}
    7eda:	0005      	movs	r5, r0
	while(STATUS_OK !=usart_write_wait(module, c));
    7edc:	b28c      	uxth	r4, r1
    7ede:	4e03      	ldr	r6, [pc, #12]	; (7eec <usart_serial_putchar+0x14>)
    7ee0:	0021      	movs	r1, r4
    7ee2:	0028      	movs	r0, r5
    7ee4:	47b0      	blx	r6
    7ee6:	2800      	cmp	r0, #0
    7ee8:	d1fa      	bne.n	7ee0 <usart_serial_putchar+0x8>

	return STATUS_OK;
}
    7eea:	bd70      	pop	{r4, r5, r6, pc}
    7eec:	0000550d 	.word	0x0000550d

00007ef0 <http_client_callback>:
 * \param[in]  module_inst     Module instance of HTTP client module.
 * \param[in]  type            Type of event.
 * \param[in]  data            Data structure of the event. \refer http_client_data
 */
static void http_client_callback(struct http_client_module *module_inst, int type, union http_client_data *data)
{
    7ef0:	b510      	push	{r4, lr}
    7ef2:	0014      	movs	r4, r2
	switch (type) {
    7ef4:	2904      	cmp	r1, #4
    7ef6:	d854      	bhi.n	7fa2 <http_client_callback+0xb2>
    7ef8:	0089      	lsls	r1, r1, #2
    7efa:	4b2a      	ldr	r3, [pc, #168]	; (7fa4 <http_client_callback+0xb4>)
    7efc:	585b      	ldr	r3, [r3, r1]
    7efe:	469f      	mov	pc, r3
	case HTTP_CLIENT_CALLBACK_SOCK_CONNECTED:
		printf("http_client_callback: HTTP client socket connected.\r\n");
    7f00:	4829      	ldr	r0, [pc, #164]	; (7fa8 <http_client_callback+0xb8>)
    7f02:	4b2a      	ldr	r3, [pc, #168]	; (7fac <http_client_callback+0xbc>)
    7f04:	4798      	blx	r3
		break;
    7f06:	e04c      	b.n	7fa2 <http_client_callback+0xb2>

	case HTTP_CLIENT_CALLBACK_REQUESTED:
		printf("http_client_callback: request completed.\r\n");
    7f08:	4829      	ldr	r0, [pc, #164]	; (7fb0 <http_client_callback+0xc0>)
    7f0a:	4b28      	ldr	r3, [pc, #160]	; (7fac <http_client_callback+0xbc>)
    7f0c:	4798      	blx	r3
		add_state(GET_REQUESTED);
    7f0e:	2004      	movs	r0, #4
    7f10:	4b28      	ldr	r3, [pc, #160]	; (7fb4 <http_client_callback+0xc4>)
    7f12:	4798      	blx	r3
		break;
    7f14:	e045      	b.n	7fa2 <http_client_callback+0xb2>

	case HTTP_CLIENT_CALLBACK_RECV_RESPONSE:
		printf("http_client_callback: received response %u data size %u\r\n",
    7f16:	8811      	ldrh	r1, [r2, #0]
    7f18:	6852      	ldr	r2, [r2, #4]
    7f1a:	4827      	ldr	r0, [pc, #156]	; (7fb8 <http_client_callback+0xc8>)
    7f1c:	4b27      	ldr	r3, [pc, #156]	; (7fbc <http_client_callback+0xcc>)
    7f1e:	4798      	blx	r3
				(unsigned int)data->recv_response.response_code,
				(unsigned int)data->recv_response.content_length);
		if ((unsigned int)data->recv_response.response_code == 200) {
    7f20:	8823      	ldrh	r3, [r4, #0]
    7f22:	2bc8      	cmp	r3, #200	; 0xc8
    7f24:	d10a      	bne.n	7f3c <http_client_callback+0x4c>
			http_file_size = data->recv_response.content_length;
    7f26:	6861      	ldr	r1, [r4, #4]
    7f28:	4b25      	ldr	r3, [pc, #148]	; (7fc0 <http_client_callback+0xd0>)
    7f2a:	6019      	str	r1, [r3, #0]
			received_file_size = 0;
    7f2c:	2200      	movs	r2, #0
    7f2e:	4b25      	ldr	r3, [pc, #148]	; (7fc4 <http_client_callback+0xd4>)
    7f30:	601a      	str	r2, [r3, #0]
		} 
		else {
			add_state(CANCELED);
			return;
		}
		if (data->recv_response.content_length <= MAIN_BUFFER_MAX_SIZE) {
    7f32:	2380      	movs	r3, #128	; 0x80
    7f34:	00db      	lsls	r3, r3, #3
    7f36:	4299      	cmp	r1, r3
    7f38:	d833      	bhi.n	7fa2 <http_client_callback+0xb2>
    7f3a:	e003      	b.n	7f44 <http_client_callback+0x54>
		if ((unsigned int)data->recv_response.response_code == 200) {
			http_file_size = data->recv_response.content_length;
			received_file_size = 0;
		} 
		else {
			add_state(CANCELED);
    7f3c:	2020      	movs	r0, #32
    7f3e:	4b1d      	ldr	r3, [pc, #116]	; (7fb4 <http_client_callback+0xc4>)
    7f40:	4798      	blx	r3
			return;
    7f42:	e02e      	b.n	7fa2 <http_client_callback+0xb2>
		}
		if (data->recv_response.content_length <= MAIN_BUFFER_MAX_SIZE) {
			store_file_packet(data->recv_response.content, data->recv_response.content_length);
    7f44:	68a0      	ldr	r0, [r4, #8]
    7f46:	4b20      	ldr	r3, [pc, #128]	; (7fc8 <http_client_callback+0xd8>)
    7f48:	4798      	blx	r3
			add_state(COMPLETED);
    7f4a:	2010      	movs	r0, #16
    7f4c:	4b19      	ldr	r3, [pc, #100]	; (7fb4 <http_client_callback+0xc4>)
    7f4e:	4798      	blx	r3
    7f50:	e027      	b.n	7fa2 <http_client_callback+0xb2>
		}
		break;

	case HTTP_CLIENT_CALLBACK_RECV_CHUNKED_DATA:
		store_file_packet(data->recv_chunked_data.data, data->recv_chunked_data.length);
    7f52:	6811      	ldr	r1, [r2, #0]
    7f54:	6850      	ldr	r0, [r2, #4]
    7f56:	4b1c      	ldr	r3, [pc, #112]	; (7fc8 <http_client_callback+0xd8>)
    7f58:	4798      	blx	r3
		if (data->recv_chunked_data.is_complete) {
    7f5a:	7a23      	ldrb	r3, [r4, #8]
    7f5c:	2b00      	cmp	r3, #0
    7f5e:	d020      	beq.n	7fa2 <http_client_callback+0xb2>
			add_state(COMPLETED);
    7f60:	2010      	movs	r0, #16
    7f62:	4b14      	ldr	r3, [pc, #80]	; (7fb4 <http_client_callback+0xc4>)
    7f64:	4798      	blx	r3
    7f66:	e01c      	b.n	7fa2 <http_client_callback+0xb2>
		}

		break;

	case HTTP_CLIENT_CALLBACK_DISCONNECTED:
		printf("http_client_callback: disconnection reason:%d\r\n", data->disconnected.reason);
    7f68:	6811      	ldr	r1, [r2, #0]
    7f6a:	4818      	ldr	r0, [pc, #96]	; (7fcc <http_client_callback+0xdc>)
    7f6c:	4b13      	ldr	r3, [pc, #76]	; (7fbc <http_client_callback+0xcc>)
    7f6e:	4798      	blx	r3

		/* If disconnect reason is equal to -ECONNRESET(-104),
		 * It means the server has closed the connection (timeout).
		 * This is normal operation.
		 */
		if (data->disconnected.reason == -EAGAIN) {
    7f70:	6823      	ldr	r3, [r4, #0]
    7f72:	330b      	adds	r3, #11
    7f74:	d115      	bne.n	7fa2 <http_client_callback+0xb2>
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    7f76:	4b16      	ldr	r3, [pc, #88]	; (7fd0 <http_client_callback+0xe0>)
		 * It means the server has closed the connection (timeout).
		 * This is normal operation.
		 */
		if (data->disconnected.reason == -EAGAIN) {
			/* Server has not responded. Retry immediately. */
			if (is_state_set(DOWNLOADING)) {
    7f78:	781b      	ldrb	r3, [r3, #0]
    7f7a:	071b      	lsls	r3, r3, #28
    7f7c:	d507      	bpl.n	7f8e <http_client_callback+0x9e>
				f_close(&file_object);
    7f7e:	4815      	ldr	r0, [pc, #84]	; (7fd4 <http_client_callback+0xe4>)
    7f80:	4b15      	ldr	r3, [pc, #84]	; (7fd8 <http_client_callback+0xe8>)
    7f82:	4798      	blx	r3
 * \brief Clear state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void clear_state(download_state mask)
{
	down_state &= ~mask;
    7f84:	4a12      	ldr	r2, [pc, #72]	; (7fd0 <http_client_callback+0xe0>)
    7f86:	7813      	ldrb	r3, [r2, #0]
    7f88:	2108      	movs	r1, #8
    7f8a:	438b      	bics	r3, r1
    7f8c:	7013      	strb	r3, [r2, #0]
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    7f8e:	4b10      	ldr	r3, [pc, #64]	; (7fd0 <http_client_callback+0xe0>)
    7f90:	781b      	ldrb	r3, [r3, #0]
			if (is_state_set(DOWNLOADING)) {
				f_close(&file_object);
				clear_state(DOWNLOADING);
			}

			if (is_state_set(GET_REQUESTED)) {
    7f92:	075a      	lsls	r2, r3, #29
    7f94:	d503      	bpl.n	7f9e <http_client_callback+0xae>
 * \brief Clear state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void clear_state(download_state mask)
{
	down_state &= ~mask;
    7f96:	2204      	movs	r2, #4
    7f98:	4393      	bics	r3, r2
    7f9a:	4a0d      	ldr	r2, [pc, #52]	; (7fd0 <http_client_callback+0xe0>)
    7f9c:	7013      	strb	r3, [r2, #0]

			if (is_state_set(GET_REQUESTED)) {
				clear_state(GET_REQUESTED);
			}

			start_download();
    7f9e:	4b0f      	ldr	r3, [pc, #60]	; (7fdc <http_client_callback+0xec>)
    7fa0:	4798      	blx	r3
		}

		break;
	}
}
    7fa2:	bd10      	pop	{r4, pc}
    7fa4:	0000b108 	.word	0x0000b108
    7fa8:	0000b2bc 	.word	0x0000b2bc
    7fac:	00008965 	.word	0x00008965
    7fb0:	0000b2f4 	.word	0x0000b2f4
    7fb4:	00007d69 	.word	0x00007d69
    7fb8:	0000b320 	.word	0x0000b320
    7fbc:	00008845 	.word	0x00008845
    7fc0:	200001c0 	.word	0x200001c0
    7fc4:	200001e8 	.word	0x200001e8
    7fc8:	00007d79 	.word	0x00007d79
    7fcc:	0000b35c 	.word	0x0000b35c
    7fd0:	200001bc 	.word	0x200001bc
    7fd4:	200001c4 	.word	0x200001c4
    7fd8:	00006b45 	.word	0x00006b45
    7fdc:	00007e35 	.word	0x00007e35

00007fe0 <wifi_cb>:
 *  - tstrM2MAPResp
 *  - tstrM2mScanDone
 *  - tstrM2mWifiscanResult
 */
static void wifi_cb(uint8_t u8MsgType, void *pvMsg)
{
    7fe0:	b510      	push	{r4, lr}
    7fe2:	b082      	sub	sp, #8
	switch (u8MsgType) {
    7fe4:	282c      	cmp	r0, #44	; 0x2c
    7fe6:	d002      	beq.n	7fee <wifi_cb+0xe>
    7fe8:	2832      	cmp	r0, #50	; 0x32
    7fea:	d02e      	beq.n	804a <wifi_cb+0x6a>
    7fec:	e03b      	b.n	8066 <wifi_cb+0x86>
	case M2M_WIFI_RESP_CON_STATE_CHANGED:
	{
		tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg;
		if (pstrWifiState->u8CurrState == M2M_WIFI_CONNECTED) {
    7fee:	780b      	ldrb	r3, [r1, #0]
    7ff0:	2b01      	cmp	r3, #1
    7ff2:	d105      	bne.n	8000 <wifi_cb+0x20>
			printf("wifi_cb: M2M_WIFI_CONNECTED\r\n");
    7ff4:	481d      	ldr	r0, [pc, #116]	; (806c <wifi_cb+0x8c>)
    7ff6:	4b1e      	ldr	r3, [pc, #120]	; (8070 <wifi_cb+0x90>)
    7ff8:	4798      	blx	r3
			m2m_wifi_request_dhcp_client();
    7ffa:	4b1e      	ldr	r3, [pc, #120]	; (8074 <wifi_cb+0x94>)
    7ffc:	4798      	blx	r3
    7ffe:	e032      	b.n	8066 <wifi_cb+0x86>
		} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
    8000:	2b00      	cmp	r3, #0
    8002:	d130      	bne.n	8066 <wifi_cb+0x86>
			printf("wifi_cb: M2M_WIFI_DISCONNECTED\r\n");
    8004:	481c      	ldr	r0, [pc, #112]	; (8078 <wifi_cb+0x98>)
    8006:	4b1a      	ldr	r3, [pc, #104]	; (8070 <wifi_cb+0x90>)
    8008:	4798      	blx	r3
 * \brief Clear state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void clear_state(download_state mask)
{
	down_state &= ~mask;
    800a:	4a1c      	ldr	r2, [pc, #112]	; (807c <wifi_cb+0x9c>)
    800c:	7813      	ldrb	r3, [r2, #0]
    800e:	2102      	movs	r1, #2
    8010:	438b      	bics	r3, r1
    8012:	7013      	strb	r3, [r2, #0]
			printf("wifi_cb: M2M_WIFI_CONNECTED\r\n");
			m2m_wifi_request_dhcp_client();
		} else if (pstrWifiState->u8CurrState == M2M_WIFI_DISCONNECTED) {
			printf("wifi_cb: M2M_WIFI_DISCONNECTED\r\n");
			clear_state(WIFI_CONNECTED);
			if (is_state_set(DOWNLOADING)) {
    8014:	071b      	lsls	r3, r3, #28
    8016:	d507      	bpl.n	8028 <wifi_cb+0x48>
				f_close(&file_object);
    8018:	4819      	ldr	r0, [pc, #100]	; (8080 <wifi_cb+0xa0>)
    801a:	4b1a      	ldr	r3, [pc, #104]	; (8084 <wifi_cb+0xa4>)
    801c:	4798      	blx	r3
 * \brief Clear state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void clear_state(download_state mask)
{
	down_state &= ~mask;
    801e:	4a17      	ldr	r2, [pc, #92]	; (807c <wifi_cb+0x9c>)
    8020:	7813      	ldrb	r3, [r2, #0]
    8022:	2108      	movs	r1, #8
    8024:	438b      	bics	r3, r1
    8026:	7013      	strb	r3, [r2, #0]
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    8028:	4b14      	ldr	r3, [pc, #80]	; (807c <wifi_cb+0x9c>)
    802a:	781b      	ldrb	r3, [r3, #0]
			if (is_state_set(DOWNLOADING)) {
				f_close(&file_object);
				clear_state(DOWNLOADING);
			}

			if (is_state_set(GET_REQUESTED)) {
    802c:	075a      	lsls	r2, r3, #29
    802e:	d503      	bpl.n	8038 <wifi_cb+0x58>
 * \brief Clear state parameter at download processing state.
 * \param[in] mask Check download_state.
 */
static void clear_state(download_state mask)
{
	down_state &= ~mask;
    8030:	2204      	movs	r2, #4
    8032:	4393      	bics	r3, r2
    8034:	4a11      	ldr	r2, [pc, #68]	; (807c <wifi_cb+0x9c>)
    8036:	7013      	strb	r3, [r2, #0]

			if (is_state_set(GET_REQUESTED)) {
				clear_state(GET_REQUESTED);
			}

			m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID),
    8038:	23ff      	movs	r3, #255	; 0xff
    803a:	9300      	str	r3, [sp, #0]
    803c:	4b12      	ldr	r3, [pc, #72]	; (8088 <wifi_cb+0xa8>)
    803e:	2202      	movs	r2, #2
    8040:	210d      	movs	r1, #13
    8042:	4812      	ldr	r0, [pc, #72]	; (808c <wifi_cb+0xac>)
    8044:	4c12      	ldr	r4, [pc, #72]	; (8090 <wifi_cb+0xb0>)
    8046:	47a0      	blx	r4
    8048:	e00d      	b.n	8066 <wifi_cb+0x86>
	}

	case M2M_WIFI_REQ_DHCP_CONF:
	{
		uint8_t *pu8IPAddress = (uint8_t *)pvMsg;
		printf("wifi_cb: IP address is %u.%u.%u.%u\r\n",
    804a:	788b      	ldrb	r3, [r1, #2]
    804c:	784a      	ldrb	r2, [r1, #1]
    804e:	7808      	ldrb	r0, [r1, #0]
    8050:	78c9      	ldrb	r1, [r1, #3]
    8052:	9100      	str	r1, [sp, #0]
    8054:	0001      	movs	r1, r0
    8056:	480f      	ldr	r0, [pc, #60]	; (8094 <wifi_cb+0xb4>)
    8058:	4c0f      	ldr	r4, [pc, #60]	; (8098 <wifi_cb+0xb8>)
    805a:	47a0      	blx	r4
				pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]);
		add_state(WIFI_CONNECTED);
    805c:	2002      	movs	r0, #2
    805e:	4b0f      	ldr	r3, [pc, #60]	; (809c <wifi_cb+0xbc>)
    8060:	4798      	blx	r3
		start_download();
    8062:	4b0f      	ldr	r3, [pc, #60]	; (80a0 <wifi_cb+0xc0>)
    8064:	4798      	blx	r3
	}

	default:
		break;
	}
}
    8066:	b002      	add	sp, #8
    8068:	bd10      	pop	{r4, pc}
    806a:	46c0      	nop			; (mov r8, r8)
    806c:	0000b38c 	.word	0x0000b38c
    8070:	00008965 	.word	0x00008965
    8074:	00002525 	.word	0x00002525
    8078:	0000b3ac 	.word	0x0000b3ac
    807c:	200001bc 	.word	0x200001bc
    8080:	200001c4 	.word	0x200001c4
    8084:	00006b45 	.word	0x00006b45
    8088:	0000b3cc 	.word	0x0000b3cc
    808c:	0000b3d8 	.word	0x0000b3d8
    8090:	00002509 	.word	0x00002509
    8094:	0000b3e8 	.word	0x0000b3e8
    8098:	00008845 	.word	0x00008845
    809c:	00007d69 	.word	0x00007d69
    80a0:	00007e35 	.word	0x00007e35

000080a4 <main>:
 * Application entry point.
 *
 * \return program return value.
 */
int main(void)
{
    80a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    80a6:	b099      	sub	sp, #100	; 0x64
/**
 * \brief Initialize download state to not ready.
 */
static void init_state(void)
{
	down_state = NOT_READY;
    80a8:	2400      	movs	r4, #0
    80aa:	2600      	movs	r6, #0
    80ac:	4b61      	ldr	r3, [pc, #388]	; (8234 <main+0x190>)
    80ae:	701c      	strb	r4, [r3, #0]
	tstrWifiInitParam param;
	int8_t ret;
	init_state();

	/* Initialize the board. */
	system_init();
    80b0:	4b61      	ldr	r3, [pc, #388]	; (8238 <main+0x194>)
    80b2:	4798      	blx	r3
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    80b4:	aa02      	add	r2, sp, #8
    80b6:	2380      	movs	r3, #128	; 0x80
    80b8:	05db      	lsls	r3, r3, #23
    80ba:	9302      	str	r3, [sp, #8]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    80bc:	6054      	str	r4, [r2, #4]
	config->parity           = USART_PARITY_NONE;
    80be:	23ff      	movs	r3, #255	; 0xff
    80c0:	8113      	strh	r3, [r2, #8]
	config->stopbits         = USART_STOPBITS_1;
    80c2:	7294      	strb	r4, [r2, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    80c4:	72d4      	strb	r4, [r2, #11]
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    80c6:	2501      	movs	r5, #1
    80c8:	3bdb      	subs	r3, #219	; 0xdb
    80ca:	54d5      	strb	r5, [r2, r3]
	config->transmitter_enable = true;
    80cc:	3301      	adds	r3, #1
    80ce:	54d5      	strb	r5, [r2, r3]
	config->clock_polarity_inverted = false;
    80d0:	3301      	adds	r3, #1
    80d2:	54d4      	strb	r4, [r2, r3]
	config->use_external_clock = false;
    80d4:	3301      	adds	r3, #1
    80d6:	54d4      	strb	r4, [r2, r3]
	config->ext_clock_freq   = 0;
    80d8:	6294      	str	r4, [r2, #40]	; 0x28
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
	config->run_in_standby   = false;
    80da:	3305      	adds	r3, #5
    80dc:	54d4      	strb	r4, [r2, r3]
	config->generator_source = GCLK_GENERATOR_0;
    80de:	3301      	adds	r3, #1
    80e0:	54d4      	strb	r4, [r2, r3]
	config->pinmux_pad0      = PINMUX_DEFAULT;
	config->pinmux_pad1      = PINMUX_DEFAULT;
	config->pinmux_pad2      = PINMUX_DEFAULT;
	config->pinmux_pad3      = PINMUX_DEFAULT;
#ifdef FEATURE_USART_OVER_SAMPLE
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    80e2:	6154      	str	r4, [r2, #20]
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    80e4:	8214      	strh	r4, [r2, #16]
#endif
#ifdef FEATURE_USART_LIN_SLAVE
	config->lin_slave_enable      = false;
    80e6:	2300      	movs	r3, #0
    80e8:	76d3      	strb	r3, [r2, #27]
	config->lin_header_delay = LIN_MASTER_HEADER_DELAY_0;
	config->lin_break_length = LIN_MASTER_BREAK_LENGTH_13_BIT;
#endif

#ifdef FEATURE_USART_IMMEDIATE_BUFFER_OVERFLOW_NOTIFICATION
	config->immediate_buffer_overflow_notification  = false;
    80ea:	7616      	strb	r6, [r2, #24]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
    80ec:	7716      	strb	r6, [r2, #28]
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
    80ee:	7656      	strb	r6, [r2, #25]
	config->receive_pulse_length                    = 19;
    80f0:	2313      	movs	r3, #19
    80f2:	7693      	strb	r3, [r2, #26]
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    80f4:	7756      	strb	r6, [r2, #29]
static void configure_console(void)
{
	struct usart_config usart_conf;

	usart_get_config_defaults(&usart_conf);
	usart_conf.mux_setting = EDBG_CDC_SERCOM_MUX_SETTING;
    80f6:	23c4      	movs	r3, #196	; 0xc4
    80f8:	039b      	lsls	r3, r3, #14
    80fa:	60d3      	str	r3, [r2, #12]
	usart_conf.pinmux_pad0 = EDBG_CDC_SERCOM_PINMUX_PAD0;
    80fc:	2301      	movs	r3, #1
    80fe:	425b      	negs	r3, r3
    8100:	6313      	str	r3, [r2, #48]	; 0x30
	usart_conf.pinmux_pad1 = EDBG_CDC_SERCOM_PINMUX_PAD1;
    8102:	6353      	str	r3, [r2, #52]	; 0x34
	usart_conf.pinmux_pad2 = EDBG_CDC_SERCOM_PINMUX_PAD2;
    8104:	4b4d      	ldr	r3, [pc, #308]	; (823c <main+0x198>)
    8106:	6393      	str	r3, [r2, #56]	; 0x38
	usart_conf.pinmux_pad3 = EDBG_CDC_SERCOM_PINMUX_PAD3;
    8108:	4b4d      	ldr	r3, [pc, #308]	; (8240 <main+0x19c>)
    810a:	63d3      	str	r3, [r2, #60]	; 0x3c
	usart_conf.baudrate    = 115200;
    810c:	23e1      	movs	r3, #225	; 0xe1
    810e:	025b      	lsls	r3, r3, #9
    8110:	6213      	str	r3, [r2, #32]
static inline void stdio_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	stdio_base = (void *)module;
    8112:	4c4c      	ldr	r4, [pc, #304]	; (8244 <main+0x1a0>)
    8114:	4b4c      	ldr	r3, [pc, #304]	; (8248 <main+0x1a4>)
    8116:	601c      	str	r4, [r3, #0]
	ptr_put = (int (*)(void volatile*,char))&usart_serial_putchar;
    8118:	494c      	ldr	r1, [pc, #304]	; (824c <main+0x1a8>)
    811a:	4b4d      	ldr	r3, [pc, #308]	; (8250 <main+0x1ac>)
    811c:	6019      	str	r1, [r3, #0]
	ptr_get = (void (*)(void volatile*,char*))&usart_serial_getchar;
    811e:	494d      	ldr	r1, [pc, #308]	; (8254 <main+0x1b0>)
    8120:	4b4d      	ldr	r3, [pc, #308]	; (8258 <main+0x1b4>)
    8122:	6019      	str	r1, [r3, #0]
static inline bool usart_serial_init(
		struct usart_module *const module,
		usart_inst_t const hw,
		const struct usart_config *const config)
{
	if (usart_init(module, hw, config) == STATUS_OK) {
    8124:	494d      	ldr	r1, [pc, #308]	; (825c <main+0x1b8>)
    8126:	0020      	movs	r0, r4
    8128:	4b4d      	ldr	r3, [pc, #308]	; (8260 <main+0x1bc>)
    812a:	4798      	blx	r3

	usart_serial_init(module, hw, config);
# if defined(__GNUC__)
	// Specify that stdout and stdin should not be buffered.
	setbuf(stdout, NULL);
    812c:	4f4d      	ldr	r7, [pc, #308]	; (8264 <main+0x1c0>)
    812e:	683b      	ldr	r3, [r7, #0]
    8130:	6898      	ldr	r0, [r3, #8]
    8132:	2100      	movs	r1, #0
    8134:	4e4c      	ldr	r6, [pc, #304]	; (8268 <main+0x1c4>)
    8136:	47b0      	blx	r6
	setbuf(stdin, NULL);
    8138:	683b      	ldr	r3, [r7, #0]
    813a:	6858      	ldr	r0, [r3, #4]
    813c:	2100      	movs	r1, #0
    813e:	47b0      	blx	r6
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    8140:	6826      	ldr	r6, [r4, #0]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    8142:	0030      	movs	r0, r6
    8144:	4b49      	ldr	r3, [pc, #292]	; (826c <main+0x1c8>)
    8146:	4798      	blx	r3
    8148:	231f      	movs	r3, #31
    814a:	4018      	ands	r0, r3
    814c:	4085      	lsls	r5, r0
    814e:	4b48      	ldr	r3, [pc, #288]	; (8270 <main+0x1cc>)
    8150:	601d      	str	r5, [r3, #0]
{
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomUsart *const usart_hw = &(module->hw->USART);
    8152:	6822      	ldr	r2, [r4, #0]

#ifdef FEATURE_USART_SYNC_SCHEME_V2
	return (usart_hw->SYNCBUSY.reg);
    8154:	69d3      	ldr	r3, [r2, #28]
		const struct usart_module *const module)
{
	/* Sanity check */
	Assert(module);

	while (usart_is_syncing(module)) {
    8156:	2b00      	cmp	r3, #0
    8158:	d1fc      	bne.n	8154 <main+0xb0>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    815a:	6832      	ldr	r2, [r6, #0]
    815c:	3302      	adds	r3, #2
    815e:	4313      	orrs	r3, r2
    8160:	6033      	str	r3, [r6, #0]
	/* Initialize the board. */
	system_init();

	/* Initialize the UART console. */
	configure_console();
	printf(STRING_HEADER);
    8162:	4844      	ldr	r0, [pc, #272]	; (8274 <main+0x1d0>)
    8164:	4c44      	ldr	r4, [pc, #272]	; (8278 <main+0x1d4>)
    8166:	47a0      	blx	r4
	printf("\r\nThis example requires the AP to have Internet access.\r\n\r\n");
    8168:	4844      	ldr	r0, [pc, #272]	; (827c <main+0x1d8>)
    816a:	47a0      	blx	r4
 * \brief Configure Timer module.
 */
static void configure_timer(void)
{
	struct sw_timer_config swt_conf;
	sw_timer_get_config_defaults(&swt_conf);
    816c:	a802      	add	r0, sp, #8
    816e:	4b44      	ldr	r3, [pc, #272]	; (8280 <main+0x1dc>)
    8170:	4798      	blx	r3

	sw_timer_init(&swt_module_inst, &swt_conf);
    8172:	4c44      	ldr	r4, [pc, #272]	; (8284 <main+0x1e0>)
    8174:	a902      	add	r1, sp, #8
    8176:	0020      	movs	r0, r4
    8178:	4b43      	ldr	r3, [pc, #268]	; (8288 <main+0x1e4>)
    817a:	4798      	blx	r3
	sw_timer_enable(&swt_module_inst);
    817c:	0020      	movs	r0, r4
    817e:	4b43      	ldr	r3, [pc, #268]	; (828c <main+0x1e8>)
    8180:	4798      	blx	r3
static void configure_http_client(void)
{
	struct http_client_config httpc_conf;
	int ret;

	http_client_get_config_defaults(&httpc_conf);
    8182:	a802      	add	r0, sp, #8
    8184:	4b42      	ldr	r3, [pc, #264]	; (8290 <main+0x1ec>)
    8186:	4798      	blx	r3

	httpc_conf.recv_buffer_size = MAIN_BUFFER_MAX_SIZE;
    8188:	2380      	movs	r3, #128	; 0x80
    818a:	00db      	lsls	r3, r3, #3
    818c:	9306      	str	r3, [sp, #24]
	httpc_conf.timer_inst = &swt_module_inst;
    818e:	9403      	str	r4, [sp, #12]

	ret = http_client_init(&http_client_module_inst, &httpc_conf);
    8190:	a902      	add	r1, sp, #8
    8192:	4840      	ldr	r0, [pc, #256]	; (8294 <main+0x1f0>)
    8194:	4b40      	ldr	r3, [pc, #256]	; (8298 <main+0x1f4>)
    8196:	4798      	blx	r3
    8198:	1e01      	subs	r1, r0, #0
	if (ret < 0) {
    819a:	da03      	bge.n	81a4 <main+0x100>
		printf("configure_http_client: HTTP client initialization failed! (res %d)\r\n", ret);
    819c:	483f      	ldr	r0, [pc, #252]	; (829c <main+0x1f8>)
    819e:	4b40      	ldr	r3, [pc, #256]	; (82a0 <main+0x1fc>)
    81a0:	4798      	blx	r3
    81a2:	e7fe      	b.n	81a2 <main+0xfe>
		while (1) {
		} /* Loop forever. */
	}

	http_client_register_callback(&http_client_module_inst, http_client_callback);
    81a4:	493f      	ldr	r1, [pc, #252]	; (82a4 <main+0x200>)
    81a6:	483b      	ldr	r0, [pc, #236]	; (8294 <main+0x1f0>)
    81a8:	4b3f      	ldr	r3, [pc, #252]	; (82a8 <main+0x204>)
    81aa:	4798      	blx	r3

	/* Initialize the HTTP client service. */
	configure_http_client();

	/* Initialize the BSP. */
	nm_bsp_init();
    81ac:	4b3f      	ldr	r3, [pc, #252]	; (82ac <main+0x208>)
    81ae:	4798      	blx	r3
	//Ctrl_status status;

	/* Initialize SD/MMC stack. */
	//sd_mmc_init();
	while (true) {
		printf("init_storage: please plug an SD/MMC card in slot...\r\n");
    81b0:	483f      	ldr	r0, [pc, #252]	; (82b0 <main+0x20c>)
    81b2:	4c31      	ldr	r4, [pc, #196]	; (8278 <main+0x1d4>)
    81b4:	47a0      	blx	r4
		//if (FR_INVALID_DRIVE == res) {
			//printf("init_storage: SD card mount failed! (res %d)\r\n", res);
			//return;
		//}

		printf("init_storage: SD card mount OK.\r\n");
    81b6:	483f      	ldr	r0, [pc, #252]	; (82b4 <main+0x210>)
    81b8:	47a0      	blx	r4
		add_state(STORAGE_READY);
    81ba:	2001      	movs	r0, #1
    81bc:	4b3e      	ldr	r3, [pc, #248]	; (82b8 <main+0x214>)
    81be:	4798      	blx	r3

	/* Initialize SD/MMC storage. */
	init_storage();

	/* Initialize Wi-Fi parameters structure. */
	memset((uint8_t *)&param, 0, sizeof(tstrWifiInitParam));
    81c0:	2218      	movs	r2, #24
    81c2:	2100      	movs	r1, #0
    81c4:	a812      	add	r0, sp, #72	; 0x48
    81c6:	4b3d      	ldr	r3, [pc, #244]	; (82bc <main+0x218>)
    81c8:	4798      	blx	r3

	/* Initialize Wi-Fi driver with data and status callbacks. */
	param.pfAppWifiCb = wifi_cb;
    81ca:	4b3d      	ldr	r3, [pc, #244]	; (82c0 <main+0x21c>)
    81cc:	9312      	str	r3, [sp, #72]	; 0x48
	ret = m2m_wifi_init(&param);
    81ce:	a812      	add	r0, sp, #72	; 0x48
    81d0:	4b3c      	ldr	r3, [pc, #240]	; (82c4 <main+0x220>)
    81d2:	4798      	blx	r3
    81d4:	1e01      	subs	r1, r0, #0
	if (M2M_SUCCESS != ret) {
    81d6:	d003      	beq.n	81e0 <main+0x13c>
		printf("main: m2m_wifi_init call error! (res %d)\r\n", ret);
    81d8:	483b      	ldr	r0, [pc, #236]	; (82c8 <main+0x224>)
    81da:	4b31      	ldr	r3, [pc, #196]	; (82a0 <main+0x1fc>)
    81dc:	4798      	blx	r3
    81de:	e7fe      	b.n	81de <main+0x13a>
		while (1) {
		}
	}

	/* Initialize socket module. */
	socketInit();
    81e0:	4b3a      	ldr	r3, [pc, #232]	; (82cc <main+0x228>)
    81e2:	4798      	blx	r3
	/* Register socket callback function. */
	registerSocketCallback(socket_cb, resolve_cb);
    81e4:	493a      	ldr	r1, [pc, #232]	; (82d0 <main+0x22c>)
    81e6:	483b      	ldr	r0, [pc, #236]	; (82d4 <main+0x230>)
    81e8:	4b3b      	ldr	r3, [pc, #236]	; (82d8 <main+0x234>)
    81ea:	4798      	blx	r3

	/* Connect to router. */
	printf("main: connecting to WiFi AP %s...\r\n", (char *)MAIN_WLAN_SSID);
    81ec:	4c3b      	ldr	r4, [pc, #236]	; (82dc <main+0x238>)
    81ee:	0021      	movs	r1, r4
    81f0:	483b      	ldr	r0, [pc, #236]	; (82e0 <main+0x23c>)
    81f2:	4b2b      	ldr	r3, [pc, #172]	; (82a0 <main+0x1fc>)
    81f4:	4798      	blx	r3
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
    81f6:	23ff      	movs	r3, #255	; 0xff
    81f8:	9300      	str	r3, [sp, #0]
    81fa:	4b3a      	ldr	r3, [pc, #232]	; (82e4 <main+0x240>)
    81fc:	2202      	movs	r2, #2
    81fe:	210d      	movs	r1, #13
    8200:	0020      	movs	r0, r4
    8202:	4c39      	ldr	r4, [pc, #228]	; (82e8 <main+0x244>)
    8204:	47a0      	blx	r4
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    8206:	4b0b      	ldr	r3, [pc, #44]	; (8234 <main+0x190>)

	/* Connect to router. */
	printf("main: connecting to WiFi AP %s...\r\n", (char *)MAIN_WLAN_SSID);
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);

	while (!(is_state_set(COMPLETED) || is_state_set(CANCELED))) {
    8208:	781a      	ldrb	r2, [r3, #0]
    820a:	2330      	movs	r3, #48	; 0x30
    820c:	421a      	tst	r2, r3
    820e:	d10b      	bne.n	8228 <main+0x184>
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    8210:	4e36      	ldr	r6, [pc, #216]	; (82ec <main+0x248>)
		/* Checks the timer timeout. */
		sw_timer_task(&swt_module_inst);
    8212:	4d1c      	ldr	r5, [pc, #112]	; (8284 <main+0x1e0>)
    8214:	4c36      	ldr	r4, [pc, #216]	; (82f0 <main+0x24c>)
	printf("main: connecting to WiFi AP %s...\r\n", (char *)MAIN_WLAN_SSID);
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);

	while (!(is_state_set(COMPLETED) || is_state_set(CANCELED))) {
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
    8216:	2000      	movs	r0, #0
    8218:	47b0      	blx	r6
		/* Checks the timer timeout. */
		sw_timer_task(&swt_module_inst);
    821a:	0028      	movs	r0, r5
    821c:	47a0      	blx	r4
 * \return true if this state is set, false otherwise.
 */

static inline bool is_state_set(download_state mask)
{
	return ((down_state & mask) != 0);
    821e:	4b05      	ldr	r3, [pc, #20]	; (8234 <main+0x190>)

	/* Connect to router. */
	printf("main: connecting to WiFi AP %s...\r\n", (char *)MAIN_WLAN_SSID);
	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);

	while (!(is_state_set(COMPLETED) || is_state_set(CANCELED))) {
    8220:	781b      	ldrb	r3, [r3, #0]
    8222:	2230      	movs	r2, #48	; 0x30
    8224:	421a      	tst	r2, r3
    8226:	d0f6      	beq.n	8216 <main+0x172>
		/* Handle pending events from network controller. */
		m2m_wifi_handle_events(NULL);
		/* Checks the timer timeout. */
		sw_timer_task(&swt_module_inst);
	}
	printf("main: please unplug the SD/MMC card.\r\n");
    8228:	4832      	ldr	r0, [pc, #200]	; (82f4 <main+0x250>)
    822a:	4c13      	ldr	r4, [pc, #76]	; (8278 <main+0x1d4>)
    822c:	47a0      	blx	r4
	printf("main: done.\r\n");
    822e:	4832      	ldr	r0, [pc, #200]	; (82f8 <main+0x254>)
    8230:	47a0      	blx	r4
    8232:	e7fe      	b.n	8232 <main+0x18e>
    8234:	200001bc 	.word	0x200001bc
    8238:	00005ec9 	.word	0x00005ec9
    823c:	002a0003 	.word	0x002a0003
    8240:	002b0003 	.word	0x002b0003
    8244:	20000188 	.word	0x20000188
    8248:	20000394 	.word	0x20000394
    824c:	00007ed9 	.word	0x00007ed9
    8250:	20000390 	.word	0x20000390
    8254:	00007ead 	.word	0x00007ead
    8258:	2000038c 	.word	0x2000038c
    825c:	42001800 	.word	0x42001800
    8260:	000051cd 	.word	0x000051cd
    8264:	20000090 	.word	0x20000090
    8268:	0000899d 	.word	0x0000899d
    826c:	00004aa9 	.word	0x00004aa9
    8270:	e000e100 	.word	0xe000e100
    8274:	0000b410 	.word	0x0000b410
    8278:	00008965 	.word	0x00008965
    827c:	0000b478 	.word	0x0000b478
    8280:	00007bd5 	.word	0x00007bd5
    8284:	200003ac 	.word	0x200003ac
    8288:	00007be1 	.word	0x00007be1
    828c:	00007c8d 	.word	0x00007c8d
    8290:	00006bcd 	.word	0x00006bcd
    8294:	20000404 	.word	0x20000404
    8298:	00006bf5 	.word	0x00006bf5
    829c:	0000b4b4 	.word	0x0000b4b4
    82a0:	00008845 	.word	0x00008845
    82a4:	00007ef1 	.word	0x00007ef1
    82a8:	00006ca9 	.word	0x00006ca9
    82ac:	0000121d 	.word	0x0000121d
    82b0:	0000b4fc 	.word	0x0000b4fc
    82b4:	0000b534 	.word	0x0000b534
    82b8:	00007d69 	.word	0x00007d69
    82bc:	000086fd 	.word	0x000086fd
    82c0:	00007fe1 	.word	0x00007fe1
    82c4:	00002149 	.word	0x00002149
    82c8:	0000b558 	.word	0x0000b558
    82cc:	00003d41 	.word	0x00003d41
    82d0:	00007ded 	.word	0x00007ded
    82d4:	00007e29 	.word	0x00007e29
    82d8:	00003d85 	.word	0x00003d85
    82dc:	0000b3d8 	.word	0x0000b3d8
    82e0:	0000b584 	.word	0x0000b584
    82e4:	0000b3cc 	.word	0x0000b3cc
    82e8:	00002509 	.word	0x00002509
    82ec:	00002279 	.word	0x00002279
    82f0:	00007d15 	.word	0x00007d15
    82f4:	0000b5a8 	.word	0x0000b5a8
    82f8:	0000b5d0 	.word	0x0000b5d0

000082fc <__aeabi_uidiv>:
    82fc:	2200      	movs	r2, #0
    82fe:	0843      	lsrs	r3, r0, #1
    8300:	428b      	cmp	r3, r1
    8302:	d374      	bcc.n	83ee <__aeabi_uidiv+0xf2>
    8304:	0903      	lsrs	r3, r0, #4
    8306:	428b      	cmp	r3, r1
    8308:	d35f      	bcc.n	83ca <__aeabi_uidiv+0xce>
    830a:	0a03      	lsrs	r3, r0, #8
    830c:	428b      	cmp	r3, r1
    830e:	d344      	bcc.n	839a <__aeabi_uidiv+0x9e>
    8310:	0b03      	lsrs	r3, r0, #12
    8312:	428b      	cmp	r3, r1
    8314:	d328      	bcc.n	8368 <__aeabi_uidiv+0x6c>
    8316:	0c03      	lsrs	r3, r0, #16
    8318:	428b      	cmp	r3, r1
    831a:	d30d      	bcc.n	8338 <__aeabi_uidiv+0x3c>
    831c:	22ff      	movs	r2, #255	; 0xff
    831e:	0209      	lsls	r1, r1, #8
    8320:	ba12      	rev	r2, r2
    8322:	0c03      	lsrs	r3, r0, #16
    8324:	428b      	cmp	r3, r1
    8326:	d302      	bcc.n	832e <__aeabi_uidiv+0x32>
    8328:	1212      	asrs	r2, r2, #8
    832a:	0209      	lsls	r1, r1, #8
    832c:	d065      	beq.n	83fa <__aeabi_uidiv+0xfe>
    832e:	0b03      	lsrs	r3, r0, #12
    8330:	428b      	cmp	r3, r1
    8332:	d319      	bcc.n	8368 <__aeabi_uidiv+0x6c>
    8334:	e000      	b.n	8338 <__aeabi_uidiv+0x3c>
    8336:	0a09      	lsrs	r1, r1, #8
    8338:	0bc3      	lsrs	r3, r0, #15
    833a:	428b      	cmp	r3, r1
    833c:	d301      	bcc.n	8342 <__aeabi_uidiv+0x46>
    833e:	03cb      	lsls	r3, r1, #15
    8340:	1ac0      	subs	r0, r0, r3
    8342:	4152      	adcs	r2, r2
    8344:	0b83      	lsrs	r3, r0, #14
    8346:	428b      	cmp	r3, r1
    8348:	d301      	bcc.n	834e <__aeabi_uidiv+0x52>
    834a:	038b      	lsls	r3, r1, #14
    834c:	1ac0      	subs	r0, r0, r3
    834e:	4152      	adcs	r2, r2
    8350:	0b43      	lsrs	r3, r0, #13
    8352:	428b      	cmp	r3, r1
    8354:	d301      	bcc.n	835a <__aeabi_uidiv+0x5e>
    8356:	034b      	lsls	r3, r1, #13
    8358:	1ac0      	subs	r0, r0, r3
    835a:	4152      	adcs	r2, r2
    835c:	0b03      	lsrs	r3, r0, #12
    835e:	428b      	cmp	r3, r1
    8360:	d301      	bcc.n	8366 <__aeabi_uidiv+0x6a>
    8362:	030b      	lsls	r3, r1, #12
    8364:	1ac0      	subs	r0, r0, r3
    8366:	4152      	adcs	r2, r2
    8368:	0ac3      	lsrs	r3, r0, #11
    836a:	428b      	cmp	r3, r1
    836c:	d301      	bcc.n	8372 <__aeabi_uidiv+0x76>
    836e:	02cb      	lsls	r3, r1, #11
    8370:	1ac0      	subs	r0, r0, r3
    8372:	4152      	adcs	r2, r2
    8374:	0a83      	lsrs	r3, r0, #10
    8376:	428b      	cmp	r3, r1
    8378:	d301      	bcc.n	837e <__aeabi_uidiv+0x82>
    837a:	028b      	lsls	r3, r1, #10
    837c:	1ac0      	subs	r0, r0, r3
    837e:	4152      	adcs	r2, r2
    8380:	0a43      	lsrs	r3, r0, #9
    8382:	428b      	cmp	r3, r1
    8384:	d301      	bcc.n	838a <__aeabi_uidiv+0x8e>
    8386:	024b      	lsls	r3, r1, #9
    8388:	1ac0      	subs	r0, r0, r3
    838a:	4152      	adcs	r2, r2
    838c:	0a03      	lsrs	r3, r0, #8
    838e:	428b      	cmp	r3, r1
    8390:	d301      	bcc.n	8396 <__aeabi_uidiv+0x9a>
    8392:	020b      	lsls	r3, r1, #8
    8394:	1ac0      	subs	r0, r0, r3
    8396:	4152      	adcs	r2, r2
    8398:	d2cd      	bcs.n	8336 <__aeabi_uidiv+0x3a>
    839a:	09c3      	lsrs	r3, r0, #7
    839c:	428b      	cmp	r3, r1
    839e:	d301      	bcc.n	83a4 <__aeabi_uidiv+0xa8>
    83a0:	01cb      	lsls	r3, r1, #7
    83a2:	1ac0      	subs	r0, r0, r3
    83a4:	4152      	adcs	r2, r2
    83a6:	0983      	lsrs	r3, r0, #6
    83a8:	428b      	cmp	r3, r1
    83aa:	d301      	bcc.n	83b0 <__aeabi_uidiv+0xb4>
    83ac:	018b      	lsls	r3, r1, #6
    83ae:	1ac0      	subs	r0, r0, r3
    83b0:	4152      	adcs	r2, r2
    83b2:	0943      	lsrs	r3, r0, #5
    83b4:	428b      	cmp	r3, r1
    83b6:	d301      	bcc.n	83bc <__aeabi_uidiv+0xc0>
    83b8:	014b      	lsls	r3, r1, #5
    83ba:	1ac0      	subs	r0, r0, r3
    83bc:	4152      	adcs	r2, r2
    83be:	0903      	lsrs	r3, r0, #4
    83c0:	428b      	cmp	r3, r1
    83c2:	d301      	bcc.n	83c8 <__aeabi_uidiv+0xcc>
    83c4:	010b      	lsls	r3, r1, #4
    83c6:	1ac0      	subs	r0, r0, r3
    83c8:	4152      	adcs	r2, r2
    83ca:	08c3      	lsrs	r3, r0, #3
    83cc:	428b      	cmp	r3, r1
    83ce:	d301      	bcc.n	83d4 <__aeabi_uidiv+0xd8>
    83d0:	00cb      	lsls	r3, r1, #3
    83d2:	1ac0      	subs	r0, r0, r3
    83d4:	4152      	adcs	r2, r2
    83d6:	0883      	lsrs	r3, r0, #2
    83d8:	428b      	cmp	r3, r1
    83da:	d301      	bcc.n	83e0 <__aeabi_uidiv+0xe4>
    83dc:	008b      	lsls	r3, r1, #2
    83de:	1ac0      	subs	r0, r0, r3
    83e0:	4152      	adcs	r2, r2
    83e2:	0843      	lsrs	r3, r0, #1
    83e4:	428b      	cmp	r3, r1
    83e6:	d301      	bcc.n	83ec <__aeabi_uidiv+0xf0>
    83e8:	004b      	lsls	r3, r1, #1
    83ea:	1ac0      	subs	r0, r0, r3
    83ec:	4152      	adcs	r2, r2
    83ee:	1a41      	subs	r1, r0, r1
    83f0:	d200      	bcs.n	83f4 <__aeabi_uidiv+0xf8>
    83f2:	4601      	mov	r1, r0
    83f4:	4152      	adcs	r2, r2
    83f6:	4610      	mov	r0, r2
    83f8:	4770      	bx	lr
    83fa:	e7ff      	b.n	83fc <__aeabi_uidiv+0x100>
    83fc:	b501      	push	{r0, lr}
    83fe:	2000      	movs	r0, #0
    8400:	f000 f8f0 	bl	85e4 <__aeabi_idiv0>
    8404:	bd02      	pop	{r1, pc}
    8406:	46c0      	nop			; (mov r8, r8)

00008408 <__aeabi_uidivmod>:
    8408:	2900      	cmp	r1, #0
    840a:	d0f7      	beq.n	83fc <__aeabi_uidiv+0x100>
    840c:	e776      	b.n	82fc <__aeabi_uidiv>
    840e:	4770      	bx	lr

00008410 <__aeabi_idiv>:
    8410:	4603      	mov	r3, r0
    8412:	430b      	orrs	r3, r1
    8414:	d47f      	bmi.n	8516 <__aeabi_idiv+0x106>
    8416:	2200      	movs	r2, #0
    8418:	0843      	lsrs	r3, r0, #1
    841a:	428b      	cmp	r3, r1
    841c:	d374      	bcc.n	8508 <__aeabi_idiv+0xf8>
    841e:	0903      	lsrs	r3, r0, #4
    8420:	428b      	cmp	r3, r1
    8422:	d35f      	bcc.n	84e4 <__aeabi_idiv+0xd4>
    8424:	0a03      	lsrs	r3, r0, #8
    8426:	428b      	cmp	r3, r1
    8428:	d344      	bcc.n	84b4 <__aeabi_idiv+0xa4>
    842a:	0b03      	lsrs	r3, r0, #12
    842c:	428b      	cmp	r3, r1
    842e:	d328      	bcc.n	8482 <__aeabi_idiv+0x72>
    8430:	0c03      	lsrs	r3, r0, #16
    8432:	428b      	cmp	r3, r1
    8434:	d30d      	bcc.n	8452 <__aeabi_idiv+0x42>
    8436:	22ff      	movs	r2, #255	; 0xff
    8438:	0209      	lsls	r1, r1, #8
    843a:	ba12      	rev	r2, r2
    843c:	0c03      	lsrs	r3, r0, #16
    843e:	428b      	cmp	r3, r1
    8440:	d302      	bcc.n	8448 <__aeabi_idiv+0x38>
    8442:	1212      	asrs	r2, r2, #8
    8444:	0209      	lsls	r1, r1, #8
    8446:	d065      	beq.n	8514 <__aeabi_idiv+0x104>
    8448:	0b03      	lsrs	r3, r0, #12
    844a:	428b      	cmp	r3, r1
    844c:	d319      	bcc.n	8482 <__aeabi_idiv+0x72>
    844e:	e000      	b.n	8452 <__aeabi_idiv+0x42>
    8450:	0a09      	lsrs	r1, r1, #8
    8452:	0bc3      	lsrs	r3, r0, #15
    8454:	428b      	cmp	r3, r1
    8456:	d301      	bcc.n	845c <__aeabi_idiv+0x4c>
    8458:	03cb      	lsls	r3, r1, #15
    845a:	1ac0      	subs	r0, r0, r3
    845c:	4152      	adcs	r2, r2
    845e:	0b83      	lsrs	r3, r0, #14
    8460:	428b      	cmp	r3, r1
    8462:	d301      	bcc.n	8468 <__aeabi_idiv+0x58>
    8464:	038b      	lsls	r3, r1, #14
    8466:	1ac0      	subs	r0, r0, r3
    8468:	4152      	adcs	r2, r2
    846a:	0b43      	lsrs	r3, r0, #13
    846c:	428b      	cmp	r3, r1
    846e:	d301      	bcc.n	8474 <__aeabi_idiv+0x64>
    8470:	034b      	lsls	r3, r1, #13
    8472:	1ac0      	subs	r0, r0, r3
    8474:	4152      	adcs	r2, r2
    8476:	0b03      	lsrs	r3, r0, #12
    8478:	428b      	cmp	r3, r1
    847a:	d301      	bcc.n	8480 <__aeabi_idiv+0x70>
    847c:	030b      	lsls	r3, r1, #12
    847e:	1ac0      	subs	r0, r0, r3
    8480:	4152      	adcs	r2, r2
    8482:	0ac3      	lsrs	r3, r0, #11
    8484:	428b      	cmp	r3, r1
    8486:	d301      	bcc.n	848c <__aeabi_idiv+0x7c>
    8488:	02cb      	lsls	r3, r1, #11
    848a:	1ac0      	subs	r0, r0, r3
    848c:	4152      	adcs	r2, r2
    848e:	0a83      	lsrs	r3, r0, #10
    8490:	428b      	cmp	r3, r1
    8492:	d301      	bcc.n	8498 <__aeabi_idiv+0x88>
    8494:	028b      	lsls	r3, r1, #10
    8496:	1ac0      	subs	r0, r0, r3
    8498:	4152      	adcs	r2, r2
    849a:	0a43      	lsrs	r3, r0, #9
    849c:	428b      	cmp	r3, r1
    849e:	d301      	bcc.n	84a4 <__aeabi_idiv+0x94>
    84a0:	024b      	lsls	r3, r1, #9
    84a2:	1ac0      	subs	r0, r0, r3
    84a4:	4152      	adcs	r2, r2
    84a6:	0a03      	lsrs	r3, r0, #8
    84a8:	428b      	cmp	r3, r1
    84aa:	d301      	bcc.n	84b0 <__aeabi_idiv+0xa0>
    84ac:	020b      	lsls	r3, r1, #8
    84ae:	1ac0      	subs	r0, r0, r3
    84b0:	4152      	adcs	r2, r2
    84b2:	d2cd      	bcs.n	8450 <__aeabi_idiv+0x40>
    84b4:	09c3      	lsrs	r3, r0, #7
    84b6:	428b      	cmp	r3, r1
    84b8:	d301      	bcc.n	84be <__aeabi_idiv+0xae>
    84ba:	01cb      	lsls	r3, r1, #7
    84bc:	1ac0      	subs	r0, r0, r3
    84be:	4152      	adcs	r2, r2
    84c0:	0983      	lsrs	r3, r0, #6
    84c2:	428b      	cmp	r3, r1
    84c4:	d301      	bcc.n	84ca <__aeabi_idiv+0xba>
    84c6:	018b      	lsls	r3, r1, #6
    84c8:	1ac0      	subs	r0, r0, r3
    84ca:	4152      	adcs	r2, r2
    84cc:	0943      	lsrs	r3, r0, #5
    84ce:	428b      	cmp	r3, r1
    84d0:	d301      	bcc.n	84d6 <__aeabi_idiv+0xc6>
    84d2:	014b      	lsls	r3, r1, #5
    84d4:	1ac0      	subs	r0, r0, r3
    84d6:	4152      	adcs	r2, r2
    84d8:	0903      	lsrs	r3, r0, #4
    84da:	428b      	cmp	r3, r1
    84dc:	d301      	bcc.n	84e2 <__aeabi_idiv+0xd2>
    84de:	010b      	lsls	r3, r1, #4
    84e0:	1ac0      	subs	r0, r0, r3
    84e2:	4152      	adcs	r2, r2
    84e4:	08c3      	lsrs	r3, r0, #3
    84e6:	428b      	cmp	r3, r1
    84e8:	d301      	bcc.n	84ee <__aeabi_idiv+0xde>
    84ea:	00cb      	lsls	r3, r1, #3
    84ec:	1ac0      	subs	r0, r0, r3
    84ee:	4152      	adcs	r2, r2
    84f0:	0883      	lsrs	r3, r0, #2
    84f2:	428b      	cmp	r3, r1
    84f4:	d301      	bcc.n	84fa <__aeabi_idiv+0xea>
    84f6:	008b      	lsls	r3, r1, #2
    84f8:	1ac0      	subs	r0, r0, r3
    84fa:	4152      	adcs	r2, r2
    84fc:	0843      	lsrs	r3, r0, #1
    84fe:	428b      	cmp	r3, r1
    8500:	d301      	bcc.n	8506 <__aeabi_idiv+0xf6>
    8502:	004b      	lsls	r3, r1, #1
    8504:	1ac0      	subs	r0, r0, r3
    8506:	4152      	adcs	r2, r2
    8508:	1a41      	subs	r1, r0, r1
    850a:	d200      	bcs.n	850e <__aeabi_idiv+0xfe>
    850c:	4601      	mov	r1, r0
    850e:	4152      	adcs	r2, r2
    8510:	4610      	mov	r0, r2
    8512:	4770      	bx	lr
    8514:	e05d      	b.n	85d2 <__aeabi_idiv+0x1c2>
    8516:	0fca      	lsrs	r2, r1, #31
    8518:	d000      	beq.n	851c <__aeabi_idiv+0x10c>
    851a:	4249      	negs	r1, r1
    851c:	1003      	asrs	r3, r0, #32
    851e:	d300      	bcc.n	8522 <__aeabi_idiv+0x112>
    8520:	4240      	negs	r0, r0
    8522:	4053      	eors	r3, r2
    8524:	2200      	movs	r2, #0
    8526:	469c      	mov	ip, r3
    8528:	0903      	lsrs	r3, r0, #4
    852a:	428b      	cmp	r3, r1
    852c:	d32d      	bcc.n	858a <__aeabi_idiv+0x17a>
    852e:	0a03      	lsrs	r3, r0, #8
    8530:	428b      	cmp	r3, r1
    8532:	d312      	bcc.n	855a <__aeabi_idiv+0x14a>
    8534:	22fc      	movs	r2, #252	; 0xfc
    8536:	0189      	lsls	r1, r1, #6
    8538:	ba12      	rev	r2, r2
    853a:	0a03      	lsrs	r3, r0, #8
    853c:	428b      	cmp	r3, r1
    853e:	d30c      	bcc.n	855a <__aeabi_idiv+0x14a>
    8540:	0189      	lsls	r1, r1, #6
    8542:	1192      	asrs	r2, r2, #6
    8544:	428b      	cmp	r3, r1
    8546:	d308      	bcc.n	855a <__aeabi_idiv+0x14a>
    8548:	0189      	lsls	r1, r1, #6
    854a:	1192      	asrs	r2, r2, #6
    854c:	428b      	cmp	r3, r1
    854e:	d304      	bcc.n	855a <__aeabi_idiv+0x14a>
    8550:	0189      	lsls	r1, r1, #6
    8552:	d03a      	beq.n	85ca <__aeabi_idiv+0x1ba>
    8554:	1192      	asrs	r2, r2, #6
    8556:	e000      	b.n	855a <__aeabi_idiv+0x14a>
    8558:	0989      	lsrs	r1, r1, #6
    855a:	09c3      	lsrs	r3, r0, #7
    855c:	428b      	cmp	r3, r1
    855e:	d301      	bcc.n	8564 <__aeabi_idiv+0x154>
    8560:	01cb      	lsls	r3, r1, #7
    8562:	1ac0      	subs	r0, r0, r3
    8564:	4152      	adcs	r2, r2
    8566:	0983      	lsrs	r3, r0, #6
    8568:	428b      	cmp	r3, r1
    856a:	d301      	bcc.n	8570 <__aeabi_idiv+0x160>
    856c:	018b      	lsls	r3, r1, #6
    856e:	1ac0      	subs	r0, r0, r3
    8570:	4152      	adcs	r2, r2
    8572:	0943      	lsrs	r3, r0, #5
    8574:	428b      	cmp	r3, r1
    8576:	d301      	bcc.n	857c <__aeabi_idiv+0x16c>
    8578:	014b      	lsls	r3, r1, #5
    857a:	1ac0      	subs	r0, r0, r3
    857c:	4152      	adcs	r2, r2
    857e:	0903      	lsrs	r3, r0, #4
    8580:	428b      	cmp	r3, r1
    8582:	d301      	bcc.n	8588 <__aeabi_idiv+0x178>
    8584:	010b      	lsls	r3, r1, #4
    8586:	1ac0      	subs	r0, r0, r3
    8588:	4152      	adcs	r2, r2
    858a:	08c3      	lsrs	r3, r0, #3
    858c:	428b      	cmp	r3, r1
    858e:	d301      	bcc.n	8594 <__aeabi_idiv+0x184>
    8590:	00cb      	lsls	r3, r1, #3
    8592:	1ac0      	subs	r0, r0, r3
    8594:	4152      	adcs	r2, r2
    8596:	0883      	lsrs	r3, r0, #2
    8598:	428b      	cmp	r3, r1
    859a:	d301      	bcc.n	85a0 <__aeabi_idiv+0x190>
    859c:	008b      	lsls	r3, r1, #2
    859e:	1ac0      	subs	r0, r0, r3
    85a0:	4152      	adcs	r2, r2
    85a2:	d2d9      	bcs.n	8558 <__aeabi_idiv+0x148>
    85a4:	0843      	lsrs	r3, r0, #1
    85a6:	428b      	cmp	r3, r1
    85a8:	d301      	bcc.n	85ae <__aeabi_idiv+0x19e>
    85aa:	004b      	lsls	r3, r1, #1
    85ac:	1ac0      	subs	r0, r0, r3
    85ae:	4152      	adcs	r2, r2
    85b0:	1a41      	subs	r1, r0, r1
    85b2:	d200      	bcs.n	85b6 <__aeabi_idiv+0x1a6>
    85b4:	4601      	mov	r1, r0
    85b6:	4663      	mov	r3, ip
    85b8:	4152      	adcs	r2, r2
    85ba:	105b      	asrs	r3, r3, #1
    85bc:	4610      	mov	r0, r2
    85be:	d301      	bcc.n	85c4 <__aeabi_idiv+0x1b4>
    85c0:	4240      	negs	r0, r0
    85c2:	2b00      	cmp	r3, #0
    85c4:	d500      	bpl.n	85c8 <__aeabi_idiv+0x1b8>
    85c6:	4249      	negs	r1, r1
    85c8:	4770      	bx	lr
    85ca:	4663      	mov	r3, ip
    85cc:	105b      	asrs	r3, r3, #1
    85ce:	d300      	bcc.n	85d2 <__aeabi_idiv+0x1c2>
    85d0:	4240      	negs	r0, r0
    85d2:	b501      	push	{r0, lr}
    85d4:	2000      	movs	r0, #0
    85d6:	f000 f805 	bl	85e4 <__aeabi_idiv0>
    85da:	bd02      	pop	{r1, pc}

000085dc <__aeabi_idivmod>:
    85dc:	2900      	cmp	r1, #0
    85de:	d0f8      	beq.n	85d2 <__aeabi_idiv+0x1c2>
    85e0:	e716      	b.n	8410 <__aeabi_idiv>
    85e2:	4770      	bx	lr

000085e4 <__aeabi_idiv0>:
    85e4:	4770      	bx	lr
    85e6:	46c0      	nop			; (mov r8, r8)

000085e8 <__aeabi_lmul>:
    85e8:	b5f0      	push	{r4, r5, r6, r7, lr}
    85ea:	464f      	mov	r7, r9
    85ec:	4646      	mov	r6, r8
    85ee:	b4c0      	push	{r6, r7}
    85f0:	0416      	lsls	r6, r2, #16
    85f2:	0c36      	lsrs	r6, r6, #16
    85f4:	4699      	mov	r9, r3
    85f6:	0033      	movs	r3, r6
    85f8:	0405      	lsls	r5, r0, #16
    85fa:	0c2c      	lsrs	r4, r5, #16
    85fc:	0c07      	lsrs	r7, r0, #16
    85fe:	0c15      	lsrs	r5, r2, #16
    8600:	4363      	muls	r3, r4
    8602:	437e      	muls	r6, r7
    8604:	436f      	muls	r7, r5
    8606:	4365      	muls	r5, r4
    8608:	0c1c      	lsrs	r4, r3, #16
    860a:	19ad      	adds	r5, r5, r6
    860c:	1964      	adds	r4, r4, r5
    860e:	469c      	mov	ip, r3
    8610:	42a6      	cmp	r6, r4
    8612:	d903      	bls.n	861c <__aeabi_lmul+0x34>
    8614:	2380      	movs	r3, #128	; 0x80
    8616:	025b      	lsls	r3, r3, #9
    8618:	4698      	mov	r8, r3
    861a:	4447      	add	r7, r8
    861c:	4663      	mov	r3, ip
    861e:	0c25      	lsrs	r5, r4, #16
    8620:	19ef      	adds	r7, r5, r7
    8622:	041d      	lsls	r5, r3, #16
    8624:	464b      	mov	r3, r9
    8626:	434a      	muls	r2, r1
    8628:	4343      	muls	r3, r0
    862a:	0c2d      	lsrs	r5, r5, #16
    862c:	0424      	lsls	r4, r4, #16
    862e:	1964      	adds	r4, r4, r5
    8630:	1899      	adds	r1, r3, r2
    8632:	19c9      	adds	r1, r1, r7
    8634:	0020      	movs	r0, r4
    8636:	bc0c      	pop	{r2, r3}
    8638:	4690      	mov	r8, r2
    863a:	4699      	mov	r9, r3
    863c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    863e:	46c0      	nop			; (mov r8, r8)

00008640 <atoi>:
    8640:	b510      	push	{r4, lr}
    8642:	220a      	movs	r2, #10
    8644:	2100      	movs	r1, #0
    8646:	f000 fb7b 	bl	8d40 <strtol>
    864a:	bd10      	pop	{r4, pc}

0000864c <__libc_init_array>:
    864c:	4b0e      	ldr	r3, [pc, #56]	; (8688 <__libc_init_array+0x3c>)
    864e:	b570      	push	{r4, r5, r6, lr}
    8650:	2500      	movs	r5, #0
    8652:	001e      	movs	r6, r3
    8654:	4c0d      	ldr	r4, [pc, #52]	; (868c <__libc_init_array+0x40>)
    8656:	1ae4      	subs	r4, r4, r3
    8658:	10a4      	asrs	r4, r4, #2
    865a:	42a5      	cmp	r5, r4
    865c:	d004      	beq.n	8668 <__libc_init_array+0x1c>
    865e:	00ab      	lsls	r3, r5, #2
    8660:	58f3      	ldr	r3, [r6, r3]
    8662:	4798      	blx	r3
    8664:	3501      	adds	r5, #1
    8666:	e7f8      	b.n	865a <__libc_init_array+0xe>
    8668:	f003 f88a 	bl	b780 <_init>
    866c:	4b08      	ldr	r3, [pc, #32]	; (8690 <__libc_init_array+0x44>)
    866e:	2500      	movs	r5, #0
    8670:	001e      	movs	r6, r3
    8672:	4c08      	ldr	r4, [pc, #32]	; (8694 <__libc_init_array+0x48>)
    8674:	1ae4      	subs	r4, r4, r3
    8676:	10a4      	asrs	r4, r4, #2
    8678:	42a5      	cmp	r5, r4
    867a:	d004      	beq.n	8686 <__libc_init_array+0x3a>
    867c:	00ab      	lsls	r3, r5, #2
    867e:	58f3      	ldr	r3, [r6, r3]
    8680:	4798      	blx	r3
    8682:	3501      	adds	r5, #1
    8684:	e7f8      	b.n	8678 <__libc_init_array+0x2c>
    8686:	bd70      	pop	{r4, r5, r6, pc}
    8688:	0000b78c 	.word	0x0000b78c
    868c:	0000b78c 	.word	0x0000b78c
    8690:	0000b78c 	.word	0x0000b78c
    8694:	0000b790 	.word	0x0000b790

00008698 <malloc>:
    8698:	b510      	push	{r4, lr}
    869a:	4b03      	ldr	r3, [pc, #12]	; (86a8 <malloc+0x10>)
    869c:	0001      	movs	r1, r0
    869e:	6818      	ldr	r0, [r3, #0]
    86a0:	f000 f87a 	bl	8798 <_malloc_r>
    86a4:	bd10      	pop	{r4, pc}
    86a6:	46c0      	nop			; (mov r8, r8)
    86a8:	20000090 	.word	0x20000090

000086ac <free>:
    86ac:	b510      	push	{r4, lr}
    86ae:	4b03      	ldr	r3, [pc, #12]	; (86bc <free+0x10>)
    86b0:	0001      	movs	r1, r0
    86b2:	6818      	ldr	r0, [r3, #0]
    86b4:	f000 f82a 	bl	870c <_free_r>
    86b8:	bd10      	pop	{r4, pc}
    86ba:	46c0      	nop			; (mov r8, r8)
    86bc:	20000090 	.word	0x20000090

000086c0 <memcpy>:
    86c0:	2300      	movs	r3, #0
    86c2:	b510      	push	{r4, lr}
    86c4:	429a      	cmp	r2, r3
    86c6:	d003      	beq.n	86d0 <memcpy+0x10>
    86c8:	5ccc      	ldrb	r4, [r1, r3]
    86ca:	54c4      	strb	r4, [r0, r3]
    86cc:	3301      	adds	r3, #1
    86ce:	e7f9      	b.n	86c4 <memcpy+0x4>
    86d0:	bd10      	pop	{r4, pc}

000086d2 <memmove>:
    86d2:	b510      	push	{r4, lr}
    86d4:	4288      	cmp	r0, r1
    86d6:	d902      	bls.n	86de <memmove+0xc>
    86d8:	188b      	adds	r3, r1, r2
    86da:	4298      	cmp	r0, r3
    86dc:	d301      	bcc.n	86e2 <memmove+0x10>
    86de:	2300      	movs	r3, #0
    86e0:	e005      	b.n	86ee <memmove+0x1c>
    86e2:	1a9b      	subs	r3, r3, r2
    86e4:	3a01      	subs	r2, #1
    86e6:	d308      	bcc.n	86fa <memmove+0x28>
    86e8:	5c99      	ldrb	r1, [r3, r2]
    86ea:	5481      	strb	r1, [r0, r2]
    86ec:	e7fa      	b.n	86e4 <memmove+0x12>
    86ee:	4293      	cmp	r3, r2
    86f0:	d003      	beq.n	86fa <memmove+0x28>
    86f2:	5ccc      	ldrb	r4, [r1, r3]
    86f4:	54c4      	strb	r4, [r0, r3]
    86f6:	3301      	adds	r3, #1
    86f8:	e7f9      	b.n	86ee <memmove+0x1c>
    86fa:	bd10      	pop	{r4, pc}

000086fc <memset>:
    86fc:	0003      	movs	r3, r0
    86fe:	1882      	adds	r2, r0, r2
    8700:	4293      	cmp	r3, r2
    8702:	d002      	beq.n	870a <memset+0xe>
    8704:	7019      	strb	r1, [r3, #0]
    8706:	3301      	adds	r3, #1
    8708:	e7fa      	b.n	8700 <memset+0x4>
    870a:	4770      	bx	lr

0000870c <_free_r>:
    870c:	b530      	push	{r4, r5, lr}
    870e:	2900      	cmp	r1, #0
    8710:	d03e      	beq.n	8790 <_free_r+0x84>
    8712:	3904      	subs	r1, #4
    8714:	680b      	ldr	r3, [r1, #0]
    8716:	2b00      	cmp	r3, #0
    8718:	da00      	bge.n	871c <_free_r+0x10>
    871a:	18c9      	adds	r1, r1, r3
    871c:	4a1d      	ldr	r2, [pc, #116]	; (8794 <_free_r+0x88>)
    871e:	6813      	ldr	r3, [r2, #0]
    8720:	0014      	movs	r4, r2
    8722:	2b00      	cmp	r3, #0
    8724:	d102      	bne.n	872c <_free_r+0x20>
    8726:	604b      	str	r3, [r1, #4]
    8728:	6011      	str	r1, [r2, #0]
    872a:	e031      	b.n	8790 <_free_r+0x84>
    872c:	428b      	cmp	r3, r1
    872e:	d90d      	bls.n	874c <_free_r+0x40>
    8730:	680a      	ldr	r2, [r1, #0]
    8732:	1888      	adds	r0, r1, r2
    8734:	4283      	cmp	r3, r0
    8736:	d103      	bne.n	8740 <_free_r+0x34>
    8738:	6818      	ldr	r0, [r3, #0]
    873a:	685b      	ldr	r3, [r3, #4]
    873c:	1882      	adds	r2, r0, r2
    873e:	600a      	str	r2, [r1, #0]
    8740:	604b      	str	r3, [r1, #4]
    8742:	6021      	str	r1, [r4, #0]
    8744:	e024      	b.n	8790 <_free_r+0x84>
    8746:	428a      	cmp	r2, r1
    8748:	d803      	bhi.n	8752 <_free_r+0x46>
    874a:	0013      	movs	r3, r2
    874c:	685a      	ldr	r2, [r3, #4]
    874e:	2a00      	cmp	r2, #0
    8750:	d1f9      	bne.n	8746 <_free_r+0x3a>
    8752:	681d      	ldr	r5, [r3, #0]
    8754:	195c      	adds	r4, r3, r5
    8756:	428c      	cmp	r4, r1
    8758:	d10b      	bne.n	8772 <_free_r+0x66>
    875a:	6809      	ldr	r1, [r1, #0]
    875c:	1869      	adds	r1, r5, r1
    875e:	1858      	adds	r0, r3, r1
    8760:	6019      	str	r1, [r3, #0]
    8762:	4282      	cmp	r2, r0
    8764:	d114      	bne.n	8790 <_free_r+0x84>
    8766:	6810      	ldr	r0, [r2, #0]
    8768:	6852      	ldr	r2, [r2, #4]
    876a:	1841      	adds	r1, r0, r1
    876c:	6019      	str	r1, [r3, #0]
    876e:	605a      	str	r2, [r3, #4]
    8770:	e00e      	b.n	8790 <_free_r+0x84>
    8772:	428c      	cmp	r4, r1
    8774:	d902      	bls.n	877c <_free_r+0x70>
    8776:	230c      	movs	r3, #12
    8778:	6003      	str	r3, [r0, #0]
    877a:	e009      	b.n	8790 <_free_r+0x84>
    877c:	6808      	ldr	r0, [r1, #0]
    877e:	180c      	adds	r4, r1, r0
    8780:	42a2      	cmp	r2, r4
    8782:	d103      	bne.n	878c <_free_r+0x80>
    8784:	6814      	ldr	r4, [r2, #0]
    8786:	6852      	ldr	r2, [r2, #4]
    8788:	1820      	adds	r0, r4, r0
    878a:	6008      	str	r0, [r1, #0]
    878c:	604a      	str	r2, [r1, #4]
    878e:	6059      	str	r1, [r3, #4]
    8790:	bd30      	pop	{r4, r5, pc}
    8792:	46c0      	nop			; (mov r8, r8)
    8794:	200001f0 	.word	0x200001f0

00008798 <_malloc_r>:
    8798:	2303      	movs	r3, #3
    879a:	b570      	push	{r4, r5, r6, lr}
    879c:	1ccd      	adds	r5, r1, #3
    879e:	439d      	bics	r5, r3
    87a0:	3508      	adds	r5, #8
    87a2:	0006      	movs	r6, r0
    87a4:	2d0c      	cmp	r5, #12
    87a6:	d201      	bcs.n	87ac <_malloc_r+0x14>
    87a8:	250c      	movs	r5, #12
    87aa:	e005      	b.n	87b8 <_malloc_r+0x20>
    87ac:	2d00      	cmp	r5, #0
    87ae:	da03      	bge.n	87b8 <_malloc_r+0x20>
    87b0:	230c      	movs	r3, #12
    87b2:	2000      	movs	r0, #0
    87b4:	6033      	str	r3, [r6, #0]
    87b6:	e040      	b.n	883a <_malloc_r+0xa2>
    87b8:	42a9      	cmp	r1, r5
    87ba:	d8f9      	bhi.n	87b0 <_malloc_r+0x18>
    87bc:	4b1f      	ldr	r3, [pc, #124]	; (883c <_malloc_r+0xa4>)
    87be:	681c      	ldr	r4, [r3, #0]
    87c0:	001a      	movs	r2, r3
    87c2:	0021      	movs	r1, r4
    87c4:	2900      	cmp	r1, #0
    87c6:	d013      	beq.n	87f0 <_malloc_r+0x58>
    87c8:	680b      	ldr	r3, [r1, #0]
    87ca:	1b5b      	subs	r3, r3, r5
    87cc:	d40d      	bmi.n	87ea <_malloc_r+0x52>
    87ce:	2b0b      	cmp	r3, #11
    87d0:	d902      	bls.n	87d8 <_malloc_r+0x40>
    87d2:	600b      	str	r3, [r1, #0]
    87d4:	18cc      	adds	r4, r1, r3
    87d6:	e01e      	b.n	8816 <_malloc_r+0x7e>
    87d8:	428c      	cmp	r4, r1
    87da:	d102      	bne.n	87e2 <_malloc_r+0x4a>
    87dc:	6863      	ldr	r3, [r4, #4]
    87de:	6013      	str	r3, [r2, #0]
    87e0:	e01a      	b.n	8818 <_malloc_r+0x80>
    87e2:	684b      	ldr	r3, [r1, #4]
    87e4:	6063      	str	r3, [r4, #4]
    87e6:	000c      	movs	r4, r1
    87e8:	e016      	b.n	8818 <_malloc_r+0x80>
    87ea:	000c      	movs	r4, r1
    87ec:	6849      	ldr	r1, [r1, #4]
    87ee:	e7e9      	b.n	87c4 <_malloc_r+0x2c>
    87f0:	4c13      	ldr	r4, [pc, #76]	; (8840 <_malloc_r+0xa8>)
    87f2:	6823      	ldr	r3, [r4, #0]
    87f4:	2b00      	cmp	r3, #0
    87f6:	d103      	bne.n	8800 <_malloc_r+0x68>
    87f8:	0030      	movs	r0, r6
    87fa:	f000 f8bd 	bl	8978 <_sbrk_r>
    87fe:	6020      	str	r0, [r4, #0]
    8800:	0029      	movs	r1, r5
    8802:	0030      	movs	r0, r6
    8804:	f000 f8b8 	bl	8978 <_sbrk_r>
    8808:	1c43      	adds	r3, r0, #1
    880a:	d0d1      	beq.n	87b0 <_malloc_r+0x18>
    880c:	2303      	movs	r3, #3
    880e:	1cc4      	adds	r4, r0, #3
    8810:	439c      	bics	r4, r3
    8812:	42a0      	cmp	r0, r4
    8814:	d10a      	bne.n	882c <_malloc_r+0x94>
    8816:	6025      	str	r5, [r4, #0]
    8818:	0020      	movs	r0, r4
    881a:	2207      	movs	r2, #7
    881c:	300b      	adds	r0, #11
    881e:	1d23      	adds	r3, r4, #4
    8820:	4390      	bics	r0, r2
    8822:	1ac3      	subs	r3, r0, r3
    8824:	d009      	beq.n	883a <_malloc_r+0xa2>
    8826:	425a      	negs	r2, r3
    8828:	50e2      	str	r2, [r4, r3]
    882a:	e006      	b.n	883a <_malloc_r+0xa2>
    882c:	1a21      	subs	r1, r4, r0
    882e:	0030      	movs	r0, r6
    8830:	f000 f8a2 	bl	8978 <_sbrk_r>
    8834:	1c43      	adds	r3, r0, #1
    8836:	d1ee      	bne.n	8816 <_malloc_r+0x7e>
    8838:	e7ba      	b.n	87b0 <_malloc_r+0x18>
    883a:	bd70      	pop	{r4, r5, r6, pc}
    883c:	200001f0 	.word	0x200001f0
    8840:	200001ec 	.word	0x200001ec

00008844 <iprintf>:
    8844:	b40f      	push	{r0, r1, r2, r3}
    8846:	4b0b      	ldr	r3, [pc, #44]	; (8874 <iprintf+0x30>)
    8848:	b513      	push	{r0, r1, r4, lr}
    884a:	681c      	ldr	r4, [r3, #0]
    884c:	2c00      	cmp	r4, #0
    884e:	d005      	beq.n	885c <iprintf+0x18>
    8850:	69a3      	ldr	r3, [r4, #24]
    8852:	2b00      	cmp	r3, #0
    8854:	d102      	bne.n	885c <iprintf+0x18>
    8856:	0020      	movs	r0, r4
    8858:	f000 fc40 	bl	90dc <__sinit>
    885c:	ab05      	add	r3, sp, #20
    885e:	9a04      	ldr	r2, [sp, #16]
    8860:	68a1      	ldr	r1, [r4, #8]
    8862:	0020      	movs	r0, r4
    8864:	9301      	str	r3, [sp, #4]
    8866:	f000 feb9 	bl	95dc <_vfiprintf_r>
    886a:	bc16      	pop	{r1, r2, r4}
    886c:	bc08      	pop	{r3}
    886e:	b004      	add	sp, #16
    8870:	4718      	bx	r3
    8872:	46c0      	nop			; (mov r8, r8)
    8874:	20000090 	.word	0x20000090

00008878 <putchar>:
    8878:	4b08      	ldr	r3, [pc, #32]	; (889c <putchar+0x24>)
    887a:	b570      	push	{r4, r5, r6, lr}
    887c:	681c      	ldr	r4, [r3, #0]
    887e:	0005      	movs	r5, r0
    8880:	2c00      	cmp	r4, #0
    8882:	d005      	beq.n	8890 <putchar+0x18>
    8884:	69a3      	ldr	r3, [r4, #24]
    8886:	2b00      	cmp	r3, #0
    8888:	d102      	bne.n	8890 <putchar+0x18>
    888a:	0020      	movs	r0, r4
    888c:	f000 fc26 	bl	90dc <__sinit>
    8890:	0029      	movs	r1, r5
    8892:	68a2      	ldr	r2, [r4, #8]
    8894:	0020      	movs	r0, r4
    8896:	f001 f94d 	bl	9b34 <_putc_r>
    889a:	bd70      	pop	{r4, r5, r6, pc}
    889c:	20000090 	.word	0x20000090

000088a0 <_puts_r>:
    88a0:	b570      	push	{r4, r5, r6, lr}
    88a2:	0005      	movs	r5, r0
    88a4:	000e      	movs	r6, r1
    88a6:	2800      	cmp	r0, #0
    88a8:	d004      	beq.n	88b4 <_puts_r+0x14>
    88aa:	6983      	ldr	r3, [r0, #24]
    88ac:	2b00      	cmp	r3, #0
    88ae:	d101      	bne.n	88b4 <_puts_r+0x14>
    88b0:	f000 fc14 	bl	90dc <__sinit>
    88b4:	69ab      	ldr	r3, [r5, #24]
    88b6:	68ac      	ldr	r4, [r5, #8]
    88b8:	2b00      	cmp	r3, #0
    88ba:	d102      	bne.n	88c2 <_puts_r+0x22>
    88bc:	0028      	movs	r0, r5
    88be:	f000 fc0d 	bl	90dc <__sinit>
    88c2:	4b25      	ldr	r3, [pc, #148]	; (8958 <_puts_r+0xb8>)
    88c4:	429c      	cmp	r4, r3
    88c6:	d101      	bne.n	88cc <_puts_r+0x2c>
    88c8:	686c      	ldr	r4, [r5, #4]
    88ca:	e008      	b.n	88de <_puts_r+0x3e>
    88cc:	4b23      	ldr	r3, [pc, #140]	; (895c <_puts_r+0xbc>)
    88ce:	429c      	cmp	r4, r3
    88d0:	d101      	bne.n	88d6 <_puts_r+0x36>
    88d2:	68ac      	ldr	r4, [r5, #8]
    88d4:	e003      	b.n	88de <_puts_r+0x3e>
    88d6:	4b22      	ldr	r3, [pc, #136]	; (8960 <_puts_r+0xc0>)
    88d8:	429c      	cmp	r4, r3
    88da:	d100      	bne.n	88de <_puts_r+0x3e>
    88dc:	68ec      	ldr	r4, [r5, #12]
    88de:	89a3      	ldrh	r3, [r4, #12]
    88e0:	071b      	lsls	r3, r3, #28
    88e2:	d502      	bpl.n	88ea <_puts_r+0x4a>
    88e4:	6923      	ldr	r3, [r4, #16]
    88e6:	2b00      	cmp	r3, #0
    88e8:	d111      	bne.n	890e <_puts_r+0x6e>
    88ea:	0021      	movs	r1, r4
    88ec:	0028      	movs	r0, r5
    88ee:	f000 fa8b 	bl	8e08 <__swsetup_r>
    88f2:	2800      	cmp	r0, #0
    88f4:	d00b      	beq.n	890e <_puts_r+0x6e>
    88f6:	2001      	movs	r0, #1
    88f8:	4240      	negs	r0, r0
    88fa:	e02b      	b.n	8954 <_puts_r+0xb4>
    88fc:	3b01      	subs	r3, #1
    88fe:	3601      	adds	r6, #1
    8900:	60a3      	str	r3, [r4, #8]
    8902:	2b00      	cmp	r3, #0
    8904:	db08      	blt.n	8918 <_puts_r+0x78>
    8906:	6823      	ldr	r3, [r4, #0]
    8908:	1c5a      	adds	r2, r3, #1
    890a:	6022      	str	r2, [r4, #0]
    890c:	7019      	strb	r1, [r3, #0]
    890e:	7831      	ldrb	r1, [r6, #0]
    8910:	68a3      	ldr	r3, [r4, #8]
    8912:	2900      	cmp	r1, #0
    8914:	d1f2      	bne.n	88fc <_puts_r+0x5c>
    8916:	e00b      	b.n	8930 <_puts_r+0x90>
    8918:	69a2      	ldr	r2, [r4, #24]
    891a:	4293      	cmp	r3, r2
    891c:	db01      	blt.n	8922 <_puts_r+0x82>
    891e:	290a      	cmp	r1, #10
    8920:	d1f1      	bne.n	8906 <_puts_r+0x66>
    8922:	0022      	movs	r2, r4
    8924:	0028      	movs	r0, r5
    8926:	f000 fa17 	bl	8d58 <__swbuf_r>
    892a:	1c43      	adds	r3, r0, #1
    892c:	d1ef      	bne.n	890e <_puts_r+0x6e>
    892e:	e7e2      	b.n	88f6 <_puts_r+0x56>
    8930:	3b01      	subs	r3, #1
    8932:	60a3      	str	r3, [r4, #8]
    8934:	2b00      	cmp	r3, #0
    8936:	da08      	bge.n	894a <_puts_r+0xaa>
    8938:	0022      	movs	r2, r4
    893a:	310a      	adds	r1, #10
    893c:	0028      	movs	r0, r5
    893e:	f000 fa0b 	bl	8d58 <__swbuf_r>
    8942:	1c43      	adds	r3, r0, #1
    8944:	d0d7      	beq.n	88f6 <_puts_r+0x56>
    8946:	200a      	movs	r0, #10
    8948:	e004      	b.n	8954 <_puts_r+0xb4>
    894a:	200a      	movs	r0, #10
    894c:	6823      	ldr	r3, [r4, #0]
    894e:	1c5a      	adds	r2, r3, #1
    8950:	6022      	str	r2, [r4, #0]
    8952:	7018      	strb	r0, [r3, #0]
    8954:	bd70      	pop	{r4, r5, r6, pc}
    8956:	46c0      	nop			; (mov r8, r8)
    8958:	0000b6ec 	.word	0x0000b6ec
    895c:	0000b70c 	.word	0x0000b70c
    8960:	0000b72c 	.word	0x0000b72c

00008964 <puts>:
    8964:	b510      	push	{r4, lr}
    8966:	4b03      	ldr	r3, [pc, #12]	; (8974 <puts+0x10>)
    8968:	0001      	movs	r1, r0
    896a:	6818      	ldr	r0, [r3, #0]
    896c:	f7ff ff98 	bl	88a0 <_puts_r>
    8970:	bd10      	pop	{r4, pc}
    8972:	46c0      	nop			; (mov r8, r8)
    8974:	20000090 	.word	0x20000090

00008978 <_sbrk_r>:
    8978:	2300      	movs	r3, #0
    897a:	b570      	push	{r4, r5, r6, lr}
    897c:	4c06      	ldr	r4, [pc, #24]	; (8998 <_sbrk_r+0x20>)
    897e:	0005      	movs	r5, r0
    8980:	0008      	movs	r0, r1
    8982:	6023      	str	r3, [r4, #0]
    8984:	f7fd fea2 	bl	66cc <_sbrk>
    8988:	1c43      	adds	r3, r0, #1
    898a:	d103      	bne.n	8994 <_sbrk_r+0x1c>
    898c:	6823      	ldr	r3, [r4, #0]
    898e:	2b00      	cmp	r3, #0
    8990:	d000      	beq.n	8994 <_sbrk_r+0x1c>
    8992:	602b      	str	r3, [r5, #0]
    8994:	bd70      	pop	{r4, r5, r6, pc}
    8996:	46c0      	nop			; (mov r8, r8)
    8998:	200004ec 	.word	0x200004ec

0000899c <setbuf>:
    899c:	424a      	negs	r2, r1
    899e:	414a      	adcs	r2, r1
    89a0:	2380      	movs	r3, #128	; 0x80
    89a2:	b510      	push	{r4, lr}
    89a4:	0052      	lsls	r2, r2, #1
    89a6:	00db      	lsls	r3, r3, #3
    89a8:	f000 f802 	bl	89b0 <setvbuf>
    89ac:	bd10      	pop	{r4, pc}
	...

000089b0 <setvbuf>:
    89b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    89b2:	001d      	movs	r5, r3
    89b4:	4b51      	ldr	r3, [pc, #324]	; (8afc <setvbuf+0x14c>)
    89b6:	b085      	sub	sp, #20
    89b8:	681e      	ldr	r6, [r3, #0]
    89ba:	0004      	movs	r4, r0
    89bc:	000f      	movs	r7, r1
    89be:	9200      	str	r2, [sp, #0]
    89c0:	2e00      	cmp	r6, #0
    89c2:	d005      	beq.n	89d0 <setvbuf+0x20>
    89c4:	69b3      	ldr	r3, [r6, #24]
    89c6:	2b00      	cmp	r3, #0
    89c8:	d102      	bne.n	89d0 <setvbuf+0x20>
    89ca:	0030      	movs	r0, r6
    89cc:	f000 fb86 	bl	90dc <__sinit>
    89d0:	4b4b      	ldr	r3, [pc, #300]	; (8b00 <setvbuf+0x150>)
    89d2:	429c      	cmp	r4, r3
    89d4:	d101      	bne.n	89da <setvbuf+0x2a>
    89d6:	6874      	ldr	r4, [r6, #4]
    89d8:	e008      	b.n	89ec <setvbuf+0x3c>
    89da:	4b4a      	ldr	r3, [pc, #296]	; (8b04 <setvbuf+0x154>)
    89dc:	429c      	cmp	r4, r3
    89de:	d101      	bne.n	89e4 <setvbuf+0x34>
    89e0:	68b4      	ldr	r4, [r6, #8]
    89e2:	e003      	b.n	89ec <setvbuf+0x3c>
    89e4:	4b48      	ldr	r3, [pc, #288]	; (8b08 <setvbuf+0x158>)
    89e6:	429c      	cmp	r4, r3
    89e8:	d100      	bne.n	89ec <setvbuf+0x3c>
    89ea:	68f4      	ldr	r4, [r6, #12]
    89ec:	9b00      	ldr	r3, [sp, #0]
    89ee:	2b02      	cmp	r3, #2
    89f0:	d005      	beq.n	89fe <setvbuf+0x4e>
    89f2:	2b01      	cmp	r3, #1
    89f4:	d900      	bls.n	89f8 <setvbuf+0x48>
    89f6:	e07c      	b.n	8af2 <setvbuf+0x142>
    89f8:	2d00      	cmp	r5, #0
    89fa:	da00      	bge.n	89fe <setvbuf+0x4e>
    89fc:	e079      	b.n	8af2 <setvbuf+0x142>
    89fe:	0021      	movs	r1, r4
    8a00:	0030      	movs	r0, r6
    8a02:	f000 fafd 	bl	9000 <_fflush_r>
    8a06:	6b61      	ldr	r1, [r4, #52]	; 0x34
    8a08:	2900      	cmp	r1, #0
    8a0a:	d008      	beq.n	8a1e <setvbuf+0x6e>
    8a0c:	0023      	movs	r3, r4
    8a0e:	3344      	adds	r3, #68	; 0x44
    8a10:	4299      	cmp	r1, r3
    8a12:	d002      	beq.n	8a1a <setvbuf+0x6a>
    8a14:	0030      	movs	r0, r6
    8a16:	f7ff fe79 	bl	870c <_free_r>
    8a1a:	2300      	movs	r3, #0
    8a1c:	6363      	str	r3, [r4, #52]	; 0x34
    8a1e:	2300      	movs	r3, #0
    8a20:	61a3      	str	r3, [r4, #24]
    8a22:	6063      	str	r3, [r4, #4]
    8a24:	89a3      	ldrh	r3, [r4, #12]
    8a26:	061b      	lsls	r3, r3, #24
    8a28:	d503      	bpl.n	8a32 <setvbuf+0x82>
    8a2a:	6921      	ldr	r1, [r4, #16]
    8a2c:	0030      	movs	r0, r6
    8a2e:	f7ff fe6d 	bl	870c <_free_r>
    8a32:	89a2      	ldrh	r2, [r4, #12]
    8a34:	4b35      	ldr	r3, [pc, #212]	; (8b0c <setvbuf+0x15c>)
    8a36:	4013      	ands	r3, r2
    8a38:	81a3      	strh	r3, [r4, #12]
    8a3a:	9b00      	ldr	r3, [sp, #0]
    8a3c:	2b02      	cmp	r3, #2
    8a3e:	d021      	beq.n	8a84 <setvbuf+0xd4>
    8a40:	ab03      	add	r3, sp, #12
    8a42:	aa02      	add	r2, sp, #8
    8a44:	0021      	movs	r1, r4
    8a46:	0030      	movs	r0, r6
    8a48:	f000 fbdc 	bl	9204 <__swhatbuf_r>
    8a4c:	89a3      	ldrh	r3, [r4, #12]
    8a4e:	4318      	orrs	r0, r3
    8a50:	81a0      	strh	r0, [r4, #12]
    8a52:	2d00      	cmp	r5, #0
    8a54:	d101      	bne.n	8a5a <setvbuf+0xaa>
    8a56:	9d02      	ldr	r5, [sp, #8]
    8a58:	e001      	b.n	8a5e <setvbuf+0xae>
    8a5a:	2f00      	cmp	r7, #0
    8a5c:	d125      	bne.n	8aaa <setvbuf+0xfa>
    8a5e:	0028      	movs	r0, r5
    8a60:	f7ff fe1a 	bl	8698 <malloc>
    8a64:	9501      	str	r5, [sp, #4]
    8a66:	1e07      	subs	r7, r0, #0
    8a68:	d11a      	bne.n	8aa0 <setvbuf+0xf0>
    8a6a:	9b02      	ldr	r3, [sp, #8]
    8a6c:	9301      	str	r3, [sp, #4]
    8a6e:	42ab      	cmp	r3, r5
    8a70:	d102      	bne.n	8a78 <setvbuf+0xc8>
    8a72:	2001      	movs	r0, #1
    8a74:	4240      	negs	r0, r0
    8a76:	e006      	b.n	8a86 <setvbuf+0xd6>
    8a78:	9801      	ldr	r0, [sp, #4]
    8a7a:	f7ff fe0d 	bl	8698 <malloc>
    8a7e:	1e07      	subs	r7, r0, #0
    8a80:	d10e      	bne.n	8aa0 <setvbuf+0xf0>
    8a82:	e7f6      	b.n	8a72 <setvbuf+0xc2>
    8a84:	2000      	movs	r0, #0
    8a86:	2202      	movs	r2, #2
    8a88:	89a3      	ldrh	r3, [r4, #12]
    8a8a:	4313      	orrs	r3, r2
    8a8c:	81a3      	strh	r3, [r4, #12]
    8a8e:	2300      	movs	r3, #0
    8a90:	60a3      	str	r3, [r4, #8]
    8a92:	0023      	movs	r3, r4
    8a94:	3347      	adds	r3, #71	; 0x47
    8a96:	6023      	str	r3, [r4, #0]
    8a98:	6123      	str	r3, [r4, #16]
    8a9a:	2301      	movs	r3, #1
    8a9c:	6163      	str	r3, [r4, #20]
    8a9e:	e02a      	b.n	8af6 <setvbuf+0x146>
    8aa0:	2280      	movs	r2, #128	; 0x80
    8aa2:	89a3      	ldrh	r3, [r4, #12]
    8aa4:	9d01      	ldr	r5, [sp, #4]
    8aa6:	4313      	orrs	r3, r2
    8aa8:	81a3      	strh	r3, [r4, #12]
    8aaa:	69b3      	ldr	r3, [r6, #24]
    8aac:	2b00      	cmp	r3, #0
    8aae:	d102      	bne.n	8ab6 <setvbuf+0x106>
    8ab0:	0030      	movs	r0, r6
    8ab2:	f000 fb13 	bl	90dc <__sinit>
    8ab6:	9b00      	ldr	r3, [sp, #0]
    8ab8:	2b01      	cmp	r3, #1
    8aba:	d103      	bne.n	8ac4 <setvbuf+0x114>
    8abc:	89a3      	ldrh	r3, [r4, #12]
    8abe:	9a00      	ldr	r2, [sp, #0]
    8ac0:	431a      	orrs	r2, r3
    8ac2:	81a2      	strh	r2, [r4, #12]
    8ac4:	2308      	movs	r3, #8
    8ac6:	89a2      	ldrh	r2, [r4, #12]
    8ac8:	6027      	str	r7, [r4, #0]
    8aca:	4013      	ands	r3, r2
    8acc:	6127      	str	r7, [r4, #16]
    8ace:	6165      	str	r5, [r4, #20]
    8ad0:	1e18      	subs	r0, r3, #0
    8ad2:	d00c      	beq.n	8aee <setvbuf+0x13e>
    8ad4:	2301      	movs	r3, #1
    8ad6:	401a      	ands	r2, r3
    8ad8:	2300      	movs	r3, #0
    8ada:	1e10      	subs	r0, r2, #0
    8adc:	4298      	cmp	r0, r3
    8ade:	d004      	beq.n	8aea <setvbuf+0x13a>
    8ae0:	426d      	negs	r5, r5
    8ae2:	60a3      	str	r3, [r4, #8]
    8ae4:	61a5      	str	r5, [r4, #24]
    8ae6:	0018      	movs	r0, r3
    8ae8:	e005      	b.n	8af6 <setvbuf+0x146>
    8aea:	60a5      	str	r5, [r4, #8]
    8aec:	e003      	b.n	8af6 <setvbuf+0x146>
    8aee:	60a3      	str	r3, [r4, #8]
    8af0:	e001      	b.n	8af6 <setvbuf+0x146>
    8af2:	2001      	movs	r0, #1
    8af4:	4240      	negs	r0, r0
    8af6:	b005      	add	sp, #20
    8af8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8afa:	46c0      	nop			; (mov r8, r8)
    8afc:	20000090 	.word	0x20000090
    8b00:	0000b6ec 	.word	0x0000b6ec
    8b04:	0000b70c 	.word	0x0000b70c
    8b08:	0000b72c 	.word	0x0000b72c
    8b0c:	fffff35c 	.word	0xfffff35c

00008b10 <siprintf>:
    8b10:	b40e      	push	{r1, r2, r3}
    8b12:	b510      	push	{r4, lr}
    8b14:	b09d      	sub	sp, #116	; 0x74
    8b16:	a902      	add	r1, sp, #8
    8b18:	9002      	str	r0, [sp, #8]
    8b1a:	6108      	str	r0, [r1, #16]
    8b1c:	480b      	ldr	r0, [pc, #44]	; (8b4c <siprintf+0x3c>)
    8b1e:	2482      	movs	r4, #130	; 0x82
    8b20:	6088      	str	r0, [r1, #8]
    8b22:	6148      	str	r0, [r1, #20]
    8b24:	2001      	movs	r0, #1
    8b26:	4240      	negs	r0, r0
    8b28:	ab1f      	add	r3, sp, #124	; 0x7c
    8b2a:	81c8      	strh	r0, [r1, #14]
    8b2c:	4808      	ldr	r0, [pc, #32]	; (8b50 <siprintf+0x40>)
    8b2e:	cb04      	ldmia	r3!, {r2}
    8b30:	00a4      	lsls	r4, r4, #2
    8b32:	6800      	ldr	r0, [r0, #0]
    8b34:	9301      	str	r3, [sp, #4]
    8b36:	818c      	strh	r4, [r1, #12]
    8b38:	f000 fc2a 	bl	9390 <_svfiprintf_r>
    8b3c:	2300      	movs	r3, #0
    8b3e:	9a02      	ldr	r2, [sp, #8]
    8b40:	7013      	strb	r3, [r2, #0]
    8b42:	b01d      	add	sp, #116	; 0x74
    8b44:	bc10      	pop	{r4}
    8b46:	bc08      	pop	{r3}
    8b48:	b003      	add	sp, #12
    8b4a:	4718      	bx	r3
    8b4c:	7fffffff 	.word	0x7fffffff
    8b50:	20000090 	.word	0x20000090

00008b54 <strcmp>:
    8b54:	7802      	ldrb	r2, [r0, #0]
    8b56:	780b      	ldrb	r3, [r1, #0]
    8b58:	2a00      	cmp	r2, #0
    8b5a:	d003      	beq.n	8b64 <strcmp+0x10>
    8b5c:	3001      	adds	r0, #1
    8b5e:	3101      	adds	r1, #1
    8b60:	429a      	cmp	r2, r3
    8b62:	d0f7      	beq.n	8b54 <strcmp>
    8b64:	1ad0      	subs	r0, r2, r3
    8b66:	4770      	bx	lr

00008b68 <strcpy>:
    8b68:	1c03      	adds	r3, r0, #0
    8b6a:	780a      	ldrb	r2, [r1, #0]
    8b6c:	3101      	adds	r1, #1
    8b6e:	701a      	strb	r2, [r3, #0]
    8b70:	3301      	adds	r3, #1
    8b72:	2a00      	cmp	r2, #0
    8b74:	d1f9      	bne.n	8b6a <strcpy+0x2>
    8b76:	4770      	bx	lr

00008b78 <strdup>:
    8b78:	b510      	push	{r4, lr}
    8b7a:	4b03      	ldr	r3, [pc, #12]	; (8b88 <strdup+0x10>)
    8b7c:	0001      	movs	r1, r0
    8b7e:	6818      	ldr	r0, [r3, #0]
    8b80:	f000 f804 	bl	8b8c <_strdup_r>
    8b84:	bd10      	pop	{r4, pc}
    8b86:	46c0      	nop			; (mov r8, r8)
    8b88:	20000090 	.word	0x20000090

00008b8c <_strdup_r>:
    8b8c:	b570      	push	{r4, r5, r6, lr}
    8b8e:	0005      	movs	r5, r0
    8b90:	0008      	movs	r0, r1
    8b92:	000e      	movs	r6, r1
    8b94:	f000 f80d 	bl	8bb2 <strlen>
    8b98:	1c44      	adds	r4, r0, #1
    8b9a:	0021      	movs	r1, r4
    8b9c:	0028      	movs	r0, r5
    8b9e:	f7ff fdfb 	bl	8798 <_malloc_r>
    8ba2:	1e05      	subs	r5, r0, #0
    8ba4:	d003      	beq.n	8bae <_strdup_r+0x22>
    8ba6:	0022      	movs	r2, r4
    8ba8:	0031      	movs	r1, r6
    8baa:	f7ff fd89 	bl	86c0 <memcpy>
    8bae:	0028      	movs	r0, r5
    8bb0:	bd70      	pop	{r4, r5, r6, pc}

00008bb2 <strlen>:
    8bb2:	2300      	movs	r3, #0
    8bb4:	5cc2      	ldrb	r2, [r0, r3]
    8bb6:	3301      	adds	r3, #1
    8bb8:	2a00      	cmp	r2, #0
    8bba:	d1fb      	bne.n	8bb4 <strlen+0x2>
    8bbc:	1e58      	subs	r0, r3, #1
    8bbe:	4770      	bx	lr

00008bc0 <strncmp>:
    8bc0:	2300      	movs	r3, #0
    8bc2:	b530      	push	{r4, r5, lr}
    8bc4:	429a      	cmp	r2, r3
    8bc6:	d00b      	beq.n	8be0 <strncmp+0x20>
    8bc8:	3a01      	subs	r2, #1
    8bca:	5cc4      	ldrb	r4, [r0, r3]
    8bcc:	5ccd      	ldrb	r5, [r1, r3]
    8bce:	42ac      	cmp	r4, r5
    8bd0:	d105      	bne.n	8bde <strncmp+0x1e>
    8bd2:	429a      	cmp	r2, r3
    8bd4:	d002      	beq.n	8bdc <strncmp+0x1c>
    8bd6:	3301      	adds	r3, #1
    8bd8:	2c00      	cmp	r4, #0
    8bda:	d1f6      	bne.n	8bca <strncmp+0xa>
    8bdc:	0025      	movs	r5, r4
    8bde:	1b63      	subs	r3, r4, r5
    8be0:	0018      	movs	r0, r3
    8be2:	bd30      	pop	{r4, r5, pc}

00008be4 <strstr>:
    8be4:	b510      	push	{r4, lr}
    8be6:	7803      	ldrb	r3, [r0, #0]
    8be8:	0002      	movs	r2, r0
    8bea:	2b00      	cmp	r3, #0
    8bec:	d105      	bne.n	8bfa <strstr+0x16>
    8bee:	7809      	ldrb	r1, [r1, #0]
    8bf0:	0018      	movs	r0, r3
    8bf2:	2900      	cmp	r1, #0
    8bf4:	d00d      	beq.n	8c12 <strstr+0x2e>
    8bf6:	e00f      	b.n	8c18 <strstr+0x34>
    8bf8:	3201      	adds	r2, #1
    8bfa:	7813      	ldrb	r3, [r2, #0]
    8bfc:	2b00      	cmp	r3, #0
    8bfe:	d00a      	beq.n	8c16 <strstr+0x32>
    8c00:	2300      	movs	r3, #0
    8c02:	5cc8      	ldrb	r0, [r1, r3]
    8c04:	2800      	cmp	r0, #0
    8c06:	d004      	beq.n	8c12 <strstr+0x2e>
    8c08:	5cd4      	ldrb	r4, [r2, r3]
    8c0a:	4284      	cmp	r4, r0
    8c0c:	d1f4      	bne.n	8bf8 <strstr+0x14>
    8c0e:	3301      	adds	r3, #1
    8c10:	e7f7      	b.n	8c02 <strstr+0x1e>
    8c12:	0010      	movs	r0, r2
    8c14:	e000      	b.n	8c18 <strstr+0x34>
    8c16:	0018      	movs	r0, r3
    8c18:	bd10      	pop	{r4, pc}
	...

00008c1c <_strtol_r>:
    8c1c:	b5f0      	push	{r4, r5, r6, r7, lr}
    8c1e:	001e      	movs	r6, r3
    8c20:	4b45      	ldr	r3, [pc, #276]	; (8d38 <_strtol_r+0x11c>)
    8c22:	b087      	sub	sp, #28
    8c24:	681b      	ldr	r3, [r3, #0]
    8c26:	9201      	str	r2, [sp, #4]
    8c28:	9302      	str	r3, [sp, #8]
    8c2a:	2208      	movs	r2, #8
    8c2c:	000b      	movs	r3, r1
    8c2e:	9005      	str	r0, [sp, #20]
    8c30:	9103      	str	r1, [sp, #12]
    8c32:	781c      	ldrb	r4, [r3, #0]
    8c34:	9902      	ldr	r1, [sp, #8]
    8c36:	1c5d      	adds	r5, r3, #1
    8c38:	1909      	adds	r1, r1, r4
    8c3a:	7848      	ldrb	r0, [r1, #1]
    8c3c:	4010      	ands	r0, r2
    8c3e:	d001      	beq.n	8c44 <_strtol_r+0x28>
    8c40:	002b      	movs	r3, r5
    8c42:	e7f6      	b.n	8c32 <_strtol_r+0x16>
    8c44:	2c2d      	cmp	r4, #45	; 0x2d
    8c46:	d104      	bne.n	8c52 <_strtol_r+0x36>
    8c48:	1c9d      	adds	r5, r3, #2
    8c4a:	785c      	ldrb	r4, [r3, #1]
    8c4c:	2301      	movs	r3, #1
    8c4e:	9300      	str	r3, [sp, #0]
    8c50:	e004      	b.n	8c5c <_strtol_r+0x40>
    8c52:	9000      	str	r0, [sp, #0]
    8c54:	2c2b      	cmp	r4, #43	; 0x2b
    8c56:	d101      	bne.n	8c5c <_strtol_r+0x40>
    8c58:	785c      	ldrb	r4, [r3, #1]
    8c5a:	1c9d      	adds	r5, r3, #2
    8c5c:	2e00      	cmp	r6, #0
    8c5e:	d002      	beq.n	8c66 <_strtol_r+0x4a>
    8c60:	2e10      	cmp	r6, #16
    8c62:	d10a      	bne.n	8c7a <_strtol_r+0x5e>
    8c64:	e062      	b.n	8d2c <_strtol_r+0x110>
    8c66:	2c30      	cmp	r4, #48	; 0x30
    8c68:	d15e      	bne.n	8d28 <_strtol_r+0x10c>
    8c6a:	2220      	movs	r2, #32
    8c6c:	782b      	ldrb	r3, [r5, #0]
    8c6e:	4393      	bics	r3, r2
    8c70:	2b58      	cmp	r3, #88	; 0x58
    8c72:	d154      	bne.n	8d1e <_strtol_r+0x102>
    8c74:	2610      	movs	r6, #16
    8c76:	786c      	ldrb	r4, [r5, #1]
    8c78:	3502      	adds	r5, #2
    8c7a:	9f00      	ldr	r7, [sp, #0]
    8c7c:	0031      	movs	r1, r6
    8c7e:	1e7b      	subs	r3, r7, #1
    8c80:	419f      	sbcs	r7, r3
    8c82:	4b2e      	ldr	r3, [pc, #184]	; (8d3c <_strtol_r+0x120>)
    8c84:	18ff      	adds	r7, r7, r3
    8c86:	0038      	movs	r0, r7
    8c88:	f7ff fbbe 	bl	8408 <__aeabi_uidivmod>
    8c8c:	0038      	movs	r0, r7
    8c8e:	9104      	str	r1, [sp, #16]
    8c90:	0031      	movs	r1, r6
    8c92:	f7ff fb33 	bl	82fc <__aeabi_uidiv>
    8c96:	2300      	movs	r3, #0
    8c98:	2203      	movs	r2, #3
    8c9a:	0007      	movs	r7, r0
    8c9c:	4694      	mov	ip, r2
    8c9e:	0018      	movs	r0, r3
    8ca0:	9a02      	ldr	r2, [sp, #8]
    8ca2:	1912      	adds	r2, r2, r4
    8ca4:	7851      	ldrb	r1, [r2, #1]
    8ca6:	2204      	movs	r2, #4
    8ca8:	4211      	tst	r1, r2
    8caa:	d001      	beq.n	8cb0 <_strtol_r+0x94>
    8cac:	3c30      	subs	r4, #48	; 0x30
    8cae:	e007      	b.n	8cc0 <_strtol_r+0xa4>
    8cb0:	4662      	mov	r2, ip
    8cb2:	4011      	ands	r1, r2
    8cb4:	d017      	beq.n	8ce6 <_strtol_r+0xca>
    8cb6:	2237      	movs	r2, #55	; 0x37
    8cb8:	2901      	cmp	r1, #1
    8cba:	d000      	beq.n	8cbe <_strtol_r+0xa2>
    8cbc:	3220      	adds	r2, #32
    8cbe:	1aa4      	subs	r4, r4, r2
    8cc0:	42a6      	cmp	r6, r4
    8cc2:	dd10      	ble.n	8ce6 <_strtol_r+0xca>
    8cc4:	1c5a      	adds	r2, r3, #1
    8cc6:	d00b      	beq.n	8ce0 <_strtol_r+0xc4>
    8cc8:	42b8      	cmp	r0, r7
    8cca:	d807      	bhi.n	8cdc <_strtol_r+0xc0>
    8ccc:	d102      	bne.n	8cd4 <_strtol_r+0xb8>
    8cce:	9b04      	ldr	r3, [sp, #16]
    8cd0:	429c      	cmp	r4, r3
    8cd2:	dc03      	bgt.n	8cdc <_strtol_r+0xc0>
    8cd4:	4370      	muls	r0, r6
    8cd6:	2301      	movs	r3, #1
    8cd8:	1820      	adds	r0, r4, r0
    8cda:	e001      	b.n	8ce0 <_strtol_r+0xc4>
    8cdc:	2301      	movs	r3, #1
    8cde:	425b      	negs	r3, r3
    8ce0:	782c      	ldrb	r4, [r5, #0]
    8ce2:	3501      	adds	r5, #1
    8ce4:	e7dc      	b.n	8ca0 <_strtol_r+0x84>
    8ce6:	1c5a      	adds	r2, r3, #1
    8ce8:	d10b      	bne.n	8d02 <_strtol_r+0xe6>
    8cea:	9800      	ldr	r0, [sp, #0]
    8cec:	9a05      	ldr	r2, [sp, #20]
    8cee:	1e43      	subs	r3, r0, #1
    8cf0:	4198      	sbcs	r0, r3
    8cf2:	4b12      	ldr	r3, [pc, #72]	; (8d3c <_strtol_r+0x120>)
    8cf4:	18c0      	adds	r0, r0, r3
    8cf6:	2322      	movs	r3, #34	; 0x22
    8cf8:	6013      	str	r3, [r2, #0]
    8cfa:	9b01      	ldr	r3, [sp, #4]
    8cfc:	2b00      	cmp	r3, #0
    8cfe:	d10a      	bne.n	8d16 <_strtol_r+0xfa>
    8d00:	e017      	b.n	8d32 <_strtol_r+0x116>
    8d02:	9a00      	ldr	r2, [sp, #0]
    8d04:	2a00      	cmp	r2, #0
    8d06:	d000      	beq.n	8d0a <_strtol_r+0xee>
    8d08:	4240      	negs	r0, r0
    8d0a:	9a01      	ldr	r2, [sp, #4]
    8d0c:	2a00      	cmp	r2, #0
    8d0e:	d010      	beq.n	8d32 <_strtol_r+0x116>
    8d10:	9a03      	ldr	r2, [sp, #12]
    8d12:	2b00      	cmp	r3, #0
    8d14:	d000      	beq.n	8d18 <_strtol_r+0xfc>
    8d16:	1e6a      	subs	r2, r5, #1
    8d18:	9b01      	ldr	r3, [sp, #4]
    8d1a:	601a      	str	r2, [r3, #0]
    8d1c:	e009      	b.n	8d32 <_strtol_r+0x116>
    8d1e:	2430      	movs	r4, #48	; 0x30
    8d20:	2e00      	cmp	r6, #0
    8d22:	d1aa      	bne.n	8c7a <_strtol_r+0x5e>
    8d24:	2608      	movs	r6, #8
    8d26:	e7a8      	b.n	8c7a <_strtol_r+0x5e>
    8d28:	260a      	movs	r6, #10
    8d2a:	e7a6      	b.n	8c7a <_strtol_r+0x5e>
    8d2c:	2c30      	cmp	r4, #48	; 0x30
    8d2e:	d09c      	beq.n	8c6a <_strtol_r+0x4e>
    8d30:	e7a3      	b.n	8c7a <_strtol_r+0x5e>
    8d32:	b007      	add	sp, #28
    8d34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8d36:	46c0      	nop			; (mov r8, r8)
    8d38:	20000094 	.word	0x20000094
    8d3c:	7fffffff 	.word	0x7fffffff

00008d40 <strtol>:
    8d40:	b510      	push	{r4, lr}
    8d42:	0013      	movs	r3, r2
    8d44:	000a      	movs	r2, r1
    8d46:	0001      	movs	r1, r0
    8d48:	4802      	ldr	r0, [pc, #8]	; (8d54 <strtol+0x14>)
    8d4a:	6800      	ldr	r0, [r0, #0]
    8d4c:	f7ff ff66 	bl	8c1c <_strtol_r>
    8d50:	bd10      	pop	{r4, pc}
    8d52:	46c0      	nop			; (mov r8, r8)
    8d54:	20000090 	.word	0x20000090

00008d58 <__swbuf_r>:
    8d58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8d5a:	0005      	movs	r5, r0
    8d5c:	000f      	movs	r7, r1
    8d5e:	0014      	movs	r4, r2
    8d60:	2800      	cmp	r0, #0
    8d62:	d004      	beq.n	8d6e <__swbuf_r+0x16>
    8d64:	6983      	ldr	r3, [r0, #24]
    8d66:	2b00      	cmp	r3, #0
    8d68:	d101      	bne.n	8d6e <__swbuf_r+0x16>
    8d6a:	f000 f9b7 	bl	90dc <__sinit>
    8d6e:	4b23      	ldr	r3, [pc, #140]	; (8dfc <__swbuf_r+0xa4>)
    8d70:	429c      	cmp	r4, r3
    8d72:	d101      	bne.n	8d78 <__swbuf_r+0x20>
    8d74:	686c      	ldr	r4, [r5, #4]
    8d76:	e008      	b.n	8d8a <__swbuf_r+0x32>
    8d78:	4b21      	ldr	r3, [pc, #132]	; (8e00 <__swbuf_r+0xa8>)
    8d7a:	429c      	cmp	r4, r3
    8d7c:	d101      	bne.n	8d82 <__swbuf_r+0x2a>
    8d7e:	68ac      	ldr	r4, [r5, #8]
    8d80:	e003      	b.n	8d8a <__swbuf_r+0x32>
    8d82:	4b20      	ldr	r3, [pc, #128]	; (8e04 <__swbuf_r+0xac>)
    8d84:	429c      	cmp	r4, r3
    8d86:	d100      	bne.n	8d8a <__swbuf_r+0x32>
    8d88:	68ec      	ldr	r4, [r5, #12]
    8d8a:	69a3      	ldr	r3, [r4, #24]
    8d8c:	60a3      	str	r3, [r4, #8]
    8d8e:	89a3      	ldrh	r3, [r4, #12]
    8d90:	071b      	lsls	r3, r3, #28
    8d92:	d50a      	bpl.n	8daa <__swbuf_r+0x52>
    8d94:	6923      	ldr	r3, [r4, #16]
    8d96:	2b00      	cmp	r3, #0
    8d98:	d007      	beq.n	8daa <__swbuf_r+0x52>
    8d9a:	6823      	ldr	r3, [r4, #0]
    8d9c:	6922      	ldr	r2, [r4, #16]
    8d9e:	b2fe      	uxtb	r6, r7
    8da0:	1a98      	subs	r0, r3, r2
    8da2:	6963      	ldr	r3, [r4, #20]
    8da4:	4298      	cmp	r0, r3
    8da6:	db0f      	blt.n	8dc8 <__swbuf_r+0x70>
    8da8:	e008      	b.n	8dbc <__swbuf_r+0x64>
    8daa:	0021      	movs	r1, r4
    8dac:	0028      	movs	r0, r5
    8dae:	f000 f82b 	bl	8e08 <__swsetup_r>
    8db2:	2800      	cmp	r0, #0
    8db4:	d0f1      	beq.n	8d9a <__swbuf_r+0x42>
    8db6:	2001      	movs	r0, #1
    8db8:	4240      	negs	r0, r0
    8dba:	e01d      	b.n	8df8 <__swbuf_r+0xa0>
    8dbc:	0021      	movs	r1, r4
    8dbe:	0028      	movs	r0, r5
    8dc0:	f000 f91e 	bl	9000 <_fflush_r>
    8dc4:	2800      	cmp	r0, #0
    8dc6:	d1f6      	bne.n	8db6 <__swbuf_r+0x5e>
    8dc8:	68a3      	ldr	r3, [r4, #8]
    8dca:	3001      	adds	r0, #1
    8dcc:	3b01      	subs	r3, #1
    8dce:	60a3      	str	r3, [r4, #8]
    8dd0:	6823      	ldr	r3, [r4, #0]
    8dd2:	1c5a      	adds	r2, r3, #1
    8dd4:	6022      	str	r2, [r4, #0]
    8dd6:	701f      	strb	r7, [r3, #0]
    8dd8:	6963      	ldr	r3, [r4, #20]
    8dda:	4298      	cmp	r0, r3
    8ddc:	d005      	beq.n	8dea <__swbuf_r+0x92>
    8dde:	89a3      	ldrh	r3, [r4, #12]
    8de0:	0030      	movs	r0, r6
    8de2:	07db      	lsls	r3, r3, #31
    8de4:	d508      	bpl.n	8df8 <__swbuf_r+0xa0>
    8de6:	2e0a      	cmp	r6, #10
    8de8:	d106      	bne.n	8df8 <__swbuf_r+0xa0>
    8dea:	0021      	movs	r1, r4
    8dec:	0028      	movs	r0, r5
    8dee:	f000 f907 	bl	9000 <_fflush_r>
    8df2:	2800      	cmp	r0, #0
    8df4:	d1df      	bne.n	8db6 <__swbuf_r+0x5e>
    8df6:	0030      	movs	r0, r6
    8df8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    8dfa:	46c0      	nop			; (mov r8, r8)
    8dfc:	0000b6ec 	.word	0x0000b6ec
    8e00:	0000b70c 	.word	0x0000b70c
    8e04:	0000b72c 	.word	0x0000b72c

00008e08 <__swsetup_r>:
    8e08:	4b36      	ldr	r3, [pc, #216]	; (8ee4 <__swsetup_r+0xdc>)
    8e0a:	b570      	push	{r4, r5, r6, lr}
    8e0c:	681d      	ldr	r5, [r3, #0]
    8e0e:	0006      	movs	r6, r0
    8e10:	000c      	movs	r4, r1
    8e12:	2d00      	cmp	r5, #0
    8e14:	d005      	beq.n	8e22 <__swsetup_r+0x1a>
    8e16:	69ab      	ldr	r3, [r5, #24]
    8e18:	2b00      	cmp	r3, #0
    8e1a:	d102      	bne.n	8e22 <__swsetup_r+0x1a>
    8e1c:	0028      	movs	r0, r5
    8e1e:	f000 f95d 	bl	90dc <__sinit>
    8e22:	4b31      	ldr	r3, [pc, #196]	; (8ee8 <__swsetup_r+0xe0>)
    8e24:	429c      	cmp	r4, r3
    8e26:	d101      	bne.n	8e2c <__swsetup_r+0x24>
    8e28:	686c      	ldr	r4, [r5, #4]
    8e2a:	e008      	b.n	8e3e <__swsetup_r+0x36>
    8e2c:	4b2f      	ldr	r3, [pc, #188]	; (8eec <__swsetup_r+0xe4>)
    8e2e:	429c      	cmp	r4, r3
    8e30:	d101      	bne.n	8e36 <__swsetup_r+0x2e>
    8e32:	68ac      	ldr	r4, [r5, #8]
    8e34:	e003      	b.n	8e3e <__swsetup_r+0x36>
    8e36:	4b2e      	ldr	r3, [pc, #184]	; (8ef0 <__swsetup_r+0xe8>)
    8e38:	429c      	cmp	r4, r3
    8e3a:	d100      	bne.n	8e3e <__swsetup_r+0x36>
    8e3c:	68ec      	ldr	r4, [r5, #12]
    8e3e:	220c      	movs	r2, #12
    8e40:	5ea3      	ldrsh	r3, [r4, r2]
    8e42:	b29a      	uxth	r2, r3
    8e44:	0711      	lsls	r1, r2, #28
    8e46:	d423      	bmi.n	8e90 <__swsetup_r+0x88>
    8e48:	06d1      	lsls	r1, r2, #27
    8e4a:	d407      	bmi.n	8e5c <__swsetup_r+0x54>
    8e4c:	2209      	movs	r2, #9
    8e4e:	2001      	movs	r0, #1
    8e50:	6032      	str	r2, [r6, #0]
    8e52:	3237      	adds	r2, #55	; 0x37
    8e54:	4313      	orrs	r3, r2
    8e56:	81a3      	strh	r3, [r4, #12]
    8e58:	4240      	negs	r0, r0
    8e5a:	e042      	b.n	8ee2 <__swsetup_r+0xda>
    8e5c:	0753      	lsls	r3, r2, #29
    8e5e:	d513      	bpl.n	8e88 <__swsetup_r+0x80>
    8e60:	6b61      	ldr	r1, [r4, #52]	; 0x34
    8e62:	2900      	cmp	r1, #0
    8e64:	d008      	beq.n	8e78 <__swsetup_r+0x70>
    8e66:	0023      	movs	r3, r4
    8e68:	3344      	adds	r3, #68	; 0x44
    8e6a:	4299      	cmp	r1, r3
    8e6c:	d002      	beq.n	8e74 <__swsetup_r+0x6c>
    8e6e:	0030      	movs	r0, r6
    8e70:	f7ff fc4c 	bl	870c <_free_r>
    8e74:	2300      	movs	r3, #0
    8e76:	6363      	str	r3, [r4, #52]	; 0x34
    8e78:	2224      	movs	r2, #36	; 0x24
    8e7a:	89a3      	ldrh	r3, [r4, #12]
    8e7c:	4393      	bics	r3, r2
    8e7e:	81a3      	strh	r3, [r4, #12]
    8e80:	2300      	movs	r3, #0
    8e82:	6063      	str	r3, [r4, #4]
    8e84:	6923      	ldr	r3, [r4, #16]
    8e86:	6023      	str	r3, [r4, #0]
    8e88:	2208      	movs	r2, #8
    8e8a:	89a3      	ldrh	r3, [r4, #12]
    8e8c:	4313      	orrs	r3, r2
    8e8e:	81a3      	strh	r3, [r4, #12]
    8e90:	6923      	ldr	r3, [r4, #16]
    8e92:	2b00      	cmp	r3, #0
    8e94:	d10b      	bne.n	8eae <__swsetup_r+0xa6>
    8e96:	23a0      	movs	r3, #160	; 0xa0
    8e98:	89a2      	ldrh	r2, [r4, #12]
    8e9a:	009b      	lsls	r3, r3, #2
    8e9c:	4013      	ands	r3, r2
    8e9e:	2280      	movs	r2, #128	; 0x80
    8ea0:	0092      	lsls	r2, r2, #2
    8ea2:	4293      	cmp	r3, r2
    8ea4:	d003      	beq.n	8eae <__swsetup_r+0xa6>
    8ea6:	0021      	movs	r1, r4
    8ea8:	0030      	movs	r0, r6
    8eaa:	f000 f9d1 	bl	9250 <__smakebuf_r>
    8eae:	2301      	movs	r3, #1
    8eb0:	89a2      	ldrh	r2, [r4, #12]
    8eb2:	4013      	ands	r3, r2
    8eb4:	d005      	beq.n	8ec2 <__swsetup_r+0xba>
    8eb6:	2300      	movs	r3, #0
    8eb8:	60a3      	str	r3, [r4, #8]
    8eba:	6963      	ldr	r3, [r4, #20]
    8ebc:	425b      	negs	r3, r3
    8ebe:	61a3      	str	r3, [r4, #24]
    8ec0:	e003      	b.n	8eca <__swsetup_r+0xc2>
    8ec2:	0792      	lsls	r2, r2, #30
    8ec4:	d400      	bmi.n	8ec8 <__swsetup_r+0xc0>
    8ec6:	6963      	ldr	r3, [r4, #20]
    8ec8:	60a3      	str	r3, [r4, #8]
    8eca:	2000      	movs	r0, #0
    8ecc:	6923      	ldr	r3, [r4, #16]
    8ece:	4283      	cmp	r3, r0
    8ed0:	d107      	bne.n	8ee2 <__swsetup_r+0xda>
    8ed2:	220c      	movs	r2, #12
    8ed4:	5ea3      	ldrsh	r3, [r4, r2]
    8ed6:	061a      	lsls	r2, r3, #24
    8ed8:	d503      	bpl.n	8ee2 <__swsetup_r+0xda>
    8eda:	2240      	movs	r2, #64	; 0x40
    8edc:	4313      	orrs	r3, r2
    8ede:	81a3      	strh	r3, [r4, #12]
    8ee0:	3801      	subs	r0, #1
    8ee2:	bd70      	pop	{r4, r5, r6, pc}
    8ee4:	20000090 	.word	0x20000090
    8ee8:	0000b6ec 	.word	0x0000b6ec
    8eec:	0000b70c 	.word	0x0000b70c
    8ef0:	0000b72c 	.word	0x0000b72c

00008ef4 <__sflush_r>:
    8ef4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    8ef6:	898a      	ldrh	r2, [r1, #12]
    8ef8:	0005      	movs	r5, r0
    8efa:	000c      	movs	r4, r1
    8efc:	0713      	lsls	r3, r2, #28
    8efe:	d45a      	bmi.n	8fb6 <__sflush_r+0xc2>
    8f00:	684b      	ldr	r3, [r1, #4]
    8f02:	2b00      	cmp	r3, #0
    8f04:	dc02      	bgt.n	8f0c <__sflush_r+0x18>
    8f06:	6c0b      	ldr	r3, [r1, #64]	; 0x40
    8f08:	2b00      	cmp	r3, #0
    8f0a:	dd19      	ble.n	8f40 <__sflush_r+0x4c>
    8f0c:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    8f0e:	2f00      	cmp	r7, #0
    8f10:	d016      	beq.n	8f40 <__sflush_r+0x4c>
    8f12:	2300      	movs	r3, #0
    8f14:	682e      	ldr	r6, [r5, #0]
    8f16:	602b      	str	r3, [r5, #0]
    8f18:	2380      	movs	r3, #128	; 0x80
    8f1a:	015b      	lsls	r3, r3, #5
    8f1c:	401a      	ands	r2, r3
    8f1e:	d001      	beq.n	8f24 <__sflush_r+0x30>
    8f20:	6d60      	ldr	r0, [r4, #84]	; 0x54
    8f22:	e014      	b.n	8f4e <__sflush_r+0x5a>
    8f24:	2301      	movs	r3, #1
    8f26:	6a21      	ldr	r1, [r4, #32]
    8f28:	0028      	movs	r0, r5
    8f2a:	47b8      	blx	r7
    8f2c:	1c43      	adds	r3, r0, #1
    8f2e:	d10e      	bne.n	8f4e <__sflush_r+0x5a>
    8f30:	682b      	ldr	r3, [r5, #0]
    8f32:	2b00      	cmp	r3, #0
    8f34:	d00b      	beq.n	8f4e <__sflush_r+0x5a>
    8f36:	2b1d      	cmp	r3, #29
    8f38:	d001      	beq.n	8f3e <__sflush_r+0x4a>
    8f3a:	2b16      	cmp	r3, #22
    8f3c:	d102      	bne.n	8f44 <__sflush_r+0x50>
    8f3e:	602e      	str	r6, [r5, #0]
    8f40:	2000      	movs	r0, #0
    8f42:	e05a      	b.n	8ffa <__sflush_r+0x106>
    8f44:	2240      	movs	r2, #64	; 0x40
    8f46:	89a3      	ldrh	r3, [r4, #12]
    8f48:	4313      	orrs	r3, r2
    8f4a:	81a3      	strh	r3, [r4, #12]
    8f4c:	e055      	b.n	8ffa <__sflush_r+0x106>
    8f4e:	89a3      	ldrh	r3, [r4, #12]
    8f50:	075b      	lsls	r3, r3, #29
    8f52:	d506      	bpl.n	8f62 <__sflush_r+0x6e>
    8f54:	6863      	ldr	r3, [r4, #4]
    8f56:	1ac0      	subs	r0, r0, r3
    8f58:	6b63      	ldr	r3, [r4, #52]	; 0x34
    8f5a:	2b00      	cmp	r3, #0
    8f5c:	d001      	beq.n	8f62 <__sflush_r+0x6e>
    8f5e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    8f60:	1ac0      	subs	r0, r0, r3
    8f62:	2300      	movs	r3, #0
    8f64:	0002      	movs	r2, r0
    8f66:	6a21      	ldr	r1, [r4, #32]
    8f68:	0028      	movs	r0, r5
    8f6a:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
    8f6c:	47b8      	blx	r7
    8f6e:	89a3      	ldrh	r3, [r4, #12]
    8f70:	1c42      	adds	r2, r0, #1
    8f72:	d106      	bne.n	8f82 <__sflush_r+0x8e>
    8f74:	6829      	ldr	r1, [r5, #0]
    8f76:	291d      	cmp	r1, #29
    8f78:	d83a      	bhi.n	8ff0 <__sflush_r+0xfc>
    8f7a:	4a20      	ldr	r2, [pc, #128]	; (8ffc <__sflush_r+0x108>)
    8f7c:	40ca      	lsrs	r2, r1
    8f7e:	07d2      	lsls	r2, r2, #31
    8f80:	d536      	bpl.n	8ff0 <__sflush_r+0xfc>
    8f82:	2200      	movs	r2, #0
    8f84:	6062      	str	r2, [r4, #4]
    8f86:	6922      	ldr	r2, [r4, #16]
    8f88:	6022      	str	r2, [r4, #0]
    8f8a:	04db      	lsls	r3, r3, #19
    8f8c:	d505      	bpl.n	8f9a <__sflush_r+0xa6>
    8f8e:	1c43      	adds	r3, r0, #1
    8f90:	d102      	bne.n	8f98 <__sflush_r+0xa4>
    8f92:	682b      	ldr	r3, [r5, #0]
    8f94:	2b00      	cmp	r3, #0
    8f96:	d100      	bne.n	8f9a <__sflush_r+0xa6>
    8f98:	6560      	str	r0, [r4, #84]	; 0x54
    8f9a:	6b61      	ldr	r1, [r4, #52]	; 0x34
    8f9c:	602e      	str	r6, [r5, #0]
    8f9e:	2900      	cmp	r1, #0
    8fa0:	d0ce      	beq.n	8f40 <__sflush_r+0x4c>
    8fa2:	0023      	movs	r3, r4
    8fa4:	3344      	adds	r3, #68	; 0x44
    8fa6:	4299      	cmp	r1, r3
    8fa8:	d002      	beq.n	8fb0 <__sflush_r+0xbc>
    8faa:	0028      	movs	r0, r5
    8fac:	f7ff fbae 	bl	870c <_free_r>
    8fb0:	2000      	movs	r0, #0
    8fb2:	6360      	str	r0, [r4, #52]	; 0x34
    8fb4:	e021      	b.n	8ffa <__sflush_r+0x106>
    8fb6:	690f      	ldr	r7, [r1, #16]
    8fb8:	2f00      	cmp	r7, #0
    8fba:	d0c1      	beq.n	8f40 <__sflush_r+0x4c>
    8fbc:	680b      	ldr	r3, [r1, #0]
    8fbe:	600f      	str	r7, [r1, #0]
    8fc0:	1bdb      	subs	r3, r3, r7
    8fc2:	9301      	str	r3, [sp, #4]
    8fc4:	2300      	movs	r3, #0
    8fc6:	0792      	lsls	r2, r2, #30
    8fc8:	d100      	bne.n	8fcc <__sflush_r+0xd8>
    8fca:	694b      	ldr	r3, [r1, #20]
    8fcc:	60a3      	str	r3, [r4, #8]
    8fce:	e003      	b.n	8fd8 <__sflush_r+0xe4>
    8fd0:	9b01      	ldr	r3, [sp, #4]
    8fd2:	183f      	adds	r7, r7, r0
    8fd4:	1a1b      	subs	r3, r3, r0
    8fd6:	9301      	str	r3, [sp, #4]
    8fd8:	9b01      	ldr	r3, [sp, #4]
    8fda:	2b00      	cmp	r3, #0
    8fdc:	ddb0      	ble.n	8f40 <__sflush_r+0x4c>
    8fde:	9b01      	ldr	r3, [sp, #4]
    8fe0:	003a      	movs	r2, r7
    8fe2:	6a21      	ldr	r1, [r4, #32]
    8fe4:	0028      	movs	r0, r5
    8fe6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
    8fe8:	47b0      	blx	r6
    8fea:	2800      	cmp	r0, #0
    8fec:	dcf0      	bgt.n	8fd0 <__sflush_r+0xdc>
    8fee:	89a3      	ldrh	r3, [r4, #12]
    8ff0:	2240      	movs	r2, #64	; 0x40
    8ff2:	2001      	movs	r0, #1
    8ff4:	4313      	orrs	r3, r2
    8ff6:	81a3      	strh	r3, [r4, #12]
    8ff8:	4240      	negs	r0, r0
    8ffa:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    8ffc:	20400001 	.word	0x20400001

00009000 <_fflush_r>:
    9000:	690b      	ldr	r3, [r1, #16]
    9002:	b570      	push	{r4, r5, r6, lr}
    9004:	0005      	movs	r5, r0
    9006:	000c      	movs	r4, r1
    9008:	2b00      	cmp	r3, #0
    900a:	d101      	bne.n	9010 <_fflush_r+0x10>
    900c:	2000      	movs	r0, #0
    900e:	e01c      	b.n	904a <_fflush_r+0x4a>
    9010:	2800      	cmp	r0, #0
    9012:	d004      	beq.n	901e <_fflush_r+0x1e>
    9014:	6983      	ldr	r3, [r0, #24]
    9016:	2b00      	cmp	r3, #0
    9018:	d101      	bne.n	901e <_fflush_r+0x1e>
    901a:	f000 f85f 	bl	90dc <__sinit>
    901e:	4b0b      	ldr	r3, [pc, #44]	; (904c <_fflush_r+0x4c>)
    9020:	429c      	cmp	r4, r3
    9022:	d101      	bne.n	9028 <_fflush_r+0x28>
    9024:	686c      	ldr	r4, [r5, #4]
    9026:	e008      	b.n	903a <_fflush_r+0x3a>
    9028:	4b09      	ldr	r3, [pc, #36]	; (9050 <_fflush_r+0x50>)
    902a:	429c      	cmp	r4, r3
    902c:	d101      	bne.n	9032 <_fflush_r+0x32>
    902e:	68ac      	ldr	r4, [r5, #8]
    9030:	e003      	b.n	903a <_fflush_r+0x3a>
    9032:	4b08      	ldr	r3, [pc, #32]	; (9054 <_fflush_r+0x54>)
    9034:	429c      	cmp	r4, r3
    9036:	d100      	bne.n	903a <_fflush_r+0x3a>
    9038:	68ec      	ldr	r4, [r5, #12]
    903a:	220c      	movs	r2, #12
    903c:	5ea3      	ldrsh	r3, [r4, r2]
    903e:	2b00      	cmp	r3, #0
    9040:	d0e4      	beq.n	900c <_fflush_r+0xc>
    9042:	0021      	movs	r1, r4
    9044:	0028      	movs	r0, r5
    9046:	f7ff ff55 	bl	8ef4 <__sflush_r>
    904a:	bd70      	pop	{r4, r5, r6, pc}
    904c:	0000b6ec 	.word	0x0000b6ec
    9050:	0000b70c 	.word	0x0000b70c
    9054:	0000b72c 	.word	0x0000b72c

00009058 <_cleanup_r>:
    9058:	b510      	push	{r4, lr}
    905a:	4902      	ldr	r1, [pc, #8]	; (9064 <_cleanup_r+0xc>)
    905c:	f000 f8b0 	bl	91c0 <_fwalk_reent>
    9060:	bd10      	pop	{r4, pc}
    9062:	46c0      	nop			; (mov r8, r8)
    9064:	00009001 	.word	0x00009001

00009068 <std.isra.0>:
    9068:	2300      	movs	r3, #0
    906a:	b510      	push	{r4, lr}
    906c:	0004      	movs	r4, r0
    906e:	6003      	str	r3, [r0, #0]
    9070:	6043      	str	r3, [r0, #4]
    9072:	6083      	str	r3, [r0, #8]
    9074:	8181      	strh	r1, [r0, #12]
    9076:	6643      	str	r3, [r0, #100]	; 0x64
    9078:	81c2      	strh	r2, [r0, #14]
    907a:	6103      	str	r3, [r0, #16]
    907c:	6143      	str	r3, [r0, #20]
    907e:	6183      	str	r3, [r0, #24]
    9080:	0019      	movs	r1, r3
    9082:	2208      	movs	r2, #8
    9084:	305c      	adds	r0, #92	; 0x5c
    9086:	f7ff fb39 	bl	86fc <memset>
    908a:	4b05      	ldr	r3, [pc, #20]	; (90a0 <std.isra.0+0x38>)
    908c:	6224      	str	r4, [r4, #32]
    908e:	6263      	str	r3, [r4, #36]	; 0x24
    9090:	4b04      	ldr	r3, [pc, #16]	; (90a4 <std.isra.0+0x3c>)
    9092:	62a3      	str	r3, [r4, #40]	; 0x28
    9094:	4b04      	ldr	r3, [pc, #16]	; (90a8 <std.isra.0+0x40>)
    9096:	62e3      	str	r3, [r4, #44]	; 0x2c
    9098:	4b04      	ldr	r3, [pc, #16]	; (90ac <std.isra.0+0x44>)
    909a:	6323      	str	r3, [r4, #48]	; 0x30
    909c:	bd10      	pop	{r4, pc}
    909e:	46c0      	nop			; (mov r8, r8)
    90a0:	00009ba1 	.word	0x00009ba1
    90a4:	00009bc9 	.word	0x00009bc9
    90a8:	00009c01 	.word	0x00009c01
    90ac:	00009c2d 	.word	0x00009c2d

000090b0 <__sfmoreglue>:
    90b0:	b570      	push	{r4, r5, r6, lr}
    90b2:	2568      	movs	r5, #104	; 0x68
    90b4:	1e4b      	subs	r3, r1, #1
    90b6:	435d      	muls	r5, r3
    90b8:	000e      	movs	r6, r1
    90ba:	0029      	movs	r1, r5
    90bc:	3174      	adds	r1, #116	; 0x74
    90be:	f7ff fb6b 	bl	8798 <_malloc_r>
    90c2:	1e04      	subs	r4, r0, #0
    90c4:	d008      	beq.n	90d8 <__sfmoreglue+0x28>
    90c6:	2100      	movs	r1, #0
    90c8:	002a      	movs	r2, r5
    90ca:	6001      	str	r1, [r0, #0]
    90cc:	6046      	str	r6, [r0, #4]
    90ce:	300c      	adds	r0, #12
    90d0:	60a0      	str	r0, [r4, #8]
    90d2:	3268      	adds	r2, #104	; 0x68
    90d4:	f7ff fb12 	bl	86fc <memset>
    90d8:	0020      	movs	r0, r4
    90da:	bd70      	pop	{r4, r5, r6, pc}

000090dc <__sinit>:
    90dc:	6983      	ldr	r3, [r0, #24]
    90de:	b513      	push	{r0, r1, r4, lr}
    90e0:	0004      	movs	r4, r0
    90e2:	2b00      	cmp	r3, #0
    90e4:	d128      	bne.n	9138 <__sinit+0x5c>
    90e6:	6483      	str	r3, [r0, #72]	; 0x48
    90e8:	64c3      	str	r3, [r0, #76]	; 0x4c
    90ea:	6503      	str	r3, [r0, #80]	; 0x50
    90ec:	4b13      	ldr	r3, [pc, #76]	; (913c <__sinit+0x60>)
    90ee:	4a14      	ldr	r2, [pc, #80]	; (9140 <__sinit+0x64>)
    90f0:	681b      	ldr	r3, [r3, #0]
    90f2:	6282      	str	r2, [r0, #40]	; 0x28
    90f4:	9301      	str	r3, [sp, #4]
    90f6:	4298      	cmp	r0, r3
    90f8:	d101      	bne.n	90fe <__sinit+0x22>
    90fa:	2301      	movs	r3, #1
    90fc:	6183      	str	r3, [r0, #24]
    90fe:	0020      	movs	r0, r4
    9100:	f000 f820 	bl	9144 <__sfp>
    9104:	6060      	str	r0, [r4, #4]
    9106:	0020      	movs	r0, r4
    9108:	f000 f81c 	bl	9144 <__sfp>
    910c:	60a0      	str	r0, [r4, #8]
    910e:	0020      	movs	r0, r4
    9110:	f000 f818 	bl	9144 <__sfp>
    9114:	2200      	movs	r2, #0
    9116:	60e0      	str	r0, [r4, #12]
    9118:	2104      	movs	r1, #4
    911a:	6860      	ldr	r0, [r4, #4]
    911c:	f7ff ffa4 	bl	9068 <std.isra.0>
    9120:	2201      	movs	r2, #1
    9122:	2109      	movs	r1, #9
    9124:	68a0      	ldr	r0, [r4, #8]
    9126:	f7ff ff9f 	bl	9068 <std.isra.0>
    912a:	2202      	movs	r2, #2
    912c:	2112      	movs	r1, #18
    912e:	68e0      	ldr	r0, [r4, #12]
    9130:	f7ff ff9a 	bl	9068 <std.isra.0>
    9134:	2301      	movs	r3, #1
    9136:	61a3      	str	r3, [r4, #24]
    9138:	bd13      	pop	{r0, r1, r4, pc}
    913a:	46c0      	nop			; (mov r8, r8)
    913c:	0000b5e4 	.word	0x0000b5e4
    9140:	00009059 	.word	0x00009059

00009144 <__sfp>:
    9144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9146:	4b1d      	ldr	r3, [pc, #116]	; (91bc <__sfp+0x78>)
    9148:	0006      	movs	r6, r0
    914a:	681d      	ldr	r5, [r3, #0]
    914c:	69ab      	ldr	r3, [r5, #24]
    914e:	2b00      	cmp	r3, #0
    9150:	d102      	bne.n	9158 <__sfp+0x14>
    9152:	0028      	movs	r0, r5
    9154:	f7ff ffc2 	bl	90dc <__sinit>
    9158:	3548      	adds	r5, #72	; 0x48
    915a:	68ac      	ldr	r4, [r5, #8]
    915c:	686b      	ldr	r3, [r5, #4]
    915e:	3b01      	subs	r3, #1
    9160:	d405      	bmi.n	916e <__sfp+0x2a>
    9162:	220c      	movs	r2, #12
    9164:	5ea7      	ldrsh	r7, [r4, r2]
    9166:	2f00      	cmp	r7, #0
    9168:	d010      	beq.n	918c <__sfp+0x48>
    916a:	3468      	adds	r4, #104	; 0x68
    916c:	e7f7      	b.n	915e <__sfp+0x1a>
    916e:	682b      	ldr	r3, [r5, #0]
    9170:	2b00      	cmp	r3, #0
    9172:	d001      	beq.n	9178 <__sfp+0x34>
    9174:	682d      	ldr	r5, [r5, #0]
    9176:	e7f0      	b.n	915a <__sfp+0x16>
    9178:	2104      	movs	r1, #4
    917a:	0030      	movs	r0, r6
    917c:	f7ff ff98 	bl	90b0 <__sfmoreglue>
    9180:	6028      	str	r0, [r5, #0]
    9182:	2800      	cmp	r0, #0
    9184:	d1f6      	bne.n	9174 <__sfp+0x30>
    9186:	230c      	movs	r3, #12
    9188:	6033      	str	r3, [r6, #0]
    918a:	e016      	b.n	91ba <__sfp+0x76>
    918c:	2301      	movs	r3, #1
    918e:	0020      	movs	r0, r4
    9190:	425b      	negs	r3, r3
    9192:	81e3      	strh	r3, [r4, #14]
    9194:	3302      	adds	r3, #2
    9196:	81a3      	strh	r3, [r4, #12]
    9198:	6667      	str	r7, [r4, #100]	; 0x64
    919a:	6027      	str	r7, [r4, #0]
    919c:	60a7      	str	r7, [r4, #8]
    919e:	6067      	str	r7, [r4, #4]
    91a0:	6127      	str	r7, [r4, #16]
    91a2:	6167      	str	r7, [r4, #20]
    91a4:	61a7      	str	r7, [r4, #24]
    91a6:	305c      	adds	r0, #92	; 0x5c
    91a8:	2208      	movs	r2, #8
    91aa:	0039      	movs	r1, r7
    91ac:	f7ff faa6 	bl	86fc <memset>
    91b0:	0020      	movs	r0, r4
    91b2:	6367      	str	r7, [r4, #52]	; 0x34
    91b4:	63a7      	str	r7, [r4, #56]	; 0x38
    91b6:	64a7      	str	r7, [r4, #72]	; 0x48
    91b8:	64e7      	str	r7, [r4, #76]	; 0x4c
    91ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    91bc:	0000b5e4 	.word	0x0000b5e4

000091c0 <_fwalk_reent>:
    91c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    91c2:	0004      	movs	r4, r0
    91c4:	0007      	movs	r7, r0
    91c6:	2600      	movs	r6, #0
    91c8:	9101      	str	r1, [sp, #4]
    91ca:	3448      	adds	r4, #72	; 0x48
    91cc:	2c00      	cmp	r4, #0
    91ce:	d016      	beq.n	91fe <_fwalk_reent+0x3e>
    91d0:	6863      	ldr	r3, [r4, #4]
    91d2:	68a5      	ldr	r5, [r4, #8]
    91d4:	9300      	str	r3, [sp, #0]
    91d6:	9b00      	ldr	r3, [sp, #0]
    91d8:	3b01      	subs	r3, #1
    91da:	9300      	str	r3, [sp, #0]
    91dc:	d40d      	bmi.n	91fa <_fwalk_reent+0x3a>
    91de:	89ab      	ldrh	r3, [r5, #12]
    91e0:	2b01      	cmp	r3, #1
    91e2:	d908      	bls.n	91f6 <_fwalk_reent+0x36>
    91e4:	220e      	movs	r2, #14
    91e6:	5eab      	ldrsh	r3, [r5, r2]
    91e8:	3301      	adds	r3, #1
    91ea:	d004      	beq.n	91f6 <_fwalk_reent+0x36>
    91ec:	0029      	movs	r1, r5
    91ee:	0038      	movs	r0, r7
    91f0:	9b01      	ldr	r3, [sp, #4]
    91f2:	4798      	blx	r3
    91f4:	4306      	orrs	r6, r0
    91f6:	3568      	adds	r5, #104	; 0x68
    91f8:	e7ed      	b.n	91d6 <_fwalk_reent+0x16>
    91fa:	6824      	ldr	r4, [r4, #0]
    91fc:	e7e6      	b.n	91cc <_fwalk_reent+0xc>
    91fe:	0030      	movs	r0, r6
    9200:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	...

00009204 <__swhatbuf_r>:
    9204:	b570      	push	{r4, r5, r6, lr}
    9206:	000e      	movs	r6, r1
    9208:	001d      	movs	r5, r3
    920a:	230e      	movs	r3, #14
    920c:	5ec9      	ldrsh	r1, [r1, r3]
    920e:	b090      	sub	sp, #64	; 0x40
    9210:	0014      	movs	r4, r2
    9212:	2900      	cmp	r1, #0
    9214:	da06      	bge.n	9224 <__swhatbuf_r+0x20>
    9216:	2300      	movs	r3, #0
    9218:	602b      	str	r3, [r5, #0]
    921a:	89b3      	ldrh	r3, [r6, #12]
    921c:	061b      	lsls	r3, r3, #24
    921e:	d50f      	bpl.n	9240 <__swhatbuf_r+0x3c>
    9220:	2340      	movs	r3, #64	; 0x40
    9222:	e00f      	b.n	9244 <__swhatbuf_r+0x40>
    9224:	aa01      	add	r2, sp, #4
    9226:	f000 fd2d 	bl	9c84 <_fstat_r>
    922a:	2800      	cmp	r0, #0
    922c:	dbf3      	blt.n	9216 <__swhatbuf_r+0x12>
    922e:	23f0      	movs	r3, #240	; 0xf0
    9230:	9a02      	ldr	r2, [sp, #8]
    9232:	021b      	lsls	r3, r3, #8
    9234:	4013      	ands	r3, r2
    9236:	4a05      	ldr	r2, [pc, #20]	; (924c <__swhatbuf_r+0x48>)
    9238:	189b      	adds	r3, r3, r2
    923a:	425a      	negs	r2, r3
    923c:	4153      	adcs	r3, r2
    923e:	602b      	str	r3, [r5, #0]
    9240:	2380      	movs	r3, #128	; 0x80
    9242:	00db      	lsls	r3, r3, #3
    9244:	2000      	movs	r0, #0
    9246:	6023      	str	r3, [r4, #0]
    9248:	b010      	add	sp, #64	; 0x40
    924a:	bd70      	pop	{r4, r5, r6, pc}
    924c:	ffffe000 	.word	0xffffe000

00009250 <__smakebuf_r>:
    9250:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9252:	2602      	movs	r6, #2
    9254:	898b      	ldrh	r3, [r1, #12]
    9256:	0005      	movs	r5, r0
    9258:	000c      	movs	r4, r1
    925a:	4233      	tst	r3, r6
    925c:	d110      	bne.n	9280 <__smakebuf_r+0x30>
    925e:	ab01      	add	r3, sp, #4
    9260:	466a      	mov	r2, sp
    9262:	f7ff ffcf 	bl	9204 <__swhatbuf_r>
    9266:	9900      	ldr	r1, [sp, #0]
    9268:	0007      	movs	r7, r0
    926a:	0028      	movs	r0, r5
    926c:	f7ff fa94 	bl	8798 <_malloc_r>
    9270:	2800      	cmp	r0, #0
    9272:	d10c      	bne.n	928e <__smakebuf_r+0x3e>
    9274:	220c      	movs	r2, #12
    9276:	5ea3      	ldrsh	r3, [r4, r2]
    9278:	059a      	lsls	r2, r3, #22
    927a:	d423      	bmi.n	92c4 <__smakebuf_r+0x74>
    927c:	4333      	orrs	r3, r6
    927e:	81a3      	strh	r3, [r4, #12]
    9280:	0023      	movs	r3, r4
    9282:	3347      	adds	r3, #71	; 0x47
    9284:	6023      	str	r3, [r4, #0]
    9286:	6123      	str	r3, [r4, #16]
    9288:	2301      	movs	r3, #1
    928a:	6163      	str	r3, [r4, #20]
    928c:	e01a      	b.n	92c4 <__smakebuf_r+0x74>
    928e:	2280      	movs	r2, #128	; 0x80
    9290:	4b0d      	ldr	r3, [pc, #52]	; (92c8 <__smakebuf_r+0x78>)
    9292:	62ab      	str	r3, [r5, #40]	; 0x28
    9294:	89a3      	ldrh	r3, [r4, #12]
    9296:	6020      	str	r0, [r4, #0]
    9298:	4313      	orrs	r3, r2
    929a:	81a3      	strh	r3, [r4, #12]
    929c:	9b00      	ldr	r3, [sp, #0]
    929e:	6120      	str	r0, [r4, #16]
    92a0:	6163      	str	r3, [r4, #20]
    92a2:	9b01      	ldr	r3, [sp, #4]
    92a4:	2b00      	cmp	r3, #0
    92a6:	d00a      	beq.n	92be <__smakebuf_r+0x6e>
    92a8:	230e      	movs	r3, #14
    92aa:	5ee1      	ldrsh	r1, [r4, r3]
    92ac:	0028      	movs	r0, r5
    92ae:	f000 fcfb 	bl	9ca8 <_isatty_r>
    92b2:	2800      	cmp	r0, #0
    92b4:	d003      	beq.n	92be <__smakebuf_r+0x6e>
    92b6:	2201      	movs	r2, #1
    92b8:	89a3      	ldrh	r3, [r4, #12]
    92ba:	4313      	orrs	r3, r2
    92bc:	81a3      	strh	r3, [r4, #12]
    92be:	89a3      	ldrh	r3, [r4, #12]
    92c0:	431f      	orrs	r7, r3
    92c2:	81a7      	strh	r7, [r4, #12]
    92c4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    92c6:	46c0      	nop			; (mov r8, r8)
    92c8:	00009059 	.word	0x00009059

000092cc <__ssputs_r>:
    92cc:	b5f0      	push	{r4, r5, r6, r7, lr}
    92ce:	688e      	ldr	r6, [r1, #8]
    92d0:	b085      	sub	sp, #20
    92d2:	0007      	movs	r7, r0
    92d4:	000c      	movs	r4, r1
    92d6:	9203      	str	r2, [sp, #12]
    92d8:	9301      	str	r3, [sp, #4]
    92da:	429e      	cmp	r6, r3
    92dc:	d843      	bhi.n	9366 <__ssputs_r+0x9a>
    92de:	2390      	movs	r3, #144	; 0x90
    92e0:	898a      	ldrh	r2, [r1, #12]
    92e2:	00db      	lsls	r3, r3, #3
    92e4:	421a      	tst	r2, r3
    92e6:	d03e      	beq.n	9366 <__ssputs_r+0x9a>
    92e8:	2503      	movs	r5, #3
    92ea:	6909      	ldr	r1, [r1, #16]
    92ec:	6823      	ldr	r3, [r4, #0]
    92ee:	9801      	ldr	r0, [sp, #4]
    92f0:	1a5b      	subs	r3, r3, r1
    92f2:	9302      	str	r3, [sp, #8]
    92f4:	6963      	ldr	r3, [r4, #20]
    92f6:	435d      	muls	r5, r3
    92f8:	0feb      	lsrs	r3, r5, #31
    92fa:	195d      	adds	r5, r3, r5
    92fc:	9b02      	ldr	r3, [sp, #8]
    92fe:	106d      	asrs	r5, r5, #1
    9300:	3301      	adds	r3, #1
    9302:	181b      	adds	r3, r3, r0
    9304:	42ab      	cmp	r3, r5
    9306:	d900      	bls.n	930a <__ssputs_r+0x3e>
    9308:	001d      	movs	r5, r3
    930a:	0553      	lsls	r3, r2, #21
    930c:	d510      	bpl.n	9330 <__ssputs_r+0x64>
    930e:	0029      	movs	r1, r5
    9310:	0038      	movs	r0, r7
    9312:	f7ff fa41 	bl	8798 <_malloc_r>
    9316:	1e06      	subs	r6, r0, #0
    9318:	d014      	beq.n	9344 <__ssputs_r+0x78>
    931a:	9a02      	ldr	r2, [sp, #8]
    931c:	6921      	ldr	r1, [r4, #16]
    931e:	f7ff f9cf 	bl	86c0 <memcpy>
    9322:	89a2      	ldrh	r2, [r4, #12]
    9324:	4b19      	ldr	r3, [pc, #100]	; (938c <__ssputs_r+0xc0>)
    9326:	4013      	ands	r3, r2
    9328:	2280      	movs	r2, #128	; 0x80
    932a:	4313      	orrs	r3, r2
    932c:	81a3      	strh	r3, [r4, #12]
    932e:	e012      	b.n	9356 <__ssputs_r+0x8a>
    9330:	002a      	movs	r2, r5
    9332:	0038      	movs	r0, r7
    9334:	f000 fce9 	bl	9d0a <_realloc_r>
    9338:	1e06      	subs	r6, r0, #0
    933a:	d10c      	bne.n	9356 <__ssputs_r+0x8a>
    933c:	6921      	ldr	r1, [r4, #16]
    933e:	0038      	movs	r0, r7
    9340:	f7ff f9e4 	bl	870c <_free_r>
    9344:	230c      	movs	r3, #12
    9346:	2240      	movs	r2, #64	; 0x40
    9348:	2001      	movs	r0, #1
    934a:	603b      	str	r3, [r7, #0]
    934c:	89a3      	ldrh	r3, [r4, #12]
    934e:	4240      	negs	r0, r0
    9350:	4313      	orrs	r3, r2
    9352:	81a3      	strh	r3, [r4, #12]
    9354:	e017      	b.n	9386 <__ssputs_r+0xba>
    9356:	9b02      	ldr	r3, [sp, #8]
    9358:	6126      	str	r6, [r4, #16]
    935a:	18f6      	adds	r6, r6, r3
    935c:	6026      	str	r6, [r4, #0]
    935e:	6165      	str	r5, [r4, #20]
    9360:	9e01      	ldr	r6, [sp, #4]
    9362:	1aed      	subs	r5, r5, r3
    9364:	60a5      	str	r5, [r4, #8]
    9366:	9b01      	ldr	r3, [sp, #4]
    9368:	42b3      	cmp	r3, r6
    936a:	d200      	bcs.n	936e <__ssputs_r+0xa2>
    936c:	001e      	movs	r6, r3
    936e:	0032      	movs	r2, r6
    9370:	9903      	ldr	r1, [sp, #12]
    9372:	6820      	ldr	r0, [r4, #0]
    9374:	f7ff f9ad 	bl	86d2 <memmove>
    9378:	2000      	movs	r0, #0
    937a:	68a3      	ldr	r3, [r4, #8]
    937c:	1b9b      	subs	r3, r3, r6
    937e:	60a3      	str	r3, [r4, #8]
    9380:	6823      	ldr	r3, [r4, #0]
    9382:	199e      	adds	r6, r3, r6
    9384:	6026      	str	r6, [r4, #0]
    9386:	b005      	add	sp, #20
    9388:	bdf0      	pop	{r4, r5, r6, r7, pc}
    938a:	46c0      	nop			; (mov r8, r8)
    938c:	fffffb7f 	.word	0xfffffb7f

00009390 <_svfiprintf_r>:
    9390:	b5f0      	push	{r4, r5, r6, r7, lr}
    9392:	b09f      	sub	sp, #124	; 0x7c
    9394:	9002      	str	r0, [sp, #8]
    9396:	9305      	str	r3, [sp, #20]
    9398:	898b      	ldrh	r3, [r1, #12]
    939a:	000f      	movs	r7, r1
    939c:	0016      	movs	r6, r2
    939e:	061b      	lsls	r3, r3, #24
    93a0:	d510      	bpl.n	93c4 <_svfiprintf_r+0x34>
    93a2:	690b      	ldr	r3, [r1, #16]
    93a4:	2b00      	cmp	r3, #0
    93a6:	d10d      	bne.n	93c4 <_svfiprintf_r+0x34>
    93a8:	2140      	movs	r1, #64	; 0x40
    93aa:	f7ff f9f5 	bl	8798 <_malloc_r>
    93ae:	6038      	str	r0, [r7, #0]
    93b0:	6138      	str	r0, [r7, #16]
    93b2:	2800      	cmp	r0, #0
    93b4:	d104      	bne.n	93c0 <_svfiprintf_r+0x30>
    93b6:	230c      	movs	r3, #12
    93b8:	9a02      	ldr	r2, [sp, #8]
    93ba:	3801      	subs	r0, #1
    93bc:	6013      	str	r3, [r2, #0]
    93be:	e0d8      	b.n	9572 <_svfiprintf_r+0x1e2>
    93c0:	2340      	movs	r3, #64	; 0x40
    93c2:	617b      	str	r3, [r7, #20]
    93c4:	2300      	movs	r3, #0
    93c6:	ad06      	add	r5, sp, #24
    93c8:	616b      	str	r3, [r5, #20]
    93ca:	3320      	adds	r3, #32
    93cc:	766b      	strb	r3, [r5, #25]
    93ce:	3310      	adds	r3, #16
    93d0:	76ab      	strb	r3, [r5, #26]
    93d2:	0034      	movs	r4, r6
    93d4:	7823      	ldrb	r3, [r4, #0]
    93d6:	2b00      	cmp	r3, #0
    93d8:	d103      	bne.n	93e2 <_svfiprintf_r+0x52>
    93da:	1ba3      	subs	r3, r4, r6
    93dc:	9304      	str	r3, [sp, #16]
    93de:	d012      	beq.n	9406 <_svfiprintf_r+0x76>
    93e0:	e003      	b.n	93ea <_svfiprintf_r+0x5a>
    93e2:	2b25      	cmp	r3, #37	; 0x25
    93e4:	d0f9      	beq.n	93da <_svfiprintf_r+0x4a>
    93e6:	3401      	adds	r4, #1
    93e8:	e7f4      	b.n	93d4 <_svfiprintf_r+0x44>
    93ea:	1ba3      	subs	r3, r4, r6
    93ec:	0032      	movs	r2, r6
    93ee:	0039      	movs	r1, r7
    93f0:	9802      	ldr	r0, [sp, #8]
    93f2:	f7ff ff6b 	bl	92cc <__ssputs_r>
    93f6:	1c43      	adds	r3, r0, #1
    93f8:	d100      	bne.n	93fc <_svfiprintf_r+0x6c>
    93fa:	e0b4      	b.n	9566 <_svfiprintf_r+0x1d6>
    93fc:	696a      	ldr	r2, [r5, #20]
    93fe:	9b04      	ldr	r3, [sp, #16]
    9400:	4694      	mov	ip, r2
    9402:	4463      	add	r3, ip
    9404:	616b      	str	r3, [r5, #20]
    9406:	7823      	ldrb	r3, [r4, #0]
    9408:	2b00      	cmp	r3, #0
    940a:	d100      	bne.n	940e <_svfiprintf_r+0x7e>
    940c:	e0ab      	b.n	9566 <_svfiprintf_r+0x1d6>
    940e:	2201      	movs	r2, #1
    9410:	2300      	movs	r3, #0
    9412:	4252      	negs	r2, r2
    9414:	606a      	str	r2, [r5, #4]
    9416:	a902      	add	r1, sp, #8
    9418:	3254      	adds	r2, #84	; 0x54
    941a:	1852      	adds	r2, r2, r1
    941c:	3401      	adds	r4, #1
    941e:	602b      	str	r3, [r5, #0]
    9420:	60eb      	str	r3, [r5, #12]
    9422:	60ab      	str	r3, [r5, #8]
    9424:	7013      	strb	r3, [r2, #0]
    9426:	65ab      	str	r3, [r5, #88]	; 0x58
    9428:	4e53      	ldr	r6, [pc, #332]	; (9578 <_svfiprintf_r+0x1e8>)
    942a:	7821      	ldrb	r1, [r4, #0]
    942c:	2205      	movs	r2, #5
    942e:	0030      	movs	r0, r6
    9430:	f000 fc60 	bl	9cf4 <memchr>
    9434:	2800      	cmp	r0, #0
    9436:	d007      	beq.n	9448 <_svfiprintf_r+0xb8>
    9438:	2301      	movs	r3, #1
    943a:	1b80      	subs	r0, r0, r6
    943c:	4083      	lsls	r3, r0
    943e:	682a      	ldr	r2, [r5, #0]
    9440:	3401      	adds	r4, #1
    9442:	4313      	orrs	r3, r2
    9444:	602b      	str	r3, [r5, #0]
    9446:	e7ef      	b.n	9428 <_svfiprintf_r+0x98>
    9448:	682b      	ldr	r3, [r5, #0]
    944a:	06da      	lsls	r2, r3, #27
    944c:	d504      	bpl.n	9458 <_svfiprintf_r+0xc8>
    944e:	2253      	movs	r2, #83	; 0x53
    9450:	2120      	movs	r1, #32
    9452:	a802      	add	r0, sp, #8
    9454:	1812      	adds	r2, r2, r0
    9456:	7011      	strb	r1, [r2, #0]
    9458:	071a      	lsls	r2, r3, #28
    945a:	d504      	bpl.n	9466 <_svfiprintf_r+0xd6>
    945c:	2253      	movs	r2, #83	; 0x53
    945e:	212b      	movs	r1, #43	; 0x2b
    9460:	a802      	add	r0, sp, #8
    9462:	1812      	adds	r2, r2, r0
    9464:	7011      	strb	r1, [r2, #0]
    9466:	7822      	ldrb	r2, [r4, #0]
    9468:	2a2a      	cmp	r2, #42	; 0x2a
    946a:	d003      	beq.n	9474 <_svfiprintf_r+0xe4>
    946c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    946e:	2000      	movs	r0, #0
    9470:	210a      	movs	r1, #10
    9472:	e00e      	b.n	9492 <_svfiprintf_r+0x102>
    9474:	9a05      	ldr	r2, [sp, #20]
    9476:	1d11      	adds	r1, r2, #4
    9478:	6812      	ldr	r2, [r2, #0]
    947a:	9105      	str	r1, [sp, #20]
    947c:	2a00      	cmp	r2, #0
    947e:	db01      	blt.n	9484 <_svfiprintf_r+0xf4>
    9480:	9209      	str	r2, [sp, #36]	; 0x24
    9482:	e004      	b.n	948e <_svfiprintf_r+0xfe>
    9484:	4252      	negs	r2, r2
    9486:	60ea      	str	r2, [r5, #12]
    9488:	2202      	movs	r2, #2
    948a:	4313      	orrs	r3, r2
    948c:	602b      	str	r3, [r5, #0]
    948e:	3401      	adds	r4, #1
    9490:	e00b      	b.n	94aa <_svfiprintf_r+0x11a>
    9492:	7822      	ldrb	r2, [r4, #0]
    9494:	3a30      	subs	r2, #48	; 0x30
    9496:	2a09      	cmp	r2, #9
    9498:	d804      	bhi.n	94a4 <_svfiprintf_r+0x114>
    949a:	434b      	muls	r3, r1
    949c:	3401      	adds	r4, #1
    949e:	189b      	adds	r3, r3, r2
    94a0:	2001      	movs	r0, #1
    94a2:	e7f6      	b.n	9492 <_svfiprintf_r+0x102>
    94a4:	2800      	cmp	r0, #0
    94a6:	d000      	beq.n	94aa <_svfiprintf_r+0x11a>
    94a8:	9309      	str	r3, [sp, #36]	; 0x24
    94aa:	7823      	ldrb	r3, [r4, #0]
    94ac:	2b2e      	cmp	r3, #46	; 0x2e
    94ae:	d11e      	bne.n	94ee <_svfiprintf_r+0x15e>
    94b0:	7863      	ldrb	r3, [r4, #1]
    94b2:	2b2a      	cmp	r3, #42	; 0x2a
    94b4:	d10a      	bne.n	94cc <_svfiprintf_r+0x13c>
    94b6:	9b05      	ldr	r3, [sp, #20]
    94b8:	3402      	adds	r4, #2
    94ba:	1d1a      	adds	r2, r3, #4
    94bc:	681b      	ldr	r3, [r3, #0]
    94be:	9205      	str	r2, [sp, #20]
    94c0:	2b00      	cmp	r3, #0
    94c2:	da01      	bge.n	94c8 <_svfiprintf_r+0x138>
    94c4:	2301      	movs	r3, #1
    94c6:	425b      	negs	r3, r3
    94c8:	9307      	str	r3, [sp, #28]
    94ca:	e010      	b.n	94ee <_svfiprintf_r+0x15e>
    94cc:	2300      	movs	r3, #0
    94ce:	200a      	movs	r0, #10
    94d0:	001a      	movs	r2, r3
    94d2:	3401      	adds	r4, #1
    94d4:	606b      	str	r3, [r5, #4]
    94d6:	7821      	ldrb	r1, [r4, #0]
    94d8:	3930      	subs	r1, #48	; 0x30
    94da:	2909      	cmp	r1, #9
    94dc:	d804      	bhi.n	94e8 <_svfiprintf_r+0x158>
    94de:	4342      	muls	r2, r0
    94e0:	3401      	adds	r4, #1
    94e2:	1852      	adds	r2, r2, r1
    94e4:	2301      	movs	r3, #1
    94e6:	e7f6      	b.n	94d6 <_svfiprintf_r+0x146>
    94e8:	2b00      	cmp	r3, #0
    94ea:	d000      	beq.n	94ee <_svfiprintf_r+0x15e>
    94ec:	9207      	str	r2, [sp, #28]
    94ee:	4e23      	ldr	r6, [pc, #140]	; (957c <_svfiprintf_r+0x1ec>)
    94f0:	7821      	ldrb	r1, [r4, #0]
    94f2:	2203      	movs	r2, #3
    94f4:	0030      	movs	r0, r6
    94f6:	f000 fbfd 	bl	9cf4 <memchr>
    94fa:	2800      	cmp	r0, #0
    94fc:	d006      	beq.n	950c <_svfiprintf_r+0x17c>
    94fe:	2340      	movs	r3, #64	; 0x40
    9500:	1b80      	subs	r0, r0, r6
    9502:	4083      	lsls	r3, r0
    9504:	682a      	ldr	r2, [r5, #0]
    9506:	3401      	adds	r4, #1
    9508:	4313      	orrs	r3, r2
    950a:	602b      	str	r3, [r5, #0]
    950c:	7821      	ldrb	r1, [r4, #0]
    950e:	2206      	movs	r2, #6
    9510:	481b      	ldr	r0, [pc, #108]	; (9580 <_svfiprintf_r+0x1f0>)
    9512:	1c66      	adds	r6, r4, #1
    9514:	7629      	strb	r1, [r5, #24]
    9516:	f000 fbed 	bl	9cf4 <memchr>
    951a:	2800      	cmp	r0, #0
    951c:	d012      	beq.n	9544 <_svfiprintf_r+0x1b4>
    951e:	4b19      	ldr	r3, [pc, #100]	; (9584 <_svfiprintf_r+0x1f4>)
    9520:	2b00      	cmp	r3, #0
    9522:	d106      	bne.n	9532 <_svfiprintf_r+0x1a2>
    9524:	2207      	movs	r2, #7
    9526:	9b05      	ldr	r3, [sp, #20]
    9528:	3307      	adds	r3, #7
    952a:	4393      	bics	r3, r2
    952c:	3308      	adds	r3, #8
    952e:	9305      	str	r3, [sp, #20]
    9530:	e014      	b.n	955c <_svfiprintf_r+0x1cc>
    9532:	ab05      	add	r3, sp, #20
    9534:	9300      	str	r3, [sp, #0]
    9536:	003a      	movs	r2, r7
    9538:	4b13      	ldr	r3, [pc, #76]	; (9588 <_svfiprintf_r+0x1f8>)
    953a:	0029      	movs	r1, r5
    953c:	9802      	ldr	r0, [sp, #8]
    953e:	e000      	b.n	9542 <_svfiprintf_r+0x1b2>
    9540:	bf00      	nop
    9542:	e007      	b.n	9554 <_svfiprintf_r+0x1c4>
    9544:	ab05      	add	r3, sp, #20
    9546:	9300      	str	r3, [sp, #0]
    9548:	003a      	movs	r2, r7
    954a:	4b0f      	ldr	r3, [pc, #60]	; (9588 <_svfiprintf_r+0x1f8>)
    954c:	0029      	movs	r1, r5
    954e:	9802      	ldr	r0, [sp, #8]
    9550:	f000 f9ce 	bl	98f0 <_printf_i>
    9554:	9003      	str	r0, [sp, #12]
    9556:	9b03      	ldr	r3, [sp, #12]
    9558:	3301      	adds	r3, #1
    955a:	d004      	beq.n	9566 <_svfiprintf_r+0x1d6>
    955c:	696b      	ldr	r3, [r5, #20]
    955e:	9a03      	ldr	r2, [sp, #12]
    9560:	189b      	adds	r3, r3, r2
    9562:	616b      	str	r3, [r5, #20]
    9564:	e735      	b.n	93d2 <_svfiprintf_r+0x42>
    9566:	89bb      	ldrh	r3, [r7, #12]
    9568:	980b      	ldr	r0, [sp, #44]	; 0x2c
    956a:	065b      	lsls	r3, r3, #25
    956c:	d501      	bpl.n	9572 <_svfiprintf_r+0x1e2>
    956e:	2001      	movs	r0, #1
    9570:	4240      	negs	r0, r0
    9572:	b01f      	add	sp, #124	; 0x7c
    9574:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9576:	46c0      	nop			; (mov r8, r8)
    9578:	0000b74c 	.word	0x0000b74c
    957c:	0000b752 	.word	0x0000b752
    9580:	0000b756 	.word	0x0000b756
    9584:	00000000 	.word	0x00000000
    9588:	000092cd 	.word	0x000092cd

0000958c <__sfputc_r>:
    958c:	6893      	ldr	r3, [r2, #8]
    958e:	b510      	push	{r4, lr}
    9590:	3b01      	subs	r3, #1
    9592:	6093      	str	r3, [r2, #8]
    9594:	2b00      	cmp	r3, #0
    9596:	da05      	bge.n	95a4 <__sfputc_r+0x18>
    9598:	6994      	ldr	r4, [r2, #24]
    959a:	42a3      	cmp	r3, r4
    959c:	db08      	blt.n	95b0 <__sfputc_r+0x24>
    959e:	b2cb      	uxtb	r3, r1
    95a0:	2b0a      	cmp	r3, #10
    95a2:	d005      	beq.n	95b0 <__sfputc_r+0x24>
    95a4:	6813      	ldr	r3, [r2, #0]
    95a6:	1c58      	adds	r0, r3, #1
    95a8:	6010      	str	r0, [r2, #0]
    95aa:	7019      	strb	r1, [r3, #0]
    95ac:	b2c8      	uxtb	r0, r1
    95ae:	e001      	b.n	95b4 <__sfputc_r+0x28>
    95b0:	f7ff fbd2 	bl	8d58 <__swbuf_r>
    95b4:	bd10      	pop	{r4, pc}

000095b6 <__sfputs_r>:
    95b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    95b8:	0006      	movs	r6, r0
    95ba:	000f      	movs	r7, r1
    95bc:	0014      	movs	r4, r2
    95be:	18d5      	adds	r5, r2, r3
    95c0:	42ac      	cmp	r4, r5
    95c2:	d008      	beq.n	95d6 <__sfputs_r+0x20>
    95c4:	7821      	ldrb	r1, [r4, #0]
    95c6:	003a      	movs	r2, r7
    95c8:	0030      	movs	r0, r6
    95ca:	f7ff ffdf 	bl	958c <__sfputc_r>
    95ce:	3401      	adds	r4, #1
    95d0:	1c43      	adds	r3, r0, #1
    95d2:	d1f5      	bne.n	95c0 <__sfputs_r+0xa>
    95d4:	e000      	b.n	95d8 <__sfputs_r+0x22>
    95d6:	2000      	movs	r0, #0
    95d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000095dc <_vfiprintf_r>:
    95dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    95de:	b09f      	sub	sp, #124	; 0x7c
    95e0:	0006      	movs	r6, r0
    95e2:	000f      	movs	r7, r1
    95e4:	9202      	str	r2, [sp, #8]
    95e6:	9305      	str	r3, [sp, #20]
    95e8:	2800      	cmp	r0, #0
    95ea:	d004      	beq.n	95f6 <_vfiprintf_r+0x1a>
    95ec:	6983      	ldr	r3, [r0, #24]
    95ee:	2b00      	cmp	r3, #0
    95f0:	d101      	bne.n	95f6 <_vfiprintf_r+0x1a>
    95f2:	f7ff fd73 	bl	90dc <__sinit>
    95f6:	4b7f      	ldr	r3, [pc, #508]	; (97f4 <_vfiprintf_r+0x218>)
    95f8:	429f      	cmp	r7, r3
    95fa:	d101      	bne.n	9600 <_vfiprintf_r+0x24>
    95fc:	6877      	ldr	r7, [r6, #4]
    95fe:	e008      	b.n	9612 <_vfiprintf_r+0x36>
    9600:	4b7d      	ldr	r3, [pc, #500]	; (97f8 <_vfiprintf_r+0x21c>)
    9602:	429f      	cmp	r7, r3
    9604:	d101      	bne.n	960a <_vfiprintf_r+0x2e>
    9606:	68b7      	ldr	r7, [r6, #8]
    9608:	e003      	b.n	9612 <_vfiprintf_r+0x36>
    960a:	4b7c      	ldr	r3, [pc, #496]	; (97fc <_vfiprintf_r+0x220>)
    960c:	429f      	cmp	r7, r3
    960e:	d100      	bne.n	9612 <_vfiprintf_r+0x36>
    9610:	68f7      	ldr	r7, [r6, #12]
    9612:	89bb      	ldrh	r3, [r7, #12]
    9614:	071b      	lsls	r3, r3, #28
    9616:	d50a      	bpl.n	962e <_vfiprintf_r+0x52>
    9618:	693b      	ldr	r3, [r7, #16]
    961a:	2b00      	cmp	r3, #0
    961c:	d007      	beq.n	962e <_vfiprintf_r+0x52>
    961e:	2300      	movs	r3, #0
    9620:	ad06      	add	r5, sp, #24
    9622:	616b      	str	r3, [r5, #20]
    9624:	3320      	adds	r3, #32
    9626:	766b      	strb	r3, [r5, #25]
    9628:	3310      	adds	r3, #16
    962a:	76ab      	strb	r3, [r5, #26]
    962c:	e03d      	b.n	96aa <_vfiprintf_r+0xce>
    962e:	0039      	movs	r1, r7
    9630:	0030      	movs	r0, r6
    9632:	f7ff fbe9 	bl	8e08 <__swsetup_r>
    9636:	2800      	cmp	r0, #0
    9638:	d0f1      	beq.n	961e <_vfiprintf_r+0x42>
    963a:	2001      	movs	r0, #1
    963c:	4240      	negs	r0, r0
    963e:	e0d6      	b.n	97ee <_vfiprintf_r+0x212>
    9640:	9a05      	ldr	r2, [sp, #20]
    9642:	1d11      	adds	r1, r2, #4
    9644:	6812      	ldr	r2, [r2, #0]
    9646:	9105      	str	r1, [sp, #20]
    9648:	2a00      	cmp	r2, #0
    964a:	da00      	bge.n	964e <_vfiprintf_r+0x72>
    964c:	e07f      	b.n	974e <_vfiprintf_r+0x172>
    964e:	9209      	str	r2, [sp, #36]	; 0x24
    9650:	3401      	adds	r4, #1
    9652:	7823      	ldrb	r3, [r4, #0]
    9654:	2b2e      	cmp	r3, #46	; 0x2e
    9656:	d100      	bne.n	965a <_vfiprintf_r+0x7e>
    9658:	e08d      	b.n	9776 <_vfiprintf_r+0x19a>
    965a:	7821      	ldrb	r1, [r4, #0]
    965c:	2203      	movs	r2, #3
    965e:	4868      	ldr	r0, [pc, #416]	; (9800 <_vfiprintf_r+0x224>)
    9660:	f000 fb48 	bl	9cf4 <memchr>
    9664:	2800      	cmp	r0, #0
    9666:	d007      	beq.n	9678 <_vfiprintf_r+0x9c>
    9668:	4b65      	ldr	r3, [pc, #404]	; (9800 <_vfiprintf_r+0x224>)
    966a:	682a      	ldr	r2, [r5, #0]
    966c:	1ac0      	subs	r0, r0, r3
    966e:	2340      	movs	r3, #64	; 0x40
    9670:	4083      	lsls	r3, r0
    9672:	4313      	orrs	r3, r2
    9674:	602b      	str	r3, [r5, #0]
    9676:	3401      	adds	r4, #1
    9678:	7821      	ldrb	r1, [r4, #0]
    967a:	1c63      	adds	r3, r4, #1
    967c:	2206      	movs	r2, #6
    967e:	4861      	ldr	r0, [pc, #388]	; (9804 <_vfiprintf_r+0x228>)
    9680:	9302      	str	r3, [sp, #8]
    9682:	7629      	strb	r1, [r5, #24]
    9684:	f000 fb36 	bl	9cf4 <memchr>
    9688:	2800      	cmp	r0, #0
    968a:	d100      	bne.n	968e <_vfiprintf_r+0xb2>
    968c:	e09d      	b.n	97ca <_vfiprintf_r+0x1ee>
    968e:	4b5e      	ldr	r3, [pc, #376]	; (9808 <_vfiprintf_r+0x22c>)
    9690:	2b00      	cmp	r3, #0
    9692:	d000      	beq.n	9696 <_vfiprintf_r+0xba>
    9694:	e090      	b.n	97b8 <_vfiprintf_r+0x1dc>
    9696:	2207      	movs	r2, #7
    9698:	9b05      	ldr	r3, [sp, #20]
    969a:	3307      	adds	r3, #7
    969c:	4393      	bics	r3, r2
    969e:	3308      	adds	r3, #8
    96a0:	9305      	str	r3, [sp, #20]
    96a2:	696b      	ldr	r3, [r5, #20]
    96a4:	9a03      	ldr	r2, [sp, #12]
    96a6:	189b      	adds	r3, r3, r2
    96a8:	616b      	str	r3, [r5, #20]
    96aa:	9c02      	ldr	r4, [sp, #8]
    96ac:	7823      	ldrb	r3, [r4, #0]
    96ae:	2b00      	cmp	r3, #0
    96b0:	d104      	bne.n	96bc <_vfiprintf_r+0xe0>
    96b2:	9b02      	ldr	r3, [sp, #8]
    96b4:	1ae3      	subs	r3, r4, r3
    96b6:	9304      	str	r3, [sp, #16]
    96b8:	d012      	beq.n	96e0 <_vfiprintf_r+0x104>
    96ba:	e003      	b.n	96c4 <_vfiprintf_r+0xe8>
    96bc:	2b25      	cmp	r3, #37	; 0x25
    96be:	d0f8      	beq.n	96b2 <_vfiprintf_r+0xd6>
    96c0:	3401      	adds	r4, #1
    96c2:	e7f3      	b.n	96ac <_vfiprintf_r+0xd0>
    96c4:	9b04      	ldr	r3, [sp, #16]
    96c6:	9a02      	ldr	r2, [sp, #8]
    96c8:	0039      	movs	r1, r7
    96ca:	0030      	movs	r0, r6
    96cc:	f7ff ff73 	bl	95b6 <__sfputs_r>
    96d0:	1c43      	adds	r3, r0, #1
    96d2:	d100      	bne.n	96d6 <_vfiprintf_r+0xfa>
    96d4:	e086      	b.n	97e4 <_vfiprintf_r+0x208>
    96d6:	696a      	ldr	r2, [r5, #20]
    96d8:	9b04      	ldr	r3, [sp, #16]
    96da:	4694      	mov	ip, r2
    96dc:	4463      	add	r3, ip
    96de:	616b      	str	r3, [r5, #20]
    96e0:	7823      	ldrb	r3, [r4, #0]
    96e2:	2b00      	cmp	r3, #0
    96e4:	d07e      	beq.n	97e4 <_vfiprintf_r+0x208>
    96e6:	2201      	movs	r2, #1
    96e8:	2300      	movs	r3, #0
    96ea:	4252      	negs	r2, r2
    96ec:	606a      	str	r2, [r5, #4]
    96ee:	a902      	add	r1, sp, #8
    96f0:	3254      	adds	r2, #84	; 0x54
    96f2:	1852      	adds	r2, r2, r1
    96f4:	3401      	adds	r4, #1
    96f6:	602b      	str	r3, [r5, #0]
    96f8:	60eb      	str	r3, [r5, #12]
    96fa:	60ab      	str	r3, [r5, #8]
    96fc:	7013      	strb	r3, [r2, #0]
    96fe:	65ab      	str	r3, [r5, #88]	; 0x58
    9700:	7821      	ldrb	r1, [r4, #0]
    9702:	2205      	movs	r2, #5
    9704:	4841      	ldr	r0, [pc, #260]	; (980c <_vfiprintf_r+0x230>)
    9706:	f000 faf5 	bl	9cf4 <memchr>
    970a:	2800      	cmp	r0, #0
    970c:	d008      	beq.n	9720 <_vfiprintf_r+0x144>
    970e:	4b3f      	ldr	r3, [pc, #252]	; (980c <_vfiprintf_r+0x230>)
    9710:	682a      	ldr	r2, [r5, #0]
    9712:	1ac0      	subs	r0, r0, r3
    9714:	2301      	movs	r3, #1
    9716:	4083      	lsls	r3, r0
    9718:	4313      	orrs	r3, r2
    971a:	602b      	str	r3, [r5, #0]
    971c:	3401      	adds	r4, #1
    971e:	e7ef      	b.n	9700 <_vfiprintf_r+0x124>
    9720:	682b      	ldr	r3, [r5, #0]
    9722:	06da      	lsls	r2, r3, #27
    9724:	d504      	bpl.n	9730 <_vfiprintf_r+0x154>
    9726:	2253      	movs	r2, #83	; 0x53
    9728:	2120      	movs	r1, #32
    972a:	a802      	add	r0, sp, #8
    972c:	1812      	adds	r2, r2, r0
    972e:	7011      	strb	r1, [r2, #0]
    9730:	071a      	lsls	r2, r3, #28
    9732:	d504      	bpl.n	973e <_vfiprintf_r+0x162>
    9734:	2253      	movs	r2, #83	; 0x53
    9736:	212b      	movs	r1, #43	; 0x2b
    9738:	a802      	add	r0, sp, #8
    973a:	1812      	adds	r2, r2, r0
    973c:	7011      	strb	r1, [r2, #0]
    973e:	7822      	ldrb	r2, [r4, #0]
    9740:	2a2a      	cmp	r2, #42	; 0x2a
    9742:	d100      	bne.n	9746 <_vfiprintf_r+0x16a>
    9744:	e77c      	b.n	9640 <_vfiprintf_r+0x64>
    9746:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9748:	2000      	movs	r0, #0
    974a:	210a      	movs	r1, #10
    974c:	e005      	b.n	975a <_vfiprintf_r+0x17e>
    974e:	4252      	negs	r2, r2
    9750:	60ea      	str	r2, [r5, #12]
    9752:	2202      	movs	r2, #2
    9754:	4313      	orrs	r3, r2
    9756:	602b      	str	r3, [r5, #0]
    9758:	e77a      	b.n	9650 <_vfiprintf_r+0x74>
    975a:	7822      	ldrb	r2, [r4, #0]
    975c:	3a30      	subs	r2, #48	; 0x30
    975e:	2a09      	cmp	r2, #9
    9760:	d804      	bhi.n	976c <_vfiprintf_r+0x190>
    9762:	434b      	muls	r3, r1
    9764:	3401      	adds	r4, #1
    9766:	189b      	adds	r3, r3, r2
    9768:	2001      	movs	r0, #1
    976a:	e7f6      	b.n	975a <_vfiprintf_r+0x17e>
    976c:	2800      	cmp	r0, #0
    976e:	d100      	bne.n	9772 <_vfiprintf_r+0x196>
    9770:	e76f      	b.n	9652 <_vfiprintf_r+0x76>
    9772:	9309      	str	r3, [sp, #36]	; 0x24
    9774:	e76d      	b.n	9652 <_vfiprintf_r+0x76>
    9776:	7863      	ldrb	r3, [r4, #1]
    9778:	2b2a      	cmp	r3, #42	; 0x2a
    977a:	d10a      	bne.n	9792 <_vfiprintf_r+0x1b6>
    977c:	9b05      	ldr	r3, [sp, #20]
    977e:	3402      	adds	r4, #2
    9780:	1d1a      	adds	r2, r3, #4
    9782:	681b      	ldr	r3, [r3, #0]
    9784:	9205      	str	r2, [sp, #20]
    9786:	2b00      	cmp	r3, #0
    9788:	da01      	bge.n	978e <_vfiprintf_r+0x1b2>
    978a:	2301      	movs	r3, #1
    978c:	425b      	negs	r3, r3
    978e:	9307      	str	r3, [sp, #28]
    9790:	e763      	b.n	965a <_vfiprintf_r+0x7e>
    9792:	2300      	movs	r3, #0
    9794:	200a      	movs	r0, #10
    9796:	001a      	movs	r2, r3
    9798:	3401      	adds	r4, #1
    979a:	606b      	str	r3, [r5, #4]
    979c:	7821      	ldrb	r1, [r4, #0]
    979e:	3930      	subs	r1, #48	; 0x30
    97a0:	2909      	cmp	r1, #9
    97a2:	d804      	bhi.n	97ae <_vfiprintf_r+0x1d2>
    97a4:	4342      	muls	r2, r0
    97a6:	3401      	adds	r4, #1
    97a8:	1852      	adds	r2, r2, r1
    97aa:	2301      	movs	r3, #1
    97ac:	e7f6      	b.n	979c <_vfiprintf_r+0x1c0>
    97ae:	2b00      	cmp	r3, #0
    97b0:	d100      	bne.n	97b4 <_vfiprintf_r+0x1d8>
    97b2:	e752      	b.n	965a <_vfiprintf_r+0x7e>
    97b4:	9207      	str	r2, [sp, #28]
    97b6:	e750      	b.n	965a <_vfiprintf_r+0x7e>
    97b8:	ab05      	add	r3, sp, #20
    97ba:	9300      	str	r3, [sp, #0]
    97bc:	003a      	movs	r2, r7
    97be:	4b14      	ldr	r3, [pc, #80]	; (9810 <_vfiprintf_r+0x234>)
    97c0:	0029      	movs	r1, r5
    97c2:	0030      	movs	r0, r6
    97c4:	e000      	b.n	97c8 <_vfiprintf_r+0x1ec>
    97c6:	bf00      	nop
    97c8:	e007      	b.n	97da <_vfiprintf_r+0x1fe>
    97ca:	ab05      	add	r3, sp, #20
    97cc:	9300      	str	r3, [sp, #0]
    97ce:	003a      	movs	r2, r7
    97d0:	4b0f      	ldr	r3, [pc, #60]	; (9810 <_vfiprintf_r+0x234>)
    97d2:	0029      	movs	r1, r5
    97d4:	0030      	movs	r0, r6
    97d6:	f000 f88b 	bl	98f0 <_printf_i>
    97da:	9003      	str	r0, [sp, #12]
    97dc:	9b03      	ldr	r3, [sp, #12]
    97de:	3301      	adds	r3, #1
    97e0:	d000      	beq.n	97e4 <_vfiprintf_r+0x208>
    97e2:	e75e      	b.n	96a2 <_vfiprintf_r+0xc6>
    97e4:	89bb      	ldrh	r3, [r7, #12]
    97e6:	065b      	lsls	r3, r3, #25
    97e8:	d500      	bpl.n	97ec <_vfiprintf_r+0x210>
    97ea:	e726      	b.n	963a <_vfiprintf_r+0x5e>
    97ec:	980b      	ldr	r0, [sp, #44]	; 0x2c
    97ee:	b01f      	add	sp, #124	; 0x7c
    97f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    97f2:	46c0      	nop			; (mov r8, r8)
    97f4:	0000b6ec 	.word	0x0000b6ec
    97f8:	0000b70c 	.word	0x0000b70c
    97fc:	0000b72c 	.word	0x0000b72c
    9800:	0000b752 	.word	0x0000b752
    9804:	0000b756 	.word	0x0000b756
    9808:	00000000 	.word	0x00000000
    980c:	0000b74c 	.word	0x0000b74c
    9810:	000095b7 	.word	0x000095b7

00009814 <_printf_common>:
    9814:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    9816:	0017      	movs	r7, r2
    9818:	9301      	str	r3, [sp, #4]
    981a:	688a      	ldr	r2, [r1, #8]
    981c:	690b      	ldr	r3, [r1, #16]
    981e:	9000      	str	r0, [sp, #0]
    9820:	000c      	movs	r4, r1
    9822:	4293      	cmp	r3, r2
    9824:	da00      	bge.n	9828 <_printf_common+0x14>
    9826:	0013      	movs	r3, r2
    9828:	0022      	movs	r2, r4
    982a:	603b      	str	r3, [r7, #0]
    982c:	3243      	adds	r2, #67	; 0x43
    982e:	7812      	ldrb	r2, [r2, #0]
    9830:	2a00      	cmp	r2, #0
    9832:	d001      	beq.n	9838 <_printf_common+0x24>
    9834:	3301      	adds	r3, #1
    9836:	603b      	str	r3, [r7, #0]
    9838:	6823      	ldr	r3, [r4, #0]
    983a:	069b      	lsls	r3, r3, #26
    983c:	d502      	bpl.n	9844 <_printf_common+0x30>
    983e:	683b      	ldr	r3, [r7, #0]
    9840:	3302      	adds	r3, #2
    9842:	603b      	str	r3, [r7, #0]
    9844:	2506      	movs	r5, #6
    9846:	6823      	ldr	r3, [r4, #0]
    9848:	401d      	ands	r5, r3
    984a:	d01e      	beq.n	988a <_printf_common+0x76>
    984c:	0023      	movs	r3, r4
    984e:	3343      	adds	r3, #67	; 0x43
    9850:	781b      	ldrb	r3, [r3, #0]
    9852:	1e5a      	subs	r2, r3, #1
    9854:	4193      	sbcs	r3, r2
    9856:	6822      	ldr	r2, [r4, #0]
    9858:	0692      	lsls	r2, r2, #26
    985a:	d51c      	bpl.n	9896 <_printf_common+0x82>
    985c:	2030      	movs	r0, #48	; 0x30
    985e:	18e1      	adds	r1, r4, r3
    9860:	3143      	adds	r1, #67	; 0x43
    9862:	7008      	strb	r0, [r1, #0]
    9864:	0021      	movs	r1, r4
    9866:	1c5a      	adds	r2, r3, #1
    9868:	3145      	adds	r1, #69	; 0x45
    986a:	7809      	ldrb	r1, [r1, #0]
    986c:	18a2      	adds	r2, r4, r2
    986e:	3243      	adds	r2, #67	; 0x43
    9870:	3302      	adds	r3, #2
    9872:	7011      	strb	r1, [r2, #0]
    9874:	e00f      	b.n	9896 <_printf_common+0x82>
    9876:	0022      	movs	r2, r4
    9878:	2301      	movs	r3, #1
    987a:	3219      	adds	r2, #25
    987c:	9901      	ldr	r1, [sp, #4]
    987e:	9800      	ldr	r0, [sp, #0]
    9880:	9e08      	ldr	r6, [sp, #32]
    9882:	47b0      	blx	r6
    9884:	1c43      	adds	r3, r0, #1
    9886:	d00e      	beq.n	98a6 <_printf_common+0x92>
    9888:	3501      	adds	r5, #1
    988a:	68e3      	ldr	r3, [r4, #12]
    988c:	683a      	ldr	r2, [r7, #0]
    988e:	1a9b      	subs	r3, r3, r2
    9890:	429d      	cmp	r5, r3
    9892:	dbf0      	blt.n	9876 <_printf_common+0x62>
    9894:	e7da      	b.n	984c <_printf_common+0x38>
    9896:	0022      	movs	r2, r4
    9898:	9901      	ldr	r1, [sp, #4]
    989a:	3243      	adds	r2, #67	; 0x43
    989c:	9800      	ldr	r0, [sp, #0]
    989e:	9d08      	ldr	r5, [sp, #32]
    98a0:	47a8      	blx	r5
    98a2:	1c43      	adds	r3, r0, #1
    98a4:	d102      	bne.n	98ac <_printf_common+0x98>
    98a6:	2001      	movs	r0, #1
    98a8:	4240      	negs	r0, r0
    98aa:	e020      	b.n	98ee <_printf_common+0xda>
    98ac:	2306      	movs	r3, #6
    98ae:	6820      	ldr	r0, [r4, #0]
    98b0:	68e1      	ldr	r1, [r4, #12]
    98b2:	683a      	ldr	r2, [r7, #0]
    98b4:	4003      	ands	r3, r0
    98b6:	2500      	movs	r5, #0
    98b8:	2b04      	cmp	r3, #4
    98ba:	d103      	bne.n	98c4 <_printf_common+0xb0>
    98bc:	1a8d      	subs	r5, r1, r2
    98be:	43eb      	mvns	r3, r5
    98c0:	17db      	asrs	r3, r3, #31
    98c2:	401d      	ands	r5, r3
    98c4:	68a3      	ldr	r3, [r4, #8]
    98c6:	6922      	ldr	r2, [r4, #16]
    98c8:	4293      	cmp	r3, r2
    98ca:	dd01      	ble.n	98d0 <_printf_common+0xbc>
    98cc:	1a9b      	subs	r3, r3, r2
    98ce:	18ed      	adds	r5, r5, r3
    98d0:	2700      	movs	r7, #0
    98d2:	42bd      	cmp	r5, r7
    98d4:	d00a      	beq.n	98ec <_printf_common+0xd8>
    98d6:	0022      	movs	r2, r4
    98d8:	2301      	movs	r3, #1
    98da:	321a      	adds	r2, #26
    98dc:	9901      	ldr	r1, [sp, #4]
    98de:	9800      	ldr	r0, [sp, #0]
    98e0:	9e08      	ldr	r6, [sp, #32]
    98e2:	47b0      	blx	r6
    98e4:	1c43      	adds	r3, r0, #1
    98e6:	d0de      	beq.n	98a6 <_printf_common+0x92>
    98e8:	3701      	adds	r7, #1
    98ea:	e7f2      	b.n	98d2 <_printf_common+0xbe>
    98ec:	2000      	movs	r0, #0
    98ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

000098f0 <_printf_i>:
    98f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    98f2:	b08b      	sub	sp, #44	; 0x2c
    98f4:	9206      	str	r2, [sp, #24]
    98f6:	000a      	movs	r2, r1
    98f8:	3243      	adds	r2, #67	; 0x43
    98fa:	9307      	str	r3, [sp, #28]
    98fc:	9005      	str	r0, [sp, #20]
    98fe:	9204      	str	r2, [sp, #16]
    9900:	7e0a      	ldrb	r2, [r1, #24]
    9902:	000c      	movs	r4, r1
    9904:	9b10      	ldr	r3, [sp, #64]	; 0x40
    9906:	2a6e      	cmp	r2, #110	; 0x6e
    9908:	d100      	bne.n	990c <_printf_i+0x1c>
    990a:	e0ab      	b.n	9a64 <_printf_i+0x174>
    990c:	d811      	bhi.n	9932 <_printf_i+0x42>
    990e:	2a63      	cmp	r2, #99	; 0x63
    9910:	d022      	beq.n	9958 <_printf_i+0x68>
    9912:	d809      	bhi.n	9928 <_printf_i+0x38>
    9914:	2a00      	cmp	r2, #0
    9916:	d100      	bne.n	991a <_printf_i+0x2a>
    9918:	e0b5      	b.n	9a86 <_printf_i+0x196>
    991a:	2a58      	cmp	r2, #88	; 0x58
    991c:	d000      	beq.n	9920 <_printf_i+0x30>
    991e:	e0c5      	b.n	9aac <_printf_i+0x1bc>
    9920:	3145      	adds	r1, #69	; 0x45
    9922:	700a      	strb	r2, [r1, #0]
    9924:	4a81      	ldr	r2, [pc, #516]	; (9b2c <_printf_i+0x23c>)
    9926:	e04f      	b.n	99c8 <_printf_i+0xd8>
    9928:	2a64      	cmp	r2, #100	; 0x64
    992a:	d01d      	beq.n	9968 <_printf_i+0x78>
    992c:	2a69      	cmp	r2, #105	; 0x69
    992e:	d01b      	beq.n	9968 <_printf_i+0x78>
    9930:	e0bc      	b.n	9aac <_printf_i+0x1bc>
    9932:	2a73      	cmp	r2, #115	; 0x73
    9934:	d100      	bne.n	9938 <_printf_i+0x48>
    9936:	e0aa      	b.n	9a8e <_printf_i+0x19e>
    9938:	d809      	bhi.n	994e <_printf_i+0x5e>
    993a:	2a6f      	cmp	r2, #111	; 0x6f
    993c:	d029      	beq.n	9992 <_printf_i+0xa2>
    993e:	2a70      	cmp	r2, #112	; 0x70
    9940:	d000      	beq.n	9944 <_printf_i+0x54>
    9942:	e0b3      	b.n	9aac <_printf_i+0x1bc>
    9944:	2220      	movs	r2, #32
    9946:	6809      	ldr	r1, [r1, #0]
    9948:	430a      	orrs	r2, r1
    994a:	6022      	str	r2, [r4, #0]
    994c:	e037      	b.n	99be <_printf_i+0xce>
    994e:	2a75      	cmp	r2, #117	; 0x75
    9950:	d01f      	beq.n	9992 <_printf_i+0xa2>
    9952:	2a78      	cmp	r2, #120	; 0x78
    9954:	d033      	beq.n	99be <_printf_i+0xce>
    9956:	e0a9      	b.n	9aac <_printf_i+0x1bc>
    9958:	000e      	movs	r6, r1
    995a:	681a      	ldr	r2, [r3, #0]
    995c:	3642      	adds	r6, #66	; 0x42
    995e:	1d11      	adds	r1, r2, #4
    9960:	6019      	str	r1, [r3, #0]
    9962:	6813      	ldr	r3, [r2, #0]
    9964:	7033      	strb	r3, [r6, #0]
    9966:	e0a4      	b.n	9ab2 <_printf_i+0x1c2>
    9968:	6821      	ldr	r1, [r4, #0]
    996a:	681a      	ldr	r2, [r3, #0]
    996c:	0608      	lsls	r0, r1, #24
    996e:	d406      	bmi.n	997e <_printf_i+0x8e>
    9970:	0649      	lsls	r1, r1, #25
    9972:	d504      	bpl.n	997e <_printf_i+0x8e>
    9974:	1d11      	adds	r1, r2, #4
    9976:	6019      	str	r1, [r3, #0]
    9978:	2300      	movs	r3, #0
    997a:	5ed5      	ldrsh	r5, [r2, r3]
    997c:	e002      	b.n	9984 <_printf_i+0x94>
    997e:	1d11      	adds	r1, r2, #4
    9980:	6019      	str	r1, [r3, #0]
    9982:	6815      	ldr	r5, [r2, #0]
    9984:	2d00      	cmp	r5, #0
    9986:	da3b      	bge.n	9a00 <_printf_i+0x110>
    9988:	232d      	movs	r3, #45	; 0x2d
    998a:	9a04      	ldr	r2, [sp, #16]
    998c:	426d      	negs	r5, r5
    998e:	7013      	strb	r3, [r2, #0]
    9990:	e036      	b.n	9a00 <_printf_i+0x110>
    9992:	6821      	ldr	r1, [r4, #0]
    9994:	681a      	ldr	r2, [r3, #0]
    9996:	0608      	lsls	r0, r1, #24
    9998:	d406      	bmi.n	99a8 <_printf_i+0xb8>
    999a:	0649      	lsls	r1, r1, #25
    999c:	d504      	bpl.n	99a8 <_printf_i+0xb8>
    999e:	6815      	ldr	r5, [r2, #0]
    99a0:	1d11      	adds	r1, r2, #4
    99a2:	6019      	str	r1, [r3, #0]
    99a4:	b2ad      	uxth	r5, r5
    99a6:	e002      	b.n	99ae <_printf_i+0xbe>
    99a8:	1d11      	adds	r1, r2, #4
    99aa:	6019      	str	r1, [r3, #0]
    99ac:	6815      	ldr	r5, [r2, #0]
    99ae:	4b5f      	ldr	r3, [pc, #380]	; (9b2c <_printf_i+0x23c>)
    99b0:	7e22      	ldrb	r2, [r4, #24]
    99b2:	9303      	str	r3, [sp, #12]
    99b4:	2708      	movs	r7, #8
    99b6:	2a6f      	cmp	r2, #111	; 0x6f
    99b8:	d01d      	beq.n	99f6 <_printf_i+0x106>
    99ba:	270a      	movs	r7, #10
    99bc:	e01b      	b.n	99f6 <_printf_i+0x106>
    99be:	0022      	movs	r2, r4
    99c0:	2178      	movs	r1, #120	; 0x78
    99c2:	3245      	adds	r2, #69	; 0x45
    99c4:	7011      	strb	r1, [r2, #0]
    99c6:	4a5a      	ldr	r2, [pc, #360]	; (9b30 <_printf_i+0x240>)
    99c8:	6819      	ldr	r1, [r3, #0]
    99ca:	9203      	str	r2, [sp, #12]
    99cc:	1d08      	adds	r0, r1, #4
    99ce:	6822      	ldr	r2, [r4, #0]
    99d0:	6018      	str	r0, [r3, #0]
    99d2:	680d      	ldr	r5, [r1, #0]
    99d4:	0610      	lsls	r0, r2, #24
    99d6:	d402      	bmi.n	99de <_printf_i+0xee>
    99d8:	0650      	lsls	r0, r2, #25
    99da:	d500      	bpl.n	99de <_printf_i+0xee>
    99dc:	b2ad      	uxth	r5, r5
    99de:	07d3      	lsls	r3, r2, #31
    99e0:	d502      	bpl.n	99e8 <_printf_i+0xf8>
    99e2:	2320      	movs	r3, #32
    99e4:	431a      	orrs	r2, r3
    99e6:	6022      	str	r2, [r4, #0]
    99e8:	2710      	movs	r7, #16
    99ea:	2d00      	cmp	r5, #0
    99ec:	d103      	bne.n	99f6 <_printf_i+0x106>
    99ee:	2320      	movs	r3, #32
    99f0:	6822      	ldr	r2, [r4, #0]
    99f2:	439a      	bics	r2, r3
    99f4:	6022      	str	r2, [r4, #0]
    99f6:	0023      	movs	r3, r4
    99f8:	2200      	movs	r2, #0
    99fa:	3343      	adds	r3, #67	; 0x43
    99fc:	701a      	strb	r2, [r3, #0]
    99fe:	e002      	b.n	9a06 <_printf_i+0x116>
    9a00:	270a      	movs	r7, #10
    9a02:	4b4a      	ldr	r3, [pc, #296]	; (9b2c <_printf_i+0x23c>)
    9a04:	9303      	str	r3, [sp, #12]
    9a06:	6863      	ldr	r3, [r4, #4]
    9a08:	60a3      	str	r3, [r4, #8]
    9a0a:	2b00      	cmp	r3, #0
    9a0c:	db09      	blt.n	9a22 <_printf_i+0x132>
    9a0e:	2204      	movs	r2, #4
    9a10:	6821      	ldr	r1, [r4, #0]
    9a12:	4391      	bics	r1, r2
    9a14:	6021      	str	r1, [r4, #0]
    9a16:	2d00      	cmp	r5, #0
    9a18:	d105      	bne.n	9a26 <_printf_i+0x136>
    9a1a:	9e04      	ldr	r6, [sp, #16]
    9a1c:	2b00      	cmp	r3, #0
    9a1e:	d011      	beq.n	9a44 <_printf_i+0x154>
    9a20:	e07b      	b.n	9b1a <_printf_i+0x22a>
    9a22:	2d00      	cmp	r5, #0
    9a24:	d079      	beq.n	9b1a <_printf_i+0x22a>
    9a26:	9e04      	ldr	r6, [sp, #16]
    9a28:	0028      	movs	r0, r5
    9a2a:	0039      	movs	r1, r7
    9a2c:	f7fe fcec 	bl	8408 <__aeabi_uidivmod>
    9a30:	9b03      	ldr	r3, [sp, #12]
    9a32:	3e01      	subs	r6, #1
    9a34:	5c5b      	ldrb	r3, [r3, r1]
    9a36:	0028      	movs	r0, r5
    9a38:	7033      	strb	r3, [r6, #0]
    9a3a:	0039      	movs	r1, r7
    9a3c:	f7fe fc5e 	bl	82fc <__aeabi_uidiv>
    9a40:	1e05      	subs	r5, r0, #0
    9a42:	d1f1      	bne.n	9a28 <_printf_i+0x138>
    9a44:	2f08      	cmp	r7, #8
    9a46:	d109      	bne.n	9a5c <_printf_i+0x16c>
    9a48:	6823      	ldr	r3, [r4, #0]
    9a4a:	07db      	lsls	r3, r3, #31
    9a4c:	d506      	bpl.n	9a5c <_printf_i+0x16c>
    9a4e:	6863      	ldr	r3, [r4, #4]
    9a50:	6922      	ldr	r2, [r4, #16]
    9a52:	4293      	cmp	r3, r2
    9a54:	dc02      	bgt.n	9a5c <_printf_i+0x16c>
    9a56:	2330      	movs	r3, #48	; 0x30
    9a58:	3e01      	subs	r6, #1
    9a5a:	7033      	strb	r3, [r6, #0]
    9a5c:	9b04      	ldr	r3, [sp, #16]
    9a5e:	1b9b      	subs	r3, r3, r6
    9a60:	6123      	str	r3, [r4, #16]
    9a62:	e02b      	b.n	9abc <_printf_i+0x1cc>
    9a64:	6809      	ldr	r1, [r1, #0]
    9a66:	681a      	ldr	r2, [r3, #0]
    9a68:	0608      	lsls	r0, r1, #24
    9a6a:	d407      	bmi.n	9a7c <_printf_i+0x18c>
    9a6c:	0649      	lsls	r1, r1, #25
    9a6e:	d505      	bpl.n	9a7c <_printf_i+0x18c>
    9a70:	1d11      	adds	r1, r2, #4
    9a72:	6019      	str	r1, [r3, #0]
    9a74:	6813      	ldr	r3, [r2, #0]
    9a76:	8aa2      	ldrh	r2, [r4, #20]
    9a78:	801a      	strh	r2, [r3, #0]
    9a7a:	e004      	b.n	9a86 <_printf_i+0x196>
    9a7c:	1d11      	adds	r1, r2, #4
    9a7e:	6019      	str	r1, [r3, #0]
    9a80:	6813      	ldr	r3, [r2, #0]
    9a82:	6962      	ldr	r2, [r4, #20]
    9a84:	601a      	str	r2, [r3, #0]
    9a86:	2300      	movs	r3, #0
    9a88:	9e04      	ldr	r6, [sp, #16]
    9a8a:	6123      	str	r3, [r4, #16]
    9a8c:	e016      	b.n	9abc <_printf_i+0x1cc>
    9a8e:	681a      	ldr	r2, [r3, #0]
    9a90:	1d11      	adds	r1, r2, #4
    9a92:	6019      	str	r1, [r3, #0]
    9a94:	6816      	ldr	r6, [r2, #0]
    9a96:	2100      	movs	r1, #0
    9a98:	6862      	ldr	r2, [r4, #4]
    9a9a:	0030      	movs	r0, r6
    9a9c:	f000 f92a 	bl	9cf4 <memchr>
    9aa0:	2800      	cmp	r0, #0
    9aa2:	d001      	beq.n	9aa8 <_printf_i+0x1b8>
    9aa4:	1b80      	subs	r0, r0, r6
    9aa6:	6060      	str	r0, [r4, #4]
    9aa8:	6863      	ldr	r3, [r4, #4]
    9aaa:	e003      	b.n	9ab4 <_printf_i+0x1c4>
    9aac:	0026      	movs	r6, r4
    9aae:	3642      	adds	r6, #66	; 0x42
    9ab0:	7032      	strb	r2, [r6, #0]
    9ab2:	2301      	movs	r3, #1
    9ab4:	6123      	str	r3, [r4, #16]
    9ab6:	2300      	movs	r3, #0
    9ab8:	9a04      	ldr	r2, [sp, #16]
    9aba:	7013      	strb	r3, [r2, #0]
    9abc:	9b07      	ldr	r3, [sp, #28]
    9abe:	aa09      	add	r2, sp, #36	; 0x24
    9ac0:	9300      	str	r3, [sp, #0]
    9ac2:	0021      	movs	r1, r4
    9ac4:	9b06      	ldr	r3, [sp, #24]
    9ac6:	9805      	ldr	r0, [sp, #20]
    9ac8:	f7ff fea4 	bl	9814 <_printf_common>
    9acc:	1c43      	adds	r3, r0, #1
    9ace:	d102      	bne.n	9ad6 <_printf_i+0x1e6>
    9ad0:	2001      	movs	r0, #1
    9ad2:	4240      	negs	r0, r0
    9ad4:	e027      	b.n	9b26 <_printf_i+0x236>
    9ad6:	6923      	ldr	r3, [r4, #16]
    9ad8:	0032      	movs	r2, r6
    9ada:	9906      	ldr	r1, [sp, #24]
    9adc:	9805      	ldr	r0, [sp, #20]
    9ade:	9d07      	ldr	r5, [sp, #28]
    9ae0:	47a8      	blx	r5
    9ae2:	1c43      	adds	r3, r0, #1
    9ae4:	d0f4      	beq.n	9ad0 <_printf_i+0x1e0>
    9ae6:	6823      	ldr	r3, [r4, #0]
    9ae8:	2500      	movs	r5, #0
    9aea:	079b      	lsls	r3, r3, #30
    9aec:	d40f      	bmi.n	9b0e <_printf_i+0x21e>
    9aee:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9af0:	68e0      	ldr	r0, [r4, #12]
    9af2:	4298      	cmp	r0, r3
    9af4:	da17      	bge.n	9b26 <_printf_i+0x236>
    9af6:	0018      	movs	r0, r3
    9af8:	e015      	b.n	9b26 <_printf_i+0x236>
    9afa:	0022      	movs	r2, r4
    9afc:	2301      	movs	r3, #1
    9afe:	3219      	adds	r2, #25
    9b00:	9906      	ldr	r1, [sp, #24]
    9b02:	9805      	ldr	r0, [sp, #20]
    9b04:	9e07      	ldr	r6, [sp, #28]
    9b06:	47b0      	blx	r6
    9b08:	1c43      	adds	r3, r0, #1
    9b0a:	d0e1      	beq.n	9ad0 <_printf_i+0x1e0>
    9b0c:	3501      	adds	r5, #1
    9b0e:	68e3      	ldr	r3, [r4, #12]
    9b10:	9a09      	ldr	r2, [sp, #36]	; 0x24
    9b12:	1a9b      	subs	r3, r3, r2
    9b14:	429d      	cmp	r5, r3
    9b16:	dbf0      	blt.n	9afa <_printf_i+0x20a>
    9b18:	e7e9      	b.n	9aee <_printf_i+0x1fe>
    9b1a:	0026      	movs	r6, r4
    9b1c:	9b03      	ldr	r3, [sp, #12]
    9b1e:	3642      	adds	r6, #66	; 0x42
    9b20:	781b      	ldrb	r3, [r3, #0]
    9b22:	7033      	strb	r3, [r6, #0]
    9b24:	e78e      	b.n	9a44 <_printf_i+0x154>
    9b26:	b00b      	add	sp, #44	; 0x2c
    9b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9b2a:	46c0      	nop			; (mov r8, r8)
    9b2c:	0000b75d 	.word	0x0000b75d
    9b30:	0000b76e 	.word	0x0000b76e

00009b34 <_putc_r>:
    9b34:	b570      	push	{r4, r5, r6, lr}
    9b36:	0006      	movs	r6, r0
    9b38:	000d      	movs	r5, r1
    9b3a:	0014      	movs	r4, r2
    9b3c:	2800      	cmp	r0, #0
    9b3e:	d004      	beq.n	9b4a <_putc_r+0x16>
    9b40:	6983      	ldr	r3, [r0, #24]
    9b42:	2b00      	cmp	r3, #0
    9b44:	d101      	bne.n	9b4a <_putc_r+0x16>
    9b46:	f7ff fac9 	bl	90dc <__sinit>
    9b4a:	4b12      	ldr	r3, [pc, #72]	; (9b94 <_putc_r+0x60>)
    9b4c:	429c      	cmp	r4, r3
    9b4e:	d101      	bne.n	9b54 <_putc_r+0x20>
    9b50:	6874      	ldr	r4, [r6, #4]
    9b52:	e008      	b.n	9b66 <_putc_r+0x32>
    9b54:	4b10      	ldr	r3, [pc, #64]	; (9b98 <_putc_r+0x64>)
    9b56:	429c      	cmp	r4, r3
    9b58:	d101      	bne.n	9b5e <_putc_r+0x2a>
    9b5a:	68b4      	ldr	r4, [r6, #8]
    9b5c:	e003      	b.n	9b66 <_putc_r+0x32>
    9b5e:	4b0f      	ldr	r3, [pc, #60]	; (9b9c <_putc_r+0x68>)
    9b60:	429c      	cmp	r4, r3
    9b62:	d100      	bne.n	9b66 <_putc_r+0x32>
    9b64:	68f4      	ldr	r4, [r6, #12]
    9b66:	68a3      	ldr	r3, [r4, #8]
    9b68:	3b01      	subs	r3, #1
    9b6a:	60a3      	str	r3, [r4, #8]
    9b6c:	2b00      	cmp	r3, #0
    9b6e:	da05      	bge.n	9b7c <_putc_r+0x48>
    9b70:	69a2      	ldr	r2, [r4, #24]
    9b72:	4293      	cmp	r3, r2
    9b74:	db08      	blt.n	9b88 <_putc_r+0x54>
    9b76:	b2eb      	uxtb	r3, r5
    9b78:	2b0a      	cmp	r3, #10
    9b7a:	d005      	beq.n	9b88 <_putc_r+0x54>
    9b7c:	6823      	ldr	r3, [r4, #0]
    9b7e:	b2e8      	uxtb	r0, r5
    9b80:	1c5a      	adds	r2, r3, #1
    9b82:	6022      	str	r2, [r4, #0]
    9b84:	701d      	strb	r5, [r3, #0]
    9b86:	e004      	b.n	9b92 <_putc_r+0x5e>
    9b88:	0022      	movs	r2, r4
    9b8a:	0029      	movs	r1, r5
    9b8c:	0030      	movs	r0, r6
    9b8e:	f7ff f8e3 	bl	8d58 <__swbuf_r>
    9b92:	bd70      	pop	{r4, r5, r6, pc}
    9b94:	0000b6ec 	.word	0x0000b6ec
    9b98:	0000b70c 	.word	0x0000b70c
    9b9c:	0000b72c 	.word	0x0000b72c

00009ba0 <__sread>:
    9ba0:	b570      	push	{r4, r5, r6, lr}
    9ba2:	000c      	movs	r4, r1
    9ba4:	250e      	movs	r5, #14
    9ba6:	5f49      	ldrsh	r1, [r1, r5]
    9ba8:	f000 f8d6 	bl	9d58 <_read_r>
    9bac:	2800      	cmp	r0, #0
    9bae:	db03      	blt.n	9bb8 <__sread+0x18>
    9bb0:	6d63      	ldr	r3, [r4, #84]	; 0x54
    9bb2:	181b      	adds	r3, r3, r0
    9bb4:	6563      	str	r3, [r4, #84]	; 0x54
    9bb6:	e003      	b.n	9bc0 <__sread+0x20>
    9bb8:	89a2      	ldrh	r2, [r4, #12]
    9bba:	4b02      	ldr	r3, [pc, #8]	; (9bc4 <__sread+0x24>)
    9bbc:	4013      	ands	r3, r2
    9bbe:	81a3      	strh	r3, [r4, #12]
    9bc0:	bd70      	pop	{r4, r5, r6, pc}
    9bc2:	46c0      	nop			; (mov r8, r8)
    9bc4:	ffffefff 	.word	0xffffefff

00009bc8 <__swrite>:
    9bc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9bca:	001f      	movs	r7, r3
    9bcc:	898b      	ldrh	r3, [r1, #12]
    9bce:	0005      	movs	r5, r0
    9bd0:	000c      	movs	r4, r1
    9bd2:	0016      	movs	r6, r2
    9bd4:	05db      	lsls	r3, r3, #23
    9bd6:	d505      	bpl.n	9be4 <__swrite+0x1c>
    9bd8:	230e      	movs	r3, #14
    9bda:	5ec9      	ldrsh	r1, [r1, r3]
    9bdc:	2200      	movs	r2, #0
    9bde:	2302      	movs	r3, #2
    9be0:	f000 f874 	bl	9ccc <_lseek_r>
    9be4:	89a2      	ldrh	r2, [r4, #12]
    9be6:	4b05      	ldr	r3, [pc, #20]	; (9bfc <__swrite+0x34>)
    9be8:	0028      	movs	r0, r5
    9bea:	4013      	ands	r3, r2
    9bec:	81a3      	strh	r3, [r4, #12]
    9bee:	0032      	movs	r2, r6
    9bf0:	230e      	movs	r3, #14
    9bf2:	5ee1      	ldrsh	r1, [r4, r3]
    9bf4:	003b      	movs	r3, r7
    9bf6:	f000 f81f 	bl	9c38 <_write_r>
    9bfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    9bfc:	ffffefff 	.word	0xffffefff

00009c00 <__sseek>:
    9c00:	b570      	push	{r4, r5, r6, lr}
    9c02:	000c      	movs	r4, r1
    9c04:	250e      	movs	r5, #14
    9c06:	5f49      	ldrsh	r1, [r1, r5]
    9c08:	f000 f860 	bl	9ccc <_lseek_r>
    9c0c:	89a3      	ldrh	r3, [r4, #12]
    9c0e:	1c42      	adds	r2, r0, #1
    9c10:	d103      	bne.n	9c1a <__sseek+0x1a>
    9c12:	4a05      	ldr	r2, [pc, #20]	; (9c28 <__sseek+0x28>)
    9c14:	4013      	ands	r3, r2
    9c16:	81a3      	strh	r3, [r4, #12]
    9c18:	e004      	b.n	9c24 <__sseek+0x24>
    9c1a:	2280      	movs	r2, #128	; 0x80
    9c1c:	0152      	lsls	r2, r2, #5
    9c1e:	4313      	orrs	r3, r2
    9c20:	81a3      	strh	r3, [r4, #12]
    9c22:	6560      	str	r0, [r4, #84]	; 0x54
    9c24:	bd70      	pop	{r4, r5, r6, pc}
    9c26:	46c0      	nop			; (mov r8, r8)
    9c28:	ffffefff 	.word	0xffffefff

00009c2c <__sclose>:
    9c2c:	b510      	push	{r4, lr}
    9c2e:	230e      	movs	r3, #14
    9c30:	5ec9      	ldrsh	r1, [r1, r3]
    9c32:	f000 f815 	bl	9c60 <_close_r>
    9c36:	bd10      	pop	{r4, pc}

00009c38 <_write_r>:
    9c38:	b570      	push	{r4, r5, r6, lr}
    9c3a:	0005      	movs	r5, r0
    9c3c:	0008      	movs	r0, r1
    9c3e:	0011      	movs	r1, r2
    9c40:	2200      	movs	r2, #0
    9c42:	4c06      	ldr	r4, [pc, #24]	; (9c5c <_write_r+0x24>)
    9c44:	6022      	str	r2, [r4, #0]
    9c46:	001a      	movs	r2, r3
    9c48:	f7fc fd18 	bl	667c <_write>
    9c4c:	1c43      	adds	r3, r0, #1
    9c4e:	d103      	bne.n	9c58 <_write_r+0x20>
    9c50:	6823      	ldr	r3, [r4, #0]
    9c52:	2b00      	cmp	r3, #0
    9c54:	d000      	beq.n	9c58 <_write_r+0x20>
    9c56:	602b      	str	r3, [r5, #0]
    9c58:	bd70      	pop	{r4, r5, r6, pc}
    9c5a:	46c0      	nop			; (mov r8, r8)
    9c5c:	200004ec 	.word	0x200004ec

00009c60 <_close_r>:
    9c60:	2300      	movs	r3, #0
    9c62:	b570      	push	{r4, r5, r6, lr}
    9c64:	4c06      	ldr	r4, [pc, #24]	; (9c80 <_close_r+0x20>)
    9c66:	0005      	movs	r5, r0
    9c68:	0008      	movs	r0, r1
    9c6a:	6023      	str	r3, [r4, #0]
    9c6c:	f7fc fd40 	bl	66f0 <_close>
    9c70:	1c43      	adds	r3, r0, #1
    9c72:	d103      	bne.n	9c7c <_close_r+0x1c>
    9c74:	6823      	ldr	r3, [r4, #0]
    9c76:	2b00      	cmp	r3, #0
    9c78:	d000      	beq.n	9c7c <_close_r+0x1c>
    9c7a:	602b      	str	r3, [r5, #0]
    9c7c:	bd70      	pop	{r4, r5, r6, pc}
    9c7e:	46c0      	nop			; (mov r8, r8)
    9c80:	200004ec 	.word	0x200004ec

00009c84 <_fstat_r>:
    9c84:	2300      	movs	r3, #0
    9c86:	b570      	push	{r4, r5, r6, lr}
    9c88:	4c06      	ldr	r4, [pc, #24]	; (9ca4 <_fstat_r+0x20>)
    9c8a:	0005      	movs	r5, r0
    9c8c:	0008      	movs	r0, r1
    9c8e:	0011      	movs	r1, r2
    9c90:	6023      	str	r3, [r4, #0]
    9c92:	f7fc fd31 	bl	66f8 <_fstat>
    9c96:	1c43      	adds	r3, r0, #1
    9c98:	d103      	bne.n	9ca2 <_fstat_r+0x1e>
    9c9a:	6823      	ldr	r3, [r4, #0]
    9c9c:	2b00      	cmp	r3, #0
    9c9e:	d000      	beq.n	9ca2 <_fstat_r+0x1e>
    9ca0:	602b      	str	r3, [r5, #0]
    9ca2:	bd70      	pop	{r4, r5, r6, pc}
    9ca4:	200004ec 	.word	0x200004ec

00009ca8 <_isatty_r>:
    9ca8:	2300      	movs	r3, #0
    9caa:	b570      	push	{r4, r5, r6, lr}
    9cac:	4c06      	ldr	r4, [pc, #24]	; (9cc8 <_isatty_r+0x20>)
    9cae:	0005      	movs	r5, r0
    9cb0:	0008      	movs	r0, r1
    9cb2:	6023      	str	r3, [r4, #0]
    9cb4:	f7fc fd26 	bl	6704 <_isatty>
    9cb8:	1c43      	adds	r3, r0, #1
    9cba:	d103      	bne.n	9cc4 <_isatty_r+0x1c>
    9cbc:	6823      	ldr	r3, [r4, #0]
    9cbe:	2b00      	cmp	r3, #0
    9cc0:	d000      	beq.n	9cc4 <_isatty_r+0x1c>
    9cc2:	602b      	str	r3, [r5, #0]
    9cc4:	bd70      	pop	{r4, r5, r6, pc}
    9cc6:	46c0      	nop			; (mov r8, r8)
    9cc8:	200004ec 	.word	0x200004ec

00009ccc <_lseek_r>:
    9ccc:	b570      	push	{r4, r5, r6, lr}
    9cce:	0005      	movs	r5, r0
    9cd0:	0008      	movs	r0, r1
    9cd2:	0011      	movs	r1, r2
    9cd4:	2200      	movs	r2, #0
    9cd6:	4c06      	ldr	r4, [pc, #24]	; (9cf0 <_lseek_r+0x24>)
    9cd8:	6022      	str	r2, [r4, #0]
    9cda:	001a      	movs	r2, r3
    9cdc:	f7fc fd14 	bl	6708 <_lseek>
    9ce0:	1c43      	adds	r3, r0, #1
    9ce2:	d103      	bne.n	9cec <_lseek_r+0x20>
    9ce4:	6823      	ldr	r3, [r4, #0]
    9ce6:	2b00      	cmp	r3, #0
    9ce8:	d000      	beq.n	9cec <_lseek_r+0x20>
    9cea:	602b      	str	r3, [r5, #0]
    9cec:	bd70      	pop	{r4, r5, r6, pc}
    9cee:	46c0      	nop			; (mov r8, r8)
    9cf0:	200004ec 	.word	0x200004ec

00009cf4 <memchr>:
    9cf4:	b2c9      	uxtb	r1, r1
    9cf6:	1882      	adds	r2, r0, r2
    9cf8:	4290      	cmp	r0, r2
    9cfa:	d004      	beq.n	9d06 <memchr+0x12>
    9cfc:	7803      	ldrb	r3, [r0, #0]
    9cfe:	428b      	cmp	r3, r1
    9d00:	d002      	beq.n	9d08 <memchr+0x14>
    9d02:	3001      	adds	r0, #1
    9d04:	e7f8      	b.n	9cf8 <memchr+0x4>
    9d06:	2000      	movs	r0, #0
    9d08:	4770      	bx	lr

00009d0a <_realloc_r>:
    9d0a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9d0c:	0006      	movs	r6, r0
    9d0e:	000c      	movs	r4, r1
    9d10:	0015      	movs	r5, r2
    9d12:	2900      	cmp	r1, #0
    9d14:	d104      	bne.n	9d20 <_realloc_r+0x16>
    9d16:	0011      	movs	r1, r2
    9d18:	f7fe fd3e 	bl	8798 <_malloc_r>
    9d1c:	0004      	movs	r4, r0
    9d1e:	e018      	b.n	9d52 <_realloc_r+0x48>
    9d20:	2a00      	cmp	r2, #0
    9d22:	d103      	bne.n	9d2c <_realloc_r+0x22>
    9d24:	f7fe fcf2 	bl	870c <_free_r>
    9d28:	002c      	movs	r4, r5
    9d2a:	e012      	b.n	9d52 <_realloc_r+0x48>
    9d2c:	f000 f828 	bl	9d80 <_malloc_usable_size_r>
    9d30:	4285      	cmp	r5, r0
    9d32:	d90e      	bls.n	9d52 <_realloc_r+0x48>
    9d34:	0029      	movs	r1, r5
    9d36:	0030      	movs	r0, r6
    9d38:	f7fe fd2e 	bl	8798 <_malloc_r>
    9d3c:	1e07      	subs	r7, r0, #0
    9d3e:	d007      	beq.n	9d50 <_realloc_r+0x46>
    9d40:	0021      	movs	r1, r4
    9d42:	002a      	movs	r2, r5
    9d44:	f7fe fcbc 	bl	86c0 <memcpy>
    9d48:	0021      	movs	r1, r4
    9d4a:	0030      	movs	r0, r6
    9d4c:	f7fe fcde 	bl	870c <_free_r>
    9d50:	003c      	movs	r4, r7
    9d52:	0020      	movs	r0, r4
    9d54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00009d58 <_read_r>:
    9d58:	b570      	push	{r4, r5, r6, lr}
    9d5a:	0005      	movs	r5, r0
    9d5c:	0008      	movs	r0, r1
    9d5e:	0011      	movs	r1, r2
    9d60:	2200      	movs	r2, #0
    9d62:	4c06      	ldr	r4, [pc, #24]	; (9d7c <_read_r+0x24>)
    9d64:	6022      	str	r2, [r4, #0]
    9d66:	001a      	movs	r2, r3
    9d68:	f7fc fc68 	bl	663c <_read>
    9d6c:	1c43      	adds	r3, r0, #1
    9d6e:	d103      	bne.n	9d78 <_read_r+0x20>
    9d70:	6823      	ldr	r3, [r4, #0]
    9d72:	2b00      	cmp	r3, #0
    9d74:	d000      	beq.n	9d78 <_read_r+0x20>
    9d76:	602b      	str	r3, [r5, #0]
    9d78:	bd70      	pop	{r4, r5, r6, pc}
    9d7a:	46c0      	nop			; (mov r8, r8)
    9d7c:	200004ec 	.word	0x200004ec

00009d80 <_malloc_usable_size_r>:
    9d80:	1f0b      	subs	r3, r1, #4
    9d82:	681a      	ldr	r2, [r3, #0]
    9d84:	1f10      	subs	r0, r2, #4
    9d86:	2a00      	cmp	r2, #0
    9d88:	da04      	bge.n	9d94 <_malloc_usable_size_r+0x14>
    9d8a:	1889      	adds	r1, r1, r2
    9d8c:	3904      	subs	r1, #4
    9d8e:	680b      	ldr	r3, [r1, #0]
    9d90:	18d0      	adds	r0, r2, r3
    9d92:	3804      	subs	r0, #4
    9d94:	4770      	bx	lr
	...

00009d98 <sd_trans_multipliers>:
    9d98:	0000 0000 000a 0000 000c 0000 000d 0000     ................
    9da8:	000f 0000 0014 0000 0019 0000 001e 0000     ................
    9db8:	0023 0000 0028 0000 002d 0000 0032 0000     #...(...-...2...
    9dc8:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00009dd8 <sd_mmc_trans_units>:
    9dd8:	000a 0000 0064 0000 03e8 0000 2710 0000     ....d........'..
	...

00009df4 <mmc_trans_multipliers>:
    9df4:	0000 0000 000a 0000 000c 0000 000d 0000     ................
    9e04:	000f 0000 0014 0000 001a 0000 001e 0000     ................
    9e14:	0023 0000 0028 0000 002d 0000 0034 0000     #...(...-...4...
    9e24:	0037 0000 003c 0000 0046 0000 0050 0000     7...<...F...P...

00009e34 <__FUNCTION__.14501>:
    9e34:	6d6e 625f 7375 695f 636f 6c74 0000 0000     nm_bus_ioctl....
    9e44:	4128 5050 2829 5245 2952 255b 5d73 255b     (APP)(ERR)[%s][%
    9e54:	5d64 0000 6e69 6176 696c 6564 6920 636f     d]..invalide ioc
    9e64:	746c 6320 646d 0000 1e3c 0000 1e0c 0000     lt cmd..<.......
    9e74:	1e04 0000 1e1c 0000 1e14 0000 1e34 0000     ............4...
    9e84:	1e24 0000 1e2c 0000                         $...,...

00009e8c <__FUNCTION__.13096>:
    9e8c:	6968 5f66 6572 6563 7669 0065               hif_receive.

00009e98 <__FUNCTION__.13112>:
    9e98:	6968 5f66 6572 6967 7473 7265 635f 0062     hif_register_cb.
    9ea8:	4128 5050 2829 4e49 4f46 0029 6c53 776f     (APP)(INFO).Slow
    9eb8:	6e69 2067 6f64 6e77 2e2e 002e 4828 4649     ing down....(HIF
    9ec8:	4629 6961 206c 6f74 7720 6b61 7075 7420     )Fail to wakup t
    9ed8:	6568 6320 6968 0070 6828 6669 2029 4957     he chip.(hif) WI
    9ee8:	4946 485f 534f 5f54 4352 5f56 5443 4c52     FI_HOST_RCV_CTRL
    9ef8:	315f 6220 7375 6620 6961 006c 6828 6669     _1 bus fail.(hif
    9f08:	2029 6461 7264 7365 2073 7562 2073 6166     ) address bus fa
    9f18:	6c69 0000 6828 6669 2029 6f43 7272 7075     il..(hif) Corrup
    9f28:	6574 2064 6170 6b63 7465 5320 7a69 2065     ted packet Size 
    9f38:	203d 7525 3c20 204c 203d 7525 202c 2047     = %u <L = %u, G 
    9f48:	203d 7525 202c 504f 3d20 2520 3230 3e58     = %u, OP = %02X>
    9f58:	000a 0000 4957 4946 6320 6c61 626c 6361     ....WIFI callbac
    9f68:	206b 7369 6e20 746f 7220 6765 7369 6574     k is not registe
    9f78:	6572 0064 6353 6b6f 7465 6320 6c61 626c     red.Scoket callb
    9f88:	6361 206b 7369 6e20 746f 7220 6765 7369     ack is not regis
    9f98:	6574 6572 0064 0000 744f 2061 6163 6c6c     tered...Ota call
    9fa8:	6162 6b63 6920 2073 6f6e 2074 6572 6967     back is not regi
    9fb8:	7473 7265 6465 0000 7243 7079 6f74 6320     stered..Crypto c
    9fc8:	6c61 626c 6361 206b 7369 6e20 746f 7220     allback is not r
    9fd8:	6765 7369 6574 6572 0064 0000 6953 6d67     egistered...Sigm
    9fe8:	2061 6163 6c6c 6162 6b63 6920 2073 6f6e     a callback is no
    9ff8:	2074 6572 6967 7473 7265 6465 0000 0000     t registered....
    a008:	6828 6669 2029 6e69 6176 696c 2064 7267     (hif) invalid gr
    a018:	756f 2070 4449 0000 6828 6669 2029 6f68     oup ID..(hif) ho
    a028:	7473 6120 7070 6420 6469 276e 2074 6573     st app didn't se
    a038:	2074 5852 4420 6e6f 2065 253c 3e75 253c     t RX Done <%u><%
    a048:	3e58 000a 6828 6669 2029 7257 6e6f 2067     X>..(hif) Wrong 
    a058:	6953 657a 0000 0000 6828 6669 2029 6146     Size....(hif) Fa
    a068:	736c 2065 6e69 6574 7272 7075 2074 6c25     lse interrupt %l
    a078:	0078 0000 6828 6669 2029 6146 6c69 7420     x...(hif) Fail t
    a088:	206f 6552 6461 6920 746e 7265 7572 7470     o Read interrupt
    a098:	7220 6765 0000 0000 4828 4649 2029 6146      reg....(HIF) Fa
    a0a8:	6c69 7420 206f 6168 646e 656c 6920 746e     il to handle int
    a0b8:	7265 7572 7470 2520 2064 7274 2079 6741     errupt %d try Ag
    a0c8:	6961 2e6e 0a2e 0000 6820 6669 725f 6365     ain..... hif_rec
    a0d8:	6965 6576 203a 6e49 6176 696c 2064 7261     eive: Invalid ar
    a0e8:	7567 656d 746e 0000 5041 2050 6552 7571     gument..APP Requ
    a0f8:	7365 6574 2064 6953 657a 6920 2073 616c     ested Size is la
    a108:	6772 7265 7420 6168 206e 6874 2065 6572     rger than the re
    a118:	6963 6576 2064 7562 6666 7265 7320 7a69     cived buffer siz
    a128:	2065 253c 3e75 253c 756c 0a3e 0000 0000     e <%u><%lu>.....
    a138:	5041 2050 6552 7571 7365 6574 2064 6441     APP Requested Ad
    a148:	7264 7365 2073 6562 6f79 646e 7420 6568     dress beyond the
    a158:	7220 6365 7669 6465 6220 6675 6566 2072      recived buffer 
    a168:	6461 7264 7365 2073 6e61 2064 656c 676e     address and leng
    a178:	6874 0000 5247 2070 203f 6425 000a 0000     th..GRp ? %d....

0000a188 <__FUNCTION__.13068>:
    a188:	6968 5f66 6573 646e 0000 0000               hif_send....

0000a194 <__FUNCTION__.13078>:
    a194:	6968 5f66 7369 0072                         hif_isr.

0000a19c <__FUNCTION__.13084>:
    a19c:	6968 5f66 6168 646e 656c 695f 7273 0000     hif_handle_isr..

0000a1ac <__FUNCTION__.13076>:
    a1ac:	326d 5f6d 6977 6966 695f 696e 0074 0000     m2m_wifi_init...

0000a1bc <__FUNCTION__.13047>:
    a1bc:	326d 5f6d 6977 6966 635f 0062               m2m_wifi_cb.

0000a1c8 <__FUNCTION__.13104>:
    a1c8:	326d 5f6d 6977 6966 635f 6e6f 656e 7463     m2m_wifi_connect
    a1d8:	735f 0063 6f43 666e 696c 7463 6465 4920     _sc.Conflicted I
    a1e8:	2050 2022 7525 252e 2e75 7525 252e 2075     P " %u.%u.%u.%u 
    a1f8:	2022 000a 4552 2051 6f4e 2074 6564 6966     " ..REQ Not defi
    a208:	656e 2064 6425 000a 4e49 4156 494c 2044     ned %d..INVALID 
    a218:	4f50 4e49 4554 0052 4e49 4156 494c 2044     POINTER.INVALID 
    a228:	5353 4449 0000 0000 4e49 4156 494c 2044     SSID....INVALID 
    a238:	4843 0000 4e49 4156 494c 2044 4844 5043     CH..INVALID DHCP
    a248:	5320 5245 4556 2052 5049 0000 4e49 4156      SERVER IP..INVA
    a258:	494c 2044 454b 2059 4e49 4544 0058 0000     LID KEY INDEX...
    a268:	4e49 4156 494c 2044 454b 2059 5453 4952     INVALID KEY STRI
    a278:	474e 5320 5a49 0045 4e49 4156 494c 2044     NG SIZE.INVALID 
    a288:	454b 2059 4953 455a 0000 0000 4e49 4156     KEY SIZE....INVA
    a298:	494c 2044 5057 2041 454b 2059 4953 455a     LID WPA KEY SIZE
    a2a8:	0000 0000 4e49 4156 494c 2044 5541 4854     ....INVALID AUTH
    a2b8:	4e45 4954 4143 4954 4e4f 4d20 444f 0045     ENTICATION MODE.
    a2c8:	6946 6d72 6177 6572 7620 7265 2020 3a20     Firmware ver   :
    a2d8:	2520 2e75 7525 252e 2075 7653 726e 7665      %u.%u.%u Svnrev
    a2e8:	2520 0a75 0000 0000 6946 6d72 6177 6572      %u.....Firmware
    a2f8:	4220 6975 646c 2520 2073 6954 656d 2520      Build %s Time %
    a308:	0a73 0000 6946 6d72 6177 6572 4d20 6e69     s...Firmware Min
    a318:	6420 6972 6576 2072 6576 2072 203a 7525      driver ver : %u
    a328:	252e 2e75 7525 000a 7244 7669 7265 7620     .%u.%u..Driver v
    a338:	7265 203a 7525 252e 2e75 7525 000a 0000     er: %u.%u.%u....
    a348:	3831 303a 3a35 3431 0000 0000 614d 2072     18:05:14....Mar 
    a358:	3831 3220 3130 0037 7244 7669 7265 6220     18 2017.Driver b
    a368:	6975 746c 6120 2074 7325 2509 0a73 0000     uilt at %s.%s...
    a378:	694d 6d73 7461 6863 4620 7269 616d 7277     Mismatch Firmawr
    a388:	2065 6556 7372 6f69 006e 0000 654b 2079     e Version...Key 
    a398:	7369 6e20 746f 7620 6c61 6469 0000 0000     is not valid....
    a3a8:	6e49 6176 696c 2064 654b 0079 5353 4449     Invalid Key.SSID
    a3b8:	4c20 4e45 4920 564e 4c41 4449 0000 0000      LEN INVALID....
    a3c8:	4843 4920 564e 4c41 4449 0000 6e49 6176     CH INVALID..Inva
    a3d8:	696c 2064 6557 2070 656b 2079 6e69 6564     lid Wep key inde
    a3e8:	2078 6425 000a 0000 6e49 6176 696c 2064     x %d....Invalid 
    a3f8:	6557 2070 656b 2079 656c 676e 6874 2520     Wep key length %
    a408:	0a64 0000 6e49 6f63 7272 6365 2074 5350     d...Incorrect PS
    a418:	204b 656b 2079 656c 676e 6874 0000 0000     K key length....
    a428:	6e75 6564 6966 656e 2064 6573 2063 7974     undefined sec ty
    a438:	6570 0000 4e49 4156 494c 2044 6f4e 6f20     pe..INVALID No o
    a448:	2066 6373 6e61 7320 6f6c 7374 2021 6425     f scan slots! %d
    a458:	000a 0000 4e49 4156 494c 2044 6373 6e61     ....INVALID scan
    a468:	7320 6f6c 2074 6974 656d 2021 6425 000a      slot time! %d..
    a478:	4e49 4156 494c 2044 6f4e 6f20 2066 7270     INVALID No of pr
    a488:	626f 2065 6572 7571 7365 7374 7020 7265     obe requests per
    a498:	7320 6163 206e 6c73 746f 2520 0a64 0000      scan slot %d...
    a4a8:	4e49 4156 494c 2044 5352 4953 7420 7268     INVALID RSSI thr
    a4b8:	7365 6f68 646c 2520 2064 000a 505f 5f53     eshold %d .._PS_
    a4c8:	4553 5652 5245 205f 7369 6e20 746f 6420     SERVER_ is not d
    a4d8:	6665 6e69 6465 0000 694c 7473 6e65 6320     efined..Listen c
    a4e8:	6168 6e6e 6c65 7320 6f68 6c75 2064 6e6f     hannel should on
    a4f8:	796c 6220 2065 324d 5f4d 4957 4946 435f     ly be M2M_WIFI_C
    a508:	5f48 2f31 2f36 3131 0020 0000 4f50 4557     H_1/6/11 ...POWE
    a518:	2052 4153 4556 2520 0a64 0000 4e49 4156     R SAVE %d...INVA
    a528:	494c 2044 4f44 414d 4e49 4e20 4d41 0045     LID DOMAIN NAME.
    a538:	5250 474e 4220 6675 6566 2072 7865 6563     PRNG Buffer exce
    a548:	6465 6465 6d20 7861 6d69 6d75 7320 7a69     eded maximum siz
    a558:	2065 6425 6f20 2072 554e 4c4c 4220 6675     e %d or NULL Buf
    a568:	6566 0a72 0000 0000 7542 2073 7265 6f72     fer.....Bus erro
    a578:	2072 3528 2e29 6425 2520 786c 000a 0000     r (5).%d %lx....
    a588:	6146 6c69 6465 7420 206f 6177 756b 2070     Failed to wakup 
    a598:	6874 2065 6863 7069 0000 0000 7244 7669     the chip....Driv
    a5a8:	7265 6556 4972 666e 3a6f 3020 2578 3830     erVerInfo: 0x%08
    a5b8:	786c 000a 6166 6c69 6465 7420 206f 6564     lx..failed to de
    a5c8:	692d 696e 6974 6c61 7a69 0065               -initialize.

0000a5d4 <__FUNCTION__.12959>:
    a5d4:	6863 7069 645f 6965 696e 0074               chip_deinit.

0000a5e0 <__FUNCTION__.12910>:
    a5e0:	6863 7069 775f 6b61 0065 0000 6e5b 696d     chip_wake...[nmi
    a5f0:	7320 6174 7472 3a5d 6620 6961 206c 6e69      start]: fail in
    a600:	7469 6220 7375 0000 6843 7069 4920 2044     it bus..Chip ID 
    a610:	6c25 0a78 0000 0000 6166 6c69 6465 7420     %lx.....failed t
    a620:	206f 6e65 6261 656c 6920 746e 7265 7572     o enable interru
    a630:	7470 2e73 002e 0000 6e5b 696d 7320 6f74     pts.....[nmi sto
    a640:	5d70 203a 6863 7069 645f 6965 696e 2074     p]: chip_deinit 
    a650:	6166 6c69 0000 0000 6e5b 696d 7320 6f74     fail....[nmi sto
    a660:	5d70 203a 5053 2049 6c66 7361 2068 6964     p]: SPI flash di
    a670:	6173 6c62 2065 6166 6c69 0000 6e5b 696d     sable fail..[nmi
    a680:	7320 6f74 5d70 203a 6166 6c69 6920 696e      stop]: fail ini
    a690:	2074 7562 0073 0000                         t bus...

0000a698 <__FUNCTION__.12957>:
    a698:	6d6e 645f 7672 695f 696e 0074               nm_drv_init.

0000a6a4 <__FUNCTION__.12964>:
    a6a4:	6d6e 645f 7672 645f 6965 696e 0074 0000     nm_drv_deinit...
    a6b4:	2de0 0000 2de0 0000 2e10 0000 2d92 0000     .-...-.......-..
    a6c4:	2db6 0000 2dc4 0000 2df6 0000 2df6 0000     .-...-...-...-..
    a6d4:	2e3e 0000 2d82 0000 2ea0 0000 2ea0 0000     >....-..........
    a6e4:	2ea0 0000 2ea0 0000 2dd2 0000 c9c3 cac4     .........-......

0000a6f4 <__FUNCTION__.12310>:
    a6f4:	7073 5f69 6164 6174 775f 6972 6574 0000     spi_data_write..

0000a704 <__FUNCTION__.12263>:
    a704:	7073 5f69 6d63 0064                         spi_cmd.

0000a70c <__FUNCTION__.12270>:
    a70c:	7073 5f69 6164 6174 725f 7073 0000 0000     spi_data_rsp....

0000a71c <__FUNCTION__.12322>:
    a71c:	7073 5f69 7277 7469 5f65 6572 0067 0000     spi_write_reg...

0000a72c <__FUNCTION__.12379>:
    a72c:	6d6e 735f 6970 695f 696e 0074               nm_spi_init.

0000a738 <__FUNCTION__.12333>:
    a738:	6d6e 735f 6970 775f 6972 6574 0000 0000     nm_spi_write....

0000a748 <__FUNCTION__.12279>:
    a748:	7073 5f69 6d63 5f64 7372 0070 6e5b 696d     spi_cmd_rsp.[nmi
    a758:	7320 6970 3a5d 4620 6961 656c 2064 6d63      spi]: Failed cm
    a768:	2064 7277 7469 2c65 6220 7375 6520 7272     d write, bus err
    a778:	726f 2e2e 002e 0000 6e5b 696d 7320 6970     or......[nmi spi
    a788:	3a5d 4620 6961 656c 2064 6d63 2064 6572     ]: Failed cmd re
    a798:	7073 6e6f 6573 7220 6165 2c64 6220 7375     sponse read, bus
    a7a8:	6520 7272 726f 2e2e 002e 0000 6e5b 696d      error......[nmi
    a7b8:	7320 6970 3a5d 4620 6961 656c 2064 6164      spi]: Failed da
    a7c8:	6174 7220 7365 6f70 736e 2065 6572 6461     ta response read
    a7d8:	202c 7562 2073 7265 6f72 2e72 2e2e 0000     , bus error.....
    a7e8:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    a7f8:	2064 6164 6174 7220 7365 6f70 736e 2065     d data response 
    a808:	6572 6461 2e2e 282e 3025 7832 0a29 0000     read...(%02x)...
    a818:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    a828:	2064 6164 6174 6220 6f6c 6b63 7220 6165     d data block rea
    a838:	2c64 6220 7375 6520 7272 726f 2e2e 002e     d, bus error....
    a848:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    a858:	2064 6164 6174 6220 6f6c 6b63 6320 6372     d data block crc
    a868:	7220 6165 2c64 6220 7375 6520 7272 726f      read, bus error
    a878:	2e2e 002e 6e5b 696d 7320 6970 3a5d 4620     ....[nmi spi]: F
    a888:	6961 656c 2064 6d63 2c64 7720 6972 6574     ailed cmd, write
    a898:	7220 6765 2820 3025 7838 2e29 2e2e 000a      reg (%08x).....
    a8a8:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    a8b8:	2064 6d63 2064 6572 7073 6e6f 6573 202c     d cmd response, 
    a8c8:	7277 7469 2065 6572 2067 2528 3830 2978     write reg (%08x)
    a8d8:	2e2e 0a2e 0000 0000 6552 6573 2074 6e61     ........Reset an
    a8e8:	2064 6572 7274 2079 6425 2520 786c 2520     d retry %d %lx %
    a8f8:	786c 000a 6e5b 696d 7320 6970 3a5d 4620     lx..[nmi spi]: F
    a908:	6961 656c 2064 6d63 2c64 7220 6165 2064     ailed cmd, read 
    a918:	6572 2067 2528 3830 2978 2e2e 0a2e 0000     reg (%08x)......
    a928:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    a938:	2064 6d63 2064 6572 7073 6e6f 6573 202c     d cmd response, 
    a948:	6572 6461 7220 6765 2820 3025 7838 2e29     read reg (%08x).
    a958:	2e2e 000a 6e5b 696d 7320 6970 3a5d 4620     ....[nmi spi]: F
    a968:	6961 656c 2064 6164 6174 7220 6165 2e64     ailed data read.
    a978:	2e2e 0000 6552 6573 2074 6e61 2064 6572     ....Reset and re
    a988:	7274 2079 6425 2520 786c 000a 6e5b 696d     try %d %lx..[nmi
    a998:	7320 6970 3a5d 4620 6961 656c 2064 6e69      spi]: Failed in
    a9a8:	6574 6e72 6c61 7220 6165 2064 7270 746f     ternal read prot
    a9b8:	636f 6c6f 7720 7469 2068 5243 2043 6e6f     ocol with CRC on
    a9c8:	202c 6572 7974 6972 676e 7720 7469 2068     , retyring with 
    a9d8:	5243 2043 666f 2e66 2e2e 0000 6e5b 696d     CRC off.....[nmi
    a9e8:	7320 6970 3a5d 4620 6961 656c 2064 6e69      spi]: Failed in
    a9f8:	6574 6e72 6c61 7220 6165 2064 7270 746f     ternal read prot
    aa08:	636f 6c6f 2e2e 002e 6e5b 696d 7320 6970     ocol....[nmi spi
    aa18:	3a5d 4620 6961 656c 2064 6e69 6574 6e72     ]: Failed intern
    aa28:	6c61 7720 6972 6574 7020 6f72 6f74 6f63     al write protoco
    aa38:	206c 6572 2e67 2e2e 0000 0000 6e5b 696d     l reg.......[nmi
    aa48:	7320 6970 3a5d 4620 6961 206c 6d63 2064      spi]: Fail cmd 
    aa58:	6572 6461 6320 6968 2070 6469 2e2e 002e     read chip id....
    aa68:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    aa78:	2064 6d63 2c64 7220 6165 2064 6c62 636f     d cmd, read bloc
    aa88:	206b 2528 3830 2978 2e2e 0a2e 0000 0000     k (%08x)........
    aa98:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    aaa8:	2064 6d63 2064 6572 7073 6e6f 6573 202c     d cmd response, 
    aab8:	6572 6461 6220 6f6c 6b63 2820 3025 7838     read block (%08x
    aac8:	2e29 2e2e 000a 0000 6e5b 696d 7320 6970     ).......[nmi spi
    aad8:	3a5d 4620 6961 656c 2064 6c62 636f 206b     ]: Failed block 
    aae8:	6164 6174 7220 6165 2e64 2e2e 0000 0000     data read.......
    aaf8:	6552 6573 2074 6e61 2064 6572 7274 2079     Reset and retry 
    ab08:	6425 2520 786c 2520 0a64 0000 6e5b 696d     %d %lx %d...[nmi
    ab18:	7320 6970 3a5d 4620 6961 656c 2064 6d63      spi]: Failed cm
    ab28:	2c64 7720 6972 6574 6220 6f6c 6b63 2820     d, write block (
    ab38:	3025 7838 2e29 2e2e 000a 0000 6e5b 696d     %08x).......[nmi
    ab48:	7320 6970 5d20 203a 6146 6c69 6465 6320      spi ]: Failed c
    ab58:	646d 7220 7365 6f70 736e 2c65 7720 6972     md response, wri
    ab68:	6574 6220 6f6c 6b63 2820 3025 7838 2e29     te block (%08x).
    ab78:	2e2e 000a 6e5b 696d 7320 6970 3a5d 4620     ....[nmi spi]: F
    ab88:	6961 656c 2064 6164 6174 6220 6f6c 6b63     ailed data block
    ab98:	6320 646d 7720 6972 6574 202c 7562 2073      cmd write, bus 
    aba8:	7265 6f72 2e72 2e2e 0000 0000 6e5b 696d     error.......[nmi
    abb8:	7320 6970 3a5d 4620 6961 656c 2064 6164      spi]: Failed da
    abc8:	6174 6220 6f6c 6b63 7720 6972 6574 202c     ta block write, 
    abd8:	7562 2073 7265 6f72 2e72 2e2e 0000 0000     bus error.......
    abe8:	6e5b 696d 7320 6970 3a5d 4620 6961 656c     [nmi spi]: Faile
    abf8:	2064 6164 6174 6220 6f6c 6b63 6320 6372     d data block crc
    ac08:	7720 6972 6574 202c 7562 2073 7265 6f72      write, bus erro
    ac18:	2e72 2e2e 0000 0000 6e5b 696d 7320 6970     r.......[nmi spi
    ac28:	3a5d 4620 6961 656c 2064 7562 2073 7265     ]: Failed bus er
    ac38:	6f72 2e72 2e2e 0000 6e5b 696d 7320 6970     ror.....[nmi spi
    ac48:	3a5d 4620 6961 656c 2064 6164 6174 7220     ]: Failed data r
    ac58:	7365 6f70 736e 2065 6572 6461 202c 7825     esponse read, %x
    ac68:	2520 2078 7825 000a 6e5b 696d 7320 6970      %x %x..[nmi spi
    ac78:	3a5d 4620 6961 656c 2064 6c62 636f 206b     ]: Failed block 
    ac88:	6164 6174 7720 6972 6574 2e2e 002e 0000     data write......

0000ac98 <__FUNCTION__.12345>:
    ac98:	7073 5f69 6572 6461 725f 6765 0000 0000     spi_read_reg....

0000aca8 <__FUNCTION__.12295>:
    aca8:	7073 5f69 6164 6174 725f 6165 0064 0000     spi_data_read...

0000acb8 <crc7_syndrome_table>:
    acb8:	0900 1b12 2d24 3f36 4148 535a 656c 777e     ....$-6?HAZSle~w
    acc8:	1019 020b 343d 262f 5851 4a43 7c75 6e67     ....=4/&QXCJu|gn
    acd8:	3b32 2920 1f16 0d04 737a 6168 575e 454c     2; )....zsha^WLE
    ace8:	222b 3039 060f 141d 6a63 7871 4e47 5c55     +"90....cjqxGNU\
    acf8:	6d64 7f76 4940 5b52 252c 373e 0108 131a     dmv.@IR[,%>7....
    ad08:	747d 666f 5059 424b 3c35 2e27 1811 0a03     }tofYPKB5<'.....
    ad18:	5f56 4d44 7b72 6960 171e 050c 333a 2128     V_DMr{`i....:3(!
    ad28:	464f 545d 626b 7079 0e07 1c15 2a23 3831     OF]Tkbyp....#*18
    ad38:	4841 5a53 6c65 7e77 0009 121b 242d 363f     AHSZelw~....-$?6
    ad48:	5158 434a 757c 676e 1910 0b02 3d34 2f26     XQJC|ung....4=&/
    ad58:	7a73 6861 5e57 4c45 323b 2029 161f 040d     szahW^EL;2) ....
    ad68:	636a 7178 474e 555c 2b22 3930 0f06 1d14     jcxqNG\U"+09....
    ad78:	2c25 3e37 0801 1a13 646d 767f 4049 525b     %,7>....md.vI@[R
    ad88:	353c 272e 1118 030a 7d74 6f66 5950 4b42     <5.'....t}foPYBK
    ad98:	1e17 0c05 3a33 2821 565f 444d 727b 6069     ....3:!(_VMD{ri`
    ada8:	070e 151c 232a 3138 4f46 5d54 6b62 7970     ....*#81FOT]bkpy

0000adb8 <__FUNCTION__.12358>:
    adb8:	6d6e 735f 6970 725f 6165 0064 4528 5252     nm_spi_read.(ERR
    adc8:	2952 7543 7272 6e65 2074 253c 3e64 000a     R)Current <%d>..
    add8:	6f53 6b63 7465 2520 2064 6573 7373 6f69     Socket %d sessio
    ade8:	206e 4449 3d20 2520 0d64 000a 6f53 6b63     n ID = %d...Sock
    adf8:	7420 206f 6564 656c 6574 3c20 6425 0a3e      to delete <%d>.
    ae08:	0000 0000 4e53 2049 7845 6563 6465 2073     ....SNI Exceeds 
    ae18:	614d 2078 654c 676e 6874 0000 6e55 6e6b     Max Length..Unkn
    ae28:	776f 206e 5353 204c 6f53 6b63 7465 4f20     own SSL Socket O
    ae38:	7470 6f69 206e 6425 000a 0000 6f4e 2074     ption %d....Not 
    ae48:	5353 204c 6f53 6b63 7465 0000 0800 4200     SSL Socket.....B
    ae58:	0c00 4200 1000 4200 1400 4200 1800 4200     ...B...B...B...B
    ae68:	1c00 4200 0a09 0c0b 0e0d 0000 5746 0000     ...B........FW..
    ae78:	5742 0000 5742 0000 57a0 0000 57a0 0000     BW..BW...W...W..
    ae88:	575a 0000 574c 0000 5760 0000 578e 0000     ZW..LW..`W...W..
    ae98:	5988 0000 5968 0000 5968 0000 59f4 0000     .Y..hY..hY...Y..
    aea8:	597a 0000 5996 0000 596c 0000 59a4 0000     zY...Y..lY...Y..
    aeb8:	59e4 0000                                   .Y..

0000aebc <_tcc_gclk_ids>:
    aebc:	1a1a 001b                                   ....

0000aec0 <_tcc_apbcmasks>:
    aec0:	0100 0000 0200 0000 0400 0000               ............

0000aecc <_tcc_maxs>:
    aecc:	ffff 00ff ffff 00ff ffff 0000               ............

0000aed8 <_tcc_cc_nums>:
    aed8:	0204 0002                                   ....

0000aedc <_tcc_ow_nums>:
    aedc:	0408 0002                                   ....

0000aee0 <_tcc_intflag>:
    aee0:	0001 0000 0002 0000 0004 0000 0008 0000     ................
    aef0:	1000 0000 2000 0000 4000 0000 8000 0000     ..... ...@......
    af00:	0000 0001 0000 0002 0000 0004 0000 0008     ................

0000af10 <tcc_interrupt_vectors.12452>:
    af10:	100f 0011 79fe 0000 79f8 0000 79f2 0000     .....y...y...y..
    af20:	79ec 0000 7a04 0000 7a0c 0000 7a04 0000     .y...z...z...z..
    af30:	79e6 0000 79e0 0000 7a04 0000 79da 0000     .y...y...z...y..
    af40:	79da 0000 79d4 0000 79ce 0000 7a0c 0000     .y...y...y...z..
    af50:	7a9c 0000 7a96 0000 7a90 0000 7a8a 0000     .z...z...z...z..
    af60:	7aa2 0000 7aaa 0000 7aa2 0000 7a84 0000     .z...z...z...z..
    af70:	7a7e 0000 7aa2 0000 7a78 0000 7a78 0000     ~z...z..xz..xz..
    af80:	7a72 0000 7a6c 0000 7aaa 0000 7b0a 0000     rz..lz...z...{..
    af90:	7b04 0000 7afe 0000 7af8 0000 7b10 0000     .{...z...z...{..
    afa0:	7b10 0000 7b10 0000 7af2 0000 7aec 0000     .{...{...z...z..
    afb0:	7b10 0000 7ae6 0000 7ae6 0000 7ae0 0000     .{...z...z...z..
    afc0:	7ada 0000 3130 3332 3534 3736 3938 6261     .z..0123456789ab
    afd0:	6463 6665 7461 656d 2f6c 2e31 2e30 0032     cdefatmel/1.0.2.
    afe0:	4547 2054 0000 0000 4f50 5453 0020 0000     GET ....POST ...
    aff0:	4544 454c 4554 0020 5550 2054 0000 0000     DELETE .PUT ....
    b000:	504f 4954 4e4f 2053 0000 0000 4548 4441     OPTIONS ....HEAD
    b010:	0020 0000 4820 5454 2f50 2e31 0d31 000a      ... HTTP/1.1...
    b020:	7355 7265 412d 6567 746e 203a 0000 0000     User-Agent: ....
    b030:	6f48 7473 203a 0000 6f43 6e6e 6365 6974     Host: ..Connecti
    b040:	6e6f 203a 654b 7065 412d 696c 6576 0a0d     on: Keep-Alive..
    b050:	0000 0000 6341 6563 7470 452d 636e 646f     ....Accept-Encod
    b060:	6e69 3a67 0d20 000a 6341 6563 7470 432d     ing: ...Accept-C
    b070:	6168 7372 7465 203a 7475 2d66 0d38 000a     harset: utf-8...
    b080:	7254 6e61 6673 7265 452d 636e 646f 6e69     Transfer-Encodin
    b090:	3a67 6320 7568 6b6e 6465 0a0d 0000 0000     g: chunked......
    b0a0:	7525 0000 6f43 746e 6e65 2d74 654c 676e     %u..Content-Leng
    b0b0:	6874 203a 0000 0000 7468 7074 2f3a 002f     th: ....http://.
    b0c0:	7468 7074 3a73 2f2f 0000 0000 7254 6e61     https://....Tran
    b0d0:	6673 7265 452d 636e 646f 6e69 3a67 0020     sfer-Encoding: .
    b0e0:	6f43 6e6e 6365 6974 6e6f 203a 0000 0000     Connection: ....
    b0f0:	5448 5054 002f 0000 0d31 0000 2000 4200     HTTP/...1.... .B
    b100:	2400 4200 2800 4200 7f00 0000 7f08 0000     .$.B.(.B........
    b110:	7f16 0000 7f52 0000 7f68 0000 7473 726f     ....R...h...stor
    b120:	5f65 6966 656c 705f 6361 656b 3a74 7220     e_file_packet: r
    b130:	6365 6965 6576 5b64 6c25 5d75 202c 6966     eceived[%lu], fi
    b140:	656c 7320 7a69 5b65 6c25 5d75 0a0d 0000     le size[%lu]....
    b150:	7473 726f 5f65 6966 656c 705f 6361 656b     store_file_packe
    b160:	3a74 6620 6c69 2065 6f64 6e77 6f6c 6461     t: file download
    b170:	6465 7320 6375 6563 7373 7566 6c6c 2e79     ed successfully.
    b180:	000d 0000 6572 6f73 766c 5f65 6263 203a     ....resolve_cb: 
    b190:	7325 4920 2050 6461 7264 7365 2073 7369     %s IP address is
    b1a0:	2520 2e64 6425 252e 2e64 6425 0a0d 0a0d      %d.%d.%d.%d....
    b1b0:	0000 0000 7473 7261 5f74 6f64 6e77 6f6c     ....start_downlo
    b1c0:	6461 203a 4d4d 2043 7473 726f 6761 2065     ad: MMC storage 
    b1d0:	6f6e 2074 6572 6461 2e79 000d 7473 7261     not ready...star
    b1e0:	5f74 6f64 6e77 6f6c 6461 203a 6957 462d     t_download: Wi-F
    b1f0:	2069 7369 6e20 746f 6320 6e6f 656e 7463     i is not connect
    b200:	6465 0d2e 0000 0000 7473 7261 5f74 6f64     ed......start_do
    b210:	6e77 6f6c 6461 203a 6572 7571 7365 2074     wnload: request 
    b220:	7369 7320 6e65 2074 6c61 6572 6461 2e79     is sent already.
    b230:	000d 0000 7473 7261 5f74 6f64 6e77 6f6c     ....start_downlo
    b240:	6461 203a 7572 6e6e 6e69 2067 6f64 6e77     ad: running down
    b250:	6f6c 6461 6120 726c 6165 7964 0d2e 0000     load already....
    b260:	7473 7261 5f74 6f64 6e77 6f6c 6461 203a     start_download: 
    b270:	6573 646e 6e69 2067 5448 5054 7220 7165     sending HTTP req
    b280:	6575 7473 2e2e 0d2e 0000 0000 7468 7074     uest........http
    b290:	2f3a 732f 6165 2e73 7075 6e65 2e6e 6465     ://seas.upenn.ed
    b2a0:	2f75 6e7e 636d 6967 6c6c 732f 6d61 3264     u/~nmcgill/samd2
    b2b0:	6931 6332 702e 676e 0000 0000 7468 7074     1i2c.png....http
    b2c0:	635f 696c 6e65 5f74 6163 6c6c 6162 6b63     _client_callback
    b2d0:	203a 5448 5054 6320 696c 6e65 2074 6f73     : HTTP client so
    b2e0:	6b63 7465 6320 6e6f 656e 7463 6465 0d2e     cket connected..
    b2f0:	0000 0000 7468 7074 635f 696c 6e65 5f74     ....http_client_
    b300:	6163 6c6c 6162 6b63 203a 6572 7571 7365     callback: reques
    b310:	2074 6f63 706d 656c 6574 2e64 000d 0000     t completed.....
    b320:	7468 7074 635f 696c 6e65 5f74 6163 6c6c     http_client_call
    b330:	6162 6b63 203a 6572 6563 7669 6465 7220     back: received r
    b340:	7365 6f70 736e 2065 7525 6420 7461 2061     esponse %u data 
    b350:	6973 657a 2520 0d75 000a 0000 7468 7074     size %u.....http
    b360:	635f 696c 6e65 5f74 6163 6c6c 6162 6b63     _client_callback
    b370:	203a 6964 6373 6e6f 656e 7463 6f69 206e     : disconnection 
    b380:	6572 7361 6e6f 253a 0d64 000a 6977 6966     reason:%d...wifi
    b390:	635f 3a62 4d20 4d32 575f 4649 5f49 4f43     _cb: M2M_WIFI_CO
    b3a0:	4e4e 4345 4554 0d44 0000 0000 6977 6966     NNECTED.....wifi
    b3b0:	635f 3a62 4d20 4d32 575f 4649 5f49 4944     _cb: M2M_WIFI_DI
    b3c0:	4353 4e4f 454e 5443 4445 000d 7573 6672     SCONNECTED..surf
    b3d0:	5573 2150 0000 0000 6854 4265 6565 6863     sUP!....TheBeech
    b3e0:	6f42 7379 0000 0000 6977 6966 635f 3a62     Boys....wifi_cb:
    b3f0:	4920 2050 6461 7264 7365 2073 7369 2520      IP address is %
    b400:	2e75 7525 252e 2e75 7525 0a0d 0000 0000     u.%u.%u.%u......
    b410:	2d2d 4820 5454 2050 6966 656c 6420 776f     -- HTTP file dow
    b420:	6c6e 616f 6564 2072 7865 6d61 6c70 2065     nloader example 
    b430:	2d2d 0a0d 2d2d 5320 4d41 3257 5f35 5058     --..-- SAMW25_XP
    b440:	414c 4e49 4445 505f 4f52 2d20 0d2d 2d0a     LAINED_PRO --..-
    b450:	202d 6f43 706d 6c69 6465 203a 614d 2072     - Compiled: Mar 
    b460:	3332 3220 3130 2037 3531 343a 3a35 3035     23 2017 15:45:50
    b470:	2d20 0d2d 0000 0000 0a0d 6854 7369 6520      --.......This e
    b480:	6178 706d 656c 7220 7165 6975 6572 2073     xample requires 
    b490:	6874 2065 5041 7420 206f 6168 6576 4920     the AP to have I
    b4a0:	746e 7265 656e 2074 6361 6563 7373 0d2e     nternet access..
    b4b0:	0d0a 0000 6f63 666e 6769 7275 5f65 7468     ....configure_ht
    b4c0:	7074 635f 696c 6e65 3a74 4820 5454 2050     tp_client: HTTP 
    b4d0:	6c63 6569 746e 6920 696e 6974 6c61 7a69     client initializ
    b4e0:	7461 6f69 206e 6166 6c69 6465 2021 7228     ation failed! (r
    b4f0:	7365 2520 2964 0a0d 0000 0000 6e69 7469     es %d)......init
    b500:	735f 6f74 6172 6567 203a 6c70 6165 6573     _storage: please
    b510:	7020 756c 2067 6e61 5320 2f44 4d4d 2043      plug an SD/MMC 
    b520:	6163 6472 6920 206e 6c73 746f 2e2e 0d2e     card in slot....
    b530:	0000 0000 6e69 7469 735f 6f74 6172 6567     ....init_storage
    b540:	203a 4453 6320 7261 2064 6f6d 6e75 2074     : SD card mount 
    b550:	4b4f 0d2e 0000 0000 616d 6e69 203a 326d     OK......main: m2
    b560:	5f6d 6977 6966 695f 696e 2074 6163 6c6c     m_wifi_init call
    b570:	6520 7272 726f 2021 7228 7365 2520 2964      error! (res %d)
    b580:	0a0d 0000 616d 6e69 203a 6f63 6e6e 6365     ....main: connec
    b590:	6974 676e 7420 206f 6957 6946 4120 2050     ting to WiFi AP 
    b5a0:	7325 2e2e 0d2e 000a 616d 6e69 203a 6c70     %s......main: pl
    b5b0:	6165 6573 7520 706e 756c 2067 6874 2065     ease unplug the 
    b5c0:	4453 4d2f 434d 6320 7261 2e64 000d 0000     SD/MMC card.....
    b5d0:	616d 6e69 203a 6f64 656e 0d2e 0000 0000     main: done......
    b5e0:	0043 0000                                   C...

0000b5e4 <_global_impure_ptr>:
    b5e4:	0030 2000                                   0.. 

0000b5e8 <_ctype_>:
    b5e8:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
    b5f8:	2020 2020 2020 2020 2020 2020 2020 2020                     
    b608:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
    b618:	0410 0404 0404 0404 0404 1004 1010 1010     ................
    b628:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
    b638:	0101 0101 0101 0101 0101 0101 1010 1010     ................
    b648:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
    b658:	0202 0202 0202 0202 0202 0202 1010 1010     ................
    b668:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

0000b6ec <__sf_fake_stdin>:
	...

0000b70c <__sf_fake_stdout>:
	...

0000b72c <__sf_fake_stderr>:
	...
    b74c:	2d23 2b30 0020 6c68 004c 6665 4567 4746     #-0+ .hlL.efgEFG
    b75c:	3000 3231 3433 3635 3837 4139 4342 4544     .0123456789ABCDE
    b76c:	0046 3130 3332 3534 3736 3938 6261 6463     F.0123456789abcd
    b77c:	6665 0000                                   ef..

0000b780 <_init>:
    b780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b782:	46c0      	nop			; (mov r8, r8)
    b784:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b786:	bc08      	pop	{r3}
    b788:	469e      	mov	lr, r3
    b78a:	4770      	bx	lr

0000b78c <__init_array_start>:
    b78c:	000000dd 	.word	0x000000dd

0000b790 <_fini>:
    b790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    b792:	46c0      	nop			; (mov r8, r8)
    b794:	bcf8      	pop	{r3, r4, r5, r6, r7}
    b796:	bc08      	pop	{r3}
    b798:	469e      	mov	lr, r3
    b79a:	4770      	bx	lr

0000b79c <__fini_array_start>:
    b79c:	000000b5 	.word	0x000000b5
